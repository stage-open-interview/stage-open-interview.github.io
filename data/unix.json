{"questions":[{"id":"q-481","question":"You're debugging a production system where processes are hanging. Using only Unix tools, how would you identify which processes are blocked on I/O, what they're waiting for, and safely terminate them without causing data corruption?","answer":"Use `lsof -p <PID>` to see open files and `strace -p <PID>` to identify blocked system calls. Check `/proc/<PID>/fd` for file descriptors. For safe termination, send SIGTERM first: `kill -15 <PID>`, wait for graceful shutdown, then use SIGKILL if necessary.","explanation":"## Process Identification\n- `ps aux | grep D` shows processes in uninterruptible sleep\n- `top` with 'H' shows thread-level status\n- `iostat -x 1` identifies I/O bottlenecks\n\n## Root Cause Analysis\n- `strace -p <PID>` reveals blocked system calls\n- `lsof -p <PID>` shows open files and network connections\n- `/proc/<PID>/status` provides process state details\n\n## Safe Termination\n- SIGTERM allows graceful shutdown\n- Check for child processes before killing\n- Verify no critical writes in progress","diagram":"flowchart TD\n  A[Detect hanging process] --> B[ps aux | grep D]\n  B --> C[strace -p PID]\n  C --> D[lsof -p PID]\n  D --> E{Safe to terminate?}\n  E -->|Yes| F[kill -15 PID]\n  E -->|No| G[Wait for I/O completion]\n  F --> H[Monitor with ps]\n  G --> F","difficulty":"advanced","tags":["unix"],"channel":"unix","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Snap","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"lastUpdated":"2026-01-10T03:29:09.162Z","createdAt":"2025-12-26 12:51:05"},{"id":"q-510","question":"You're debugging a production issue where a process is stuck in uninterruptible sleep (D state). How would you identify and handle this situation?","answer":"Use `ps aux | awk '$8 ~ /D/ {print $2, $11}'` to find D-state processes. Check `dmesg | grep -i oom` for OOM killer activity. For I/O issues, use `lsof -p <PID>` to identify blocked files. If it's NFS, verify mount status and network connectivity.","explanation":"## Identifying D-State Processes\n\n- Use `ps` with state filtering to find uninterruptible processes\n- Check system logs for hardware or filesystem errors\n- Examine I/O queues and block device status\n\n## Common Causes\n\n- NFS mount issues or network storage problems\n- Faulty hardware devices (disk, controller)\n- Kernel bugs or driver issues\n- Memory pressure causing I/O blocking\n\n## Resolution Strategies\n\n- Wait for hardware timeout (usually 30-120 seconds)\n- Check and fix underlying storage issues\n- Reboot as last resort if process won't recover\n- Monitor `/proc/<PID>/stack` for kernel call traces","diagram":"flowchart TD\n  A[Process enters D state] --> B{Identify cause}\n  B --> C[Hardware issue]\n  B --> D[Network storage]\n  B --> E[Kernel/driver]\n  C --> F[Check dmesg/logs]\n  D --> G[Verify mount status]\n  E --> H[Examine stack trace]\n  F --> I[Wait or fix hardware]\n  G --> J[Resolve network/storage]\n  H --> K[Update/reboot if needed]","difficulty":"intermediate","tags":["unix"],"channel":"unix","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["OpenAI","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"lastUpdated":"2026-01-09T03:44:39.931Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-538","question":"You notice a process is consuming excessive CPU on a production server. How would you diagnose and troubleshoot this issue using Unix commands?","answer":"I would start by using `top` or `htop` to identify the process ID (PID) consuming excessive CPU, then run `ps aux | grep PID` to get detailed process information and command line arguments. For deeper analysis, I'd use `strace -p PID` to monitor system calls in real-time, `lsof -p PID` to examine open files and network connections, and `perf top` for CPU performance profiling.","explanation":"## Diagnosis Steps\n- Use `top` or `htop` to identify the high CPU process and its PID\n- Run `ps aux` to view process details and command line arguments\n- Monitor system calls with `strace -p PID` to understand process behavior\n\n## Investigation Tools\n- `lsof -p PID` reveals open files and network connections\n- `perf top` provides CPU performance profiling and bottleneck identification\n- `/proc/PID/status` contains comprehensive memory and CPU statistics\n\n## Resolution\n- Send SIGTERM (`kill -15`) for graceful process shutdown\n- Use SIGKILL (`kill -9`) only when the process is unresponsive\n- Analyze logs in `/var/log/` to identify and address the root cause","diagram":"flowchart TD\n  A[High CPU Alert] --> B[top/htop - Identify PID]\n  B --> C[ps aux - Process Details]\n  C --> D[strace - System Calls]\n  D --> E[lsof - Open Files]\n  E --> F[perf top - Performance Profile]\n  F --> G{Process Responsive?}\n  G -->|Yes| H[kill -15 PID]\n  G -->|No| I[kill -9 PID]\n  H --> J[Monitor Resolution]\n  I --> J","difficulty":"intermediate","tags":["unix"],"channel":"unix","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Goldman Sachs","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":["troubleshooting","cpu profiling","strace","lsof","performance","diagnosis"],"voiceSuitable":true,"lastUpdated":"2026-01-08T11:43:07.374Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-564","question":"You're debugging a production system where processes are hanging. Using only Unix tools, how would you identify which processes are stuck in uninterruptible sleep (D state) and what could be causing this?","answer":"Use `ps aux | awk '$8 ~ /^D/ {print $2, $11}'` to identify processes in uninterruptible sleep state. Examine `/proc/<pid>/stack` for kernel stack traces to understand what system calls are blocking. Common causes include NFS server issues, faulty storage drivers, hardware I/O problems, or disk bottlenecks. Use `iostat -x 1` to monitor I/O activity and `dmesg | grep -i error` to check for hardware or driver errors.","explanation":"## Identifying D-State Processes\n- Use `ps aux | awk '$8 ~ /^D/ {print $2, $11}'` to filter processes in uninterruptible sleep\n- Check `/proc/<pid>/status` for detailed process state information\n- Monitor system-wide D-state processes with `top` or `htop` filtered by state\n\n## Root Cause Analysis\n- Examine `/proc/<pid>/stack` to identify the specific kernel functions blocking the process\n- Use `dmesg | grep -i error` to detect hardware or driver-related issues\n- Monitor I/O statistics with `iostat -x 1` to identify storage bottlenecks\n- Check `lsblk` and `smartctl` for disk health and controller issues\n\n## Common Causes\n- NFS server unavailability or network connectivity issues\n- Faulty disk controllers, RAID arrays, or storage drivers\n- Hardware failures in storage subsystem (bad sectors, failing drives)\n- Memory pressure causing excessive swap activity\n- Kernel bugs or incompatible device drivers\n- Storage system saturation or filesystem corruption","diagram":"flowchart TD\n  A[ps aux | awk] --> B[Identify D-state PIDs]\n  B --> C[/proc/<pid>/stack]\n  C --> D[Analyze kernel stack]\n  D --> E[lsof -p <pid>]\n  E --> F[Check open files]\n  F --> G[strace -p <pid>]\n  G --> H[Trace syscalls]","difficulty":"advanced","tags":["unix"],"channel":"unix","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","OpenAI","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":["uninterruptible sleep","d state","ps command","proc filesystem","stack traces","nfs","i/o bottlenecks","kernel debugging"],"voiceSuitable":true,"lastUpdated":"2026-01-08T11:57:22.806Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-264","question":"How do Unix pipes enable inter-process communication and what are their performance implications?","answer":"Pipes provide unidirectional byte streams between processes, utilizing kernel buffers for efficient inter-process communication with blocking I/O semantics.","explanation":"## Why Asked\nTests understanding of IPC mechanisms and system design principles for scalable applications.\n\n## Key Concepts\nUnidirectional communication, kernel buffering, blocking I/O, file descriptor abstraction, pipe capacity limits.\n\n## Code Example\n```bash\n# Create pipe and connect processes\nls -l | grep \".txt\" | wc -l\n# Kernel manages 64KB buffer between processes\n```\n\n## Follow-up Questions\nWhat's the difference between named and anonymous pipes? How do pipes handle backpressure? What are alternatives to pipes?","diagram":"flowchart TD\n  A[Process A] -->|writes| B[Pipe Buffer]\n  B -->|reads| C[Process B]\n  D[Kernel] -->|manages| B","difficulty":"beginner","tags":["posix","signals","pipes","sockets"],"channel":"unix","subChannel":"system-programming","sourceUrl":"https://man7.org/linux/man-pages/pipe.2","videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Apple","Google","Meta","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"lastUpdated":"2026-01-03T06:38:32.248Z","createdAt":"2025-12-26 12:51:07"}],"subChannels":["general","system-programming"],"companies":["Adobe","Amazon","Apple","Citadel","Goldman Sachs","Google","Meta","Microsoft","OpenAI","Snap","Snowflake","Square","Tesla"],"stats":{"total":5,"beginner":1,"intermediate":2,"advanced":2,"newThisWeek":0}}