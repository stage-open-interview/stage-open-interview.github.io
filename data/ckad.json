{"questions":[{"id":"ckad-app-design-1768193364551-0","question":"You are deploying a web app with a Deployment of 3 replicas. You want updates to roll out without any downtime. Which Deployment strategy configuration achieves zero downtime during rolling updates?","answer":"[{\"id\":\"a\",\"text\":\"maxUnavailable=0, maxSurge=1\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"maxUnavailable=1, maxSurge=1\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"maxUnavailable=0, maxSurge=0\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"strategy: Recreate\",\"isCorrect\":false}]","explanation":"## Correct Answer\n\nOption A is correct because rolling updates configured with maxUnavailable: 0 and maxSurge: 1 allow updating one extra pod while keeping all existing pods available. This avoids any downtime during the rollout.\n\n## Why Other Options Are Wrong\n\n- Option B may cause temporary unavailability because one pod is taken down while another starts up.\n- Option C with maxUnavailable: 0 and maxSurge: 0 cannot deploy new pods to replace old ones, leading to stalled updates and potential downtime.\n- Option D uses the Recreate strategy which stops all pods before starting new ones, causing downtime.\n\n## Key Concepts\n\n- Kubernetes Deployment\n- RollingUpdate strategy\n- maxUnavailable\n- maxSurge\n\n## Real-World Application\n\nUse this pattern when deploying user-facing web services that require continuous availability during deployments; pair with readiness probes to ensure traffic only reaches healthy pods.","diagram":null,"difficulty":"intermediate","tags":["Kubernetes","Deployment","RollingUpdate","zero-downtime","CKAD","certification-mcq","domain-weight-20"],"channel":"ckad","subChannel":"app-design","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T04:49:24.553Z","createdAt":"2026-01-12 04:49:24"},{"id":"ckad-app-design-1768193364551-1","question":"Your team wants to terminate TLS at the Ingress controller for a service exposed by a Kubernetes Ingress. Which combination of resources is required to achieve this in a typical setup?","answer":"[{\"id\":\"a\",\"text\":\"Deployment, Service, and Ingress with TLS secret in the same namespace\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"Deployment, ConfigMap, and Ingress\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"StatefulSet, Ingress, and a TLS secret in a different namespace\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"DaemonSet with TLS secret only\",\"isCorrect\":false}]","explanation":"## Correct Answer\n\nOption A is correct because TLS termination at the Ingress requires a TLS secret in the same namespace and a Service exposing the pods you want to reach; the Ingress references the secret to terminate TLS and routes traffic to the backend Service.\n\n## Why Other Options Are Wrong\n\n- Option B lacks a TLS secret; simply using a Deployment and ConfigMap does not enable TLS termination.\n- Option C places the TLS secret in a different namespace; TLS secrets must be in the same namespace as the Ingress to be used.\n- Option D omits the necessary Ingress and Service wiring; only a TLS secret won't expose the workload.\n\n## Key Concepts\n\n- Kubernetes Ingress\n- TLS secrets\n- Ingress Controller\n- Service backends\n\n## Real-World Application\n\nIn production, create a TLS secret (e.g., tls-secret) in the app's namespace, configure Ingress with tls:\n  - hosts: [example.com]\n    secretName: tls-secret\nand expose the app via a ClusterIP Service; this enables end-to-end TLS termination at the Ingress layer.","diagram":null,"difficulty":"intermediate","tags":["Kubernetes","Ingress","TLS","Secrets","Networking","certification-mcq","domain-weight-20"],"channel":"ckad","subChannel":"app-design","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T04:49:24.966Z","createdAt":"2026-01-12 04:49:25"},{"id":"ckad-app-design-1768193364551-2","question":"You have a microservice that writes user-uploaded files to disk and you want the data to persist beyond the life of any single Pod and be accessible to all replicas. Which Kubernetes resource is appropriate to attach to the Pod to provide persistent storage?","answer":"[{\"id\":\"a\",\"text\":\"EmptyDir\",\"isCorrect\":false},{\"id\":\"b\",\"text\":\"ConfigMap\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"PersistentVolumeClaim\",\"isCorrect\":true},{\"id\":\"d\",\"text\":\"HostPath\",\"isCorrect\":false}]","explanation":"## Correct Answer\n\nOption C is correct because PersistentVolumeClaims provide durable storage that outlives individual Pods and can be attached to multiple Pods when using a matching StorageClass or access mode.\n\n## Why Other Options Are Wrong\n\n- Option A (EmptyDir) is ephemeral and vanishes when the Pod is deleted.\n- Option B (ConfigMap) is for configuration data, not for file storage persistence.\n- Option D (HostPath) ties storage to a specific node and is not portable across nodes.\n\n## Key Concepts\n\n- PersistentVolume\n- PersistentVolumeClaim\n- StorageClass and access modes\n\n## Real-World Application\n\nUse a PVC for user-upload directories to ensure data persists across Pod rescheduling and is accessible to all replicas behind a Service.","diagram":null,"difficulty":"intermediate","tags":["Kubernetes","PersistentVolume","PVC","Storage","CKAD","certification-mcq","domain-weight-20"],"channel":"ckad","subChannel":"app-design","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T04:49:25.352Z","createdAt":"2026-01-12 04:49:25"},{"id":"ckad-app-environment-1768151848059-0","question":"Which approach protects sensitive data by avoiding passing the secret as an environment variable, while still allowing the application to read the secret?","answer":"[{\"id\":\"a\",\"text\":\"Mount the Secret as files in a volume and have the application read the password from the mounted file\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"Continue to inject the Secret as an environment variable\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"Copy the Secret into the container image\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Store the Secret in a ConfigMap and read it from the application\",\"isCorrect\":false}]","explanation":"## Correct Answer\n\n- a\n\n## Why Other Options Are Wrong\n\n- b: Exposing secrets in environment variables makes them visible in process lists and logs, violating best practices for secret handling.\n- c: Copying secrets into the image risks leakage across image layers and in registries.\n- d: ConfigMaps are intended for non-sensitive configuration data; secrets should use Secret objects, and storing them in a ConfigMap is not secure.\n\n## Key Concepts\n\n- Kubernetes Secrets vs ConfigMaps\n- Secrets mounted as files vs as environment variables\n- Secret-handling best practices in Pod specs\n\n## Real-World Application\n\n- In production, mount sensitive credentials as files from Secrets and configure apps to read from file paths, reducing exposure in the process environment.","diagram":null,"difficulty":"intermediate","tags":["Kubernetes","Secrets","Security","CKAD","certification-mcq","domain-weight-25"],"channel":"ckad","subChannel":"app-environment","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T17:17:28.060Z","createdAt":"2026-01-11 17:17:28"},{"id":"ckad-app-environment-1768151848059-1","question":"To securely supply a TLS certificate and its private key to a Pod, which approach is correct?","answer":"[{\"id\":\"a\",\"text\":\"Mount the TLS certificate and private key from a Secret as files into the container\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"Pass the certificate and key as environment variables to the container\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"Store the certificate in a ConfigMap and mount as files\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Bake the certificate into the container image\",\"isCorrect\":false}]","explanation":"## Correct Answer\n\n- a\n\n## Why Other Options Are Wrong\n\n- b: Exposing private keys via environment variables risks leakage through process listings and logs.\n- c: ConfigMaps are not intended for sensitive data; Secrets should be used for TLS material.\n- d: Including certs in the image makes rotation and revocation harder and risks distribution of secret material.\n\n## Key Concepts\n\n- Kubernetes Secrets for TLS material\n- Mounting Secrets as files vs exposing via env vars\n- Secret rotation considerations\n\n## Real-World Application\n\n- Use Secrets to store TLS certs/keys and mount them as files at standard paths for TLS-enabled services; enables safer rotation and access control.","diagram":null,"difficulty":"intermediate","tags":["Kubernetes","TLS","Secrets","CKAD","certification-mcq","domain-weight-25"],"channel":"ckad","subChannel":"app-environment","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T17:17:28.472Z","createdAt":"2026-01-11 17:17:28"},{"id":"ckad-app-environment-1768151848059-2","question":"Which Pod spec snippet properly ensures a container runs as a non-root user and cannot escalate privileges, while also enforcing read-only root filesystem?","answer":"[{\"id\":\"a\",\"text\":\"securityContext: { runAsNonRoot: true, allowPrivilegeEscalation: false, readOnlyRootFilesystem: true }\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"securityContext: { runAsUser: 0 }\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"securityContext: { allowPrivilegeEscalation: true }\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"securityContext: { privileged: true }\",\"isCorrect\":false}]","explanation":"## Correct Answer\n\n- a\n\n## Why Other Options Are Wrong\n\n- b: Running as UID 0 means the container is effectively root, defeating non-root enforcement.\n- c: AllowPrivilegeEscalation: true allows privilege escalation.\n- d: Privileged: true grants extensive host privileges and defeats isolation.\n\n## Key Concepts\n\n- Pod securityContext basics\n- runAsNonRoot, readOnlyRootFilesystem, and privilegeEscalation controls\n- Privilege separation in containers\n\n## Real-World Application\n\n- Applying these settings reduces attack surface by preventing root access and restricting file system writes, aligning with production-hardening practices.","diagram":null,"difficulty":"intermediate","tags":["Kubernetes","Security","PodSecurity","CKAD","certification-mcq","domain-weight-25"],"channel":"ckad","subChannel":"app-environment","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T17:17:28.886Z","createdAt":"2026-01-11 17:17:28"}],"subChannels":["app-design","app-environment"],"companies":[],"stats":{"total":6,"beginner":0,"intermediate":6,"advanced":0,"newThisWeek":6}}