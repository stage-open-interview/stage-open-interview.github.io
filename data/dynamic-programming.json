{"questions":[{"id":"q-1262","question":"You're given an array A of length n and an integer k. You must select exactly k non-overlapping, contiguous subarrays (non-empty) to maximize the sum of all selected elements. Return the maximum sum and the k subarrays (start and end indices). Propose a dynamic programming formulation with states and recurrences, include reconstruction, and discuss time/space complexity?","answer":"Define dp[i][t] = max sum using first i elements with exactly t subarrays, and local[i][t] = max sum ending at i with t subarrays. Recurrences: local[i][t] = max(local[i-1][t] + a[i], dp[i-1][t-1] + a","explanation":"## Why This Is Asked\nTests ability to extend Kadane to multiple disjoint subarrays with exact count, plus reconstruction.\n\n## Key Concepts\n- DP with two fabrics: global and local bests; disjoint subarray constraint; reconstruction path.\n- Space optimization and handling of -INF edge cases.\n\n## Code Example\n```javascript\n// sketch of DP with reconstruction\n```\n\n## Follow-up Questions\n- How would you modify if subarrays could be at most k? 2D dp change.\n- Could you implement an optimized solution with O(n log k) for larger constraints?","diagram":"flowchart TD\n  Start(Start) --> DPForm(DP Formulation)\n  DPForm --> Local(Local State)\n  DPForm --> Rec( reconstruction )\n  Local --> Reconstruct\n  Rec --> End(End)","difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T07:26:39.875Z","createdAt":"2026-01-13T07:26:39.875Z"},{"id":"q-1872","question":"You're given an n x m grid of integers grid[i][j]. From (0,0) to (n-1,m-1) you may move only right or down. You may turn at most K times (a turn is a change between directions). Return the maximum sum along a valid path and the path coordinates. Propose a DP with states dp[i][j][t][dir], recurrences, base cases, and reconstruction, and discuss time/space?","answer":"Propose dp[i][j][t][dir], where i,j cell, t turns used (0..K), dir ∈ {0=right,1=down}. Base: dp[0][0][0][0] = grid[0][0], dp[0][0][0][1] = grid[0][0]. Transitions: from (i,j-1) with same dir or with a","explanation":"## Why This Is Asked\nTests multi-dimensional DP with path reconstruction under a constrained number of turns, a common production planning scenario.\n\n## Key Concepts\n- 4D DP: i, j, t, dir\n- Transitions handle continuing in the same direction or taking a turn\n- Path reconstruction via parent pointers; edge-case handling when K is large\n- Complexity analysis and memory optimization considerations\n\n## Code Example\n```javascript\nfunction maxSumWithTurns(grid, K) {\n  const n = grid.length, m = grid[0].length;\n  // Placeholder: actual DP initialization and transitions would go here\n  return {best: 0, path: []};\n}\n```\n\n## Follow-up Questions\n- How would you optimize memory to O(n*m*(K+1))?\n- How would you adapt if turns also incur a penalty per turn?","diagram":"flowchart TD\n  A[Start] --> B[DP state: i, j, t, dir]\n  B --> C{Transitions}\n  C --> D[From left with same dir]\n  C --> E[From left with turn]\n  C --> F[From top with same dir]\n  C --> G[From top with turn]\n  D --> H[Update dp]\n  E --> H\n  F --> H\n  G --> H\n  H --> I[Reconstruct path]","difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","MongoDB","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T15:34:12.531Z","createdAt":"2026-01-14T15:34:12.531Z"},{"id":"q-1941","question":"You're given an array A of length n and an integer k. You must select at most k elements such that no two selected elements are adjacent. Return the maximum sum you can obtain and the list of selected indices. Propose a DP formulation with states dp[i][j], recurrences, base cases, and reconstruction?","answer":"DP uses dp[i][j] = max(dp[i-1][j], dp[i-2][j-1] + A[i-1]) for i>=2; base: dp[0][0]=0, dp[i][0]=0, dp[1][1]=A[0]. Reconstruct by backtracking from (n, min(k, floor((n+1)/2))). Time O(nk); space O(nk) (","explanation":"## Why This Is Asked\nTests DP with adjacency constraint and exact count; requires states over i and j, base cases, and backtracking.\n\n## Key Concepts\n- DP with two dimensions n and k\n- adjacency constraint via i-2 transition\n- reconstruction via parent pointers or decisions\n- space/time bounds and potential optimizations\n\n## Code Example\n```javascript\nfunction maxSumNoAdj(A, k) {\n  const n = A.length;\n  const K = Math.min(k, Math.floor((n + 1) / 2));\n  const dp = Array.from({ length: n + 1 }, () => Array(K + 1).fill(0));\n  const take = Array.from({ length: n + 1 }, () => Array(K + 1).fill(false));\n  for (let i = 1; i <= n; i++) {\n    for (let j = 0; j <= K; j++) {\n      dp[i][j] = dp[i - 1][j];\n      if (j > 0) {\n        if (i >= 2) {\n          const cand = dp[i - 2][j - 1] + A[i - 1];\n          if (cand > dp[i][j]) {\n            dp[i][j] = cand;\n            take[i][j] = true;\n          }\n        } else if (i === 1 && j === 1) {\n          if (A[0] > dp[i][j]) { dp[i][j] = A[0]; take[i][j] = true; }\n        }\n      }\n    }\n  }\n  // reconstruct\n  let i = n, j = K, indices = [];\n  while (i >= 1 && j >= 0) {\n    if (take[i][j]) { indices.push(i - 1); i -= 2; j -= 1; }\n    else { i -= 1; }\n  }\n  indices.reverse();\n  return { sum: dp[n][K], indices };\n}\n```\n\n## Follow-up Questions\n- How would you enforce exactly k selections vs at most k?\n- How to optimize space to O(k)?\n- How handle negative numbers in A?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Instacart","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T17:54:17.619Z","createdAt":"2026-01-14T17:54:17.619Z"},{"id":"q-2170","question":"You're given an array values[0..n-1] of positive integers. Two players take turns removing either the leftmost or rightmost value and add it to their score. Assuming both play optimally, return A's maximum guaranteed total score and the move sequence (L/R) for each turn. Provide a DP formulation with dp[i][j] as the maximum score difference for subarray i..j, the base cases, and how to reconstruct the moves?","answer":"DP idea: let dp[i][j] be the maximum difference current player can achieve over the opponent from values[i..j]. Transition: dp[i][j] = max(values[i] - dp[i+1][j], values[j] - dp[i][j-1]); base: dp[i][","explanation":"## Why This Is Asked\nThis tests minimax-style DP with reconstruction for a classic game.\n\n## Key Concepts\n- Two-player DP with difference state\n- Subarray DP and reconstruction path\n- Time: O(n^2) space: O(n^2)\n\n## Code Example\n```javascript\n// dp[i][j] denotes max diff for i..j\nfunction maxFirstPlayer(values){\n  const n = values.length; const dp = Array.from({length:n},()=>Array(n).fill(0));\n  let total = values.reduce((a,b)=>a+b,0);\n  for(let i=0;i<n;i++) dp[i][i]=values[i];\n  for(let len=2; len<=n; len++){\n    for(let i=0;i+len-1<n;i++){\n      const j=i+len-1;\n      dp[i][j] = Math.max(values[i]-dp[i+1][j], values[j]-dp[i][j-1]);\n    }\n  }\n  return (total + dp[0][n-1])/2;\n}\n```\n\n## Follow-up Questions\n- How would you reconstruct the exact L/R sequence from the DP table?\n- How does this change if moves include taking from both ends with a coin flip to decide who starts?","diagram":"flowchart TD\n  Start(Start) --> Choose{Take Left or Right?}\n  Choose --> ScoreLeft[Left contributes to current player]\n  Choose --> ScoreRight[Right contributes to current player]\n  ScoreLeft --> End\n  ScoreRight --> End","difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Lyft","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T05:46:13.890Z","createdAt":"2026-01-15T05:46:13.890Z"},{"id":"q-679","question":"In a warehouse grid of size n x m, each cell has a traversal cost. You can move only right or down from (0,0) to (n-1,m-1). You have a one-time token to halve the cost of exactly one visited cell. Design an O(nm) DP to compute the minimum path cost after optimally using the discount, and describe the recurrences and a space-optimized implementation?","answer":"Maintain two DP arrays: best without using the discount (dp0) and best with the discount already used (dp1). For grid costs c[i][j], set:\ndp0[i][j] = c[i][j] + min(dp0[i-1][j], dp0[i][j-1]);\ndp1[i][j]","explanation":"## Why This Is Asked\nTests real DP design with an extra state (discount used) and careful recurrence.\n\n## Key Concepts\n- 2D DP with a binary state (discount used or not)\n- Transitions combine taking cost with/without discount\n- Space optimization using rolling arrays\n\n## Code Example\n```javascript\nfunction minCostWithDiscount(grid){\n  const n = grid.length, m = grid[0].length;\n  const INF = 1e15;\n  let dp0 = new Array(m).fill(INF);\n  let dp1 = new Array(m).fill(INF);\n  dp0[0] = grid[0][0];\n  dp1[0] = Math.floor(grid[0][0] / 2);\n  for (let j = 1; j < m; j++) {\n    dp0[j] = grid[0][j] + dp0[j-1];\n    dp1[j] = Math.min(grid[0][j] + dp1[j-1], Math.floor(grid[0][j]/2) + dp0[j-1]);\n  }\n  for (let i = 1; i < n; i++) {\n    dp0[0] += grid[i][0];\n    dp1[0] = Math.min(grid[i][0] + dp1[0], Math.floor(grid[i][0]/2) + dp0[0-1]);\n    for (let j = 1; j < m; j++) {\n      const v = grid[i][j];\n      dp1[j] = Math.min(v + Math.min(dp1[j], dp1[j-1]), Math.floor(v/2) + Math.min(dp0[j], dp0[j-1]));\n      dp0[j] = v + Math.min(dp0[j], dp0[j-1]);\n    }\n  }\n  return dp1[m-1];\n}\n```\n\n## Follow-up Questions\n- How would you support multiple discounts or varying discount values?\n- How does this adapt if diagonal moves are allowed or costs can be negative?","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Snap","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-11T15:57:04.021Z","createdAt":"2026-01-11T15:57:04.021Z"},{"id":"q-691","question":"You're planning a delivery route along a straight street of n blocks. At block i you can advance up to jumps[i] blocks (at least 1). How many distinct routes reach block n-1 from block 0? If unreachable, return 0. Propose a dynamic-programming approach with dp[i] as ways to reach i and outline its time/space complexity, edge cases, and a brief correctness justification. How would you implement it?","answer":"Use a 1D DP: dp[i] is number of ways to reach i. Initialize dp[0] = 1. For i from 0 to n-1, let maxJump = min(jumps[i], n-1-i); for s from 1 to maxJump, dp[i+s] = (dp[i+s] + dp[i]) % 1000000007. Retur","explanation":"## Why This Is Asked\nTests counting paths with variable step lengths using DP, a common interview pattern in operations and logistics contexts.\n\n## Key Concepts\n- 1D DP for path counting\n- Handling variable jump lengths\n- Modulo arithmetic for large counts\n\n## Code Example\n```javascript\nfunction countWays(jumps){\n  const n = jumps.length;\n  const MOD = 1000000007;\n  const dp = new Array(n).fill(0);\n  dp[0] = 1;\n  for(let i = 0; i < n; i++){\n    const maxJump = Math.min(jumps[i], n - 1 - i);\n    for(let s = 1; s <= maxJump; s++){\n      dp[i + s] = (dp[i + s] + dp[i]) % MOD;\n    }\n  }\n  return dp[n - 1] || 0;\n}\n```\n\n## Follow-up Questions\n- How would you optimize to O(n) time if maxJump can be large but jumps form a sliding window of contributions?\n- How would you adjust for different termination criteria or multiple destinations?","diagram":"flowchart TD\n  Start([Start]) --> Init[dp[0] = 1]\n  Init --> Loop[for i in 0..n-1]\n  Loop --> Update[dp[i+s] += dp[i] for s<=maxJump]\n  Update --> End([Return dp[n-1]])","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Meta","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-11T16:24:20.467Z","createdAt":"2026-01-11T16:24:20.467Z"},{"id":"q-693","question":"You're building a daily workout planner. Over n days, you can pick Light (L) or Heavy (H) workouts, with a cooldown: after a Heavy, you must skip the next two days (no workouts). Given integers n and r, how many length-n sequences contain exactly r Heavy workouts and satisfy the cooldown rule? Provide a DP formulation with state dp[i][c][t] (days processed, cooldown days left, heavies used) and outline time/space complexity, edge cases, and a brief correctness justification?","answer":"DP state: dp[i][c][t] = ways to schedule first i days with c cooldown days left and t heavies used. If c>0, dp[i+1][c-1][t] += dp[i][c][t]. If c==0, Light gives dp[i+1][0][t] += dp[i][0][t], Heavy (t<","explanation":"## Why This Is Asked\nTests modeling of a constrained scheduling problem with cooldowns and counting exact occurrences, a staple DP pattern.\n\n## Key Concepts\n- Multidimensional DP with state: day, cooldown, heavies used\n- Transition logic for cooldown and action choices\n- Edge cases: maximum possible heavies, r bounds, unreachable states\n\n## Code Example\n```javascript\n// Pseudo-implementation sketch for DP planning\n```\n\n## Follow-up Questions\n- How would you adapt if cooldowns varied by the number of consecutive heavies?\n- How would you optimize space further for large n?","diagram":"flowchart TD\n  Start[Start] --> A[Initialize dp[0][0][0]=1]\n  A --> B{i from 0 to n-1}\n  B --> C[If c>0, carry to i+1 with c-1]\n  B --> D[If c==0, add Light to i+1 with c=0, t]\n  B --> E[If c==0, add Heavy to i+1 with c=2, t+1 if t<r]\n  C --> End1[Aggregate to dp[i+1]]\n  D --> End2\n  E --> End3\n  End1 --> End\n  End2 --> End\n  End3 --> End","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Google","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-11T17:15:40.264Z","createdAt":"2026-01-11T17:15:40.264Z"},{"id":"q-703","question":"You're navigating a warehouse grid of size n x m. Each cell (i, j) has a risk value r[i][j] ≥ 0, where higher means less safe. You may move only right or down from (0,0) to (n-1,m-1). Devise a dynamic-programming solution to minimize the maximum risk encountered on the path (i.e., minimize max(r[i][j]) along the path). Define a suitable dp[i][j], give the recurrence and base cases, describe reconstruction of the path, and analyze time/space complexity. How would you handle blocked cells by setting r[i][j] = INF?","answer":"Proposed DP: define dp[i][j] as the minimum possible maximum risk along any path from (0,0) to (i,j). Recurrence: dp[i][j] = min( max(dp[i-1][j], r[i][j]), max(dp[i][j-1], r[i][j]) ). Base: dp[0][0] =","explanation":"## Why This Is Asked\nThis question tests DP on grids with a minimax objective, reconstruction, and practical edge handling (blocked cells).\n\n## Key Concepts\n- DP on 2D grid with a minimax recurrence\n- Path reconstruction via predecessor tracking\n- Space optimization opportunities (1D row/column DP)\n- INF handling for blockers\n\n## Code Example\n```javascript\nfunction minMaxRisk(r) {\n  const n = r.length, m = r[0].length;\n  const INF = Number.POSITIVE_INFINITY;\n  const dp = Array.from({length: n}, () => Array(m).fill(INF));\n  const from = Array.from({length: n}, () => Array(m).fill(-1));\n  dp[0][0] = r[0][0];\n  for (let j = 1; j < m; j++) { dp[0][j] = Math.max(dp[0][j-1], r[0][j]); from[0][j] = 0; }\n  for (let i = 1; i < n; i++) { dp[i][0] = Math.max(dp[i-1][0], r[i][0]); from[i][0] = 1; }\n  for (let i = 1; i < n; i++) {\n    for (let j = 1; j < m; j++) {\n      const up = Math.max(dp[i-1][j], r[i][j]);\n      const left = Math.max(dp[i][j-1], r[i][j]);\n      if (up <= left) { dp[i][j] = up; from[i][j] = 0; } else { dp[i][j] = left; from[i][j] = 1; }\n    }\n  }\n  return {minMaxRisk: dp[n-1][m-1], parent: from};\n}\n```\n\n## Follow-up Questions\n- How would you extend to allow diagonal moves?\n- How would you adapt for multiple starting points or 3D grids?","diagram":"flowchart TD\n  A[Start] --> B[Compute dp per cell]\n  B --> C[Store predecessor for reconstruction]\n  C --> D[Reach (n-1,m-1)]\n  D --> E[Return minimal max risk]","difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["NVIDIA","Scale Ai","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-11T18:26:59.828Z","createdAt":"2026-01-11T18:26:59.828Z"},{"id":"q-716","question":"You're building a text formatter. Given a list of word lengths L = [l1, l2, ..., ln] and a maximum line width W, wrap the words into lines so that all lines except the last incur a penalty of (W - usedWidth)^2, where usedWidth = sum of word lengths on the line plus spaces between words. The last line has 0 penalty. Propose a dynamic programming solution with dp[i] representing the minimum penalty for words i..n-1, specify the recurrence, reconstruction method, and time/space complexity. How would you implement it?","answer":"DP on prefixes: dp[i] = minimum penalty for words i..n-1, with dp[n] = 0. For each i, extend line to j>=i; width = sum(len[i..j]) + (j - i); if width <= W then cost = (W - width)^2 + dp[j+1]. Take min","explanation":"## Why This Is Asked\\nThis gauges ability to cast a line-wrapping task into a clear 1D DP with a non-linear line cost and a reconstruction path. It tests handling of last-line quirks and feasibility checks.\\n\\n## Key Concepts\\n- 1D DP over word indices; dp[n] = 0 as base.\\n- Prefix sums to compute line width in O(1) per extension.\\n- Cost function uses squared unused space; last line excluded.\\n- Reconstruct solution via next indices.\\n- Time: O(n^2); Space: O(n).\\n\\n## Code Example\\n```javascript\\nfunction minWrap(words, W) {\\n  const n = words.length;\\n  const pref = new Array(n + 1).fill(0);\\n  for (let i = 0; i < n; i++) pref[i + 1] = pref[i] + words[i];\\n  const dp = new Array(n + 1).fill(Infinity);\\n  const nxt = new Array(n).fill(-1);\\n  dp[n] = 0;\\n  for (let i = n - 1; i >= 0; i--) {\\n    for (let j = i; j < n; j++) {\\n      const width = (pref[j + 1] - pref[i]) + (j - i);\\n      if (width <= W) {\\n        const cost = (W - width) * (W - width) + dp[j + 1];\\n        if (cost < dp[i]) { dp[i] = cost; nxt[i] = j + 1; }\\n      } else break;\\n    }\\n  }\\n  // reconstruction omitted for brevity\\n  return { minPenalty: dp[0], next: nxt };\\n}\\n```\\n\\n## Follow-up Questions\\n- How would you modify to penalize the last line as well?\\n- How would you incorporate tie-breaking to prefer fewer lines?\\n","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","DoorDash","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-11T19:18:59.844Z","createdAt":"2026-01-11T19:18:59.844Z"},{"id":"q-718","question":"You're given an array A[1..n] and an integer k. Partition into exactly k contiguous segments. The cost of a segment [t+1..i] is (sum(A[t+1..i]))^2. Return the minimum total cost and the partition indices. Propose DP: P as prefix sums, dp[i][j] = min_{t in [j-1..i-1]} dp[t][j-1] + (P[i]-P[t])^2, with base dp[0][0]=0. Explain reconstruction and discuss naive vs. optimized time, space, and edge cases?","answer":"DP formulation: P is prefix sums, dp[i][j] = min_{t in [j-1..i-1]} dp[t][j-1] + (P[i]-P[t])^2, with dp[0][0]=0; base dp[i][1] = P[i]^2. Reconstruct via argmin cuts. Naive O(n^2 k); with Divide-and-Con","explanation":"## Why This Is Asked\n\nTests DP over partitioning with a convex cost and requires reconstruction, while prompting awareness of optimizations for large n.\n\n## Key Concepts\n\n- DP on partitioning\n- Prefix sums\n- Cost convexity and optimization\n- Reconstruction of cuts\n\n## Code Example\n\n```javascript\n// skeleton: compute P, fill dp with divide-and-conquer optimization template\n```\n\n## Follow-up Questions\n\n- How would negative numbers affect correctness?\n- How would you implement the optimization in a streaming setting?","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-11T20:21:28.699Z","createdAt":"2026-01-11T20:21:28.699Z"},{"id":"q-731","question":"You're given an array A of length n with non-negative integers representing daily story points. You must partition the days into consecutive weeks, each containing 2–7 days. The cost of a week is (sum of that week's points − W)^2 where W is a fixed target. Return the minimum total cost to cover all days or INF if impossible. Propose a DP with dp[i] as min cost for first i days; dp[i] = min_{k=2..7, i-k>=0} dp[i-k] + (sum(i-k+1..i) − W)^2, using prefix sums for O(1) range sums. Reconstruct weeks and analyze time/space?","answer":"dp[i] = min over k in [2,7] of dp[i-k] + (pref[i]-pref[i-k] - W)^2, using pref for O(1) range sums. Base dp[0]=0; dp[i]=INF for invalid i. Reconstruct weeks via a parent pointer. Time: O(7n). Space: O","explanation":"## Why This Is Asked\nRealistic sprint planning with bounded weekly windows; tests ability to form and optimize DP with small constant branching and reconstruction.\n\n## Key Concepts\n- Prefix sums for fast range totals\n- DP with fixed window length (2..7)\n- Path reconstruction via parent pointers\n- Time O(n) with a small constant, Space O(n)\n\n## Code Example\n```javascript\nfunction minWeeklyCost(A, W) {\n  const n = A.length;\n  const pref = new Array(n+1).fill(0);\n  for (let i=1;i<=n;i++) pref[i] = pref[i-1] + A[i-1];\n  const INF = 1e18;\n  const dp = new Array(n+1).fill(INF);\n  const par = new Array(n+1).fill(-1);\n  dp[0] = 0;\n  for (let i=2; i<=n; i++) {\n    for (let k=2; k<=7; k++) {\n      if (i-k < 0) break;\n      const sum = pref[i] - pref[i-k];\n      const cost = dp[i-k] + (sum - W)*(sum - W);\n      if (cost < dp[i]) { dp[i] = cost; par[i] = i-k; }\n    }\n  }\n  // reconstruction would follow using par[]\n  return {cost: dp[n], prev: par[n]};\n}\n```\n\n## Follow-up Questions\n- How would you handle negative A values if allowed? \n- What changes if weeks must start on a specific weekday?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Salesforce","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-11T21:19:28.014Z","createdAt":"2026-01-11T21:19:28.014Z"},{"id":"q-736","question":"You're given an n x m grid. Each cell (i, j) has a color c[i][j] in [0, C-1] and a non-negative cost w[i][j]. Start at (0,0) and move to (n-1,m-1) with only right or down moves. You must visit at least one cell of every color that appears in the grid along your path. Return the minimum total cost to do so, or -1 if impossible. Describe a DP using dp[i][j][mask] where mask tracks visited colors; explain base cases, transitions from top/left, how to reconstruct the path, and complexity?","answer":"dp[i][j][mask] = min cost to reach (i,j) with colors mask; colorBit = 1<<c[i][j]. Only masks with (mask & colorBit) != 0 are valid. From top/left you may keep mask or use mask ^ colorBit to reflect co","explanation":"## Why This Is Asked\n\nTests DP with bitmask over colors along a grid path, forcing a nontrivial state and reconstruction.\n\n## Key Concepts\n- DP on Grid\n- Bitmask state compression\n- Transition handling when color is collected here vs earlier\n- Path reconstruction\n\n## Code Example\n\n```javascript\n// high-level outline for dp[i][j][mask]\n```\n\n## Follow-up Questions\n- How to scale when C is large (e.g., >20)?\n- How would you reconstruct the path from the dp table?","diagram":"flowchart TD\n  S(Start) --> A[dp[i][j][mask]]\n  A --> B{from top/left}\n  B --> C[dp[i-1][j][mask]]\n  B --> D[dp[i][j-1][mask]]\n  A --> E[compute min]\n  E --> F[store dp[i][j][mask]]","difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Netflix","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-11T22:19:51.690Z","createdAt":"2026-01-11T22:19:51.690Z"},{"id":"q-743","question":"You're given a list of n task durations L. Partition the tasks into consecutive days (each day at least one task); the cost of a day is the maximum duration on that day. Devise a DP to minimize the total cost across all days. Define dp[i] as the minimum cost for the first i tasks, provide the recurrence, reconstruction method, and complexity. How would you implement it?","answer":"We partition tasks into days; day cost is the maximum duration on that day. Let dp[0]=0 and for i from 1..n, dp[i]=min_{1<=k<=i}(dp[i-k]+max(L[i-k..i-1])); track cut[i]=k to reconstruct day boundaries","explanation":"## Why This Is Asked\nScheduling perspective: minimize peak workload across days; the DP is a straightforward partition DP with a range max cost. It tests understanding of maintaining running max within inner loop and reconstruction.\n\n## Key Concepts\n- DP over prefixes\n- Range max within an inner loop\n- Path reconstruction via cut[]\n- Edge cases: empty input, large n, identical durations\n\n## Code Example\n```javascript\nfunction minCostPartition(L){\n  const n=L.length;\n  const dp=new Array(n+1).fill(Infinity);\n  const cut=new Array(n+1).fill(0);\n  dp[0]=0;\n  for(let i=1;i<=n;i++){\n    let curMax=0;\n    for(let k=1;k<=i;k++){\n      curMax = Math.max(curMax, L[i-k]);\n      const val = dp[i-k] + curMax;\n      if(val < dp[i]){ dp[i] = val; cut[i] = k; }\n    }\n  }\n  const days=[];\n  let i=n;\n  while(i>0){\n    const k=cut[i];\n    days.push(L.slice(i-k, i));\n    i -= k;\n  }\n  days.reverse();\n  return {cost: dp[n], days};\n}\n```\n\n## Follow-up Questions\n- How would you adapt for a 2D grid of tasks with row/day semantics?\n- Can you optimize the inner loop to O(n) using a data structure for range max?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Slack","Stripe","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-11T23:18:27.166Z","createdAt":"2026-01-11T23:18:27.166Z"},{"id":"q-754","question":"Given a circular array v[1..n] of non-negative values and an integer d≥1, pick a subset of indices such that the cyclic distance between any two chosen indices is at least d. Maximize the sum of selected values; return both the maximum sum and the number of distinct optimal subsets. Constraints: n ≤ 2e5, v[i] ≤ 1e9. Describe an O(n) DP solution with two cases for circularity and how you'd reconstruct counts?","answer":"Use two-case DP on a linearized circle. Case A excludes index 1 and runs a linear DP on 2..n with dp[i]=max(dp[i-1], dp[i-d]+v[i]); Case B includes index 1, then run DP on the circularly valid segment","explanation":"## Why This Is Asked\nTests ability to design an optimized DP on a circular constraint and track the number of optimal solutions.\n\n## Key Concepts\n- DP on linear sequences with spacing (dp[i] = max(dp[i-1], dp[i-d] + v[i]))\n- Reducing circularity to two linear cases (include first vs exclude first)\n- Counting distinct optimal subsets with tie handling (sum counts when equal)\n\n## Code Example\n```javascript\nfunction linearDP(arr, d){\n  const n = arr.length; const dp = Array(n+1).fill(0); const ways = Array(n+1).fill(0);\n  dp[0] = 0; ways[0] = 1;\n  for(let i=1;i<=n;i++){\n    const take = arr[i-1] + (i-d>=0 ? dp[i-d] : 0);\n    const skip = dp[i-1];\n    if(take>skip){ dp[i]=take; ways[i]=(i-d>=0 ? ways[i-d] : 1); }\n    else if(take<skip){ dp[i]=skip; ways[i]=ways[i-1]; }\n    else { dp[i]=skip; ways[i] = ((i-d>=0 ? ways[i-d] : 1) + ways[i-1]); }\n  }\n  return [dp[n], ways[n]];\n}\n\nfunction maxCircular(v, d){\n  const [bestA, cntA] = linearDP(v.slice(1), d); // exclude first\n  const n = v.length;\n  const seg = (n > 2*d-1) ? v.slice(d, n-d+1) : [];\n  const [bestBseg, cntBseg] = seg.length ? linearDP(seg, d) : [0,1];\n  const bestB = v[0] + bestBseg;\n  if(bestA > bestB) return [bestA, cntA];\n  if(bestB > bestA) return [bestB, cntBseg];\n  return [bestA, cntA + cntBseg];\n}\n```\n\n## Follow-up Questions\n- How would you extend to allow a variable distance per pair or weighted distance penalties?\n- How would you test correctness and performance on worst-case inputs?","diagram":"flowchart TD\n  A[Start] --> B{Case A or Case B}\n  B --> C[DP on Case A (exclude 1)]\n  B --> D[DP on Case B (include 1)]\n  C --> E[Compare max sums]\n  D --> E\n  E --> F[Combine counts and return]","difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Netflix","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T01:32:37.055Z","createdAt":"2026-01-12T01:32:37.055Z"},{"id":"q-768","question":"You're given an array A of length n and an integer k. Partition A into exactly k non-empty contiguous subarrays. The cost of a subarray [t+1..i] is (max(A[t+1..i])) * (i-t). Return the minimum total cost and the partition indices. Propose DP: dp[i][j] = min_{t in [j-1..i-1]} dp[t][j-1] + max(A[t+1..i]) * (i-t). Explain reconstruction, base cases, and time/space?","answer":"Use dp[i][j] = min_t dp[t][j-1] + max(A[t+1..i])*(i-t). Base: dp[i][1] = max(A[1..i])*i. Precompute range maxima with mx[i][j] or compute on the fly in inner loop. Reconstruct via a predecessor table.","explanation":"## Why This Is Asked\nTests a non-trivial partition DP with a non-linear subarray cost and reconstruction.\n\n## Key Concepts\n- DP over partitions\n- Range maximum queries (precomputation or on-the-fly)\n- Path reconstruction via predecessor table\n\n## Code Example\n```javascript\nfunction minCostPartition(A, k) {\n  const n = A.length;\n  // precompute max for all ranges\n  const mx = Array.from({length: n}, ()=> Array(n).fill(0));\n  for (let i=0;i<n;i++){ mx[i][i]=A[i]; for(let j=i+1;j<n;j++) mx[i][j]=Math.max(mx[i][j-1], A[j]); }\n  const dp = Array.from({length: n+1}, ()=> Array(k+1).fill(Infinity));\n  const prv = Array.from({length: n+1}, ()=> Array(k+1).fill(-1));\n  dp[0][0]=0;\n  for(let i=1;i<=n;i++) dp[i][1] = mx[0][i-1]*(i);\n  for(let j=2;j<=k;j++){\n    for(let i=j;i<=n;i++){\n      for(let t=j-1;t<=i-1;t++){\n        const cost = dp[t][j-1] + mx[t][i-1]*(i-t);\n        if(cost < dp[i][j]){ dp[i][j]=cost; prv[i][j]=t; }\n      }\n    }\n  }\n  // reconstruction omitted for brevity\n  return {cost: dp[n][k], cutPoints: []};\n}\n```\n\n## Follow-up Questions\n- Can you optimize space to O(n) per k?\n- How to handle equal costs and tie-breaking?","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Robinhood","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T03:52:12.176Z","createdAt":"2026-01-12T03:52:12.176Z"},{"id":"q-777","question":"You're given an array A of non-negative integers representing task durations in order. You must schedule all n tasks into exactly m days. Each day can host a consecutive block with total duration <= D. The cost of a day is (sum of that day's durations)^2. Return the minimum total cost, or -1 if impossible? Propose a DP using dp[i][d] as min cost for first i tasks in d days, with transition dp[i][d] = min_{j<i, prefix[i]-prefix[j] <= D} dp[j][d-1] + (prefix[i]-prefix[j])^2. Include base cases, reconstruction, and time/space?","answer":"Use prefix sums and a 2D DP: dp[i][d] = min cost for first i tasks in d days, with dp[0][0]=0. For each i,d try all j<i where sum(j+1..i) <= D and set dp[i][d] = min(dp[i][d], dp[j][d-1] + (sum)^2). T","explanation":"## Why This Is Asked\nModels practical scheduling under capacity with a convex (squared) day cost, exercising 2D DP and reconstruction.\n\n## Key Concepts\n- DP over prefixes and days\n- Transition constrained by daily capacity D\n- Prefix sums for O(1) range sums\n- Backtracking via parent pointers to recover daily blocks\n- Complexity: O(n^2 m) time, O(n m) space\n\n## Code Example\n```javascript\nfunction minCostSchedule(A, m, D) {\n  const n = A.length;\n  const pref = new Array(n + 1).fill(0);\n  for (let i = 1; i <= n; i++) pref[i] = pref[i - 1] + A[i - 1];\n  const INF = Number.POSITIVE_INFINITY;\n  const dp = Array.from({ length: n + 1 }, () => new Array(m + 1).fill(INF));\n  const par = Array.from({ length: n + 1 }, () => new Array(m + 1).fill(-1));\n  dp[0][0] = 0;\n  for (let d = 1; d <= m; d++) {\n    for (let i = 1; i <= n; i++) {\n      for (let j = 0; j < i; j++) {\n        const sum = pref[i] - pref[j];\n        if (sum <= D && dp[j][d - 1] !== INF) {\n          const cost = dp[j][d - 1] + sum * sum;\n          if (cost < dp[i][d]) {\n            dp[i][d] = cost;\n            par[i][d] = j;\n          }\n        }\n      }\n    }\n  }\n  if (dp[n][m] === INF) return { cost: -1, blocks: [] };\n  const blocks = [];\n  let i = n, d = m;\n  while (d > 0) {\n    const j = par[i][d];\n    blocks.push([j + 1, i]);\n    i = j;\n    d--;\n  }\n  blocks.reverse();\n  return { cost: dp[n][m], blocks };\n}\n```\n\n## Follow-up Questions\n- How would you optimize to near O(n m) if D is small or sums have tighter bounds?\n- How would you present the actual day blocks to the user, including start/end indices and sums?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Apple","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T05:30:19.665Z","createdAt":"2026-01-12T05:30:19.665Z"},{"id":"q-786","question":"You have an array A of length n. Partition into exactly k non-empty contiguous blocks. The cost of a block [t+1..i] is (max(A[t+1..i])) * (sum(A[t+1..i])). Return the minimum total cost and the partition indices. Propose a DP formulation, reconstruction strategy, and complexity analysis. Assume 1-based indexing?","answer":"DP: dp[i][j] = min_{t in [j-1..i-1]} dp[t][j-1] + M(t+1,i) * (P[i]-P[t]), where P is prefix sum and M(t+1,i) is max on A[t+1..i]. Compute M on the fly by iterating t from i-1 down to j-1. Reconstruct ","explanation":"## Why This Is Asked\nTests a nontrivial DP with a block-cost dependent on both max and sum; requires handling both as a running statistic. \n\n## Key Concepts\n- DP over partitions into k blocks\n- Running block max and prefix sums\n- Reconstruction and complexity tradeoffs\n\n## Code Example\n```javascript\n// recurrence and reconstruction sketch\n```\n\n## Follow-up Questions\n- How to optimize with monotone queue or Divide-and-Conquer DP if the opt indices are monotone?\n- What about handling n up to 2e5 with large k and memory constraints?","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Scale Ai","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T06:38:54.270Z","createdAt":"2026-01-12T06:38:54.270Z"},{"id":"q-792","question":"You're given an array prices[0..n-1]. You may complete at most k buy-sell transactions (one share at a time, can't hold more than one). Return the maximum profit and the days of each trade. Propose a DP formulation with states cash[i][t] and hold[i][t], include recurrences, base cases, and reconstruction, and discuss time/space?","answer":"Max profit with at most k transactions on prices p[0..n-1]. Use DP with cash[i][t] and hold[i][t] representing max profit on day i with t completed transactions and not holding/holding. cash[i][t] = m","explanation":"## Why This Is Asked\nTests DP over time with multiple constraints: multiple transactions, reconstruction, and edge-case handling.\n\n## Key Concepts\n- Two DP states: cash (not holding) and hold (holding).\n- Transitions model buy/sell with transaction count t.\n- Base cases initialize day 0; backtracking recovers trade days.\n- Space optimization possible to O(k) with rolling arrays.\n\n## Code Example\n```javascript\nfunction maxProfit(prices, k){\n  const n = prices.length;\n  if (n===0 || k===0) return 0;\n  const cash = Array.from({length:n+1}, ()=> Array(k+1).fill(-1e15));\n  const hold = Array.from({length:n+1}, ()=> Array(k+1).fill(-1e15));\n  for (let t=0; t<=k; t++) cash[0][t] = (t===0)?0:-1e15;\n  for (let i=1; i<=n; i++){\n    for (let t=0; t<=k; t++){\n      cash[i][t] = cash[i-1][t];\n      if (t>0) cash[i][t] = Math.max(cash[i][t], hold[i-1][t] + prices[i-1]);\n      hold[i][t] = hold[i-1][t];\n      if (t>0) hold[i][t] = Math.max(hold[i][t], cash[i-1][t-1] - prices[i-1]);\n    }\n  }\n  let best = 0;\n  for (let t=0; t<=k; t++) best = Math.max(best, cash[n][t]);\n  return best;\n}\n```\n\n## Follow-up Questions\n- How would you recover the exact trade days from the DP table?\n- How does the solution change if k >= n/2 (unlimited transactions)?","diagram":"flowchart TD\n  Start([Start])\n  Day[Process day i from 0..n-1]\n  Trans{Choose action: buy, sell, hold}\n  CashUpdate[Update cash states]\n  HoldUpdate[Update hold states]\n  End([End with best cash])\n  Start --> Day --> Trans\n  Trans --> CashUpdate --> End\n  Trans --> HoldUpdate --> End","difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","IBM","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T07:28:11.075Z","createdAt":"2026-01-12T07:28:11.075Z"},{"id":"q-797","question":"You have an array of task difficulties A of length n. Partition it into exactly m non-empty contiguous chapters. Each chapter cost equals the maximum difficulty within that chapter. Return the minimum total cost and a valid partition (chapter end indices). Propose a DP: dp[i][j] = min_{t in [j-1..i-1]} dp[t][j-1] + max(A[t..i-1]), with base dp[i][1] = max(A[0..i-1]). Explain reconstruction, base cases, and time/space?","answer":"Define dp[i][j] as the minimum total cost to partition the first i tasks into j chapters. Recurrences: dp[i][1] = max(A[0..i-1]); for j>1, dp[i][j] = min_{t from j-1 to i-1} dp[t][j-1] + max(A[t..i-1]","explanation":"## Why This Is Asked\nTests ability to model partitioning with a simple per-block objective and reconstruct optimal cuts. It reveals DP formulation, range queries, and backtracking.\n\n## Key Concepts\n- Partition DP across two dimensions (prefix and blocks)\n- Range maximum precomputation or on-the-fly tracking\n- Backpointers for path reconstruction\n- Time/space trade-offs and potential optimizations\n\n## Code Example\n```javascript\nfunction minPartitionCostMax(A, m){\n  const n = A.length;\n  // precompute max for all ranges\n  const rangeMax = Array.from({length: n}, () => Array(n).fill(0));\n  for(let i=0;i<n;i++){\n    let cur = 0;\n    for(let j=i;j<n;j++){\n      cur = Math.max(cur, A[j]);\n      rangeMax[i][j] = cur;\n    }\n  }\n  const dp = Array.from({length: n+1}, () => Array(m+1).fill(Infinity));\n  const par = Array.from({length: n+1}, () => Array(m+1).fill(-1));\n  dp[0][0] = 0;\n  for(let i=1;i<=n;i++){\n    for(let j=1;j<=Math.min(i,m);j++){\n      for(let t=j-1; t<=i-1; t++){\n        const val = dp[t][j-1] + rangeMax[t][i-1];\n        if(val < dp[i][j]){\n          dp[i][j] = val;\n          par[i][j] = t;\n        }\n      }\n    }\n  }\n  // reconstruct\n  const cuts = [];\n  let i = n, j = m;\n  while(j>0){\n    const t = par[i][j];\n    cuts.push(i);\n    i = t;\n    j--;\n  }\n  cuts.reverse();\n  return {cost: dp[n][m], partitions: cuts};\n}\n```\n\n## Follow-up Questions\n- How would you optimize to O(n m) time using monotonic queues?  \n- How would you adapt if each chapter cost were max(A[t..i-1]) + c*(i-t)?","diagram":"flowchart TD\n  A[Start] --> B[Precompute rangeMax]\n  B --> C[DP transitions dp[i][j]]\n  C --> D[Backtrack cuts]\n  D --> E[Return result]","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","LinkedIn","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T08:28:52.276Z","createdAt":"2026-01-12T08:28:52.276Z"},{"id":"q-806","question":"You're given an n x m grid of digits grid[i][j] in [0..9]. You may move only right or down from (0,0) to (n-1,m-1). Define a path score as the number of times the next cell's digit is strictly larger than the previous cell's digit along the path. Return the maximum score and a valid path (as coordinates or directions). Propose a dynamic programming formulation with recurrences, base cases, and reconstruction, and discuss time/space?","answer":"We define dp[i][j] as the maximum ascents to reach (i,j). Base: dp[0][0] = 0; fill first row/column with dp[0][j] = dp[0][j-1] + (grid[0][j-1] < grid[0][j]); dp[i][0] = dp[i-1][0] + (grid[i-1][0] < gr","explanation":"## Why This Is Asked\nAssesses ability to turn path-based objectives into simple local transitions without extraneous state. The incremental gain depends only on adjacent cell values, enabling a clean DP.\n\n## Key Concepts\n- Grid DP with monotone moves\n- Backpointers for path reconstruction\n- Space optimization potential\n\n## Code Example\n```javascript\nfunction maxAscents(grid){\n  const n=grid.length, m=grid[0].length;\n  const dp=Array.from({length:n}, ()=>Array(m).fill(0));\n  const par=Array.from({length:n}, ()=>Array(m).fill(null));\n  for(let i=0;i<n;i++){\n    for(let j=0;j<m;j++){\n      if(i===0 && j===0) continue;\n      let top=-Infinity, left=-Infinity;\n      if(i>0) top = dp[i-1][j] + (grid[i-1][j] < grid[i][j] ? 1:0);\n      if(j>0) left = dp[i][j-1] + (grid[i][j-1] < grid[i][j] ? 1:0);\n      if(top >= left){ dp[i][j] = top; par[i][j] = 'U'; } else { dp[i][j] = left; par[i][j] = 'L'; }\n    }\n  }\n  // backtrack to build path\n  return {score: dp[n-1][m-1], path: []};\n}\n```","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Hugging Face","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T09:31:56.680Z","createdAt":"2026-01-12T09:31:56.680Z"},{"id":"q-813","question":"You're given a tree with N nodes (N up to 2e5). Each node i has a value val[i]. Find a connected subtree of exactly K nodes that maximizes the sum of values. Return the maximum sum and the node set. Propose a DP formulation with dp[u][s] = max sum of a connected subtree of size s that contains u and lies entirely within u's subtree when the tree is rooted at 1; include reconstruction, base cases, and discuss time/space?","answer":"Root the tree at 1. dp[u][s] = max sum of a connected subtree of size s that contains u and lies in u's subtree. Base: dp[u][1] = val[u]. For each child v, knapsack-merge: new[s+t] = max(old[s] + dp[v","explanation":"## Why This Is Asked\nTests a nontrivial tree DP pattern: building size-aware subproblems per node and merging children like a knapsack while preserving the connected-subtree constraint.\n\n## Key Concepts\n- Tree DP with per-node size states (O(nK))\n- Knapsack-style merge across an arbitrary number of children\n- Connected-subtree constraint implies a unique top node in a rooted tree\n- Reconstruction via choice-tracking during merges\n\n## Code Example\n```javascript\nfunction maxSubtreeOfSizeK(n, k, edges, val) {\n  // Placeholder skeleton for the DP approach over a rooted tree\n  // Build adjacency, root at 1, then perform DFS with knapsack merge per node\n  // Return {best: number, nodes: number[]}\n}\n```\n\n## Follow-up Questions\n- How to optimize memory to O(k) per node?\n- How does complexity change with high-degree nodes, and can we apply small-to-large merging to improve constants?","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T10:23:39.425Z","createdAt":"2026-01-12T10:23:39.425Z"},{"id":"q-821","question":"You're given a string s of length n consisting of lowercase letters. Partition s into at most k non-empty contiguous substrings. The cost of a substring is the number of distinct characters in that substring. Return the minimum total cost and one valid partition (end indices). Propose a DP formulation with recurrence dp[i][t] = min_{p in [t-1..i-1]} dp[p][t-1] + cost(p, i-1) where cost(p, q) is the number of distinct letters in s[p..q]. Explain reconstruction, base cases, and time/space complexity?","answer":"DP over cut positions: define dp[i][t] as min cost to split s[0..i-1] into t substrings, with a backpointer to recover the last cut. Precompute cost(p,i-1) = number of distinct letters in s[p..i-1] by","explanation":"## Why This Is Asked\n\nTests a non-trivial partition DP with a substring cost that requires precomputation and reconstruction, combining both combinatorial choices and an aggregate cost function.\n\n## Key Concepts\n\n- DP on partitions with a cost function over substrings\n- Efficient precomputation of substring distinct counts\n- Backtracking reconstruction of cut points\n- Time/space trade-offs and memory optimization\n\n## Code Example\n\n```javascript\n// Pseudo: precompute cost[p][i], then DP with backpointers\nconst n = s.length;\nconst INF = 1e9;\nconst cost = Array.from({ length: n }, () => Array(n).fill(0));\nfor (let p = 0; p < n; p++) {\n  const seen = new Array(26).fill(false);\n  let distinct = 0;\n  for (let i = p; i < n; i++) {\n    const idx = s.charCodeAt(i) - 97;\n    if (!seen[idx]) { seen[idx] = true; distinct++; }\n    cost[p][i] = distinct;\n  }\n}\nconst kCap = Math.min(k, n);\nconst dp = Array.from({ length: n+1 }, () => Array(kCap+1).fill(INF));\nconst prv = Array.from({ length: n+1 }, () => Array(kCap+1).fill(-1));\ndp[0][0] = 0;\nfor (let i = 1; i <= n; i++) {\n  for (let t = 1; t <= Math.min(i, kCap); t++) {\n    for (let p = t-1; p <= i-1; p++) {\n      const cand = dp[p][t-1] + cost[p][i-1];\n      if (cand < dp[i][t]) { dp[i][t] = cand; prv[i][t] = p; }\n    }\n  }\n}\n```\n","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","LinkedIn","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T11:19:30.997Z","createdAt":"2026-01-12T11:19:30.997Z"},{"id":"q-829","question":"You're given an array A of length n and an integer k. Partition A into exactly k non-empty contiguous subarrays. Each subarray's cost is max(A[l..r]) - min(A[l..r]). Return the minimum total cost and one valid partition (end indices). Propose a DP: dp[i][t] = min_{p in [t-1..i-1]} dp[p][t-1] + (max(A[p..i-1]) - min(A[p..i-1])); base: dp[i][1] = max(A[0..i-1]) - min(A[0..i-1]). Explain reconstruction, base cases, and time/space complexity?","answer":"DP over prefixes and segment counts: dp[i][t] = min over p of dp[p][t-1] + range(p, i-1), where range is max-min. Store cut indices for reconstruction. Base: dp[i][1] = range(0, i-1). Computing range ","explanation":"## Why This Is Asked\nTests DP with a range-based segment cost and path reconstruction, a common advanced pattern not covered yet.\n\n## Key Concepts\n- Contiguous partitioning\n- Range query (max-min)\n- DP with backtracking\n- Time/space trade-offs and potential optimizations\n\n## Code Example\n```javascript\nfunction minCostPartition(A, k) {\n  const n = A.length;\n  const dp = Array.from({ length: n + 1 }, () => Array(k + 1).fill(Infinity));\n  const cut = Array.from({ length: n + 1 }, () => Array(k + 1).fill(-1));\n  // base\n  for (let i = 1; i <= n; i++) {\n    let mx = -Infinity, mn = Infinity;\n    for (let p = i - 1; p >= 0; p--) {\n      mx = Math.max(mx, A[p]);\n      mn = Math.min(mn, A[p]);\n      dp[i][1] = Math.max(...A.slice(0, i)) - Math.min(...A.slice(0, i));\n    }\n  }\n  // transitions would fill dp[i][t] and cut[i][t]\n  return { cost: dp[n][k], partition: cut };\n}\n```\n\n## Follow-up Questions\n- How would you optimize range(p, i-1) queries to O(1) per transition?\n- How would you adapt for 1-indexed arrays or allow at most k segments?","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Hugging Face","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T12:41:45.018Z","createdAt":"2026-01-12T12:41:45.018Z"}],"subChannels":["general"],"companies":["Adobe","Amazon","Anthropic","Apple","Bloomberg","Citadel","Coinbase","Databricks","DoorDash","Goldman Sachs","Google","Hugging Face","IBM","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Netflix","OpenAI","Plaid","Robinhood","Salesforce","Scale Ai","Slack","Snap","Square","Stripe","Tesla","Twitter","Two Sigma","Uber"],"stats":{"total":23,"beginner":8,"intermediate":7,"advanced":8,"newThisWeek":23}}