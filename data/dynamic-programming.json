{"questions":[{"id":"q-1262","question":"You're given an array A of length n and an integer k. You must select exactly k non-overlapping, contiguous subarrays (non-empty) to maximize the sum of all selected elements. Return the maximum sum and the k subarrays (start and end indices). Propose a dynamic programming formulation with states and recurrences, include reconstruction, and discuss time/space complexity?","answer":"Define dp[i][t] = max sum using first i elements with exactly t subarrays, and local[i][t] = max sum ending at i with t subarrays. Recurrences: local[i][t] = max(local[i-1][t] + a[i], dp[i-1][t-1] + a","explanation":"## Why This Is Asked\nTests ability to extend Kadane to multiple disjoint subarrays with exact count, plus reconstruction.\n\n## Key Concepts\n- DP with two fabrics: global and local bests; disjoint subarray constraint; reconstruction path.\n- Space optimization and handling of -INF edge cases.\n\n## Code Example\n```javascript\n// sketch of DP with reconstruction\n```\n\n## Follow-up Questions\n- How would you modify if subarrays could be at most k? 2D dp change.\n- Could you implement an optimized solution with O(n log k) for larger constraints?","diagram":"flowchart TD\n  Start(Start) --> DPForm(DP Formulation)\n  DPForm --> Local(Local State)\n  DPForm --> Rec( reconstruction )\n  Local --> Reconstruct\n  Rec --> End(End)","difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T07:26:39.875Z","createdAt":"2026-01-13T07:26:39.875Z"},{"id":"q-1872","question":"You're given an n x m grid of integers grid[i][j]. From (0,0) to (n-1,m-1) you may move only right or down. You may turn at most K times (a turn is a change between directions). Return the maximum sum along a valid path and the path coordinates. Propose a DP with states dp[i][j][t][dir], recurrences, base cases, and reconstruction, and discuss time/space?","answer":"Propose dp[i][j][t][dir], where i,j cell, t turns used (0..K), dir ∈ {0=right,1=down}. Base: dp[0][0][0][0] = grid[0][0], dp[0][0][0][1] = grid[0][0]. Transitions: from (i,j-1) with same dir or with a","explanation":"## Why This Is Asked\nTests multi-dimensional DP with path reconstruction under a constrained number of turns, a common production planning scenario.\n\n## Key Concepts\n- 4D DP: i, j, t, dir\n- Transitions handle continuing in the same direction or taking a turn\n- Path reconstruction via parent pointers; edge-case handling when K is large\n- Complexity analysis and memory optimization considerations\n\n## Code Example\n```javascript\nfunction maxSumWithTurns(grid, K) {\n  const n = grid.length, m = grid[0].length;\n  // Placeholder: actual DP initialization and transitions would go here\n  return {best: 0, path: []};\n}\n```\n\n## Follow-up Questions\n- How would you optimize memory to O(n*m*(K+1))?\n- How would you adapt if turns also incur a penalty per turn?","diagram":"flowchart TD\n  A[Start] --> B[DP state: i, j, t, dir]\n  B --> C{Transitions}\n  C --> D[From left with same dir]\n  C --> E[From left with turn]\n  C --> F[From top with same dir]\n  C --> G[From top with turn]\n  D --> H[Update dp]\n  E --> H\n  F --> H\n  G --> H\n  H --> I[Reconstruct path]","difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","MongoDB","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T15:34:12.531Z","createdAt":"2026-01-14T15:34:12.531Z"},{"id":"q-1941","question":"You're given an array A of length n and an integer k. You must select at most k elements such that no two selected elements are adjacent. Return the maximum sum you can obtain and the list of selected indices. Propose a DP formulation with states dp[i][j], recurrences, base cases, and reconstruction?","answer":"DP uses dp[i][j] = max(dp[i-1][j], dp[i-2][j-1] + A[i-1]) for i>=2; base: dp[0][0]=0, dp[i][0]=0, dp[1][1]=A[0]. Reconstruct by backtracking from (n, min(k, floor((n+1)/2))). Time O(nk); space O(nk) (","explanation":"## Why This Is Asked\nTests DP with adjacency constraint and exact count; requires states over i and j, base cases, and backtracking.\n\n## Key Concepts\n- DP with two dimensions n and k\n- adjacency constraint via i-2 transition\n- reconstruction via parent pointers or decisions\n- space/time bounds and potential optimizations\n\n## Code Example\n```javascript\nfunction maxSumNoAdj(A, k) {\n  const n = A.length;\n  const K = Math.min(k, Math.floor((n + 1) / 2));\n  const dp = Array.from({ length: n + 1 }, () => Array(K + 1).fill(0));\n  const take = Array.from({ length: n + 1 }, () => Array(K + 1).fill(false));\n  for (let i = 1; i <= n; i++) {\n    for (let j = 0; j <= K; j++) {\n      dp[i][j] = dp[i - 1][j];\n      if (j > 0) {\n        if (i >= 2) {\n          const cand = dp[i - 2][j - 1] + A[i - 1];\n          if (cand > dp[i][j]) {\n            dp[i][j] = cand;\n            take[i][j] = true;\n          }\n        } else if (i === 1 && j === 1) {\n          if (A[0] > dp[i][j]) { dp[i][j] = A[0]; take[i][j] = true; }\n        }\n      }\n    }\n  }\n  // reconstruct\n  let i = n, j = K, indices = [];\n  while (i >= 1 && j >= 0) {\n    if (take[i][j]) { indices.push(i - 1); i -= 2; j -= 1; }\n    else { i -= 1; }\n  }\n  indices.reverse();\n  return { sum: dp[n][K], indices };\n}\n```\n\n## Follow-up Questions\n- How would you enforce exactly k selections vs at most k?\n- How to optimize space to O(k)?\n- How handle negative numbers in A?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Instacart","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T17:54:17.619Z","createdAt":"2026-01-14T17:54:17.619Z"},{"id":"q-2170","question":"You're given an array values[0..n-1] of positive integers. Two players take turns removing either the leftmost or rightmost value and add it to their score. Assuming both play optimally, return A's maximum guaranteed total score and the move sequence (L/R) for each turn. Provide a DP formulation with dp[i][j] as the maximum score difference for subarray i..j, the base cases, and how to reconstruct the moves?","answer":"DP idea: let dp[i][j] be the maximum difference current player can achieve over the opponent from values[i..j]. Transition: dp[i][j] = max(values[i] - dp[i+1][j], values[j] - dp[i][j-1]); base: dp[i][","explanation":"## Why This Is Asked\nThis tests minimax-style DP with reconstruction for a classic game.\n\n## Key Concepts\n- Two-player DP with difference state\n- Subarray DP and reconstruction path\n- Time: O(n^2) space: O(n^2)\n\n## Code Example\n```javascript\n// dp[i][j] denotes max diff for i..j\nfunction maxFirstPlayer(values){\n  const n = values.length; const dp = Array.from({length:n},()=>Array(n).fill(0));\n  let total = values.reduce((a,b)=>a+b,0);\n  for(let i=0;i<n;i++) dp[i][i]=values[i];\n  for(let len=2; len<=n; len++){\n    for(let i=0;i+len-1<n;i++){\n      const j=i+len-1;\n      dp[i][j] = Math.max(values[i]-dp[i+1][j], values[j]-dp[i][j-1]);\n    }\n  }\n  return (total + dp[0][n-1])/2;\n}\n```\n\n## Follow-up Questions\n- How would you reconstruct the exact L/R sequence from the DP table?\n- How does this change if moves include taking from both ends with a coin flip to decide who starts?","diagram":"flowchart TD\n  Start(Start) --> Choose{Take Left or Right?}\n  Choose --> ScoreLeft[Left contributes to current player]\n  Choose --> ScoreRight[Right contributes to current player]\n  ScoreLeft --> End\n  ScoreRight --> End","difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Lyft","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T05:46:13.890Z","createdAt":"2026-01-15T05:46:13.890Z"},{"id":"q-2405","question":"You're given an array A[0..n-1], and integers k, L, R. You must select exactly k non-overlapping contiguous subarrays such that each subarray's length is between L and R (inclusive). The sum of all elements in the selected subarrays is maximized. Return the maximum sum and the k subarrays (start and end indices). Provide a DP formulation with states, recurrences, base cases, and reconstruction, and discuss time/space?","answer":"Define dp[i][t] as the max sum using first i elements with exactly t segments, where each segment length in [L,R]. Recurrence: dp[i][t] = max(dp[i-1][t], max_{len∈[L,R]} dp[i-len][t-1] + (P[i]-P[i-len","explanation":"## Why This Is Asked\nTests a practical DP with fixed-length window constraints and reconstruction, mirroring analytics batching scenarios.\n\n## Key Concepts\n- DP over prefixes with exact segment count\n- Prefix sums for fast interval sums\n- Reconstruction path tracking\n\n## Code Example\n```javascript\nfunction maxKSubarraysWithBounds(A, k, L, R){\n  const n = A.length;\n  const P = new Array(n+1).fill(0);\n  for(let i=1;i<=n;i++) P[i] = P[i-1] + A[i-1];\n  const neg = -1/0; const dp = Array.from({length:n+1}, ()=> Array(k+1).fill(neg));\n  for(let i=0;i<=n;i++) dp[i][0] = 0;\n  const take = Array.from({length:n+1}, ()=> Array(k+1).fill(-1));\n  for(let i=1;i<=n;i++){\n    for(let t=1;t<=k;t++){\n      dp[i][t] = dp[i-1][t];\n      for(let len=L; len<=R && len<=i; len++){\n        if (dp[i-len][t-1] !== neg) {\n          const val = dp[i-len][t-1] + (P[i]-P[i-len]);\n          if (val > dp[i][t]){ dp[i][t] = val; take[i][t] = len; }\n        }\n      }\n    }\n  }\n  return {maxSum: dp[n][k], take}\n}\n```","diagram":"flowchart TD\n  A[Start: define dp[i][t]] --> B[Use first i elements with t segments]\n  B --> C[Recurrence: dp[i][t] = max(dp[i-1][t], max_len(dp[i-len][t-1] + sum))]\n  C --> D[Base cases: dp[0][0]=0; dp[i][0]=0]\n  D --> E[Reconstruction via take pointers]\n  E --> F[Complexities: time/space as per bounds]","difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T16:55:49.550Z","createdAt":"2026-01-15T16:55:49.550Z"},{"id":"q-2434","question":"You're given an array A of length n and an integer k. Choose exactly k non-empty, non-overlapping subarrays. The score of a subarray [l..r] is sum(A[l..r]) - min(A[l..r]). Return the maximum total score and the list of subarray endpoints (l, r). Propose a DP formulation: dp[i][t] = max_{p in [t-1..i-1]} dp[p][t-1] + sum(A[p+1..i]) - min(A[p+1..i]). Base: dp[i][1] = sum(A[1..i]) - min(A[1..i]). Include reconstruction, base cases, and time/space complexity?","answer":"Use dp[i][t] as the best score for first i elements using exactly t subarrays, with the t-th subarray ending at i. Recurrence: dp[i][t] = max_{p in [t-1..i-1]} dp[p][t-1] + (P[i]-P[p]) - min(A[p+1..i]","explanation":"## Why This Is Asked\nThis question tests a DP over partitioned subarrays with a non-standard per-subarray score and reconstruction.\n\n## Key Concepts\n- DP on non-overlapping subarrays\n- Prefix sums and range minimums\n- Path reconstruction and base cases\n- Complexity: O(n^2 k) time, O(nk) space\n\n## Code Example\n```javascript\nfunction maxScore(A, k){\n  const n = A.length; const P=[0]; for(let i=0;i<n;i++) P[i+1]=P[i]+A[i];\n  const dp=Array.from({length:n+1},()=>Array(k+1).fill(-Infinity));\n  const prev=Array.from({length:n+1},()=>Array(k+1).fill(-1));\n  for(let i=1;i<=n;i++) dp[i][1]=P[i]-Math.min(...A.slice(0,i));\n  for(let t=2;t<=k;t++){\n    for(let i=t;i<=n;i++){\n      for(let p=t-1;p<=i-1;p++){\n        const minVal=Math.min(...A.slice(p,i));\n        const val=dp[p][t-1]+(P[i]-P[p])-minVal;\n        if(val>dp[i][t]){ dp[i][t]=val; prev[i][t]=p; }\n      }\n    }\n  }\n  // reconstruction would trace back using prev\n  return dp[n][k];\n}\n```\n\n## Follow-up Questions\n- How to optimize min queries? N log N via RMQ, or a deque per i.\n- How to reconstruct the exact subarrays efficiently?","diagram":"flowchart TD\n  A[Start] --> B[Define dp[i][t]]\n  B --> C[Transition over p]\n  C --> D[Store prev pointers]\n  D --> E[Backtrack to subarrays]","difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Lyft","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T17:52:06.796Z","createdAt":"2026-01-15T17:52:06.796Z"},{"id":"q-2815","question":"You're given a rooted tree with n nodes, each node i has a value val[i]. You must choose a connected subgraph containing exactly k nodes to maximize the sum of values. Return the maximum sum and one such set of nodes. Propose a DP: dp[u][s] = maximum sum of a connected subgraph of size s that lies within the subtree of u and includes u. Explain the recurrence and reconstruction, and discuss time/space?","answer":"Use a DFS-based DP on trees: define dp[u][s] as max sum of a connected subgraph of size s that includes u and lies within u's subtree. Merge child DP arrays via knapsack-convolution, capping at k. Bas","explanation":"## Why This Is Asked\n\nTests advanced tree DP with a connectivity constraint and a knapsack-like merge across children. Requires careful reconstruction of the chosen nodes.\n\n## Key Concepts\n\n- Tree DP: dp[u][s] for connected subgraphs containing u within its subtree\n- Knapsack-like merging of children to combine subtree sizes\n- Path reconstruction: storing decisions to recover node set\n- Complexity: O(nk) time and O(nk) space; handle negative values with offset\n\n## Code Example\n\n```javascript\nfunction maxConnectedSubtreeSum(n, k, edges, val) {\n  const g = Array.from({ length: n }, () => []);\n  for (const [u, v] of edges) { g[u].push(v); g[v].push(u); }\n  const parent = Array(n).fill(-1);\n  const order = [];\n  function dfs(u, p) {\n    parent[u] = p;\n    for (const v of g[u]) if (v !== p) dfs(v, u);\n    order.push(u);\n  }\n  dfs(0, -1);\n  // dp[u] will be an array of length min(subtreeSize[u], k) + 1\n  // Initialization, merging and reconstruction would follow a standard tree knapsack pattern\n  // Full implementation is lengthy; outline focuses on the recurrence above\n  return { best: null, nodes: [] };\n}\n```\n\n## Follow-up Questions\n\n- How would you reconstruct the actual node set from dp? \n- How to handle multiple optimal sets? \n- How would you adapt for unrooted trees or multiple roots?","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T13:49:35.426Z","createdAt":"2026-01-16T13:49:35.428Z"},{"id":"q-2880","question":"You're given an array A of length n and an integer m (1 <= m <= n). You must select exactly m indices i1 < i2 < ... < im to form a subsequence. The cost is the sum over k=2..m of |A[ik] - A[ik-1]|. Return the minimum possible cost and the corresponding indices. Propose a DP formulation with states dp[i][t], recurrences, base cases, and reconstruction, and discuss time/space complexity and potential optimizations?","answer":"dp[i][t] = min_{p<i} dp[p][t-1] + abs(A[i]-A[p]); base dp[i][1] = 0. The result is min_i dp[i][m], with reconstruction via a parent pointer. Time: O(n^2 m); space: O(n m); optimize with rolling arrays","explanation":"## Why This Is Asked\nTests DP on subsequences with transition costs; requires deriving a 2D DP with O(n^2 m) time and backpointers. Edge cases: m=1 yields 0. Consider tie-breaking on reconstruction.\n\n## Key Concepts\n- DP on subsequences; 2D states; O(n^2 m) time; backtracking via parents; rolling arrays for space.\n\n## Code Example\n```javascript\nfunction minCostSubseq(A, m){\n  const n = A.length;\n  const INF = 1e18;\n  const dp = Array.from({length: n}, ()=>Array(m+1).fill(INF));\n  const par = Array.from({length: n}, ()=>Array(m+1).fill(-1));\n  for(let i=0; i<n; i++) dp[i][1] = 0;\n  for(let i=0; i<n; i++){\n    for(let t=2; t<=m; t++){\n      for(let p=0; p<i; p++){\n        const val = dp[p][t-1] + Math.abs(A[i]-A[p]);\n        if(val < dp[i][t]){ dp[i][t] = val; par[i][t] = p; }\n      }\n    }\n  }\n  let best = INF, end = -1;\n  for(let i=0; i<n; i++){ if(dp[i][m] < best){ best = dp[i][m]; end = i; } }\n  const idx = []; let t=m, cur = end;\n  while(t >= 1){ idx.push(cur); cur = par[cur][t]; t--; }\n  idx.reverse();\n  return {cost: best, indices: idx};\n}\n```","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T15:49:32.307Z","createdAt":"2026-01-16T15:49:32.307Z"},{"id":"q-2886","question":"You're given an array A of length n and an integer k. Find a non-contiguous subsequence of length exactly k that is non-decreasing (A[i1] <= A[i2] <= ... <= A[ik]), maximizing the sum of its elements. Return the maximum sum and the indices of the chosen elements. Propose a DP: dp[i][t] = max sum of a non-decreasing subsequence of length t ending at i. Recurrence: dp[i][1] = A[i]; dp[i][t] = A[i] + max_{j<i, A[j] <= A[i]} dp[j][t-1]. Include reconstruction, base cases, and time/space complexity?","answer":"DP approach: dp[i][t] stores the max sum of a non-decreasing subsequence of length t ending at i. Init dp[i][1] = A[i]. For t>1, dp[i][t] = A[i] + max_{j<i, A[j] <= A[i]} dp[j][t-1], with a parent poi","explanation":"## Why This Is Asked\nTests extending MSIS to fixed-length subsequences and reconstruction; good for beginners to show DP with path recovery.\n\n## Key Concepts\n- Non-contiguous subsequences\n- DP over i and t\n- Reconstruction via parent pointers\n\n## Code Example\n```javascript\nfunction maxSumNonDecreasing(A, k) {\n  // implementation outline\n}\n```\n\n## Follow-up Questions\n- How to handle equal vs strictly increasing subsequences?\n- How to optimize with prefix maxima to reduce time?","diagram":"flowchart TD\n  A[Start] --> B[Init dp and par]\n  B --> C[Iterate t = 2..k]\n  C --> D[Compute dp[i][t] via max over j<i, A[j] <= A[i]]\n  D --> E[Backtrack indices]","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Snap","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T16:39:46.090Z","createdAt":"2026-01-16T16:39:46.092Z"},{"id":"q-3070","question":"You're given an array A of length n and an integer d. You may select a subsequence (not necessarily contiguous) such that for every pair of consecutive chosen elements A[i] and A[j] with i<j, |A[i]-A[j]| <= d. Maximize the sum of the chosen elements. Return the maximum sum and one valid subsequence of indices. Provide the DP formulation, reconstruction approach, and discuss time/space?","answer":"Let dp[i] be the maximum sum of a valid subsequence ending at index i with value A[i]. Then dp[i] = A[i] + max{ dp[j] | j < i and |A[i] - A[j]| ≤ d }, or dp[i] = A[i] if no such j exists. Track parent[i] to reconstruct the optimal subsequence.","explanation":"## Why This Is Asked\nThis question tests building a DP over subsequences with constraints, requiring a clear state definition and transition over previous indices, plus reconstruction capabilities.\n\n## Key Concepts\n- Subsequence DP with constraints\n- State dp[i] and parent tracking\n- Time/space analysis and reconstruction\n\n## Code Example\n```javascript\nfunction maxSubseqWithDiff(a, d) {\n  const n = a.length;\n  const dp = Array(n).fill(0);\n  const par = Array(n).fill(-1);\n  let best = -Infinity, bestIdx = -1;\n  \n  for (let i = 0; i < n; i++) {\n    dp[i] = a[i];\n    for (let j = 0; j < i; j++) {\n      if (Math.abs(a[i] - a[j]) <= d && dp[j] + a[i] > dp[i]) {\n        dp[i] = dp[j] + a[i];\n        par[i] = j;\n      }\n    }\n    if (dp[i] > best) {\n      best = dp[i];\n      bestIdx = i;\n    }\n  }\n  \n  // Reconstruct subsequence\n  const seq = [];\n  let curr = bestIdx;\n  while (curr !== -1) {\n    seq.push(curr);\n    curr = par[curr];\n  }\n  return { maxSum: best, subsequence: seq.reverse() };\n}\n```\n\n## Time/Space Complexity\nTime: O(n²) due to nested loops checking all previous indices\nSpace: O(n) for dp and parent arrays","diagram":"flowchart TD\n  Start([Start]) --> DPState[DP State dp[i]]\n  DPState --> Transitions[Compute transitions from j<i with |A[i]-A[j]|<=d]\n  Transitions --> Reconstruct[Track parent and reconstruct indices]\n  Reconstruct --> End([End])","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Coinbase","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T04:07:28.782Z","createdAt":"2026-01-16T23:40:00.236Z"},{"id":"q-3196","question":"You're given an array A of length n and an integer k. Partition A into exactly k non-empty contiguous subarrays. The score of a subarray [l..r] is the sum of |A[i+1]-A[i]| for i in [l..r-1]. Return the maximum total score and the partition endpoints (end indices). Propose a DP: dp[i][t] = max_{p in [t-1..i-1]} dp[p][t-1] + sum_{q=p+1}^{i-1} |A[q+1]-A[q]|. Base: dp[i][1] = sum_{q=1}^{i-1} |A[q+1]-A[q]|. Explain reconstruction, base cases, and time/space complexity?","answer":"Compute diff and prefix sums to turn subarray score into a prefix-difference. Define dp[i][t] as max score for first i elements split into t blocks. Then dp[i][1] = pref[i-1], and dp[i][t] = pref[i-1]","explanation":"## Why This Is Asked\n\nTests ability to design a DP with partitioning and additive segment costs; uses prefix sums to optimize the transition to O(nk).\n\n## Key Concepts\n\n- DP on partitioning into k segments\n- Prefix sums to compute segment costs in O(1)\n- State transition optimization with a running max and backpointers\n- Reconstruction of cut points\n\n## Code Example\n\n```javascript\nfunction maxPartitionScore(A, k){\n  const n = A.length;\n  if (k <= 0 || k > n) return {score: 0, cuts: []};\n  const diff = new Array(n-1).fill(0);\n  for (let i = 0; i < n-1; i++) diff[i] = Math.abs(A[i+1] - A[i]);\n  const pref = new Array(n).fill(0);\n  for (let i = 1; i < n; i++) pref[i] = pref[i-1] + diff[i-1];\n  const dp = Array.from({length: n+1}, () => new Array(k+1).fill(-Infinity));\n  const take = Array.from({length: n+1}, () => new Array(k+1).fill(-1));\n  for (let i = 1; i <= n; i++) dp[i][1] = pref[i-1];\n  for (let t = 2; t <= k; t++) {\n    let best = -Infinity, bestP = -1;\n    for (let i = t; i <= n; i++) {\n      const p = i - 1;\n      const val = dp[p][t-1] - pref[p];\n      if (val > best) { best = val; bestP = p; }\n      dp[i][t] = pref[i-1] + best;\n      take[i][t] = bestP;\n    }\n  }\n  let cuts = [];\n  let i = n, t = k;\n  while (t > 0) {\n    const p = take[i][t];\n    cuts.push(i);\n    i = p;\n    t--;\n  }\n  cuts.reverse();\n  return {score: dp[n][k], cuts};\n}\n```","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","NVIDIA","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T06:47:08.446Z","createdAt":"2026-01-17T06:47:08.446Z"},{"id":"q-3322","question":"You're given an array A of length n and an integer k. Partition A into exactly k non-empty contiguous subarrays. Each subarray's score is the number of distinct elements within that subarray. Return the maximum total score across all partitions and the k subarrays' boundaries (start and end indices). Propose a DP formulation with states dp[i][t], recurrences, base cases, reconstruction, and discuss time/space complexity?","answer":"DP idea: dp[i][t] = max total distincts for partitioning A[0..i-1] into t blocks. Recurrence: dp[i][t] = max_{p in [t-1..i-1]} dp[p][t-1] + D(p, i-1) where D(p,i-1) is the number of distinct elements ","explanation":"## Why This Is Asked\nTests a less-traveled DP angle: maximizing a sum of subarray-specific statistics (distinct counts) with exact segmentation. Requires careful state design and backtracking for reconstruction.\n\n## Key Concepts\n- DP over prefix end i and segment count t\n- Subarray distinct counts D(p,i-1)\n- Backpointers for reconstruction\n- Time: O(n^2 k), Space: O(nk)\n\n## Code Example\n```javascript\nfunction maxDistinctPartition(A, k) {\n  const n = A.length;\n  // Precompute distinct counts D[l][r]\n  const D = Array.from({ length: n }, () => Array(n).fill(0));\n  for (let l = 0; l < n; l++) {\n    const seen = new Set();\n    for (let r = l; r < n; r++) {\n      seen.add(A[r]);\n      D[l][r] = seen.size;\n    }\n  }\n  const dp = Array.from({ length: n + 1 }, () => Array(k + 1).fill(-Infinity));\n  const bt = Array.from({ length: n + 1 }, () => Array(k + 1).fill(-1));\n  for (let i = 1; i <= n; i++) dp[i][1] = D[0][i - 1];\n  for (let t = 2; t <= k; t++) {\n    for (let i = t; i <= n; i++) {\n      for (let p = t - 1; p <= i - 1; p++) {\n        const cand = dp[p][t - 1] + D[p][i - 1];\n        if (cand > dp[i][t]) { dp[i][t] = cand; bt[i][t] = p; }\n      }\n    }\n  }\n  // reconstruct\n  let i = n, t = k;\n  const segs = [];\n  while (t > 0) {\n    const p = bt[i][t];\n    segs.push([p, i - 1]);\n    i = p; t--;\n  }\n  segs.reverse();\n  return { best: dp[n][k], segments: segs };\n}\n```\n\n## Follow-up Questions\n- How would you optimize to O(nk) memory?\n- How would you handle at most k segments instead of exactly k?\n- Can you adapt to streaming data or reconstruct segments efficiently for large n?","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Anthropic","Apple"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T11:30:58.421Z","createdAt":"2026-01-17T11:30:58.421Z"},{"id":"q-3392","question":"You are given an array A of length n and an integer m. You must select exactly m indices i1 < i2 < ... < im. The total cost is sum_{t=2..m} |A[i_t] - A[i_{t-1}]|. Return the minimum total cost and the indices. Propose a DP formulation with states dp[i][t] representing the minimum cost ending at i as the t-th picked element, base cases, recurrences, how to reconstruct the path, and discuss time/space complexity and possible optimizations?","answer":"Define dp[i][t] = minimum cost to pick t elements with i as the last pick. Base: dp[i][1] = 0. Recurrence: dp[i][t] = min_{j<i} (dp[j][t-1] + |A[i]-A[j]|). Track parent par[i][t] = argmin. Final answe","explanation":"## Why This Is Asked\nTests DP over subsequences with a fixed length and pairwise costs, plus explicit reconstruction. It moves beyond contiguous partitions by requiring last-step linkage through prior picks.\n\n## Key Concepts\n- Subsequence DP with fixed length\n- Min-over-predecessor recurrence\n- Path reconstruction via parent pointers\n- Time/space trade-offs and practical optimizations\n\n## Code Example\n```javascript\nfunction solve(A, m){\n  const n=A.length;\n  const dp=Array.from({length:n},()=>Array(m+1).fill(Infinity));\n  const par=Array.from({length:n},()=>Array(m+1).fill(-1));\n  for(let i=0;i<n;i++) dp[i][1]=0;\n  for(let t=2;t<=m;t++){\n    for(let i=t-1;i<n;i++){\n      for(let j=t-2;j<i;j++){\n        const c=dp[j][t-1]+Math.abs(A[i]-A[j]);\n        if(c<dp[i][t]){ dp[i][t]=c; par[i][t]=j; }\n      }\n    }\n  }\n  let best=Infinity,bestI=-1;\n  for(let i=m-1;i<n;i++){ if(dp[i][m]<best){ best=dp[i][m]; bestI=i; } }\n  const path=[];\n  let cur=bestI, t=m;\n  while(t>=1){\n    path.push(cur);\n    cur=par[cur][t];\n    t--;\n  }\n  path.reverse();\n  return {cost:best, indices:path};\n}\n```","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Meta","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T14:32:09.857Z","createdAt":"2026-01-17T14:32:09.858Z"},{"id":"q-3492","question":"You're given an array A of length n and an integer k. Partition A into exactly k non-empty contiguous subarrays. Each subarray's cost is the maximum element within that subarray. Return the minimum total cost and the partition endpoints. Propose a DP formulation with states dp[i][t] representing the minimum cost to partition the first i elements into t subarrays, with recurrence dp[i][t] = min_{p in [t-1..i-1]} dp[p][t-1] + max(A[p+1..i]). Base: dp[i][1] = max(A[1..i]). Describe reconstruction, base cases, and time/space complexity?","answer":"Define dp[i][t] as the minimum cost to partition first i elements into t blocks. Transition: dp[i][t] = min_{p ∈ [t-1..i-1]} dp[p][t-1] + max(A[p+1..i]). We can reconstruct with prev[i][t] = argmin p.","explanation":"## Why This Is Asked\nTests DP over prefixes with a non-linear subarray cost (max) and requires reconstruction.\n\n## Key Concepts\n- DP over prefixes and partition count\n- On-the-fly max for subarray cost\n- Reconstruction via prev pointers\n- Time/space trade-offs (O(n^2 k) time, O(nk) space)\n\n## Code Example\n```javascript\nfunction minCostPartition(A, k){\n  const n = A.length;\n  const INF = 1e15;\n  const dp = Array.from({length: n+1}, ()=> Array(k+1).fill(INF));\n  const prev = Array.from({length: n+1}, ()=> Array(k+1).fill(-1));\n  dp[0][0] = 0;\n  for(let i=1; i<=n; i++){\n    for(let t=1; t<=Math.min(i,k); t++){\n      let curMax = -Infinity;\n      for(let p=i-1; p>=t-1; p--){\n        curMax = Math.max(curMax, A[p]);\n        const val = dp[p][t-1] + curMax;\n        if(val < dp[i][t]){ dp[i][t] = val; prev[i][t] = p; }\n      }\n    }\n  }\n  return {cost: dp[n][k], prev};\n}\n```\n\n## Follow-up Questions\n- How would you optimize to O(nk) if cost allowed a Monge property? \n- How would you extend to allow a penalty for creating a new subarray? ","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Lyft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T18:48:30.829Z","createdAt":"2026-01-17T18:48:30.829Z"},{"id":"q-3812","question":"You are given a string s of length n over lowercase letters. You may delete characters to obtain a string that strictly alternates between two distinct characters, e.g., abab... or xyxy.... Choose any two distinct characters and delete all other characters. Return the maximum possible length and the pair (a,b) of characters used. Propose a DP to compute, for each ordered pair (a,b), the longest alternating subsequence using only a and b; include base cases, transitions, and how to reconstruct the solution?","answer":"Enumerate ordered pairs (a,b) with a != b (26*25). For each pair, compute the longest alternating subsequence using DP with two ends: endA = max length ending with a, endB = max length ending with b. ","explanation":"## Why This Is Asked\nTests DP over subsequences with a practical text-processing flavor and shows how to structure state for two-character alternation.\n\n## Key Concepts\n- DP over character pairs\n- Two-state subsequence extension\n- Reconstruction from DP\n\n## Code Example\n```javascript\n// Pseudocode for one pair (a,b)\nlet endA = 0, endB = 0;\nfor (const ch of s) {\n  if (ch === a) endA = Math.max(endA, endB + 1);\n  else if (ch === b) endB = Math.max(endB, endA + 1);\n}\nreturn Math.max(endA, endB); // ignore if < 2\n```\n\n## Follow-up Questions\n- How would you optimize to stop early if remaining chars cannot improve the best pair?\n- How would you modify to require both letters appear at least once in the final subsequence?","diagram":"flowchart TD\n  A[Start] --> B[Enumerate 26*25 pairs]\n  B --> C[DP per pair with endA, endB]\n  C --> D[Update best length and pair]\n  D --> E[Output max length and pair]","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T10:37:19.249Z","createdAt":"2026-01-18T10:37:19.250Z"},{"id":"q-3829","question":"You're given a DAG with n nodes and m directed edges. Each node i has value val[i]. For a fixed k, find a path with exactly k nodes maximizing the sum of values along the path. Return the max sum and the path as node indices. Provide a DP formulation with states, recurrences, base cases, reconstruction, and complexity notes?","answer":"DP idea: topologically sort the DAG. Compute best[v][t] = max sum of a path of exactly t nodes ending at v. Base: best[v][1] = val[v]. For t=2..k, best[v][t] = val[v] + max_{u->v} best[u][t-1], track ","explanation":"## Why This Is Asked\nNew angle: constraining path length in a DAG mirrors many workflow and route-planning tasks in data pipelines and dispatch systems. DP with topological order gives a clean O(k*(n+m)) solution.\n\n## Key Concepts\n- DAG topological order\n- DP by path length\n- Parent pointers for reconstruction\n- Space/time tradeoffs and edge cases (unreachable states)\n\n## Code Example\n```python\n# Python sketch\nfrom math import inf\norder = topo_sort(graph)\nbest = [[-inf]* (k+1) for _ in range(n)]\npar = [[-1]*(k+1) for _ in range(n)]\nfor v in range(n): best[v][1] = val[v]\nfor t in range(2, k+1):\n  for v in order:\n    for u in preds[v]:\n      if best[u][t-1] + val[v] > best[v][t]:\n        best[v][t] = best[u][t-1] + val[v]\n        par[v][t] = u\nend_node = max(range(n), key=lambda v: best[v][k])\npath = []\ncur = end_node; t = k\nwhile t>=1 and cur!=-1:\n  path.append(cur)\n  cur = par[cur][t]; t-=1\npath.reverse()\n```\n\n## Follow-up Questions\n- How to handle negative values or ties?\n- Adapt to at-most k nodes and returning best among t≤k.\n- Space optimization with rolling arrays.","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T11:26:21.272Z","createdAt":"2026-01-18T11:26:21.272Z"},{"id":"q-3884","question":"You're given a string s of length n and an integer k (1 <= k <= n). Partition s into exactly k non-empty contiguous substrings. For each substring, define cost as the minimum number of character changes required to make that substring a palindrome (i.e., the number of mismatched symmetric pairs). Return the minimum total cost and the partition boundaries that achieve it. Propose a DP formulation with precomputed costs cost[l][r], state dp[i][t] = min_{p in [t-1..i-1]} dp[p][t-1] + cost[p+1][i], base dp[i][1] = cost[1][i]. Describe reconstruction, base cases, and time/space complexity?","answer":"Proposed DP approach: precompute cost[l][r] = number of mismatching pairs in s[l..r] to become a palindrome (two-pointer count). Then DP: dp[i][t] = min over p in [t-1..i-1] dp[p][t-1] + cost[p+1][i],","explanation":"## Why This Is Asked\nTests DP with partitioning and a nontrivial per-substring cost, plus backtracking to recover partitions.\n\n## Key Concepts\n- DP over partitions: dp[i][t]\n- Precompute cost[l][r] in O(n^2) via two-pointer mismatches\n- Backpointers for reconstruction\n- Complexity: O(n^2 k) time, O(n^2) space\n\n## Code Example\n```javascript\nfunction minCostPalindromePartitions(s, k) {\n  const n = s.length;\n  const cost = Array.from({length: n}, ()=> Array(n).fill(0));\n  for (let l = 0; l < n; l++) {\n    for (let r = l; r < n; r++) {\n      let a = l, b = r, c = 0;\n      while (a < b) { if (s[a] !== s[b]) c++; a++; b--; }\n      cost[l][r] = c;\n    }\n  }\n  const dp = Array.from({length: n}, () => Array(k + 1).fill(Infinity));\n  const parent = Array.from({length: n}, () => Array(k + 1).fill(-1));\n  for (let i = 0; i < n; i++) dp[i][1] = cost[0][i];\n  for (let t = 2; t <= k; t++) {\n    for (let i = t - 1; i < n; i++) {\n      for (let p = t - 2; p < i; p++) {\n        const val = dp[p][t - 1] + cost[p + 1][i];\n        if (val < dp[i][t]) { dp[i][t] = val; parent[i][t] = p; }\n      }\n    }\n  }\n  const splits = [];\n  let i = n - 1, t = k;\n  while (t >= 1) {\n    splits.push(i);\n    i = parent[i][t];\n    t--;\n  }\n  splits.reverse();\n  return { minCost: dp[n - 1][k], partitions: splits };\n}\n```\n\n## Follow-up Questions\n- How would you optimize space for large n or small k?\n- How would this adapt if cost used a different per-substring metric?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T13:47:11.312Z","createdAt":"2026-01-18T13:47:11.313Z"},{"id":"q-3940","question":"You're given a string s of length n and an integer k. You may delete at most k characters from s. What is the maximum possible length of a palindromic subsequence in the remaining string? Provide a DP formulation using dp[i][j][d] as the max palindrome length in s[i..j] after exactly d deletions within that subrange. Include recurrences, base cases, reconstruction hints, and time/space complexities. Example: s = \"abca\", k = 1?","answer":"Use a 3D DP: dp[i][j][d] = max palindrome length in s[i..j] after exactly d deletions. If s[i]==s[j], dp[i][j][d] = max(dp[i+1][j-1][d]+2, dp[i+1][j][d-1], dp[i][j-1][d-1]); else dp[i][j][d] = max(dp[","explanation":"## Why This Is Asked\nTests budgeted DP on strings and reconstruction. \n\n## Key Concepts\n- dp[i][j][d] encodes a subproblem under a deletion budget; \n- palindrome subsequence logic with matches/skips; \n- reconstruction paths under deletion budget.\n\n## Code Example\n```javascript\nfunction maxPalWithDeletions(s, k){\n  const n=s.length; \n  const dp=Array.from({length:n},()=>Array.from({length:n},()=>Array(k+1).fill(0)));\n  for(let i=0;i<n;i++){ dp[i][i][0]=1; for(let d=1; d<=k; d++) dp[i][i][d]=1; }\n  for(let len=2; len<=n; len++){\n    for(let i=0; i+len-1<n; i++){\n      const j=i+len-1;\n      for(let d=0; d<=k; d++){\n        if(s[i]===s[j]){\n          dp[i][j][d]=Math.max(dp[i+1][j-1][d]+2, (d>0?dp[i+1][j][d-1]:0), (d>0?dp[i][j-1][d-1]:0));\n        } else {\n          dp[i][j][d]=Math.max(dp[i+1][j][d], dp[i][j-1][d], (d>0?dp[i+1][j-1][d-1]:0));\n        }\n      }\n    }\n  }\n  return Math.max(...Array.from({length:k+1},(_,d)=>dp[0][n-1][d]));\n}\n```\n\n## Follow-up Questions\n- Can space be reduced to O(n^2)?\n- How to reconstruct the deletion indices?\n- Change objective to count distinct palindromic subsequences with budget.","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Google","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T16:35:47.276Z","createdAt":"2026-01-18T16:35:47.276Z"},{"id":"q-4055","question":"You're given a numeric string s of length n and an integer k. Split s into exactly k non-empty contiguous substrings; interpret each substring as a decimal number with no leading zeros unless the substring is '0'. Minimize the sum of these k numbers. Return the minimum sum and the cut positions (indices after which a cut occurs). Propose a DP formulation with dp[i][t], recurrence, base cases, and reconstruction, plus time/space notes?","answer":"Split a numeric string s into exactly k non-empty contiguous substrings to minimize the sum of their numeric values. Each substring must not have leading zeros unless it is exactly \"0\". Use dynamic programming: dp[i][t] represents the minimum sum achievable by splitting the prefix s[0..i-1] into exactly t substrings. The recurrence is dp[i][t] = min(dp[j][t-1] + value(j,i-1)) for all j < i-1, where value(j,i-1) is the numeric value of s[j..i-1] if valid (no leading zeros unless single '0'). Base cases: dp[0][0] = 0, dp[i][0] = ∞ for i > 0, and dp[0][t] = ∞ for t > 0. Reconstruct the cut positions by storing predecessor indices during computation. Time complexity: O(n²k), Space complexity: O(nk) with optimization.","explanation":"## Why This Is Asked\n\nThis problem evaluates dynamic programming expertise across string partitioning with fixed segment counts, numeric parsing constraints, and solution reconstruction—fundamental skills for real-world interview scenarios.\n\n## Key Concepts\n\n- Dynamic programming over string prefixes and partition counts\n- Handling substring numeric values with leading-zero validation\n- Solution path reconstruction for determining optimal cut positions\n- Time and space complexity optimization techniques\n\n## Code Example\n\n```javascript\nfunction minSumPartition(s, k) {\n  const n = s.length;\n  \n  // Helper to get numeric value of substring [l, r)\n  const getValue = (l, r) => {\n    if (s[l] === '0' && r - l > 1) return null; // leading zero\n    return Number(s.slice(l, r));\n  };\n  \n  const dp = Array(n + 1).fill().map(() => Array(k + 1).fill(Infinity));\n  const parent = Array(n + 1).fill().map(() => Array(k + 1).fill(-1));\n  \n  dp[0][0] = 0;\n  \n  for (let i = 1; i <= n; i++) {\n    for (let t = 1; t <= k; t++) {\n      for (let j = t - 1; j < i; j++) {\n        const val = getValue(j, i);\n        if (val !== null && dp[j][t-1] + val < dp[i][t]) {\n          dp[i][t] = dp[j][t-1] + val;\n          parent[i][t] = j;\n        }\n      }\n    }\n  }\n  \n  // Reconstruct cuts\n  const cuts = [];\n  let curr = n, currT = k;\n  while (currT > 0) {\n    const prev = parent[curr][currT];\n    cuts.push(prev);\n    curr = prev;\n    currT--;\n  }\n  cuts.pop(); // remove 0\n  cuts.reverse();\n  \n  return { minSum: dp[n][k], cuts };\n}\n```\n\n## Notes\n\n- The DP explores all possible cut positions while respecting the k-substring constraint\n- Leading zero validation is crucial for correctness\n- The parent array enables O(k) reconstruction of optimal cuts","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["PayPal","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T06:04:27.158Z","createdAt":"2026-01-18T21:39:23.882Z"},{"id":"q-4189","question":"Grid path with constrained turns. You have an R x C grid with non-negative weights. Start at (0,0) and end at (R-1,C-1). You can move only right or down. You must make exactly k turns (a turn is when you switch from moving right to down or from down to right). Return the minimum path sum, or -1 if impossible. Propose a DP formulation using states dp[i][j][dir][t], with dir in {0,1} representing last move direction, t turns used. Include recurrences, base cases, reconstruction, and time/space analysis?","answer":"Approach: define dp[i][j][d][t] as min sum to reach (i,j) with last move d and t turns. Transitions: if d==0 (came from left), dp[i][j][0][t] = grid[i][j] + min(dp[i][j-1][0][t], dp[i][j-1][1][t-1]); ","explanation":"## Why This Is Asked\nAssesses ability to design a DP that tracks both position and motion state with a constraint (exact turns). Encourages reconstruction and feasibility checks.\n\n## Key Concepts\n- 4D DP state (i,j,dir,t)\n- Turn counting and alternating transitions\n- Path reconstruction and edge-case handling\n\n## Code Example\n```javascript\nconst INF = 1e15;\nfunction minPath(grid, k) {\n  const R = grid.length, C = grid[0].length;\n  // Placeholder structure; full implementation requires 4D DP and parent pointers\n  return -1;\n}\n```\n\n## Follow-up Questions\n- How would you optimize to O(C*k) space?\n- How to handle impossible k values?\n- How would you adapt for moves including right, down, and left?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T07:04:39.792Z","createdAt":"2026-01-19T07:04:39.792Z"},{"id":"q-4401","question":"You're given a binary string s of length n and an integer k. Partition s into exactly k non-empty contiguous substrings. Each substring's cost is the number of transitions inside it (positions i where s[i] != s[i-1] within the substring). Return the minimum total cost and the k partition end indices. Provide a DP formulation with dp[i][t] as the min cost to split the first i chars into t parts, recurrence dp[i][t] = min_{p in [t-1..i-1]} dp[p][t-1] + cost(p+1,i); base dp[i][1] = cost(1,i). Include reconstruction plan and complexity notes?","answer":"Let diff[i]=1 if s[i]!=s[i-1] (i>=2), pref[i]=sum diff[2..i]. Then cost(a,b)=pref[b]-pref[a]. DP: dp[i][t]=min_{p in [t-1..i-1]} dp[p][t-1]+cost(p+1,i). Base: dp[i][1]=cost(1,i). Reconstruct with a pa","explanation":"## Why This Is Asked\nTests ability to design a DP with a non-trivial cost function and prefix optimization.\n\n## Key Concepts\n- DP on prefixes and partitions\n- O(1) substring cost via precomputed diff/pref\n- Path reconstruction via parent pointers\n\n## Code Example\n```javascript\n// Precompute diff and prefix\nlet diff = Array(n+1).fill(0);\nfor (let i=2;i<=n;i++) diff[i] = s[i-1] !== s[i-2] ? 1:0;\nlet pref = Array(n+1).fill(0);\nfor (let i=2;i<=n;i++) pref[i] = pref[i-1] + diff[i];\n\n// cost(a,b)\nfunction cost(a,b){ return pref[b] - pref[a]; }\n\n// DP\nlet dp = Array.from({length:n+1}, ()=> Array(k+1).fill(Infinity));\nlet par = Array.from({length:n+1}, ()=> Array(k+1).fill(-1));\nfor(let i=1;i<=n;i++){ dp[i][1] = cost(1,i); }\n\nfor(let t=2;t<=k;t++){\n  for(let i=t;i<=n;i++){\n    for(let p=t-1;p<=i-1;p++){\n      let val = dp[p][t-1] + cost(p+1,i);\n      if(val < dp[i][t]){ dp[i][t] = val; par[i][t] = p; }\n    }\n  }\n}\n```\n\n## Follow-up Questions\n- How could you optimize to O(nk) with divide-and-conquer DP if cost satisfies quadrangle inequality?\n- How would you extract the actual partition end indices from par?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Instacart","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T17:33:35.704Z","createdAt":"2026-01-19T17:33:35.704Z"},{"id":"q-4506","question":"You're given an array A of length n representing per-minute engagement. You may select exactly k non-overlapping, contiguous time blocks in order (you may skip minutes between blocks). Each block [l..r] yields value min(A[l..r]) * (r-l+1). Return the maximum total value and the endpoints of the k blocks?","answer":"DP approach: let dp[i][t] be the maximum total value using the first i elements and exactly t blocks, where the i-th element ends the t-th block. Transition: dp[i][t] = max_{p=t-1..i} dp[p-1][t-1] + min(A[p..i]) * (i-p+1). The solution requires O(n²k) time and O(nk) space, with backpointers for reconstruction.","explanation":"## Why This Is Asked\nThis interview question tests dynamic programming with prefix-state tracking and solution reconstruction. The inner minimum calculation forces careful leftward scanning, providing a tangible beginner-to-intermediate challenge while remaining implementable in O(n²k) time.\n\n## Key Concepts\n- Dynamic programming over prefixes with block count tracking\n- On-the-fly maintenance of minimum values over sliding windows\n- Solution reconstruction via backpointers\n- Time complexity: O(n²k), Space complexity: O(nk)\n\n## Code Example\n```javascript\nfunction maxValueBlocks(A, k) {\n  const n = A.length;\n  const dp = Array.from({length: n+1}, () => Array(k+1).fill(-Infinity));\n  const pre = Array.from({length: n+1}, () => Array(k+1).fill(-1));\n  \n  dp[0][0] = 0;\n  \n  for (let i = 1; i <= n; i++) {\n    for (let t = 1; t <= Math.min(k, i); t++) {\n      let currentMin = Infinity;\n      for (let p = i; p >= t; p--) {\n        currentMin = Math.min(currentMin, A[p-1]);\n        const candidate = (dp[p-1][t-1] + currentMin * (i-p+1));\n        if (candidate > dp[i][t]) {\n          dp[i][t] = candidate;\n          pre[i][t] = p;\n        }\n      }\n    }\n  }\n  \n  // Reconstruct solution\n  const blocks = [];\n  let i = n, t = k;\n  while (t > 0) {\n    const p = pre[i][t];\n    blocks.unshift([p, i]);\n    i = p - 1;\n    t--;\n  }\n  \n  return { maxValue: dp[n][k], blocks };\n}\n```","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Instacart","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T05:27:56.180Z","createdAt":"2026-01-19T21:47:21.461Z"},{"id":"q-4604","question":"You're given a grid cost of size n x m. You start at (0,0) and must reach (n-1,m-1). You may move right, down, or diagonally down-right. Each diagonal move consumes one token from a budget of K; you may perform at most K diagonals in the path. What is the minimum total cost to reach the bottom-right, and what is the path (sequence of coordinates) taken? Propose a DP formulation with dp[i][j][t] as the minimum cost to reach (i,j) using exactly t diagonals, including recurrences, base cases, reconstruction, and a discussion of time/space?","answer":"Define dp[i][j][t] = min cost to reach (i,j) using exactly t diagonals. Recurrences: dp[i][j][t] = cost[i][j] + min(dp[i-1][j][t], dp[i][j-1][t], dp[i-1][j-1][t-1]). Base: dp[0][0][0] = cost[0][0], ot","explanation":"## Why This Is Asked\nTests ability to generalize DP with an extra resource dimension and reconstruction, a common pattern in grid path problems with constraints. It also probes edge-case handling when i or j is at 0 and when t=0. \n\n## Key Concepts\n- DP with an extra dimension for resource usage (K diagonals)\n- 3-way transitions and path reconstruction\n- Time/space trade-offs and potential optimizations\n\n## Code Example\n```javascript\nfunction minCostPath(grid, K) {\n  const n = grid.length, m = grid[0].length;\n  const INF = 1e15;\n  const dp = Array.from({ length: n }, () => Array.from({ length: m }, () => Array(K+1).fill(INF)));\n  const parent = Array.from({ length: n }, () => Array.from({ length: m }, () => Array(K+1).fill(null)));\n  dp[0][0][0] = grid[0][0];\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      for (let t = 0; t <= K; t++) {\n        if (i === 0 && j === 0 && t === 0) continue;\n        let best = INF, pick = null;\n        if (i > 0 && dp[i-1][j][t] < best) { best = dp[i-1][j][t]; pick = [i-1, j, t]; }\n        if (j > 0 && dp[i][j-1][t] < best) { best = dp[i][j-1][t]; pick = [i, j-1, t]; }\n        if (i > 0 && j > 0 && t > 0 && dp[i-1][j-1][t-1] < best) { best = dp[i-1][j-1][t-1]; pick = [i-1, j-1, t-1]; }\n        if (best < INF) {\n          dp[i][j][t] = best + grid[i][j];\n          if (pick) parent[i][j][t] = pick;\n        }\n      }\n    }\n  }\n  // find best end state\n  let bestCost = INF, endT = 0;\n  for (let t = 0; t <= K; t++) {\n    if (dp[n-1][m-1][t] < bestCost) { bestCost = dp[n-1][m-1][t]; endT = t; }\n  }\n  // reconstruct path\n  const path = [];\n  let i = n-1, j = m-1, t = endT;\n  while (i !== 0 || j !== 0 || t !== 0) {\n    path.push([i, j]);\n    const p = parent[i][j][t];\n    if (!p) break;\n    [i, j, t] = p;\n  }\n  path.push([0,0]);\n  path.reverse();\n  return { cost: bestCost, path };\n}\n```\n\n## Follow-up Questions\n- How to reduce space to O(m K) using rolling arrays?\n- How would you handle negative costs or unreachable endpoints?","diagram":"flowchart TD\n  A[Start at (0,0)] --> B[DP state dp[i][j][t]]\n  B --> C[Transitions: right, down, diag]\n  C --> D[Track t diagonals]\n  D --> E[Reconstruct path to (n-1,m-1)]","difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T04:16:13.858Z","createdAt":"2026-01-20T04:16:13.858Z"},{"id":"q-4757","question":"You're given a string s of length n and an integer k. You may delete at most k characters to transform s into a palindrome. Return whether this is possible and, if so, the resulting palindrome. Propose a DP with dp[i][j] for minimum deletions on s[i..j], recurrences: if s[i]==s[j] then dp[i][j]=dp[i+1][j-1]; else dp[i][j]=min(dp[i+1][j], dp[i][j-1])+1; base: dp[i][i]=0; dp[i][i-1]=0. Explain reconstruction, time/space, and how to recover the deletions?","answer":"Formulate dp[i][j] as the minimum deletions to make s[i..j] a palindrome. If s[i]==s[j], dp[i][j]=dp[i+1][j-1]; else dp[i][j]=min(dp[i+1][j], dp[i][j-1])+1. Base: dp[i][i]=0; dp[i][i-1]=0. Build botto","explanation":"## Why This Is Asked\nTests substring DP and reconstruction in a practical string-cleanup task, common in data processing pipelines at scale.\n\n## Key Concepts\n- DP on substrings: dp[i][j] captures minimal deletions for s[i..j]\n- Reconstruction: recover exact deletions and resulting palindrome\n- Complexity: O(n^2) time and O(n^2) space; can be optimized with path tracking\n\n## Code Example\n```javascript\nfunction minDeletionsPalindrome(s) {\n  const n = s.length;\n  const dp = Array.from({length: n}, () => Array(n).fill(0));\n  for (let len = 2; len <= n; len++) {\n    for (let i = 0; i + len - 1 < n; i++) {\n      const j = i + len - 1;\n      if (s[i] === s[j]) dp[i][j] = dp[i+1][j-1];\n      else dp[i][j] = Math.min(dp[i+1][j], dp[i][j-1]) + 1;\n    }\n  }\n  return {deletions: dp[0][n-1], dp};\n}\n```\n\n## Follow-up Questions\n- How to reconstruct the actual palindrome after deletions?\n- How to optimize to O(n) space while keeping reconstruction capability?","diagram":"flowchart TD\nA[Start] --> B{i <= j}\nB --> C{s[i] == s[j]}\nC -- Yes --> D[dp[i][j] = dp[i+1][j-1]]\nC -- No --> E[dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1]\nD --> F[move to (i+1, j-1)]\nE --> F[move to (i+1, j) or (i, j-1)]\nF --> B\n","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T11:02:18.945Z","createdAt":"2026-01-20T11:02:18.945Z"},{"id":"q-679","question":"In a warehouse grid of size n x m, each cell has a traversal cost. You can move only right or down from (0,0) to (n-1,m-1). You have a one-time token to halve the cost of exactly one visited cell. Design an O(nm) DP to compute the minimum path cost after optimally using the discount, and describe the recurrences and a space-optimized implementation?","answer":"Maintain two DP arrays: best without using the discount (dp0) and best with the discount already used (dp1). For grid costs c[i][j], set:\ndp0[i][j] = c[i][j] + min(dp0[i-1][j], dp0[i][j-1]);\ndp1[i][j]","explanation":"## Why This Is Asked\nTests real DP design with an extra state (discount used) and careful recurrence.\n\n## Key Concepts\n- 2D DP with a binary state (discount used or not)\n- Transitions combine taking cost with/without discount\n- Space optimization using rolling arrays\n\n## Code Example\n```javascript\nfunction minCostWithDiscount(grid){\n  const n = grid.length, m = grid[0].length;\n  const INF = 1e15;\n  let dp0 = new Array(m).fill(INF);\n  let dp1 = new Array(m).fill(INF);\n  dp0[0] = grid[0][0];\n  dp1[0] = Math.floor(grid[0][0] / 2);\n  for (let j = 1; j < m; j++) {\n    dp0[j] = grid[0][j] + dp0[j-1];\n    dp1[j] = Math.min(grid[0][j] + dp1[j-1], Math.floor(grid[0][j]/2) + dp0[j-1]);\n  }\n  for (let i = 1; i < n; i++) {\n    dp0[0] += grid[i][0];\n    dp1[0] = Math.min(grid[i][0] + dp1[0], Math.floor(grid[i][0]/2) + dp0[0-1]);\n    for (let j = 1; j < m; j++) {\n      const v = grid[i][j];\n      dp1[j] = Math.min(v + Math.min(dp1[j], dp1[j-1]), Math.floor(v/2) + Math.min(dp0[j], dp0[j-1]));\n      dp0[j] = v + Math.min(dp0[j], dp0[j-1]);\n    }\n  }\n  return dp1[m-1];\n}\n```\n\n## Follow-up Questions\n- How would you support multiple discounts or varying discount values?\n- How does this adapt if diagonal moves are allowed or costs can be negative?","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Snap","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T15:57:04.021Z","createdAt":"2026-01-11T15:57:04.021Z"},{"id":"q-691","question":"You're planning a delivery route along a straight street of n blocks. At block i you can advance up to jumps[i] blocks (at least 1). How many distinct routes reach block n-1 from block 0? If unreachable, return 0. Propose a dynamic-programming approach with dp[i] as ways to reach i and outline its time/space complexity, edge cases, and a brief correctness justification. How would you implement it?","answer":"Use a 1D DP: dp[i] is number of ways to reach i. Initialize dp[0] = 1. For i from 0 to n-1, let maxJump = min(jumps[i], n-1-i); for s from 1 to maxJump, dp[i+s] = (dp[i+s] + dp[i]) % 1000000007. Retur","explanation":"## Why This Is Asked\nTests counting paths with variable step lengths using DP, a common interview pattern in operations and logistics contexts.\n\n## Key Concepts\n- 1D DP for path counting\n- Handling variable jump lengths\n- Modulo arithmetic for large counts\n\n## Code Example\n```javascript\nfunction countWays(jumps){\n  const n = jumps.length;\n  const MOD = 1000000007;\n  const dp = new Array(n).fill(0);\n  dp[0] = 1;\n  for(let i = 0; i < n; i++){\n    const maxJump = Math.min(jumps[i], n - 1 - i);\n    for(let s = 1; s <= maxJump; s++){\n      dp[i + s] = (dp[i + s] + dp[i]) % MOD;\n    }\n  }\n  return dp[n - 1] || 0;\n}\n```\n\n## Follow-up Questions\n- How would you optimize to O(n) time if maxJump can be large but jumps form a sliding window of contributions?\n- How would you adjust for different termination criteria or multiple destinations?","diagram":"flowchart TD\n  Start([Start]) --> Init[dp[0] = 1]\n  Init --> Loop[for i in 0..n-1]\n  Loop --> Update[dp[i+s] += dp[i] for s<=maxJump]\n  Update --> End([Return dp[n-1]])","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Meta","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T16:24:20.467Z","createdAt":"2026-01-11T16:24:20.467Z"},{"id":"q-693","question":"You're building a daily workout planner. Over n days, you can pick Light (L) or Heavy (H) workouts, with a cooldown: after a Heavy, you must skip the next two days (no workouts). Given integers n and r, how many length-n sequences contain exactly r Heavy workouts and satisfy the cooldown rule? Provide a DP formulation with state dp[i][c][t] (days processed, cooldown days left, heavies used) and outline time/space complexity, edge cases, and a brief correctness justification?","answer":"DP state: dp[i][c][t] = ways to schedule first i days with c cooldown days left and t heavies used. If c>0, dp[i+1][c-1][t] += dp[i][c][t]. If c==0, Light gives dp[i+1][0][t] += dp[i][0][t], Heavy (t<","explanation":"## Why This Is Asked\nTests modeling of a constrained scheduling problem with cooldowns and counting exact occurrences, a staple DP pattern.\n\n## Key Concepts\n- Multidimensional DP with state: day, cooldown, heavies used\n- Transition logic for cooldown and action choices\n- Edge cases: maximum possible heavies, r bounds, unreachable states\n\n## Code Example\n```javascript\n// Pseudo-implementation sketch for DP planning\n```\n\n## Follow-up Questions\n- How would you adapt if cooldowns varied by the number of consecutive heavies?\n- How would you optimize space further for large n?","diagram":"flowchart TD\n  Start[Start] --> A[Initialize dp[0][0][0]=1]\n  A --> B{i from 0 to n-1}\n  B --> C[If c>0, carry to i+1 with c-1]\n  B --> D[If c==0, add Light to i+1 with c=0, t]\n  B --> E[If c==0, add Heavy to i+1 with c=2, t+1 if t<r]\n  C --> End1[Aggregate to dp[i+1]]\n  D --> End2\n  E --> End3\n  End1 --> End\n  End2 --> End\n  End3 --> End","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Google","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T17:15:40.264Z","createdAt":"2026-01-11T17:15:40.264Z"},{"id":"q-703","question":"You're navigating a warehouse grid of size n x m. Each cell (i, j) has a risk value r[i][j] ≥ 0, where higher means less safe. You may move only right or down from (0,0) to (n-1,m-1). Devise a dynamic-programming solution to minimize the maximum risk encountered on the path (i.e., minimize max(r[i][j]) along the path). Define a suitable dp[i][j], give the recurrence and base cases, describe reconstruction of the path, and analyze time/space complexity. How would you handle blocked cells by setting r[i][j] = INF?","answer":"Proposed DP: define dp[i][j] as the minimum possible maximum risk along any path from (0,0) to (i,j). Recurrence: dp[i][j] = min( max(dp[i-1][j], r[i][j]), max(dp[i][j-1], r[i][j]) ). Base: dp[0][0] =","explanation":"## Why This Is Asked\nThis question tests DP on grids with a minimax objective, reconstruction, and practical edge handling (blocked cells).\n\n## Key Concepts\n- DP on 2D grid with a minimax recurrence\n- Path reconstruction via predecessor tracking\n- Space optimization opportunities (1D row/column DP)\n- INF handling for blockers\n\n## Code Example\n```javascript\nfunction minMaxRisk(r) {\n  const n = r.length, m = r[0].length;\n  const INF = Number.POSITIVE_INFINITY;\n  const dp = Array.from({length: n}, () => Array(m).fill(INF));\n  const from = Array.from({length: n}, () => Array(m).fill(-1));\n  dp[0][0] = r[0][0];\n  for (let j = 1; j < m; j++) { dp[0][j] = Math.max(dp[0][j-1], r[0][j]); from[0][j] = 0; }\n  for (let i = 1; i < n; i++) { dp[i][0] = Math.max(dp[i-1][0], r[i][0]); from[i][0] = 1; }\n  for (let i = 1; i < n; i++) {\n    for (let j = 1; j < m; j++) {\n      const up = Math.max(dp[i-1][j], r[i][j]);\n      const left = Math.max(dp[i][j-1], r[i][j]);\n      if (up <= left) { dp[i][j] = up; from[i][j] = 0; } else { dp[i][j] = left; from[i][j] = 1; }\n    }\n  }\n  return {minMaxRisk: dp[n-1][m-1], parent: from};\n}\n```\n\n## Follow-up Questions\n- How would you extend to allow diagonal moves?\n- How would you adapt for multiple starting points or 3D grids?","diagram":"flowchart TD\n  A[Start] --> B[Compute dp per cell]\n  B --> C[Store predecessor for reconstruction]\n  C --> D[Reach (n-1,m-1)]\n  D --> E[Return minimal max risk]","difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["NVIDIA","Scale Ai","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T18:26:59.828Z","createdAt":"2026-01-11T18:26:59.828Z"},{"id":"q-716","question":"You're building a text formatter. Given a list of word lengths L = [l1, l2, ..., ln] and a maximum line width W, wrap the words into lines so that all lines except the last incur a penalty of (W - usedWidth)^2, where usedWidth = sum of word lengths on the line plus spaces between words. The last line has 0 penalty. Propose a dynamic programming solution with dp[i] representing the minimum penalty for words i..n-1, specify the recurrence, reconstruction method, and time/space complexity. How would you implement it?","answer":"DP on prefixes: dp[i] = minimum penalty for words i..n-1, with dp[n] = 0. For each i, extend line to j>=i; width = sum(len[i..j]) + (j - i); if width <= W then cost = (W - width)^2 + dp[j+1]. Take min","explanation":"## Why This Is Asked\\nThis gauges ability to cast a line-wrapping task into a clear 1D DP with a non-linear line cost and a reconstruction path. It tests handling of last-line quirks and feasibility checks.\\n\\n## Key Concepts\\n- 1D DP over word indices; dp[n] = 0 as base.\\n- Prefix sums to compute line width in O(1) per extension.\\n- Cost function uses squared unused space; last line excluded.\\n- Reconstruct solution via next indices.\\n- Time: O(n^2); Space: O(n).\\n\\n## Code Example\\n```javascript\\nfunction minWrap(words, W) {\\n  const n = words.length;\\n  const pref = new Array(n + 1).fill(0);\\n  for (let i = 0; i < n; i++) pref[i + 1] = pref[i] + words[i];\\n  const dp = new Array(n + 1).fill(Infinity);\\n  const nxt = new Array(n).fill(-1);\\n  dp[n] = 0;\\n  for (let i = n - 1; i >= 0; i--) {\\n    for (let j = i; j < n; j++) {\\n      const width = (pref[j + 1] - pref[i]) + (j - i);\\n      if (width <= W) {\\n        const cost = (W - width) * (W - width) + dp[j + 1];\\n        if (cost < dp[i]) { dp[i] = cost; nxt[i] = j + 1; }\\n      } else break;\\n    }\\n  }\\n  // reconstruction omitted for brevity\\n  return { minPenalty: dp[0], next: nxt };\\n}\\n```\\n\\n## Follow-up Questions\\n- How would you modify to penalize the last line as well?\\n- How would you incorporate tie-breaking to prefer fewer lines?\\n","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","DoorDash","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T19:18:59.844Z","createdAt":"2026-01-11T19:18:59.844Z"},{"id":"q-718","question":"You're given an array A[1..n] and an integer k. Partition into exactly k contiguous segments. The cost of a segment [t+1..i] is (sum(A[t+1..i]))^2. Return the minimum total cost and the partition indices. Propose DP: P as prefix sums, dp[i][j] = min_{t in [j-1..i-1]} dp[t][j-1] + (P[i]-P[t])^2, with base dp[0][0]=0. Explain reconstruction and discuss naive vs. optimized time, space, and edge cases?","answer":"DP formulation: P is prefix sums, dp[i][j] = min_{t in [j-1..i-1]} dp[t][j-1] + (P[i]-P[t])^2, with dp[0][0]=0; base dp[i][1] = P[i]^2. Reconstruct via argmin cuts. Naive O(n^2 k); with Divide-and-Con","explanation":"## Why This Is Asked\n\nTests DP over partitioning with a convex cost and requires reconstruction, while prompting awareness of optimizations for large n.\n\n## Key Concepts\n\n- DP on partitioning\n- Prefix sums\n- Cost convexity and optimization\n- Reconstruction of cuts\n\n## Code Example\n\n```javascript\n// skeleton: compute P, fill dp with divide-and-conquer optimization template\n```\n\n## Follow-up Questions\n\n- How would negative numbers affect correctness?\n- How would you implement the optimization in a streaming setting?","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T20:21:28.699Z","createdAt":"2026-01-11T20:21:28.699Z"},{"id":"q-731","question":"You're given an array A of length n with non-negative integers representing daily story points. You must partition the days into consecutive weeks, each containing 2–7 days. The cost of a week is (sum of that week's points − W)^2 where W is a fixed target. Return the minimum total cost to cover all days or INF if impossible. Propose a DP with dp[i] as min cost for first i days; dp[i] = min_{k=2..7, i-k>=0} dp[i-k] + (sum(i-k+1..i) − W)^2, using prefix sums for O(1) range sums. Reconstruct weeks and analyze time/space?","answer":"dp[i] = min over k in [2,7] of dp[i-k] + (pref[i]-pref[i-k] - W)^2, using pref for O(1) range sums. Base dp[0]=0; dp[i]=INF for invalid i. Reconstruct weeks via a parent pointer. Time: O(7n). Space: O","explanation":"## Why This Is Asked\nRealistic sprint planning with bounded weekly windows; tests ability to form and optimize DP with small constant branching and reconstruction.\n\n## Key Concepts\n- Prefix sums for fast range totals\n- DP with fixed window length (2..7)\n- Path reconstruction via parent pointers\n- Time O(n) with a small constant, Space O(n)\n\n## Code Example\n```javascript\nfunction minWeeklyCost(A, W) {\n  const n = A.length;\n  const pref = new Array(n+1).fill(0);\n  for (let i=1;i<=n;i++) pref[i] = pref[i-1] + A[i-1];\n  const INF = 1e18;\n  const dp = new Array(n+1).fill(INF);\n  const par = new Array(n+1).fill(-1);\n  dp[0] = 0;\n  for (let i=2; i<=n; i++) {\n    for (let k=2; k<=7; k++) {\n      if (i-k < 0) break;\n      const sum = pref[i] - pref[i-k];\n      const cost = dp[i-k] + (sum - W)*(sum - W);\n      if (cost < dp[i]) { dp[i] = cost; par[i] = i-k; }\n    }\n  }\n  // reconstruction would follow using par[]\n  return {cost: dp[n], prev: par[n]};\n}\n```\n\n## Follow-up Questions\n- How would you handle negative A values if allowed? \n- What changes if weeks must start on a specific weekday?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Salesforce","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T21:19:28.014Z","createdAt":"2026-01-11T21:19:28.014Z"},{"id":"q-736","question":"You're given an n x m grid. Each cell (i, j) has a color c[i][j] in [0, C-1] and a non-negative cost w[i][j]. Start at (0,0) and move to (n-1,m-1) with only right or down moves. You must visit at least one cell of every color that appears in the grid along your path. Return the minimum total cost to do so, or -1 if impossible. Describe a DP using dp[i][j][mask] where mask tracks visited colors; explain base cases, transitions from top/left, how to reconstruct the path, and complexity?","answer":"dp[i][j][mask] = min cost to reach (i,j) with colors mask; colorBit = 1<<c[i][j]. Only masks with (mask & colorBit) != 0 are valid. From top/left you may keep mask or use mask ^ colorBit to reflect co","explanation":"## Why This Is Asked\n\nTests DP with bitmask over colors along a grid path, forcing a nontrivial state and reconstruction.\n\n## Key Concepts\n- DP on Grid\n- Bitmask state compression\n- Transition handling when color is collected here vs earlier\n- Path reconstruction\n\n## Code Example\n\n```javascript\n// high-level outline for dp[i][j][mask]\n```\n\n## Follow-up Questions\n- How to scale when C is large (e.g., >20)?\n- How would you reconstruct the path from the dp table?","diagram":"flowchart TD\n  S(Start) --> A[dp[i][j][mask]]\n  A --> B{from top/left}\n  B --> C[dp[i-1][j][mask]]\n  B --> D[dp[i][j-1][mask]]\n  A --> E[compute min]\n  E --> F[store dp[i][j][mask]]","difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Netflix","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T22:19:51.690Z","createdAt":"2026-01-11T22:19:51.690Z"},{"id":"q-743","question":"You're given a list of n task durations L. Partition the tasks into consecutive days (each day at least one task); the cost of a day is the maximum duration on that day. Devise a DP to minimize the total cost across all days. Define dp[i] as the minimum cost for the first i tasks, provide the recurrence, reconstruction method, and complexity. How would you implement it?","answer":"We partition tasks into days; day cost is the maximum duration on that day. Let dp[0]=0 and for i from 1..n, dp[i]=min_{1<=k<=i}(dp[i-k]+max(L[i-k..i-1])); track cut[i]=k to reconstruct day boundaries","explanation":"## Why This Is Asked\nScheduling perspective: minimize peak workload across days; the DP is a straightforward partition DP with a range max cost. It tests understanding of maintaining running max within inner loop and reconstruction.\n\n## Key Concepts\n- DP over prefixes\n- Range max within an inner loop\n- Path reconstruction via cut[]\n- Edge cases: empty input, large n, identical durations\n\n## Code Example\n```javascript\nfunction minCostPartition(L){\n  const n=L.length;\n  const dp=new Array(n+1).fill(Infinity);\n  const cut=new Array(n+1).fill(0);\n  dp[0]=0;\n  for(let i=1;i<=n;i++){\n    let curMax=0;\n    for(let k=1;k<=i;k++){\n      curMax = Math.max(curMax, L[i-k]);\n      const val = dp[i-k] + curMax;\n      if(val < dp[i]){ dp[i] = val; cut[i] = k; }\n    }\n  }\n  const days=[];\n  let i=n;\n  while(i>0){\n    const k=cut[i];\n    days.push(L.slice(i-k, i));\n    i -= k;\n  }\n  days.reverse();\n  return {cost: dp[n], days};\n}\n```\n\n## Follow-up Questions\n- How would you adapt for a 2D grid of tasks with row/day semantics?\n- Can you optimize the inner loop to O(n) using a data structure for range max?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Slack","Stripe","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T23:18:27.166Z","createdAt":"2026-01-11T23:18:27.166Z"},{"id":"q-754","question":"Given a circular array v[1..n] of non-negative values and an integer d≥1, pick a subset of indices such that the cyclic distance between any two chosen indices is at least d. Maximize the sum of selected values; return both the maximum sum and the number of distinct optimal subsets. Constraints: n ≤ 2e5, v[i] ≤ 1e9. Describe an O(n) DP solution with two cases for circularity and how you'd reconstruct counts?","answer":"Use two-case DP on a linearized circle. Case A excludes index 1 and runs a linear DP on 2..n with dp[i]=max(dp[i-1], dp[i-d]+v[i]); Case B includes index 1, then run DP on the circularly valid segment","explanation":"## Why This Is Asked\nTests ability to design an optimized DP on a circular constraint and track the number of optimal solutions.\n\n## Key Concepts\n- DP on linear sequences with spacing (dp[i] = max(dp[i-1], dp[i-d] + v[i]))\n- Reducing circularity to two linear cases (include first vs exclude first)\n- Counting distinct optimal subsets with tie handling (sum counts when equal)\n\n## Code Example\n```javascript\nfunction linearDP(arr, d){\n  const n = arr.length; const dp = Array(n+1).fill(0); const ways = Array(n+1).fill(0);\n  dp[0] = 0; ways[0] = 1;\n  for(let i=1;i<=n;i++){\n    const take = arr[i-1] + (i-d>=0 ? dp[i-d] : 0);\n    const skip = dp[i-1];\n    if(take>skip){ dp[i]=take; ways[i]=(i-d>=0 ? ways[i-d] : 1); }\n    else if(take<skip){ dp[i]=skip; ways[i]=ways[i-1]; }\n    else { dp[i]=skip; ways[i] = ((i-d>=0 ? ways[i-d] : 1) + ways[i-1]); }\n  }\n  return [dp[n], ways[n]];\n}\n\nfunction maxCircular(v, d){\n  const [bestA, cntA] = linearDP(v.slice(1), d); // exclude first\n  const n = v.length;\n  const seg = (n > 2*d-1) ? v.slice(d, n-d+1) : [];\n  const [bestBseg, cntBseg] = seg.length ? linearDP(seg, d) : [0,1];\n  const bestB = v[0] + bestBseg;\n  if(bestA > bestB) return [bestA, cntA];\n  if(bestB > bestA) return [bestB, cntBseg];\n  return [bestA, cntA + cntBseg];\n}\n```\n\n## Follow-up Questions\n- How would you extend to allow a variable distance per pair or weighted distance penalties?\n- How would you test correctness and performance on worst-case inputs?","diagram":"flowchart TD\n  A[Start] --> B{Case A or Case B}\n  B --> C[DP on Case A (exclude 1)]\n  B --> D[DP on Case B (include 1)]\n  C --> E[Compare max sums]\n  D --> E\n  E --> F[Combine counts and return]","difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Netflix","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T01:32:37.055Z","createdAt":"2026-01-12T01:32:37.055Z"},{"id":"q-768","question":"You're given an array A of length n and an integer k. Partition A into exactly k non-empty contiguous subarrays. The cost of a subarray [t+1..i] is (max(A[t+1..i])) * (i-t). Return the minimum total cost and the partition indices. Propose DP: dp[i][j] = min_{t in [j-1..i-1]} dp[t][j-1] + max(A[t+1..i]) * (i-t). Explain reconstruction, base cases, and time/space?","answer":"Use dp[i][j] = min_t dp[t][j-1] + max(A[t+1..i])*(i-t). Base: dp[i][1] = max(A[1..i])*i. Precompute range maxima with mx[i][j] or compute on the fly in inner loop. Reconstruct via a predecessor table.","explanation":"## Why This Is Asked\nTests a non-trivial partition DP with a non-linear subarray cost and reconstruction.\n\n## Key Concepts\n- DP over partitions\n- Range maximum queries (precomputation or on-the-fly)\n- Path reconstruction via predecessor table\n\n## Code Example\n```javascript\nfunction minCostPartition(A, k) {\n  const n = A.length;\n  // precompute max for all ranges\n  const mx = Array.from({length: n}, ()=> Array(n).fill(0));\n  for (let i=0;i<n;i++){ mx[i][i]=A[i]; for(let j=i+1;j<n;j++) mx[i][j]=Math.max(mx[i][j-1], A[j]); }\n  const dp = Array.from({length: n+1}, ()=> Array(k+1).fill(Infinity));\n  const prv = Array.from({length: n+1}, ()=> Array(k+1).fill(-1));\n  dp[0][0]=0;\n  for(let i=1;i<=n;i++) dp[i][1] = mx[0][i-1]*(i);\n  for(let j=2;j<=k;j++){\n    for(let i=j;i<=n;i++){\n      for(let t=j-1;t<=i-1;t++){\n        const cost = dp[t][j-1] + mx[t][i-1]*(i-t);\n        if(cost < dp[i][j]){ dp[i][j]=cost; prv[i][j]=t; }\n      }\n    }\n  }\n  // reconstruction omitted for brevity\n  return {cost: dp[n][k], cutPoints: []};\n}\n```\n\n## Follow-up Questions\n- Can you optimize space to O(n) per k?\n- How to handle equal costs and tie-breaking?","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Robinhood","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T03:52:12.176Z","createdAt":"2026-01-12T03:52:12.176Z"},{"id":"q-777","question":"You're given an array A of non-negative integers representing task durations in order. You must schedule all n tasks into exactly m days. Each day can host a consecutive block with total duration <= D. The cost of a day is (sum of that day's durations)^2. Return the minimum total cost, or -1 if impossible? Propose a DP using dp[i][d] as min cost for first i tasks in d days, with transition dp[i][d] = min_{j<i, prefix[i]-prefix[j] <= D} dp[j][d-1] + (prefix[i]-prefix[j])^2. Include base cases, reconstruction, and time/space?","answer":"Use prefix sums and a 2D DP: dp[i][d] = min cost for first i tasks in d days, with dp[0][0]=0. For each i,d try all j<i where sum(j+1..i) <= D and set dp[i][d] = min(dp[i][d], dp[j][d-1] + (sum)^2). T","explanation":"## Why This Is Asked\nModels practical scheduling under capacity with a convex (squared) day cost, exercising 2D DP and reconstruction.\n\n## Key Concepts\n- DP over prefixes and days\n- Transition constrained by daily capacity D\n- Prefix sums for O(1) range sums\n- Backtracking via parent pointers to recover daily blocks\n- Complexity: O(n^2 m) time, O(n m) space\n\n## Code Example\n```javascript\nfunction minCostSchedule(A, m, D) {\n  const n = A.length;\n  const pref = new Array(n + 1).fill(0);\n  for (let i = 1; i <= n; i++) pref[i] = pref[i - 1] + A[i - 1];\n  const INF = Number.POSITIVE_INFINITY;\n  const dp = Array.from({ length: n + 1 }, () => new Array(m + 1).fill(INF));\n  const par = Array.from({ length: n + 1 }, () => new Array(m + 1).fill(-1));\n  dp[0][0] = 0;\n  for (let d = 1; d <= m; d++) {\n    for (let i = 1; i <= n; i++) {\n      for (let j = 0; j < i; j++) {\n        const sum = pref[i] - pref[j];\n        if (sum <= D && dp[j][d - 1] !== INF) {\n          const cost = dp[j][d - 1] + sum * sum;\n          if (cost < dp[i][d]) {\n            dp[i][d] = cost;\n            par[i][d] = j;\n          }\n        }\n      }\n    }\n  }\n  if (dp[n][m] === INF) return { cost: -1, blocks: [] };\n  const blocks = [];\n  let i = n, d = m;\n  while (d > 0) {\n    const j = par[i][d];\n    blocks.push([j + 1, i]);\n    i = j;\n    d--;\n  }\n  blocks.reverse();\n  return { cost: dp[n][m], blocks };\n}\n```\n\n## Follow-up Questions\n- How would you optimize to near O(n m) if D is small or sums have tighter bounds?\n- How would you present the actual day blocks to the user, including start/end indices and sums?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Apple","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T05:30:19.665Z","createdAt":"2026-01-12T05:30:19.665Z"},{"id":"q-786","question":"You have an array A of length n. Partition into exactly k non-empty contiguous blocks. The cost of a block [t+1..i] is (max(A[t+1..i])) * (sum(A[t+1..i])). Return the minimum total cost and the partition indices. Propose a DP formulation, reconstruction strategy, and complexity analysis. Assume 1-based indexing?","answer":"DP: dp[i][j] = min_{t in [j-1..i-1]} dp[t][j-1] + M(t+1,i) * (P[i]-P[t]), where P is prefix sum and M(t+1,i) is max on A[t+1..i]. Compute M on the fly by iterating t from i-1 down to j-1. Reconstruct ","explanation":"## Why This Is Asked\nTests a nontrivial DP with a block-cost dependent on both max and sum; requires handling both as a running statistic. \n\n## Key Concepts\n- DP over partitions into k blocks\n- Running block max and prefix sums\n- Reconstruction and complexity tradeoffs\n\n## Code Example\n```javascript\n// recurrence and reconstruction sketch\n```\n\n## Follow-up Questions\n- How to optimize with monotone queue or Divide-and-Conquer DP if the opt indices are monotone?\n- What about handling n up to 2e5 with large k and memory constraints?","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Scale Ai","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T06:38:54.270Z","createdAt":"2026-01-12T06:38:54.270Z"},{"id":"q-792","question":"You're given an array prices[0..n-1]. You may complete at most k buy-sell transactions (one share at a time, can't hold more than one). Return the maximum profit and the days of each trade. Propose a DP formulation with states cash[i][t] and hold[i][t], include recurrences, base cases, and reconstruction, and discuss time/space?","answer":"Max profit with at most k transactions on prices p[0..n-1]. Use DP with cash[i][t] and hold[i][t] representing max profit on day i with t completed transactions and not holding/holding. cash[i][t] = m","explanation":"## Why This Is Asked\nTests DP over time with multiple constraints: multiple transactions, reconstruction, and edge-case handling.\n\n## Key Concepts\n- Two DP states: cash (not holding) and hold (holding).\n- Transitions model buy/sell with transaction count t.\n- Base cases initialize day 0; backtracking recovers trade days.\n- Space optimization possible to O(k) with rolling arrays.\n\n## Code Example\n```javascript\nfunction maxProfit(prices, k){\n  const n = prices.length;\n  if (n===0 || k===0) return 0;\n  const cash = Array.from({length:n+1}, ()=> Array(k+1).fill(-1e15));\n  const hold = Array.from({length:n+1}, ()=> Array(k+1).fill(-1e15));\n  for (let t=0; t<=k; t++) cash[0][t] = (t===0)?0:-1e15;\n  for (let i=1; i<=n; i++){\n    for (let t=0; t<=k; t++){\n      cash[i][t] = cash[i-1][t];\n      if (t>0) cash[i][t] = Math.max(cash[i][t], hold[i-1][t] + prices[i-1]);\n      hold[i][t] = hold[i-1][t];\n      if (t>0) hold[i][t] = Math.max(hold[i][t], cash[i-1][t-1] - prices[i-1]);\n    }\n  }\n  let best = 0;\n  for (let t=0; t<=k; t++) best = Math.max(best, cash[n][t]);\n  return best;\n}\n```\n\n## Follow-up Questions\n- How would you recover the exact trade days from the DP table?\n- How does the solution change if k >= n/2 (unlimited transactions)?","diagram":"flowchart TD\n  Start([Start])\n  Day[Process day i from 0..n-1]\n  Trans{Choose action: buy, sell, hold}\n  CashUpdate[Update cash states]\n  HoldUpdate[Update hold states]\n  End([End with best cash])\n  Start --> Day --> Trans\n  Trans --> CashUpdate --> End\n  Trans --> HoldUpdate --> End","difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","IBM","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T07:28:11.075Z","createdAt":"2026-01-12T07:28:11.075Z"},{"id":"q-797","question":"You have an array of task difficulties A of length n. Partition it into exactly m non-empty contiguous chapters. Each chapter cost equals the maximum difficulty within that chapter. Return the minimum total cost and a valid partition (chapter end indices). Propose a DP: dp[i][j] = min_{t in [j-1..i-1]} dp[t][j-1] + max(A[t..i-1]), with base dp[i][1] = max(A[0..i-1]). Explain reconstruction, base cases, and time/space?","answer":"Define dp[i][j] as the minimum total cost to partition the first i tasks into j chapters. Recurrences: dp[i][1] = max(A[0..i-1]); for j>1, dp[i][j] = min_{t from j-1 to i-1} dp[t][j-1] + max(A[t..i-1]","explanation":"## Why This Is Asked\nTests ability to model partitioning with a simple per-block objective and reconstruct optimal cuts. It reveals DP formulation, range queries, and backtracking.\n\n## Key Concepts\n- Partition DP across two dimensions (prefix and blocks)\n- Range maximum precomputation or on-the-fly tracking\n- Backpointers for path reconstruction\n- Time/space trade-offs and potential optimizations\n\n## Code Example\n```javascript\nfunction minPartitionCostMax(A, m){\n  const n = A.length;\n  // precompute max for all ranges\n  const rangeMax = Array.from({length: n}, () => Array(n).fill(0));\n  for(let i=0;i<n;i++){\n    let cur = 0;\n    for(let j=i;j<n;j++){\n      cur = Math.max(cur, A[j]);\n      rangeMax[i][j] = cur;\n    }\n  }\n  const dp = Array.from({length: n+1}, () => Array(m+1).fill(Infinity));\n  const par = Array.from({length: n+1}, () => Array(m+1).fill(-1));\n  dp[0][0] = 0;\n  for(let i=1;i<=n;i++){\n    for(let j=1;j<=Math.min(i,m);j++){\n      for(let t=j-1; t<=i-1; t++){\n        const val = dp[t][j-1] + rangeMax[t][i-1];\n        if(val < dp[i][j]){\n          dp[i][j] = val;\n          par[i][j] = t;\n        }\n      }\n    }\n  }\n  // reconstruct\n  const cuts = [];\n  let i = n, j = m;\n  while(j>0){\n    const t = par[i][j];\n    cuts.push(i);\n    i = t;\n    j--;\n  }\n  cuts.reverse();\n  return {cost: dp[n][m], partitions: cuts};\n}\n```\n\n## Follow-up Questions\n- How would you optimize to O(n m) time using monotonic queues?  \n- How would you adapt if each chapter cost were max(A[t..i-1]) + c*(i-t)?","diagram":"flowchart TD\n  A[Start] --> B[Precompute rangeMax]\n  B --> C[DP transitions dp[i][j]]\n  C --> D[Backtrack cuts]\n  D --> E[Return result]","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","LinkedIn","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T08:28:52.276Z","createdAt":"2026-01-12T08:28:52.276Z"},{"id":"q-806","question":"You're given an n x m grid of digits grid[i][j] in [0..9]. You may move only right or down from (0,0) to (n-1,m-1). Define a path score as the number of times the next cell's digit is strictly larger than the previous cell's digit along the path. Return the maximum score and a valid path (as coordinates or directions). Propose a dynamic programming formulation with recurrences, base cases, and reconstruction, and discuss time/space?","answer":"We define dp[i][j] as the maximum ascents to reach (i,j). Base: dp[0][0] = 0; fill first row/column with dp[0][j] = dp[0][j-1] + (grid[0][j-1] < grid[0][j]); dp[i][0] = dp[i-1][0] + (grid[i-1][0] < gr","explanation":"## Why This Is Asked\nAssesses ability to turn path-based objectives into simple local transitions without extraneous state. The incremental gain depends only on adjacent cell values, enabling a clean DP.\n\n## Key Concepts\n- Grid DP with monotone moves\n- Backpointers for path reconstruction\n- Space optimization potential\n\n## Code Example\n```javascript\nfunction maxAscents(grid){\n  const n=grid.length, m=grid[0].length;\n  const dp=Array.from({length:n}, ()=>Array(m).fill(0));\n  const par=Array.from({length:n}, ()=>Array(m).fill(null));\n  for(let i=0;i<n;i++){\n    for(let j=0;j<m;j++){\n      if(i===0 && j===0) continue;\n      let top=-Infinity, left=-Infinity;\n      if(i>0) top = dp[i-1][j] + (grid[i-1][j] < grid[i][j] ? 1:0);\n      if(j>0) left = dp[i][j-1] + (grid[i][j-1] < grid[i][j] ? 1:0);\n      if(top >= left){ dp[i][j] = top; par[i][j] = 'U'; } else { dp[i][j] = left; par[i][j] = 'L'; }\n    }\n  }\n  // backtrack to build path\n  return {score: dp[n-1][m-1], path: []};\n}\n```","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Hugging Face","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T09:31:56.680Z","createdAt":"2026-01-12T09:31:56.680Z"},{"id":"q-813","question":"You're given a tree with N nodes (N up to 2e5). Each node i has a value val[i]. Find a connected subtree of exactly K nodes that maximizes the sum of values. Return the maximum sum and the node set. Propose a DP formulation with dp[u][s] = max sum of a connected subtree of size s that contains u and lies entirely within u's subtree when the tree is rooted at 1; include reconstruction, base cases, and discuss time/space?","answer":"Root the tree at 1. dp[u][s] = max sum of a connected subtree of size s that contains u and lies in u's subtree. Base: dp[u][1] = val[u]. For each child v, knapsack-merge: new[s+t] = max(old[s] + dp[v","explanation":"## Why This Is Asked\nTests a nontrivial tree DP pattern: building size-aware subproblems per node and merging children like a knapsack while preserving the connected-subtree constraint.\n\n## Key Concepts\n- Tree DP with per-node size states (O(nK))\n- Knapsack-style merge across an arbitrary number of children\n- Connected-subtree constraint implies a unique top node in a rooted tree\n- Reconstruction via choice-tracking during merges\n\n## Code Example\n```javascript\nfunction maxSubtreeOfSizeK(n, k, edges, val) {\n  // Placeholder skeleton for the DP approach over a rooted tree\n  // Build adjacency, root at 1, then perform DFS with knapsack merge per node\n  // Return {best: number, nodes: number[]}\n}\n```\n\n## Follow-up Questions\n- How to optimize memory to O(k) per node?\n- How does complexity change with high-degree nodes, and can we apply small-to-large merging to improve constants?","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T10:23:39.425Z","createdAt":"2026-01-12T10:23:39.425Z"},{"id":"q-821","question":"You're given a string s of length n consisting of lowercase letters. Partition s into at most k non-empty contiguous substrings. The cost of a substring is the number of distinct characters in that substring. Return the minimum total cost and one valid partition (end indices). Propose a DP formulation with recurrence dp[i][t] = min_{p in [t-1..i-1]} dp[p][t-1] + cost(p, i-1) where cost(p, q) is the number of distinct letters in s[p..q]. Explain reconstruction, base cases, and time/space complexity?","answer":"DP over cut positions: define dp[i][t] as min cost to split s[0..i-1] into t substrings, with a backpointer to recover the last cut. Precompute cost(p,i-1) = number of distinct letters in s[p..i-1] by","explanation":"## Why This Is Asked\n\nTests a non-trivial partition DP with a substring cost that requires precomputation and reconstruction, combining both combinatorial choices and an aggregate cost function.\n\n## Key Concepts\n\n- DP on partitions with a cost function over substrings\n- Efficient precomputation of substring distinct counts\n- Backtracking reconstruction of cut points\n- Time/space trade-offs and memory optimization\n\n## Code Example\n\n```javascript\n// Pseudo: precompute cost[p][i], then DP with backpointers\nconst n = s.length;\nconst INF = 1e9;\nconst cost = Array.from({ length: n }, () => Array(n).fill(0));\nfor (let p = 0; p < n; p++) {\n  const seen = new Array(26).fill(false);\n  let distinct = 0;\n  for (let i = p; i < n; i++) {\n    const idx = s.charCodeAt(i) - 97;\n    if (!seen[idx]) { seen[idx] = true; distinct++; }\n    cost[p][i] = distinct;\n  }\n}\nconst kCap = Math.min(k, n);\nconst dp = Array.from({ length: n+1 }, () => Array(kCap+1).fill(INF));\nconst prv = Array.from({ length: n+1 }, () => Array(kCap+1).fill(-1));\ndp[0][0] = 0;\nfor (let i = 1; i <= n; i++) {\n  for (let t = 1; t <= Math.min(i, kCap); t++) {\n    for (let p = t-1; p <= i-1; p++) {\n      const cand = dp[p][t-1] + cost[p][i-1];\n      if (cand < dp[i][t]) { dp[i][t] = cand; prv[i][t] = p; }\n    }\n  }\n}\n```\n","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","LinkedIn","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T11:19:30.997Z","createdAt":"2026-01-12T11:19:30.997Z"},{"id":"q-829","question":"You're given an array A of length n and an integer k. Partition A into exactly k non-empty contiguous subarrays. Each subarray's cost is max(A[l..r]) - min(A[l..r]). Return the minimum total cost and one valid partition (end indices). Propose a DP: dp[i][t] = min_{p in [t-1..i-1]} dp[p][t-1] + (max(A[p..i-1]) - min(A[p..i-1])); base: dp[i][1] = max(A[0..i-1]) - min(A[0..i-1]). Explain reconstruction, base cases, and time/space complexity?","answer":"DP over prefixes and segment counts: dp[i][t] = min over p of dp[p][t-1] + range(p, i-1), where range is max-min. Store cut indices for reconstruction. Base: dp[i][1] = range(0, i-1). Computing range ","explanation":"## Why This Is Asked\nTests DP with a range-based segment cost and path reconstruction, a common advanced pattern not covered yet.\n\n## Key Concepts\n- Contiguous partitioning\n- Range query (max-min)\n- DP with backtracking\n- Time/space trade-offs and potential optimizations\n\n## Code Example\n```javascript\nfunction minCostPartition(A, k) {\n  const n = A.length;\n  const dp = Array.from({ length: n + 1 }, () => Array(k + 1).fill(Infinity));\n  const cut = Array.from({ length: n + 1 }, () => Array(k + 1).fill(-1));\n  // base\n  for (let i = 1; i <= n; i++) {\n    let mx = -Infinity, mn = Infinity;\n    for (let p = i - 1; p >= 0; p--) {\n      mx = Math.max(mx, A[p]);\n      mn = Math.min(mn, A[p]);\n      dp[i][1] = Math.max(...A.slice(0, i)) - Math.min(...A.slice(0, i));\n    }\n  }\n  // transitions would fill dp[i][t] and cut[i][t]\n  return { cost: dp[n][k], partition: cut };\n}\n```\n\n## Follow-up Questions\n- How would you optimize range(p, i-1) queries to O(1) per transition?\n- How would you adapt for 1-indexed arrays or allow at most k segments?","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Hugging Face","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T12:41:45.018Z","createdAt":"2026-01-12T12:41:45.018Z"}],"subChannels":["general"],"companies":["Adobe","Airbnb","Amazon","Anthropic","Apple","Bloomberg","Citadel","Coinbase","Databricks","DoorDash","Goldman Sachs","Google","Hugging Face","IBM","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Netflix","OpenAI","Oracle","PayPal","Plaid","Robinhood","Salesforce","Scale Ai","Slack","Snap","Square","Stripe","Tesla","Twitter","Two Sigma","Uber"],"stats":{"total":43,"beginner":17,"intermediate":12,"advanced":14,"newThisWeek":23}}