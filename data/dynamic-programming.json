{"questions":[{"id":"q-1262","question":"You're given an array A of length n and an integer k. You must select exactly k non-overlapping, contiguous subarrays (non-empty) to maximize the sum of all selected elements. Return the maximum sum and the k subarrays (start and end indices). Propose a dynamic programming formulation with states and recurrences, include reconstruction, and discuss time/space complexity?","answer":"Define dp[i][t] = max sum using first i elements with exactly t subarrays, and local[i][t] = max sum ending at i with t subarrays. Recurrences: local[i][t] = max(local[i-1][t] + a[i], dp[i-1][t-1] + a","explanation":"## Why This Is Asked\nTests ability to extend Kadane to multiple disjoint subarrays with exact count, plus reconstruction.\n\n## Key Concepts\n- DP with two fabrics: global and local bests; disjoint subarray constraint; reconstruction path.\n- Space optimization and handling of -INF edge cases.\n\n## Code Example\n```javascript\n// sketch of DP with reconstruction\n```\n\n## Follow-up Questions\n- How would you modify if subarrays could be at most k? 2D dp change.\n- Could you implement an optimized solution with O(n log k) for larger constraints?","diagram":"flowchart TD\n  Start(Start) --> DPForm(DP Formulation)\n  DPForm --> Local(Local State)\n  DPForm --> Rec( reconstruction )\n  Local --> Reconstruct\n  Rec --> End(End)","difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T07:26:39.875Z","createdAt":"2026-01-13T07:26:39.875Z"},{"id":"q-1872","question":"You're given an n x m grid of integers grid[i][j]. From (0,0) to (n-1,m-1) you may move only right or down. You may turn at most K times (a turn is a change between directions). Return the maximum sum along a valid path and the path coordinates. Propose a DP with states dp[i][j][t][dir], recurrences, base cases, and reconstruction, and discuss time/space?","answer":"Propose dp[i][j][t][dir], where i,j cell, t turns used (0..K), dir ∈ {0=right,1=down}. Base: dp[0][0][0][0] = grid[0][0], dp[0][0][0][1] = grid[0][0]. Transitions: from (i,j-1) with same dir or with a","explanation":"## Why This Is Asked\nTests multi-dimensional DP with path reconstruction under a constrained number of turns, a common production planning scenario.\n\n## Key Concepts\n- 4D DP: i, j, t, dir\n- Transitions handle continuing in the same direction or taking a turn\n- Path reconstruction via parent pointers; edge-case handling when K is large\n- Complexity analysis and memory optimization considerations\n\n## Code Example\n```javascript\nfunction maxSumWithTurns(grid, K) {\n  const n = grid.length, m = grid[0].length;\n  // Placeholder: actual DP initialization and transitions would go here\n  return {best: 0, path: []};\n}\n```\n\n## Follow-up Questions\n- How would you optimize memory to O(n*m*(K+1))?\n- How would you adapt if turns also incur a penalty per turn?","diagram":"flowchart TD\n  A[Start] --> B[DP state: i, j, t, dir]\n  B --> C{Transitions}\n  C --> D[From left with same dir]\n  C --> E[From left with turn]\n  C --> F[From top with same dir]\n  C --> G[From top with turn]\n  D --> H[Update dp]\n  E --> H\n  F --> H\n  G --> H\n  H --> I[Reconstruct path]","difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","MongoDB","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T15:34:12.531Z","createdAt":"2026-01-14T15:34:12.531Z"},{"id":"q-1941","question":"You're given an array A of length n and an integer k. You must select at most k elements such that no two selected elements are adjacent. Return the maximum sum you can obtain and the list of selected indices. Propose a DP formulation with states dp[i][j], recurrences, base cases, and reconstruction?","answer":"DP uses dp[i][j] = max(dp[i-1][j], dp[i-2][j-1] + A[i-1]) for i>=2; base: dp[0][0]=0, dp[i][0]=0, dp[1][1]=A[0]. Reconstruct by backtracking from (n, min(k, floor((n+1)/2))). Time O(nk); space O(nk) (","explanation":"## Why This Is Asked\nTests DP with adjacency constraint and exact count; requires states over i and j, base cases, and backtracking.\n\n## Key Concepts\n- DP with two dimensions n and k\n- adjacency constraint via i-2 transition\n- reconstruction via parent pointers or decisions\n- space/time bounds and potential optimizations\n\n## Code Example\n```javascript\nfunction maxSumNoAdj(A, k) {\n  const n = A.length;\n  const K = Math.min(k, Math.floor((n + 1) / 2));\n  const dp = Array.from({ length: n + 1 }, () => Array(K + 1).fill(0));\n  const take = Array.from({ length: n + 1 }, () => Array(K + 1).fill(false));\n  for (let i = 1; i <= n; i++) {\n    for (let j = 0; j <= K; j++) {\n      dp[i][j] = dp[i - 1][j];\n      if (j > 0) {\n        if (i >= 2) {\n          const cand = dp[i - 2][j - 1] + A[i - 1];\n          if (cand > dp[i][j]) {\n            dp[i][j] = cand;\n            take[i][j] = true;\n          }\n        } else if (i === 1 && j === 1) {\n          if (A[0] > dp[i][j]) { dp[i][j] = A[0]; take[i][j] = true; }\n        }\n      }\n    }\n  }\n  // reconstruct\n  let i = n, j = K, indices = [];\n  while (i >= 1 && j >= 0) {\n    if (take[i][j]) { indices.push(i - 1); i -= 2; j -= 1; }\n    else { i -= 1; }\n  }\n  indices.reverse();\n  return { sum: dp[n][K], indices };\n}\n```\n\n## Follow-up Questions\n- How would you enforce exactly k selections vs at most k?\n- How to optimize space to O(k)?\n- How handle negative numbers in A?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Instacart","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T17:54:17.619Z","createdAt":"2026-01-14T17:54:17.619Z"},{"id":"q-2170","question":"You're given an array values[0..n-1] of positive integers. Two players take turns removing either the leftmost or rightmost value and add it to their score. Assuming both play optimally, return A's maximum guaranteed total score and the move sequence (L/R) for each turn. Provide a DP formulation with dp[i][j] as the maximum score difference for subarray i..j, the base cases, and how to reconstruct the moves?","answer":"DP idea: let dp[i][j] be the maximum difference current player can achieve over the opponent from values[i..j]. Transition: dp[i][j] = max(values[i] - dp[i+1][j], values[j] - dp[i][j-1]); base: dp[i][","explanation":"## Why This Is Asked\nThis tests minimax-style DP with reconstruction for a classic game.\n\n## Key Concepts\n- Two-player DP with difference state\n- Subarray DP and reconstruction path\n- Time: O(n^2) space: O(n^2)\n\n## Code Example\n```javascript\n// dp[i][j] denotes max diff for i..j\nfunction maxFirstPlayer(values){\n  const n = values.length; const dp = Array.from({length:n},()=>Array(n).fill(0));\n  let total = values.reduce((a,b)=>a+b,0);\n  for(let i=0;i<n;i++) dp[i][i]=values[i];\n  for(let len=2; len<=n; len++){\n    for(let i=0;i+len-1<n;i++){\n      const j=i+len-1;\n      dp[i][j] = Math.max(values[i]-dp[i+1][j], values[j]-dp[i][j-1]);\n    }\n  }\n  return (total + dp[0][n-1])/2;\n}\n```\n\n## Follow-up Questions\n- How would you reconstruct the exact L/R sequence from the DP table?\n- How does this change if moves include taking from both ends with a coin flip to decide who starts?","diagram":"flowchart TD\n  Start(Start) --> Choose{Take Left or Right?}\n  Choose --> ScoreLeft[Left contributes to current player]\n  Choose --> ScoreRight[Right contributes to current player]\n  ScoreLeft --> End\n  ScoreRight --> End","difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Lyft","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T05:46:13.890Z","createdAt":"2026-01-15T05:46:13.890Z"},{"id":"q-2405","question":"You're given an array A[0..n-1], and integers k, L, R. You must select exactly k non-overlapping contiguous subarrays such that each subarray's length is between L and R (inclusive). The sum of all elements in the selected subarrays is maximized. Return the maximum sum and the k subarrays (start and end indices). Provide a DP formulation with states, recurrences, base cases, and reconstruction, and discuss time/space?","answer":"Define dp[i][t] as the max sum using first i elements with exactly t segments, where each segment length in [L,R]. Recurrence: dp[i][t] = max(dp[i-1][t], max_{len∈[L,R]} dp[i-len][t-1] + (P[i]-P[i-len","explanation":"## Why This Is Asked\nTests a practical DP with fixed-length window constraints and reconstruction, mirroring analytics batching scenarios.\n\n## Key Concepts\n- DP over prefixes with exact segment count\n- Prefix sums for fast interval sums\n- Reconstruction path tracking\n\n## Code Example\n```javascript\nfunction maxKSubarraysWithBounds(A, k, L, R){\n  const n = A.length;\n  const P = new Array(n+1).fill(0);\n  for(let i=1;i<=n;i++) P[i] = P[i-1] + A[i-1];\n  const neg = -1/0; const dp = Array.from({length:n+1}, ()=> Array(k+1).fill(neg));\n  for(let i=0;i<=n;i++) dp[i][0] = 0;\n  const take = Array.from({length:n+1}, ()=> Array(k+1).fill(-1));\n  for(let i=1;i<=n;i++){\n    for(let t=1;t<=k;t++){\n      dp[i][t] = dp[i-1][t];\n      for(let len=L; len<=R && len<=i; len++){\n        if (dp[i-len][t-1] !== neg) {\n          const val = dp[i-len][t-1] + (P[i]-P[i-len]);\n          if (val > dp[i][t]){ dp[i][t] = val; take[i][t] = len; }\n        }\n      }\n    }\n  }\n  return {maxSum: dp[n][k], take}\n}\n```","diagram":"flowchart TD\n  A[Start: define dp[i][t]] --> B[Use first i elements with t segments]\n  B --> C[Recurrence: dp[i][t] = max(dp[i-1][t], max_len(dp[i-len][t-1] + sum))]\n  C --> D[Base cases: dp[0][0]=0; dp[i][0]=0]\n  D --> E[Reconstruction via take pointers]\n  E --> F[Complexities: time/space as per bounds]","difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T16:55:49.550Z","createdAt":"2026-01-15T16:55:49.550Z"},{"id":"q-2434","question":"You're given an array A of length n and an integer k. Choose exactly k non-empty, non-overlapping subarrays. The score of a subarray [l..r] is sum(A[l..r]) - min(A[l..r]). Return the maximum total score and the list of subarray endpoints (l, r). Propose a DP formulation: dp[i][t] = max_{p in [t-1..i-1]} dp[p][t-1] + sum(A[p+1..i]) - min(A[p+1..i]). Base: dp[i][1] = sum(A[1..i]) - min(A[1..i]). Include reconstruction, base cases, and time/space complexity?","answer":"Use dp[i][t] as the best score for first i elements using exactly t subarrays, with the t-th subarray ending at i. Recurrence: dp[i][t] = max_{p in [t-1..i-1]} dp[p][t-1] + (P[i]-P[p]) - min(A[p+1..i]","explanation":"## Why This Is Asked\nThis question tests a DP over partitioned subarrays with a non-standard per-subarray score and reconstruction.\n\n## Key Concepts\n- DP on non-overlapping subarrays\n- Prefix sums and range minimums\n- Path reconstruction and base cases\n- Complexity: O(n^2 k) time, O(nk) space\n\n## Code Example\n```javascript\nfunction maxScore(A, k){\n  const n = A.length; const P=[0]; for(let i=0;i<n;i++) P[i+1]=P[i]+A[i];\n  const dp=Array.from({length:n+1},()=>Array(k+1).fill(-Infinity));\n  const prev=Array.from({length:n+1},()=>Array(k+1).fill(-1));\n  for(let i=1;i<=n;i++) dp[i][1]=P[i]-Math.min(...A.slice(0,i));\n  for(let t=2;t<=k;t++){\n    for(let i=t;i<=n;i++){\n      for(let p=t-1;p<=i-1;p++){\n        const minVal=Math.min(...A.slice(p,i));\n        const val=dp[p][t-1]+(P[i]-P[p])-minVal;\n        if(val>dp[i][t]){ dp[i][t]=val; prev[i][t]=p; }\n      }\n    }\n  }\n  // reconstruction would trace back using prev\n  return dp[n][k];\n}\n```\n\n## Follow-up Questions\n- How to optimize min queries? N log N via RMQ, or a deque per i.\n- How to reconstruct the exact subarrays efficiently?","diagram":"flowchart TD\n  A[Start] --> B[Define dp[i][t]]\n  B --> C[Transition over p]\n  C --> D[Store prev pointers]\n  D --> E[Backtrack to subarrays]","difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Lyft","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T17:52:06.796Z","createdAt":"2026-01-15T17:52:06.796Z"},{"id":"q-2815","question":"You're given a rooted tree with n nodes, each node i has a value val[i]. You must choose a connected subgraph containing exactly k nodes to maximize the sum of values. Return the maximum sum and one such set of nodes. Propose a DP: dp[u][s] = maximum sum of a connected subgraph of size s that lies within the subtree of u and includes u. Explain the recurrence and reconstruction, and discuss time/space?","answer":"Use a DFS-based DP on trees: define dp[u][s] as max sum of a connected subgraph of size s that includes u and lies within u's subtree. Merge child DP arrays via knapsack-convolution, capping at k. Bas","explanation":"## Why This Is Asked\n\nTests advanced tree DP with a connectivity constraint and a knapsack-like merge across children. Requires careful reconstruction of the chosen nodes.\n\n## Key Concepts\n\n- Tree DP: dp[u][s] for connected subgraphs containing u within its subtree\n- Knapsack-like merging of children to combine subtree sizes\n- Path reconstruction: storing decisions to recover node set\n- Complexity: O(nk) time and O(nk) space; handle negative values with offset\n\n## Code Example\n\n```javascript\nfunction maxConnectedSubtreeSum(n, k, edges, val) {\n  const g = Array.from({ length: n }, () => []);\n  for (const [u, v] of edges) { g[u].push(v); g[v].push(u); }\n  const parent = Array(n).fill(-1);\n  const order = [];\n  function dfs(u, p) {\n    parent[u] = p;\n    for (const v of g[u]) if (v !== p) dfs(v, u);\n    order.push(u);\n  }\n  dfs(0, -1);\n  // dp[u] will be an array of length min(subtreeSize[u], k) + 1\n  // Initialization, merging and reconstruction would follow a standard tree knapsack pattern\n  // Full implementation is lengthy; outline focuses on the recurrence above\n  return { best: null, nodes: [] };\n}\n```\n\n## Follow-up Questions\n\n- How would you reconstruct the actual node set from dp? \n- How to handle multiple optimal sets? \n- How would you adapt for unrooted trees or multiple roots?","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T13:49:35.426Z","createdAt":"2026-01-16T13:49:35.428Z"},{"id":"q-2880","question":"You're given an array A of length n and an integer m (1 <= m <= n). You must select exactly m indices i1 < i2 < ... < im to form a subsequence. The cost is the sum over k=2..m of |A[ik] - A[ik-1]|. Return the minimum possible cost and the corresponding indices. Propose a DP formulation with states dp[i][t], recurrences, base cases, and reconstruction, and discuss time/space complexity and potential optimizations?","answer":"dp[i][t] = min_{p<i} dp[p][t-1] + abs(A[i]-A[p]); base dp[i][1] = 0. The result is min_i dp[i][m], with reconstruction via a parent pointer. Time: O(n^2 m); space: O(n m); optimize with rolling arrays","explanation":"## Why This Is Asked\nTests DP on subsequences with transition costs; requires deriving a 2D DP with O(n^2 m) time and backpointers. Edge cases: m=1 yields 0. Consider tie-breaking on reconstruction.\n\n## Key Concepts\n- DP on subsequences; 2D states; O(n^2 m) time; backtracking via parents; rolling arrays for space.\n\n## Code Example\n```javascript\nfunction minCostSubseq(A, m){\n  const n = A.length;\n  const INF = 1e18;\n  const dp = Array.from({length: n}, ()=>Array(m+1).fill(INF));\n  const par = Array.from({length: n}, ()=>Array(m+1).fill(-1));\n  for(let i=0; i<n; i++) dp[i][1] = 0;\n  for(let i=0; i<n; i++){\n    for(let t=2; t<=m; t++){\n      for(let p=0; p<i; p++){\n        const val = dp[p][t-1] + Math.abs(A[i]-A[p]);\n        if(val < dp[i][t]){ dp[i][t] = val; par[i][t] = p; }\n      }\n    }\n  }\n  let best = INF, end = -1;\n  for(let i=0; i<n; i++){ if(dp[i][m] < best){ best = dp[i][m]; end = i; } }\n  const idx = []; let t=m, cur = end;\n  while(t >= 1){ idx.push(cur); cur = par[cur][t]; t--; }\n  idx.reverse();\n  return {cost: best, indices: idx};\n}\n```","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T15:49:32.307Z","createdAt":"2026-01-16T15:49:32.307Z"},{"id":"q-2886","question":"You're given an array A of length n and an integer k. Find a non-contiguous subsequence of length exactly k that is non-decreasing (A[i1] <= A[i2] <= ... <= A[ik]), maximizing the sum of its elements. Return the maximum sum and the indices of the chosen elements. Propose a DP: dp[i][t] = max sum of a non-decreasing subsequence of length t ending at i. Recurrence: dp[i][1] = A[i]; dp[i][t] = A[i] + max_{j<i, A[j] <= A[i]} dp[j][t-1]. Include reconstruction, base cases, and time/space complexity?","answer":"DP approach: dp[i][t] stores the max sum of a non-decreasing subsequence of length t ending at i. Init dp[i][1] = A[i]. For t>1, dp[i][t] = A[i] + max_{j<i, A[j] <= A[i]} dp[j][t-1], with a parent poi","explanation":"## Why This Is Asked\nTests extending MSIS to fixed-length subsequences and reconstruction; good for beginners to show DP with path recovery.\n\n## Key Concepts\n- Non-contiguous subsequences\n- DP over i and t\n- Reconstruction via parent pointers\n\n## Code Example\n```javascript\nfunction maxSumNonDecreasing(A, k) {\n  // implementation outline\n}\n```\n\n## Follow-up Questions\n- How to handle equal vs strictly increasing subsequences?\n- How to optimize with prefix maxima to reduce time?","diagram":"flowchart TD\n  A[Start] --> B[Init dp and par]\n  B --> C[Iterate t = 2..k]\n  C --> D[Compute dp[i][t] via max over j<i, A[j] <= A[i]]\n  D --> E[Backtrack indices]","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Snap","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T16:39:46.090Z","createdAt":"2026-01-16T16:39:46.092Z"},{"id":"q-3070","question":"You're given an array A of length n and an integer d. You may select a subsequence (not necessarily contiguous) such that for every pair of consecutive chosen elements A[i] and A[j] with i<j, |A[i]-A[j]| <= d. Maximize the sum of the chosen elements. Return the maximum sum and one valid subsequence of indices. Provide the DP formulation, reconstruction approach, and discuss time/space?","answer":"Let dp[i] be the maximum sum of a valid subsequence ending at index i with value A[i]. Then dp[i] = A[i] + max{ dp[j] | j < i and |A[i] - A[j]| ≤ d }, or dp[i] = A[i] if no such j exists. Track parent[i] to reconstruct the optimal subsequence.","explanation":"## Why This Is Asked\nThis question tests building a DP over subsequences with constraints, requiring a clear state definition and transition over previous indices, plus reconstruction capabilities.\n\n## Key Concepts\n- Subsequence DP with constraints\n- State dp[i] and parent tracking\n- Time/space analysis and reconstruction\n\n## Code Example\n```javascript\nfunction maxSubseqWithDiff(a, d) {\n  const n = a.length;\n  const dp = Array(n).fill(0);\n  const par = Array(n).fill(-1);\n  let best = -Infinity, bestIdx = -1;\n  \n  for (let i = 0; i < n; i++) {\n    dp[i] = a[i];\n    for (let j = 0; j < i; j++) {\n      if (Math.abs(a[i] - a[j]) <= d && dp[j] + a[i] > dp[i]) {\n        dp[i] = dp[j] + a[i];\n        par[i] = j;\n      }\n    }\n    if (dp[i] > best) {\n      best = dp[i];\n      bestIdx = i;\n    }\n  }\n  \n  // Reconstruct subsequence\n  const seq = [];\n  let curr = bestIdx;\n  while (curr !== -1) {\n    seq.push(curr);\n    curr = par[curr];\n  }\n  return { maxSum: best, subsequence: seq.reverse() };\n}\n```\n\n## Time/Space Complexity\nTime: O(n²) due to nested loops checking all previous indices\nSpace: O(n) for dp and parent arrays","diagram":"flowchart TD\n  Start([Start]) --> DPState[DP State dp[i]]\n  DPState --> Transitions[Compute transitions from j<i with |A[i]-A[j]|<=d]\n  Transitions --> Reconstruct[Track parent and reconstruct indices]\n  Reconstruct --> End([End])","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Coinbase","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T04:07:28.782Z","createdAt":"2026-01-16T23:40:00.236Z"},{"id":"q-3196","question":"You're given an array A of length n and an integer k. Partition A into exactly k non-empty contiguous subarrays. The score of a subarray [l..r] is the sum of |A[i+1]-A[i]| for i in [l..r-1]. Return the maximum total score and the partition endpoints (end indices). Propose a DP: dp[i][t] = max_{p in [t-1..i-1]} dp[p][t-1] + sum_{q=p+1}^{i-1} |A[q+1]-A[q]|. Base: dp[i][1] = sum_{q=1}^{i-1} |A[q+1]-A[q]|. Explain reconstruction, base cases, and time/space complexity?","answer":"Compute diff and prefix sums to turn subarray score into a prefix-difference. Define dp[i][t] as max score for first i elements split into t blocks. Then dp[i][1] = pref[i-1], and dp[i][t] = pref[i-1]","explanation":"## Why This Is Asked\n\nTests ability to design a DP with partitioning and additive segment costs; uses prefix sums to optimize the transition to O(nk).\n\n## Key Concepts\n\n- DP on partitioning into k segments\n- Prefix sums to compute segment costs in O(1)\n- State transition optimization with a running max and backpointers\n- Reconstruction of cut points\n\n## Code Example\n\n```javascript\nfunction maxPartitionScore(A, k){\n  const n = A.length;\n  if (k <= 0 || k > n) return {score: 0, cuts: []};\n  const diff = new Array(n-1).fill(0);\n  for (let i = 0; i < n-1; i++) diff[i] = Math.abs(A[i+1] - A[i]);\n  const pref = new Array(n).fill(0);\n  for (let i = 1; i < n; i++) pref[i] = pref[i-1] + diff[i-1];\n  const dp = Array.from({length: n+1}, () => new Array(k+1).fill(-Infinity));\n  const take = Array.from({length: n+1}, () => new Array(k+1).fill(-1));\n  for (let i = 1; i <= n; i++) dp[i][1] = pref[i-1];\n  for (let t = 2; t <= k; t++) {\n    let best = -Infinity, bestP = -1;\n    for (let i = t; i <= n; i++) {\n      const p = i - 1;\n      const val = dp[p][t-1] - pref[p];\n      if (val > best) { best = val; bestP = p; }\n      dp[i][t] = pref[i-1] + best;\n      take[i][t] = bestP;\n    }\n  }\n  let cuts = [];\n  let i = n, t = k;\n  while (t > 0) {\n    const p = take[i][t];\n    cuts.push(i);\n    i = p;\n    t--;\n  }\n  cuts.reverse();\n  return {score: dp[n][k], cuts};\n}\n```","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","NVIDIA","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T06:47:08.446Z","createdAt":"2026-01-17T06:47:08.446Z"},{"id":"q-3322","question":"You're given an array A of length n and an integer k. Partition A into exactly k non-empty contiguous subarrays. Each subarray's score is the number of distinct elements within that subarray. Return the maximum total score across all partitions and the k subarrays' boundaries (start and end indices). Propose a DP formulation with states dp[i][t], recurrences, base cases, reconstruction, and discuss time/space complexity?","answer":"DP idea: dp[i][t] = max total distincts for partitioning A[0..i-1] into t blocks. Recurrence: dp[i][t] = max_{p in [t-1..i-1]} dp[p][t-1] + D(p, i-1) where D(p,i-1) is the number of distinct elements ","explanation":"## Why This Is Asked\nTests a less-traveled DP angle: maximizing a sum of subarray-specific statistics (distinct counts) with exact segmentation. Requires careful state design and backtracking for reconstruction.\n\n## Key Concepts\n- DP over prefix end i and segment count t\n- Subarray distinct counts D(p,i-1)\n- Backpointers for reconstruction\n- Time: O(n^2 k), Space: O(nk)\n\n## Code Example\n```javascript\nfunction maxDistinctPartition(A, k) {\n  const n = A.length;\n  // Precompute distinct counts D[l][r]\n  const D = Array.from({ length: n }, () => Array(n).fill(0));\n  for (let l = 0; l < n; l++) {\n    const seen = new Set();\n    for (let r = l; r < n; r++) {\n      seen.add(A[r]);\n      D[l][r] = seen.size;\n    }\n  }\n  const dp = Array.from({ length: n + 1 }, () => Array(k + 1).fill(-Infinity));\n  const bt = Array.from({ length: n + 1 }, () => Array(k + 1).fill(-1));\n  for (let i = 1; i <= n; i++) dp[i][1] = D[0][i - 1];\n  for (let t = 2; t <= k; t++) {\n    for (let i = t; i <= n; i++) {\n      for (let p = t - 1; p <= i - 1; p++) {\n        const cand = dp[p][t - 1] + D[p][i - 1];\n        if (cand > dp[i][t]) { dp[i][t] = cand; bt[i][t] = p; }\n      }\n    }\n  }\n  // reconstruct\n  let i = n, t = k;\n  const segs = [];\n  while (t > 0) {\n    const p = bt[i][t];\n    segs.push([p, i - 1]);\n    i = p; t--;\n  }\n  segs.reverse();\n  return { best: dp[n][k], segments: segs };\n}\n```\n\n## Follow-up Questions\n- How would you optimize to O(nk) memory?\n- How would you handle at most k segments instead of exactly k?\n- Can you adapt to streaming data or reconstruct segments efficiently for large n?","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Anthropic","Apple"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T11:30:58.421Z","createdAt":"2026-01-17T11:30:58.421Z"},{"id":"q-3392","question":"You are given an array A of length n and an integer m. You must select exactly m indices i1 < i2 < ... < im. The total cost is sum_{t=2..m} |A[i_t] - A[i_{t-1}]|. Return the minimum total cost and the indices. Propose a DP formulation with states dp[i][t] representing the minimum cost ending at i as the t-th picked element, base cases, recurrences, how to reconstruct the path, and discuss time/space complexity and possible optimizations?","answer":"Define dp[i][t] = minimum cost to pick t elements with i as the last pick. Base: dp[i][1] = 0. Recurrence: dp[i][t] = min_{j<i} (dp[j][t-1] + |A[i]-A[j]|). Track parent par[i][t] = argmin. Final answe","explanation":"## Why This Is Asked\nTests DP over subsequences with a fixed length and pairwise costs, plus explicit reconstruction. It moves beyond contiguous partitions by requiring last-step linkage through prior picks.\n\n## Key Concepts\n- Subsequence DP with fixed length\n- Min-over-predecessor recurrence\n- Path reconstruction via parent pointers\n- Time/space trade-offs and practical optimizations\n\n## Code Example\n```javascript\nfunction solve(A, m){\n  const n=A.length;\n  const dp=Array.from({length:n},()=>Array(m+1).fill(Infinity));\n  const par=Array.from({length:n},()=>Array(m+1).fill(-1));\n  for(let i=0;i<n;i++) dp[i][1]=0;\n  for(let t=2;t<=m;t++){\n    for(let i=t-1;i<n;i++){\n      for(let j=t-2;j<i;j++){\n        const c=dp[j][t-1]+Math.abs(A[i]-A[j]);\n        if(c<dp[i][t]){ dp[i][t]=c; par[i][t]=j; }\n      }\n    }\n  }\n  let best=Infinity,bestI=-1;\n  for(let i=m-1;i<n;i++){ if(dp[i][m]<best){ best=dp[i][m]; bestI=i; } }\n  const path=[];\n  let cur=bestI, t=m;\n  while(t>=1){\n    path.push(cur);\n    cur=par[cur][t];\n    t--;\n  }\n  path.reverse();\n  return {cost:best, indices:path};\n}\n```","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Meta","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T14:32:09.857Z","createdAt":"2026-01-17T14:32:09.858Z"},{"id":"q-3492","question":"You're given an array A of length n and an integer k. Partition A into exactly k non-empty contiguous subarrays. Each subarray's cost is the maximum element within that subarray. Return the minimum total cost and the partition endpoints. Propose a DP formulation with states dp[i][t] representing the minimum cost to partition the first i elements into t subarrays, with recurrence dp[i][t] = min_{p in [t-1..i-1]} dp[p][t-1] + max(A[p+1..i]). Base: dp[i][1] = max(A[1..i]). Describe reconstruction, base cases, and time/space complexity?","answer":"Define dp[i][t] as the minimum cost to partition first i elements into t blocks. Transition: dp[i][t] = min_{p ∈ [t-1..i-1]} dp[p][t-1] + max(A[p+1..i]). We can reconstruct with prev[i][t] = argmin p.","explanation":"## Why This Is Asked\nTests DP over prefixes with a non-linear subarray cost (max) and requires reconstruction.\n\n## Key Concepts\n- DP over prefixes and partition count\n- On-the-fly max for subarray cost\n- Reconstruction via prev pointers\n- Time/space trade-offs (O(n^2 k) time, O(nk) space)\n\n## Code Example\n```javascript\nfunction minCostPartition(A, k){\n  const n = A.length;\n  const INF = 1e15;\n  const dp = Array.from({length: n+1}, ()=> Array(k+1).fill(INF));\n  const prev = Array.from({length: n+1}, ()=> Array(k+1).fill(-1));\n  dp[0][0] = 0;\n  for(let i=1; i<=n; i++){\n    for(let t=1; t<=Math.min(i,k); t++){\n      let curMax = -Infinity;\n      for(let p=i-1; p>=t-1; p--){\n        curMax = Math.max(curMax, A[p]);\n        const val = dp[p][t-1] + curMax;\n        if(val < dp[i][t]){ dp[i][t] = val; prev[i][t] = p; }\n      }\n    }\n  }\n  return {cost: dp[n][k], prev};\n}\n```\n\n## Follow-up Questions\n- How would you optimize to O(nk) if cost allowed a Monge property? \n- How would you extend to allow a penalty for creating a new subarray? ","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Lyft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T18:48:30.829Z","createdAt":"2026-01-17T18:48:30.829Z"},{"id":"q-3812","question":"You are given a string s of length n over lowercase letters. You may delete characters to obtain a string that strictly alternates between two distinct characters, e.g., abab... or xyxy.... Choose any two distinct characters and delete all other characters. Return the maximum possible length and the pair (a,b) of characters used. Propose a DP to compute, for each ordered pair (a,b), the longest alternating subsequence using only a and b; include base cases, transitions, and how to reconstruct the solution?","answer":"Enumerate ordered pairs (a,b) with a != b (26*25). For each pair, compute the longest alternating subsequence using DP with two ends: endA = max length ending with a, endB = max length ending with b. ","explanation":"## Why This Is Asked\nTests DP over subsequences with a practical text-processing flavor and shows how to structure state for two-character alternation.\n\n## Key Concepts\n- DP over character pairs\n- Two-state subsequence extension\n- Reconstruction from DP\n\n## Code Example\n```javascript\n// Pseudocode for one pair (a,b)\nlet endA = 0, endB = 0;\nfor (const ch of s) {\n  if (ch === a) endA = Math.max(endA, endB + 1);\n  else if (ch === b) endB = Math.max(endB, endA + 1);\n}\nreturn Math.max(endA, endB); // ignore if < 2\n```\n\n## Follow-up Questions\n- How would you optimize to stop early if remaining chars cannot improve the best pair?\n- How would you modify to require both letters appear at least once in the final subsequence?","diagram":"flowchart TD\n  A[Start] --> B[Enumerate 26*25 pairs]\n  B --> C[DP per pair with endA, endB]\n  C --> D[Update best length and pair]\n  D --> E[Output max length and pair]","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T10:37:19.249Z","createdAt":"2026-01-18T10:37:19.250Z"},{"id":"q-3829","question":"You're given a DAG with n nodes and m directed edges. Each node i has value val[i]. For a fixed k, find a path with exactly k nodes maximizing the sum of values along the path. Return the max sum and the path as node indices. Provide a DP formulation with states, recurrences, base cases, reconstruction, and complexity notes?","answer":"DP idea: topologically sort the DAG. Compute best[v][t] = max sum of a path of exactly t nodes ending at v. Base: best[v][1] = val[v]. For t=2..k, best[v][t] = val[v] + max_{u->v} best[u][t-1], track ","explanation":"## Why This Is Asked\nNew angle: constraining path length in a DAG mirrors many workflow and route-planning tasks in data pipelines and dispatch systems. DP with topological order gives a clean O(k*(n+m)) solution.\n\n## Key Concepts\n- DAG topological order\n- DP by path length\n- Parent pointers for reconstruction\n- Space/time tradeoffs and edge cases (unreachable states)\n\n## Code Example\n```python\n# Python sketch\nfrom math import inf\norder = topo_sort(graph)\nbest = [[-inf]* (k+1) for _ in range(n)]\npar = [[-1]*(k+1) for _ in range(n)]\nfor v in range(n): best[v][1] = val[v]\nfor t in range(2, k+1):\n  for v in order:\n    for u in preds[v]:\n      if best[u][t-1] + val[v] > best[v][t]:\n        best[v][t] = best[u][t-1] + val[v]\n        par[v][t] = u\nend_node = max(range(n), key=lambda v: best[v][k])\npath = []\ncur = end_node; t = k\nwhile t>=1 and cur!=-1:\n  path.append(cur)\n  cur = par[cur][t]; t-=1\npath.reverse()\n```\n\n## Follow-up Questions\n- How to handle negative values or ties?\n- Adapt to at-most k nodes and returning best among t≤k.\n- Space optimization with rolling arrays.","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T11:26:21.272Z","createdAt":"2026-01-18T11:26:21.272Z"},{"id":"q-3884","question":"You're given a string s of length n and an integer k (1 <= k <= n). Partition s into exactly k non-empty contiguous substrings. For each substring, define cost as the minimum number of character changes required to make that substring a palindrome (i.e., the number of mismatched symmetric pairs). Return the minimum total cost and the partition boundaries that achieve it. Propose a DP formulation with precomputed costs cost[l][r], state dp[i][t] = min_{p in [t-1..i-1]} dp[p][t-1] + cost[p+1][i], base dp[i][1] = cost[1][i]. Describe reconstruction, base cases, and time/space complexity?","answer":"Proposed DP approach: precompute cost[l][r] = number of mismatching pairs in s[l..r] to become a palindrome (two-pointer count). Then DP: dp[i][t] = min over p in [t-1..i-1] dp[p][t-1] + cost[p+1][i],","explanation":"## Why This Is Asked\nTests DP with partitioning and a nontrivial per-substring cost, plus backtracking to recover partitions.\n\n## Key Concepts\n- DP over partitions: dp[i][t]\n- Precompute cost[l][r] in O(n^2) via two-pointer mismatches\n- Backpointers for reconstruction\n- Complexity: O(n^2 k) time, O(n^2) space\n\n## Code Example\n```javascript\nfunction minCostPalindromePartitions(s, k) {\n  const n = s.length;\n  const cost = Array.from({length: n}, ()=> Array(n).fill(0));\n  for (let l = 0; l < n; l++) {\n    for (let r = l; r < n; r++) {\n      let a = l, b = r, c = 0;\n      while (a < b) { if (s[a] !== s[b]) c++; a++; b--; }\n      cost[l][r] = c;\n    }\n  }\n  const dp = Array.from({length: n}, () => Array(k + 1).fill(Infinity));\n  const parent = Array.from({length: n}, () => Array(k + 1).fill(-1));\n  for (let i = 0; i < n; i++) dp[i][1] = cost[0][i];\n  for (let t = 2; t <= k; t++) {\n    for (let i = t - 1; i < n; i++) {\n      for (let p = t - 2; p < i; p++) {\n        const val = dp[p][t - 1] + cost[p + 1][i];\n        if (val < dp[i][t]) { dp[i][t] = val; parent[i][t] = p; }\n      }\n    }\n  }\n  const splits = [];\n  let i = n - 1, t = k;\n  while (t >= 1) {\n    splits.push(i);\n    i = parent[i][t];\n    t--;\n  }\n  splits.reverse();\n  return { minCost: dp[n - 1][k], partitions: splits };\n}\n```\n\n## Follow-up Questions\n- How would you optimize space for large n or small k?\n- How would this adapt if cost used a different per-substring metric?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T13:47:11.312Z","createdAt":"2026-01-18T13:47:11.313Z"},{"id":"q-3940","question":"You're given a string s of length n and an integer k. You may delete at most k characters from s. What is the maximum possible length of a palindromic subsequence in the remaining string? Provide a DP formulation using dp[i][j][d] as the max palindrome length in s[i..j] after exactly d deletions within that subrange. Include recurrences, base cases, reconstruction hints, and time/space complexities. Example: s = \"abca\", k = 1?","answer":"Use a 3D DP: dp[i][j][d] = max palindrome length in s[i..j] after exactly d deletions. If s[i]==s[j], dp[i][j][d] = max(dp[i+1][j-1][d]+2, dp[i+1][j][d-1], dp[i][j-1][d-1]); else dp[i][j][d] = max(dp[","explanation":"## Why This Is Asked\nTests budgeted DP on strings and reconstruction. \n\n## Key Concepts\n- dp[i][j][d] encodes a subproblem under a deletion budget; \n- palindrome subsequence logic with matches/skips; \n- reconstruction paths under deletion budget.\n\n## Code Example\n```javascript\nfunction maxPalWithDeletions(s, k){\n  const n=s.length; \n  const dp=Array.from({length:n},()=>Array.from({length:n},()=>Array(k+1).fill(0)));\n  for(let i=0;i<n;i++){ dp[i][i][0]=1; for(let d=1; d<=k; d++) dp[i][i][d]=1; }\n  for(let len=2; len<=n; len++){\n    for(let i=0; i+len-1<n; i++){\n      const j=i+len-1;\n      for(let d=0; d<=k; d++){\n        if(s[i]===s[j]){\n          dp[i][j][d]=Math.max(dp[i+1][j-1][d]+2, (d>0?dp[i+1][j][d-1]:0), (d>0?dp[i][j-1][d-1]:0));\n        } else {\n          dp[i][j][d]=Math.max(dp[i+1][j][d], dp[i][j-1][d], (d>0?dp[i+1][j-1][d-1]:0));\n        }\n      }\n    }\n  }\n  return Math.max(...Array.from({length:k+1},(_,d)=>dp[0][n-1][d]));\n}\n```\n\n## Follow-up Questions\n- Can space be reduced to O(n^2)?\n- How to reconstruct the deletion indices?\n- Change objective to count distinct palindromic subsequences with budget.","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Google","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T16:35:47.276Z","createdAt":"2026-01-18T16:35:47.276Z"},{"id":"q-4055","question":"You're given a numeric string s of length n and an integer k. Split s into exactly k non-empty contiguous substrings; interpret each substring as a decimal number with no leading zeros unless the substring is '0'. Minimize the sum of these k numbers. Return the minimum sum and the cut positions (indices after which a cut occurs). Propose a DP formulation with dp[i][t], recurrence, base cases, and reconstruction, plus time/space notes?","answer":"Split a numeric string s into exactly k non-empty contiguous substrings to minimize the sum of their numeric values. Each substring must not have leading zeros unless it is exactly \"0\". Use dynamic programming: dp[i][t] represents the minimum sum achievable by splitting the prefix s[0..i-1] into exactly t substrings. The recurrence is dp[i][t] = min(dp[j][t-1] + value(j,i-1)) for all j < i-1, where value(j,i-1) is the numeric value of s[j..i-1] if valid (no leading zeros unless single '0'). Base cases: dp[0][0] = 0, dp[i][0] = ∞ for i > 0, and dp[0][t] = ∞ for t > 0. Reconstruct the cut positions by storing predecessor indices during computation. Time complexity: O(n²k), Space complexity: O(nk) with optimization.","explanation":"## Why This Is Asked\n\nThis problem evaluates dynamic programming expertise across string partitioning with fixed segment counts, numeric parsing constraints, and solution reconstruction—fundamental skills for real-world interview scenarios.\n\n## Key Concepts\n\n- Dynamic programming over string prefixes and partition counts\n- Handling substring numeric values with leading-zero validation\n- Solution path reconstruction for determining optimal cut positions\n- Time and space complexity optimization techniques\n\n## Code Example\n\n```javascript\nfunction minSumPartition(s, k) {\n  const n = s.length;\n  \n  // Helper to get numeric value of substring [l, r)\n  const getValue = (l, r) => {\n    if (s[l] === '0' && r - l > 1) return null; // leading zero\n    return Number(s.slice(l, r));\n  };\n  \n  const dp = Array(n + 1).fill().map(() => Array(k + 1).fill(Infinity));\n  const parent = Array(n + 1).fill().map(() => Array(k + 1).fill(-1));\n  \n  dp[0][0] = 0;\n  \n  for (let i = 1; i <= n; i++) {\n    for (let t = 1; t <= k; t++) {\n      for (let j = t - 1; j < i; j++) {\n        const val = getValue(j, i);\n        if (val !== null && dp[j][t-1] + val < dp[i][t]) {\n          dp[i][t] = dp[j][t-1] + val;\n          parent[i][t] = j;\n        }\n      }\n    }\n  }\n  \n  // Reconstruct cuts\n  const cuts = [];\n  let curr = n, currT = k;\n  while (currT > 0) {\n    const prev = parent[curr][currT];\n    cuts.push(prev);\n    curr = prev;\n    currT--;\n  }\n  cuts.pop(); // remove 0\n  cuts.reverse();\n  \n  return { minSum: dp[n][k], cuts };\n}\n```\n\n## Notes\n\n- The DP explores all possible cut positions while respecting the k-substring constraint\n- Leading zero validation is crucial for correctness\n- The parent array enables O(k) reconstruction of optimal cuts","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["PayPal","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T06:04:27.158Z","createdAt":"2026-01-18T21:39:23.882Z"},{"id":"q-4189","question":"Grid path with constrained turns. You have an R x C grid with non-negative weights. Start at (0,0) and end at (R-1,C-1). You can move only right or down. You must make exactly k turns (a turn is when you switch from moving right to down or from down to right). Return the minimum path sum, or -1 if impossible. Propose a DP formulation using states dp[i][j][dir][t], with dir in {0,1} representing last move direction, t turns used. Include recurrences, base cases, reconstruction, and time/space analysis?","answer":"Approach: define dp[i][j][d][t] as min sum to reach (i,j) with last move d and t turns. Transitions: if d==0 (came from left), dp[i][j][0][t] = grid[i][j] + min(dp[i][j-1][0][t], dp[i][j-1][1][t-1]); ","explanation":"## Why This Is Asked\nAssesses ability to design a DP that tracks both position and motion state with a constraint (exact turns). Encourages reconstruction and feasibility checks.\n\n## Key Concepts\n- 4D DP state (i,j,dir,t)\n- Turn counting and alternating transitions\n- Path reconstruction and edge-case handling\n\n## Code Example\n```javascript\nconst INF = 1e15;\nfunction minPath(grid, k) {\n  const R = grid.length, C = grid[0].length;\n  // Placeholder structure; full implementation requires 4D DP and parent pointers\n  return -1;\n}\n```\n\n## Follow-up Questions\n- How would you optimize to O(C*k) space?\n- How to handle impossible k values?\n- How would you adapt for moves including right, down, and left?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T07:04:39.792Z","createdAt":"2026-01-19T07:04:39.792Z"},{"id":"q-4401","question":"You're given a binary string s of length n and an integer k. Partition s into exactly k non-empty contiguous substrings. Each substring's cost is the number of transitions inside it (positions i where s[i] != s[i-1] within the substring). Return the minimum total cost and the k partition end indices. Provide a DP formulation with dp[i][t] as the min cost to split the first i chars into t parts, recurrence dp[i][t] = min_{p in [t-1..i-1]} dp[p][t-1] + cost(p+1,i); base dp[i][1] = cost(1,i). Include reconstruction plan and complexity notes?","answer":"Let diff[i]=1 if s[i]!=s[i-1] (i>=2), pref[i]=sum diff[2..i]. Then cost(a,b)=pref[b]-pref[a]. DP: dp[i][t]=min_{p in [t-1..i-1]} dp[p][t-1]+cost(p+1,i). Base: dp[i][1]=cost(1,i). Reconstruct with a pa","explanation":"## Why This Is Asked\nTests ability to design a DP with a non-trivial cost function and prefix optimization.\n\n## Key Concepts\n- DP on prefixes and partitions\n- O(1) substring cost via precomputed diff/pref\n- Path reconstruction via parent pointers\n\n## Code Example\n```javascript\n// Precompute diff and prefix\nlet diff = Array(n+1).fill(0);\nfor (let i=2;i<=n;i++) diff[i] = s[i-1] !== s[i-2] ? 1:0;\nlet pref = Array(n+1).fill(0);\nfor (let i=2;i<=n;i++) pref[i] = pref[i-1] + diff[i];\n\n// cost(a,b)\nfunction cost(a,b){ return pref[b] - pref[a]; }\n\n// DP\nlet dp = Array.from({length:n+1}, ()=> Array(k+1).fill(Infinity));\nlet par = Array.from({length:n+1}, ()=> Array(k+1).fill(-1));\nfor(let i=1;i<=n;i++){ dp[i][1] = cost(1,i); }\n\nfor(let t=2;t<=k;t++){\n  for(let i=t;i<=n;i++){\n    for(let p=t-1;p<=i-1;p++){\n      let val = dp[p][t-1] + cost(p+1,i);\n      if(val < dp[i][t]){ dp[i][t] = val; par[i][t] = p; }\n    }\n  }\n}\n```\n\n## Follow-up Questions\n- How could you optimize to O(nk) with divide-and-conquer DP if cost satisfies quadrangle inequality?\n- How would you extract the actual partition end indices from par?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Instacart","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T17:33:35.704Z","createdAt":"2026-01-19T17:33:35.704Z"},{"id":"q-4506","question":"You're given an array A of length n representing per-minute engagement. You may select exactly k non-overlapping, contiguous time blocks in order (you may skip minutes between blocks). Each block [l..r] yields value min(A[l..r]) * (r-l+1). Return the maximum total value and the endpoints of the k blocks?","answer":"DP approach: let dp[i][t] be the maximum total value using the first i elements and exactly t blocks, where the i-th element ends the t-th block. Transition: dp[i][t] = max_{p=t-1..i} dp[p-1][t-1] + min(A[p..i]) * (i-p+1). The solution requires O(n²k) time and O(nk) space, with backpointers for reconstruction.","explanation":"## Why This Is Asked\nThis interview question tests dynamic programming with prefix-state tracking and solution reconstruction. The inner minimum calculation forces careful leftward scanning, providing a tangible beginner-to-intermediate challenge while remaining implementable in O(n²k) time.\n\n## Key Concepts\n- Dynamic programming over prefixes with block count tracking\n- On-the-fly maintenance of minimum values over sliding windows\n- Solution reconstruction via backpointers\n- Time complexity: O(n²k), Space complexity: O(nk)\n\n## Code Example\n```javascript\nfunction maxValueBlocks(A, k) {\n  const n = A.length;\n  const dp = Array.from({length: n+1}, () => Array(k+1).fill(-Infinity));\n  const pre = Array.from({length: n+1}, () => Array(k+1).fill(-1));\n  \n  dp[0][0] = 0;\n  \n  for (let i = 1; i <= n; i++) {\n    for (let t = 1; t <= Math.min(k, i); t++) {\n      let currentMin = Infinity;\n      for (let p = i; p >= t; p--) {\n        currentMin = Math.min(currentMin, A[p-1]);\n        const candidate = (dp[p-1][t-1] + currentMin * (i-p+1));\n        if (candidate > dp[i][t]) {\n          dp[i][t] = candidate;\n          pre[i][t] = p;\n        }\n      }\n    }\n  }\n  \n  // Reconstruct solution\n  const blocks = [];\n  let i = n, t = k;\n  while (t > 0) {\n    const p = pre[i][t];\n    blocks.unshift([p, i]);\n    i = p - 1;\n    t--;\n  }\n  \n  return { maxValue: dp[n][k], blocks };\n}\n```","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Instacart","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T05:27:56.180Z","createdAt":"2026-01-19T21:47:21.461Z"},{"id":"q-4604","question":"You're given a grid cost of size n x m. You start at (0,0) and must reach (n-1,m-1). You may move right, down, or diagonally down-right. Each diagonal move consumes one token from a budget of K; you may perform at most K diagonals in the path. What is the minimum total cost to reach the bottom-right, and what is the path (sequence of coordinates) taken? Propose a DP formulation with dp[i][j][t] as the minimum cost to reach (i,j) using exactly t diagonals, including recurrences, base cases, reconstruction, and a discussion of time/space?","answer":"Define dp[i][j][t] = min cost to reach (i,j) using exactly t diagonals. Recurrences: dp[i][j][t] = cost[i][j] + min(dp[i-1][j][t], dp[i][j-1][t], dp[i-1][j-1][t-1]). Base: dp[0][0][0] = cost[0][0], ot","explanation":"## Why This Is Asked\nTests ability to generalize DP with an extra resource dimension and reconstruction, a common pattern in grid path problems with constraints. It also probes edge-case handling when i or j is at 0 and when t=0. \n\n## Key Concepts\n- DP with an extra dimension for resource usage (K diagonals)\n- 3-way transitions and path reconstruction\n- Time/space trade-offs and potential optimizations\n\n## Code Example\n```javascript\nfunction minCostPath(grid, K) {\n  const n = grid.length, m = grid[0].length;\n  const INF = 1e15;\n  const dp = Array.from({ length: n }, () => Array.from({ length: m }, () => Array(K+1).fill(INF)));\n  const parent = Array.from({ length: n }, () => Array.from({ length: m }, () => Array(K+1).fill(null)));\n  dp[0][0][0] = grid[0][0];\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      for (let t = 0; t <= K; t++) {\n        if (i === 0 && j === 0 && t === 0) continue;\n        let best = INF, pick = null;\n        if (i > 0 && dp[i-1][j][t] < best) { best = dp[i-1][j][t]; pick = [i-1, j, t]; }\n        if (j > 0 && dp[i][j-1][t] < best) { best = dp[i][j-1][t]; pick = [i, j-1, t]; }\n        if (i > 0 && j > 0 && t > 0 && dp[i-1][j-1][t-1] < best) { best = dp[i-1][j-1][t-1]; pick = [i-1, j-1, t-1]; }\n        if (best < INF) {\n          dp[i][j][t] = best + grid[i][j];\n          if (pick) parent[i][j][t] = pick;\n        }\n      }\n    }\n  }\n  // find best end state\n  let bestCost = INF, endT = 0;\n  for (let t = 0; t <= K; t++) {\n    if (dp[n-1][m-1][t] < bestCost) { bestCost = dp[n-1][m-1][t]; endT = t; }\n  }\n  // reconstruct path\n  const path = [];\n  let i = n-1, j = m-1, t = endT;\n  while (i !== 0 || j !== 0 || t !== 0) {\n    path.push([i, j]);\n    const p = parent[i][j][t];\n    if (!p) break;\n    [i, j, t] = p;\n  }\n  path.push([0,0]);\n  path.reverse();\n  return { cost: bestCost, path };\n}\n```\n\n## Follow-up Questions\n- How to reduce space to O(m K) using rolling arrays?\n- How would you handle negative costs or unreachable endpoints?","diagram":"flowchart TD\n  A[Start at (0,0)] --> B[DP state dp[i][j][t]]\n  B --> C[Transitions: right, down, diag]\n  C --> D[Track t diagonals]\n  D --> E[Reconstruct path to (n-1,m-1)]","difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T04:16:13.858Z","createdAt":"2026-01-20T04:16:13.858Z"},{"id":"q-4757","question":"You're given a string s of length n and an integer k. You may delete at most k characters to transform s into a palindrome. Return whether this is possible and, if so, the resulting palindrome. Propose a DP with dp[i][j] for minimum deletions on s[i..j], recurrences: if s[i]==s[j] then dp[i][j]=dp[i+1][j-1]; else dp[i][j]=min(dp[i+1][j], dp[i][j-1])+1; base: dp[i][i]=0; dp[i][i-1]=0. Explain reconstruction, time/space, and how to recover the deletions?","answer":"Formulate dp[i][j] as the minimum deletions to make s[i..j] a palindrome. If s[i]==s[j], dp[i][j]=dp[i+1][j-1]; else dp[i][j]=min(dp[i+1][j], dp[i][j-1])+1. Base: dp[i][i]=0; dp[i][i-1]=0. Build botto","explanation":"## Why This Is Asked\nTests substring DP and reconstruction in a practical string-cleanup task, common in data processing pipelines at scale.\n\n## Key Concepts\n- DP on substrings: dp[i][j] captures minimal deletions for s[i..j]\n- Reconstruction: recover exact deletions and resulting palindrome\n- Complexity: O(n^2) time and O(n^2) space; can be optimized with path tracking\n\n## Code Example\n```javascript\nfunction minDeletionsPalindrome(s) {\n  const n = s.length;\n  const dp = Array.from({length: n}, () => Array(n).fill(0));\n  for (let len = 2; len <= n; len++) {\n    for (let i = 0; i + len - 1 < n; i++) {\n      const j = i + len - 1;\n      if (s[i] === s[j]) dp[i][j] = dp[i+1][j-1];\n      else dp[i][j] = Math.min(dp[i+1][j], dp[i][j-1]) + 1;\n    }\n  }\n  return {deletions: dp[0][n-1], dp};\n}\n```\n\n## Follow-up Questions\n- How to reconstruct the actual palindrome after deletions?\n- How to optimize to O(n) space while keeping reconstruction capability?","diagram":"flowchart TD\nA[Start] --> B{i <= j}\nB --> C{s[i] == s[j]}\nC -- Yes --> D[dp[i][j] = dp[i+1][j-1]]\nC -- No --> E[dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1]\nD --> F[move to (i+1, j-1)]\nE --> F[move to (i+1, j) or (i, j-1)]\nF --> B\n","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T11:02:18.945Z","createdAt":"2026-01-20T11:02:18.945Z"},{"id":"q-4865","question":"Partition an array into exactly k non-empty contiguous subarrays. The score of a subarray [l..r] is max(A[l..r]) - min(A[l..r]). Maximize the total score and return the k blocks' boundaries. Provide a DP formulation with reconstruction and discuss time/space?","answer":"We define dp[i][t] as the best total value for first i elements split into t blocks. Precompute val(l,r)=max(A[l..r])-min(A[l..r]) for all l<=r. Recurrence: dp[i][t] = max_{j from t-1 to i-1} dp[j][t-","explanation":"## Why This Is Asked\nTests DP partitioning with a non-sum objective and reconstruction requirements.\n\n## Key Concepts\n- DP over partitions with dp[i][t]\n- Precomputing max-min for all subarrays\n- Path reconstruction via parent pointers\n\n## Code Example\n```javascript\nfunction maxMinSubarrayVal(arr){\n  const n = arr.length;\n  const maxVal = Array.from({length:n}, ()=>Array(n).fill(0));\n  const minVal = Array.from({length:n}, ()=>Array(n).fill(0));\n  for(let i=0;i<n;i++){\n    let curMax = arr[i], curMin = arr[i];\n    for(let j=i;j<n;j++){\n      curMax = Math.max(curMax, arr[j]);\n      curMin = Math.min(curMin, arr[j]);\n      maxVal[i][j] = curMax;\n      minVal[i][j] = curMin;\n    }\n  }\n  const val = (l,r)=> maxVal[l][r] - minVal[l][r];\n  return val;\n}\n\nfunction bestPartition(arr, k){\n  const n = arr.length;\n  const val = maxMinSubarrayVal(arr);\n  const dp = Array.from({length:n+1}, ()=>Array(k+1).fill(-Infinity));\n  const parent = Array.from({length:n+1}, ()=>Array(k+1).fill(-1));\n  for(let i=1;i<=n;i++) dp[i][1] = val(0,i-1);\n  for(let t=2;t<=k;t++){\n    for(let i=t;i<=n;i++){\n      for(let j=t-1;j<=i-1;j++){\n        const cand = dp[j][t-1] + val(j, i-1);\n        if(cand > dp[i][t]){ dp[i][t] = cand; parent[i][t]=j; }\n      }\n    }\n  }\n  // reconstruct\n  let blocks = [];\n  let i=n, t=k;\n  while(t>0){\n    const j = parent[i][t];\n    blocks.push([j, i-1]);\n    i = j; t--;\n  }\n  blocks.reverse();\n  return {value: dp[n][k], blocks};\n}\n```\n\n## Follow-up Questions\n- How to optimize memory to O(nk)?\n- Can you handle ties deterministically for block reconstruction?","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T16:54:30.668Z","createdAt":"2026-01-20T16:54:30.668Z"},{"id":"q-4918","question":"You are given an array A of length n and an integer k. Partition A into exactly k non-empty contiguous subarrays. The cost of a subarray [l..r] is floor((sum A[l..r])/(r-l+1)). Return the minimum total cost and the partition endpoints?","answer":"Sample approach: DP with dp[i][t] minimal cost to partition first i elements into t blocks. For each i,t try all cut points p in [t-1,i-1], block cost = floor((pref[i]-pref[p])/(i-p)). Base: dp[i][1] ","explanation":"## Why This Is Asked\nThis tests DP over partitions with a non-linear block cost dependent on average, plus reconstruction.\n\n## Key Concepts\n- Partition DP over k blocks\n- Prefix sums for O(1) block sums\n- Non-linear, floor(sum/len) cost\n- Backtracking for endpoints\n- Time: O(n^2 k); Space: O(nk)\n\n## Code Example\n```javascript\nfunction minCostPartition(A, k){\n  const n = A.length;\n  const pref = new Array(n+1).fill(0);\n  for(let i=0;i<n;i++) pref[i+1] = pref[i] + A[i];\n  const INF = 1e15;\n  const dp = Array.from({length:n+1}, ()=>Array(k+1).fill(INF));\n  const par = Array.from({length:n+1}, ()=>Array(k+1).fill(-1));\n  dp[0][0] = 0;\n  for(let i=1;i<=n;i++){\n    for(let t=1;t<=Math.min(i,k);t++){\n      for(let p=t-1;p<=i-1;p++){\n        const sum = pref[i]-pref[p];\n        const len = i-p;\n        const cost = Math.floor(sum/len);\n        if(dp[p][t-1] + cost < dp[i][t]){\n          dp[i][t] = dp[p][t-1] + cost;\n          par[i][t] = p;\n        }\n      }\n    }\n  }\n  let blocks = [], i=n, t=k;\n  while(t>0){\n    const p = par[i][t];\n    blocks.push([p+1, i]);\n    i = p; t--;\n  }\n  blocks.reverse();\n  return {cost: dp[n][k], blocks};\n}\n```\n\n## Follow-up Questions\n- How to optimize to faster than O(n^2 k)?\n- How to handle negatives or alternative cost such as max/min?","diagram":"flowchart TD\n  A[Input A,k] --> B[Compute prefix sums]\n  B --> C[DP fill and backpointers]\n  C --> D[Reconstruct blocks]\n  D --> E[Output blocks and cost]","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Coinbase","Hugging Face"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T19:09:15.203Z","createdAt":"2026-01-20T19:09:15.203Z"},{"id":"q-5054","question":"You're given an array A of length n and an integer k. Partition A into exactly k non-empty contiguous subarrays. Each subarray's cost is the absolute difference between its endpoints, i.e., cost([l..r]) = |A[l] - A[r]|. Return the minimum total cost and the endpoints of the k subarrays. Propose a DP formulation with dp[i][t] = min_{p in [t-1..i-1]} dp[p][t-1] + |A[p+1] - A[i]|, base dp[i][1] = |A[1] - A[i]|. Include reconstruction, and discuss time/space?","answer":"Use DP over the first i elements and t blocks. Recurrence: dp[i][t] = min_{p in [t-1..i-1]} dp[p][t-1] + |A[p+1]-A[i]| with base dp[i][1] = |A[1]-A[i]|. Track parent pointers to reconstruct the k suba","explanation":"## Why This Is Asked\nThis tests deriving a clean DP where subarray cost depends on endpoints, not internal aggregates, and requires careful index handling and backtracking.\n\n## Key Concepts\n- DP state dp[i][t] for first i elements into t blocks\n- Transition over split point p with endpoint cost |A[p+1]-A[i]| \n- Backpointer reconstruction for endpoints\n- Time O(n^2 k), space O(nk) (can optimize with rolling arrays)\n\n## Code Example\n```javascript\nfunction minEndPointPartition(A, k) {\n  const n = A.length;\n  const dp = Array.from({ length: n }, () => Array(k + 1).fill(Infinity));\n  const par = Array.from({ length: n }, () => Array(k + 1).fill(-1));\n  for (let i = 0; i < n; i++) dp[i][1] = Math.abs(A[0] - A[i]);\n  for (let t = 2; t <= k; t++) {\n    for (let i = t - 1; i < n; i++) {\n      for (let p = t - 2; p <= i - 1; p++) {\n        const val = dp[p][t - 1] + Math.abs(A[p + 1] - A[i]);\n        if (val < dp[i][t]) {\n          dp[i][t] = val; par[i][t] = p;\n        }\n      }\n    }\n  }\n  let endpoints = [];\n  let i = n - 1, t = k;\n  while (t > 0) {\n    const p = par[i][t];\n    endpoints.unshift([p + 1, i]);\n    i = p; t--;\n  }\n  return { cost: dp[n - 1][k], endpoints };\n}\n```\n\n## Follow-up Questions\n- How would you adapt if cost were |A[l]-A[r]|^2 or involved a different function?\n- Can you optimize to O(nk) time with monotone queue tricks if the cost has structure?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","Instacart","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T04:11:54.179Z","createdAt":"2026-01-21T04:11:54.179Z"},{"id":"q-5131","question":"Given an array A[1..n] and integer k, partition into exactly k non-empty contiguous subarrays. Each segment’s cost is (sum of the segment) × (minimum element in that segment). Return the maximum total cost and the k segment endpoints. Propose DP: dp[i][t] = max_{p in [t-1..i-1]} dp[p][t-1] + (sum(p+1..i)) × minVal[p+1][i]. Include base cases, reconstruction, and discuss time/space?","answer":"To solve: precompute minVal for all l,r and prefix sums. Then DP: dp[i][t] = max_{p in [t-1..i-1]} dp[p][t-1] + (prefix[i]-prefix[p]) × minVal[p+1][i]. Base: dp[i][1] = (prefix[i]-prefix[0]) × minVal[","explanation":"## Why This Is Asked\nThis tests DP partitioning with a non-trivial per-segment cost that depends on both sum and min, plus reconstruction.\n\n## Key Concepts\n- Partition DP with exact k segments\n- Precompute minVal(l,r) in O(n^2)\n- Transition uses prefix sums and minVal; reconstruct with parent pointers\n\n## Code Example\n```javascript\nfunction maxCost(A, k){\n  const n = A.length;\n  const pref = new Array(n+1).fill(0);\n  for(let i=1;i<=n;i++) pref[i] = pref[i-1] + A[i-1];\n  // minVal[l][r]\n  const minVal = Array.from({length:n+2}, ()=>Array(n+2).fill(0));\n  for(let l=1;l<=n;l++){\n    let m = A[l-1];\n    minVal[l][l] = m;\n    for(let r=l;r<=n;r++){\n      m = (r===l) ? A[l-1] : Math.min(m, A[r-1]);\n      minVal[l][r] = m;\n    }\n  }\n  const dp = Array.from({length:n+1}, ()=>Array(k+1).fill(-Infinity));\n  const par = Array.from({length:n+1}, ()=>Array(k+1).fill(-1));\n  for(let i=1;i<=n;i++){ dp[i][1] = (pref[i]-pref[0]) * minVal[1][i]; par[i][1] = 0; }\n  for(let t=2;t<=k;t++){\n    for(let i=t;i<=n;i++){\n      for(let p=t-1;p<=i-1;p++){\n        const val = dp[p][t-1] + (pref[i]-pref[p]) * minVal[p+1][i];\n        if(val > dp[i][t]){ dp[i][t] = val; par[i][t] = p; }\n      }\n    }\n  }\n  // reconstruction omitted for brevity\n  return {best: dp[n][k]};\n}\n```","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Discord","Goldman Sachs"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T07:40:26.035Z","createdAt":"2026-01-21T07:40:26.035Z"},{"id":"q-5370","question":"You're given an array prices[0..n-1] representing daily stock prices. You may perform at most k buy-sell transactions, but after each sale you must skip the next day (cooldown of 1). Return the maximum profit and the days of each trade. Propose a DP formulation with states noStock, hold, and cooldown per day and t, including recurrences, base cases, and a reconstruction plan?","answer":"Use a 3-state DP per day and per t: noStock[i][t] (ready to buy), hold[i][t] (holding), cooldown[i][t] (just sold, next day cannot buy). Transitions: noStock[i][t] = max(noStock[i-1][t], cooldown[i-1]","explanation":"## Why This Is Asked\nTests ability to extend DP with a cooldown constraint and to backtrack trades.\n\n## Key Concepts\n- Multi-state DP with cooldown\n- 1-based transaction counting, backtracking\n- Space optimization via rolling arrays\n\n## Code Example\n```javascript\nfunction maxProfitWithCooldown(prices, k) {\n  const n = prices.length; if (!n || k===0) return 0;\n  const NEG = -1e15;\n  let no = new Array(k+1).fill(0);\n  let hold = new Array(k+1).fill(NEG);\n  let cool = new Array(k+1).fill(NEG);\n  hold[0] = -prices[0];\n  for (let i=1;i<n;i++){\n    let nno=no.slice(), nhold=hold.slice(), ncool=cool.slice();\n    for (let t=0;t<=k;t++){\n      nno[t] = Math.max(nno[t], cool[t]);\n      nhold[t] = Math.max(nhold[t], no[t] - prices[i]);\n      if (t>0) ncool[t] = Math.max(ncool[t], hold[t-1] + prices[i]);\n    }\n    no=nno; hold=nhold; cool=ncool;\n  }\n  let best=0; for (let t=0;t<=k;t++) best=Math.max(best,no[t],cool[t]);\n  return best;\n}\n```\n\n## Follow-up Questions\n- How would you reconstruct the exact trade days?\n- How does the solution change with unlimited cooldown or different cooldown durations?","diagram":"flowchart TD\nDay[Day i] --> NoStock{NoStock}\nDay --> Hold{Hold}\nDay --> Cooldown{Cooldown}\nNoStock --> Hold\nHold --> Cooldown\nCooldown --> NoStock","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Oracle","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T19:46:54.029Z","createdAt":"2026-01-21T19:46:54.029Z"},{"id":"q-5502","question":"You're given an array A of length n and an integer k. Partition A into exactly k non-empty contiguous subarrays. Each subarray's score is sum(subarray) * index_of_subarray_in_partition (1-based). Return the maximum total score and the endpoints of the k subarrays?","answer":"Let P be prefix sums. Define dp[i][t] as the maximum score for the first i elements partitioned into t blocks. Transition: dp[i][t] = max_{p ∈ [t-1..i-1]} dp[p][t-1] + (P[i]-P[p]) * t. Base case: dp[i][1] = P[i].","explanation":"## Why This Is Asked\nThis problem introduces a dynamic programming angle where subarrays are weighted by their block index. It tests the ability to transform interval sums into prefix sums, derive a two-dimensional DP over position and block count, and implement solution reconstruction.\n\n## Key Concepts\n- Prefix sums for O(1) interval sum computation\n- 2D DP over position and block count\n- Solution reconstruction via parent pointers\n- Time complexity: O(n²k); Space complexity: O(nk)\n\n## Code Example\n```javascript\nfunction maxScorePartition(A, k) {\n  const n = A.length;\n  const P = [0];\n  for (let x of A) P.push(P[P.length-1] + x);\n  const dp = Array.from({length: n+1}, () => new Array(k+1).fill(-Infinity));\n  const parent = Array.from({length: n+1}, () => new Array(k+1).fill(-1));\n  \n  for (let i = 1; i <= n; i++) {\n    dp[i][1] = P[i];\n  }\n  \n  for (let t = 2; t <= k; t++) {\n    for (let i = t; i <= n; i++) {\n      for (let p = t-1; p < i; p++) {\n        const score = dp[p][t-1] + (P[i] - P[p]) * t;\n        if (score > dp[i][t]) {\n          dp[i][t] = score;\n          parent[i][t] = p;\n        }\n      }\n    }\n  }\n  \n  // Reconstruct partitions\n  const partitions = [];\n  let end = n;\n  for (let t = k; t >= 1; t--) {\n    const start = parent[end][t];\n    partitions.unshift([start+1, end]);\n    end = start;\n  }\n  \n  return { maxScore: dp[n][k], partitions };\n}\n```","diagram":"flowchart TD\n  A[Prefix sums P] --> B[DP transitions dp[i][t]]\n  B --> C[Store par[i][t] for reconstruction]\n  C --> D[Reconstruct endpoints]\n  D --> E[Return dp[n][k]]","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Databricks"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T04:07:38.637Z","createdAt":"2026-01-22T02:45:00.477Z"},{"id":"q-5691","question":"Context: you have a timeline of user activity represented by A[0..n-1], where A[i] is actions in minute i. You must select exactly k non-overlapping, contiguous windows [l..r] to maximize the value sum over windows of (r-l+1) * sum(A[l..r]). Return the maximum value and the k windows. How would you design a DP formulation and reconstruction?","answer":"Let pref be prefix sums. Define dp[i][t] as max value using first i elements with exactly t blocks. Recurrence: dp[i][t] = max(dp[i-1][t], max_{j=1..i} dp[j-1][t-1] + (i-j+1) * (pref[i]-pref[j-1])). B","explanation":"## Why This Is Asked\n\nThis problem tests partitioning a sequence into exactly k blocks where block value is non-linear in length. It requires a careful DP with reconstruction and shows understanding of prefix sums and state transitions.\n\n## Key Concepts\n\n- DP over partitions\n- Prefix sums for O(1) subarray sums\n- Non-linear block value and reconstruction\n- Time/space trade-offs: O(n^2 k) time, O(nk) space\n\n## Code Example\n\n```javascript\nfunction maxKSubarraysProduct(a, k) {\n  const n = a.length;\n  const pref = new Array(n + 1).fill(0);\n  for (let i = 1; i <= n; i++) pref[i] = pref[i-1] + a[i-1];\n  const dp = Array.from({ length: n + 1 }, () => new Array(k + 1).fill(-Infinity));\n  const pick = Array.from({ length: n + 1 }, () => new Array(k + 1).fill(-1));\n  dp[0][0] = 0;\n  for (let i = 1; i <= n; i++) {\n    for (let t = 1; t <= k; t++) {\n      dp[i][t] = dp[i-1][t];\n      for (let j = 1; j <= i; j++) {\n        const val = dp[j-1][t-1] + (i - j + 1) * (pref[i] - pref[j-1]);\n        if (val > dp[i][t]) {\n          dp[i][t] = val;\n          pick[i][t] = j;\n        }\n      }\n    }\n  }\n  // reconstruction omitted for brevity\n  return dp[n][k];\n}\n```\n\n## Follow-up Questions\n\n- How would you optimize to O(nk) time with monotone queue or divide-and-conquer tricks?\n- How would you handle allowing at most k blocks and a penalty for unused blocks?","diagram":"flowchart TD\n  A[Start] --> B[Compute prefix sums]\n  B --> C[DP transitions dp[i][t]]\n  C --> D[Record back-pointers for reconstruction]\n  D --> E[Return final value and intervals]","difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Databricks","IBM"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T11:40:21.561Z","createdAt":"2026-01-22T11:40:21.561Z"},{"id":"q-5831","question":"You’re given an array A of length n and an integer k. You must select exactly k non-overlapping, non-empty subarrays in order. Each subarray [l..r] yields score min(A[l..r]) * (r-l+1). Return the maximum total score and the endpoints of the k subarrays. Propose a DP formulation with dp[i][t] = max_{p in [t-1..i-1]} dp[p][t-1] + min(A[p+1..i]) * (i-p). Explain base cases, reconstruction, and time/space complexity, and mention preprocessing for range minima?","answer":"Use a DP: dp[i][t] = max over p in [t-1..i-1] of dp[p][t-1] + min(A[p+1..i]) * (i-p). Base: dp[i][1] = min(A[1..i]) * i. Precompute range mins via a sparse table or RMQ for O(1) min queries. Track par","explanation":"## Why This Is Asked\nTests ability to design a DP for partitioning with a non-linear subarray score (min * length), including reconstruction and efficient min queries.\n\n## Key Concepts\n- DP over i and t with non-overlapping partitions\n- Range minimum queries (preprocessing)\n- Path reconstruction from parent pointers\n- Time/space trade-offs and optimization notes\n\n## Code Example\n```javascript\nfunction solve(A, k) {\n  // Precompute min for ranges, build dp and parent\n}\n```\n\n## Follow-up Questions\n- How to optimize to O(nk) with monotone minima structures?\n- How would you handle at-most-k subarrays or provide ties in reconstruction?\n","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T18:50:06.070Z","createdAt":"2026-01-22T18:50:06.070Z"},{"id":"q-5876","question":"You're given an array A of length n and an integer k. Partition A into exactly k non-empty contiguous subarrays in order. For each subarray [l..r], its value is min(A[l..r]) * sum(A[l..r]). Return the maximum total value and the endpoints of the k subarrays. Propose a DP formulation with dp[i][t] = max_{p in [t-1..i-1]} dp[p][t-1] + min(A[p+1..i]) * (prefixSum[i]-prefixSum[p]); outline base cases, reconstruction plan, and discuss time/space implications and potential optimizations?","answer":"Partition A into exactly k nonempty contiguous subarrays in order, where each segment [l..r] has value min(A[l..r]) × sum(A[l..r]). DP formulation: dp[i][t] = maximum value for prefix A[1..i] using exactly t segments. Transition: dp[i][t] = max_{p∈[t-1..i-1]} dp[p][t-1] + min(A[p+1..i]) × (prefix[i] - prefix[p]). Base cases: dp[i][1] = min(A[1..i]) × prefix[i] for all i≥1, and dp[0][0] = 0. Path reconstruction: maintain parent[i][t] = argmax_{p} in transition, then backtrack: for i=n down to 1, set segment_end[t] = i, i = parent[i][t], decrement t. Use sparse table or segment tree for O(1) range min queries, enabling O(n²k) time. Space can be optimized to O(nk) with rolling arrays, or O(n) if only storing parent pointers for final reconstruction.","explanation":"## Why This Is Asked\nTests comprehensive DP design for partitioning problems with nonlinear segment costs involving both min and sum operations, requiring careful handling of base cases and path reconstruction.\n\n## Key Concepts\n- Multi-dimensional DP over partition indices\n- Range minimum query optimization within transitions\n- Complete solution from base cases through reconstruction\n- Space-time tradeoffs and optimization strategies\n\n## Code Example\n```javascript\n// Initialize DP table and parent pointers\ndp[0][0] = 0;\nfor (let i = 1; i <= n; i++) {\n  dp[i][1] = rangeMin(1, i) * prefix[i];\n  parent[i][1] = 0;\n}\n\n// Fill DP table\nfor (let t = 2; t <= k; t++) {\n  for (let i = t; i <= n; i++) {\n    for (let p = t-1; p < i; p++) {\n      const segVal = rangeMin(p+1, i) * (prefix[i] - prefix[p]);\n      const total = dp[p][t-1] + segVal;\n      if (total > dp[i][t]) {\n        dp[i][t] = total;\n        parent[i][t] = p;\n      }\n    }\n  }\n}\n\n// Reconstruct segments\nlet i = n, t = k;\nwhile (t > 0) {\n  const p = parent[i][t];\n  segments[t] = [p+1, i];\n  i = p;\n  t--;\n}\n```\n\n## Follow-up Questions\n- How would handle negative numbers and at-most-k segments?\n- Can you optimize to O(nk log n) using monotone queues?\n- What modifications needed for weighted segment costs?","diagram":"flowchart TD\n  A[Start] --> B[DP State] \n  B --> C[Transition] \n  C --> D[Reconstruct] \n  D --> E[Return]","difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":["contiguous subarrays","range minimum query","prefix sum","dp formulation","path reconstruction","segment tree","sparse table","rolling arrays","base cases","transition optimization","parent pointers","space complexity"],"voiceSuitable":true,"isNew":true,"lastUpdated":"2026-01-26T05:19:30.014Z","createdAt":"2026-01-22T19:53:27.232Z"},{"id":"q-5963","question":"You're given a numeric string s of length n and an integer k. You may insert exactly k-1 plus signs to split s into k non-empty numbers. Interpret each as decimal and maximize the sum. Return the maximum sum and the split indices. Provide a DP formulation with states dp[i][t] representing the max sum for the first i digits split into t numbers, transitions by last cut j in [t-1..i-1], base dp[i][1] = value(0,i), and include reconstruction, plus a complexity discussion on time/space?","answer":"DP over prefixes and pieces. Let dp[i][t] be the maximum sum for the first i digits split into t numbers. The last piece is s[j..i-1], so dp[i][t] = max_{j ∈ [t-1..i-1]} dp[j][t-1] + val(j,i). Base case: dp[i][1] = val(0,i).","explanation":"## Why This Is Asked\nTests concrete DP skills on string partitioning with reconstruction; approachable for beginners yet non-trivial.\n\n## Key Concepts\n- dp[i][t]: maximum sum for first i digits split into t parts\n- val(j,i): integer value of s[j..i-1] (leading zeros allowed)\n- transition: dp[i][t] = max_{j ∈ [t-1..i-1]} dp[j][t-1] + val(j,i)\n- reconstruction: track prev to recover split indices\n- complexity: O(n²k) time, O(nk) space; use BigInt for large results\n\n## Code Example\n```javascript\nfunction maxSumSplit(s, k){\n  const n = s.length;\n  const val = (a,b)=> BigInt(s.slice(a,b));\n  const dp = Array.from({length: n+1}, () => Array(k+1).fill(-1n));\n  const prev = Array.from({length: n+1}, () => Array(k+1).fill(-1));\n  \n  for(let i=1;i<=n;i++){\n    dp[i][1] = val(0,i);\n  }\n  \n  for(let t=2;t<=k;t++){\n    for(let i=t;i<=n;i++){\n      for(let j=t-1;j<i;j++){\n        const candidate = dp[j][t-1] + val(j,i);\n        if(candidate > dp[i][t]){\n          dp[i][t] = candidate;\n          prev[i][t] = j;\n        }\n      }\n    }\n  }\n  \n  // Reconstruct splits\n  const splits = [];\n  let curr = n, parts = k;\n  while(parts > 1){\n    const j = prev[curr][parts];\n    splits.push(j);\n    curr = j;\n    parts--;\n  }\n  splits.reverse();\n  \n  return {maxSum: dp[n][k], splits};\n}\n```","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Discord","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T04:03:25.418Z","createdAt":"2026-01-22T23:50:03.267Z"},{"id":"q-6015","question":"You have an array revenue[0..n-1] representing daily revenue. Partition into at most k non-empty, contiguous blocks to minimize the maximum block sum. Provide a DP formulation with states and reconstruction; include base cases and time/space analysis, and show how to output the k cut points?","answer":"Let pref[i] be prefix sums. dp[i][t] = min_{j<i} max(dp[j][t-1], pref[i]-pref[j]). Base: dp[i][1] = pref[i]. Reconstruct with parent[i][t] = argmin j. Output cuts by backtracking from (n-1, k). Time O","explanation":"## Why This Is Asked\nTests DP on partitioning with a minimax objective, a practical budgeting scenario.\n\n## Key Concepts\n- DP over partitions; - Recurrence: min over j of max of subproblem and block sum; - Reconstruction via parent pointers.\n\n## Code Example\n```javascript\n// sketch\nfunction partitionMinMaxSum(a, k) {\n  const n = a.length;\n  const pref = new Array(n+1).fill(0);\n  for (let i=0;i<n;i++) pref[i+1]=pref[i]+a[i];\n  const dp = Array.from({length:n},()=>new Array(k+1).fill(Infinity));\n  const par = Array.from({length:n},()=>new Array(k+1).fill(-1));\n  for (let i=0;i<n;i++) dp[i][1]=pref[i+1];\n  for (let t=2;t<=k;t++){\n    for (let i=0;i<n;i++){\n      for (let j=0;j<i;j++){\n        const val = Math.max(dp[j][t-1], pref[i+1]-pref[j+0]);\n        if (val<dp[i][t]){ dp[i][t]=val; par[i][t]=j; }\n      }\n    }\n  }\n  return {best: dp[n-1][Math.min(k,n)], cuts: par};\n}\n```\n\n## Follow-up Questions\n- How would you implement a monotone-queue or divide-and-conquer optimization here?\n- How would you adapt for exactly k vs at most k blocks and output exact cut points?","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Hugging Face","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T04:32:02.703Z","createdAt":"2026-01-23T04:32:02.703Z"},{"id":"q-6138","question":"You're given an array A of length n and an integer k. Partition A into exactly k non-empty contiguous blocks. For each block [l..r], the block value is sum(A[l..r]) - min(A[l..r]). Return the maximum total value and the endpoints of the k blocks (start and end indices). Propose a dynamic-programming formulation with dp[i][t] = max value for first i elements partitioned into t blocks, provide recurrences, base cases, and reconstruction plan; discuss time and space complexity?","answer":"Let prefix sums P and a range-min query structure. The DP is dp[i][t] = max_{j<i} dp[j][t-1] + (P[i]-P[j]) - min(A[j+1..i]). Base: dp[i][1] = (P[i]-P[0]) - min(A[0..i]). Reconstruct via a parent table","explanation":"## Why This Is Asked\nTests partition DP with a non-linear block value combining sums and range minimums, plus reconstruction.\n\n## Key Concepts\n- Partition DP, range-min queries, prefix sums, solution reconstruction.\n\n## Code Example\n```javascript\nfunction maxBlockValue(A, k) {\n  const n = A.length;\n  const pref = new Array(n+1).fill(0);\n  for (let i=0;i<n;i++) pref[i+1]=pref[i]+A[i];\n  // mins and DP would be filled here\n  return 0;\n}\n```\n\n## Follow-up Questions\n- How would you optimize with divide-and-conquer DP if applicable?\n- How would you extend to at most k blocks?","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Stripe","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T10:36:29.913Z","createdAt":"2026-01-23T10:36:29.913Z"},{"id":"q-6325","question":"You're given a string s of length n consisting of lowercase letters. Choose exactly k non-overlapping substrings that maximize the total length, with the constraint that each chosen substring can be rearranged to form a palindrome (i.e., its character counts allow at most one odd count). Return the maximum total length and the endpoints of the chosen substrings. Propose a DP formulation with dp[i][t] = max total length for first i chars using t substrings, including a fast feasibility test for s[p..i], base cases, and reconstruction plan; discuss time/space?","answer":"Outline an O(n^2 k) DP with rolling arrays and a fast palindromic-anagram test. Compute prefix parity masks pref[i] representing XOR of 1<<char for s[1..i]. s[l..r] is palindromable iff popcount(pref[","explanation":"## Why This Is Asked\n\nExplores a new DP angle: selecting exactly k non-overlapping substrings with a per-substring palindrome-anagram constraint, requiring fast feasibility testing via prefix masks and reconstruction.\n\n## Key Concepts\n\n- Palindromable substrings via 26-bit parity mask\n- Prefix XOR to test s[l..r] in O(1)\n- DP over i and t with transitions from p-1\n- Backpointer reconstruction; space optimization with rolling arrays\n- Time complexity: O(n^2 k)\n\n## Code Example\n\n```javascript\nfunction maxLenPalAnagram(s, k) {\n  const n = s.length;\n  const pref = new Array(n + 1).fill(0);\n  for (let i = 1; i <= n; i++) pref[i] = pref[i - 1] ^ (1 << (s.charCodeAt(i - 1) - 97));\n  function popcount(x) { let c = 0; while (x) { x &= x - 1; c++; } return c; }\n  function canPal(l, r) {\n    return popcount(pref[r] ^ pref[l - 1]) <= 1;\n  }\n  // DP skeleton: dp[i][t] = max total length through i with t substrings\n}\n```\n\n## Follow-up Questions\n\n- How to optimize to near O(nk) for special input patterns? \n- How to reconstruct actual substrings efficiently and handle ties? ","diagram":"flowchart TD\n  Start[Input s, k] --> Feas[Feasibility via prefix masks]\n  Feas --> DP[DP over i, t]\n  DP --> Reconst[Backpointer reconstruction]\n  Reconst --> End[Output endpoints and length]","difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Netflix","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T19:33:25.461Z","createdAt":"2026-01-23T19:33:25.462Z"},{"id":"q-6539","question":"You are given an array A of length n and an integer k. You may select exactly k non-overlapping, non-empty subarrays in order. The value of a subarray [l..r] is (sum(A[l..r]) - min(A[l..r])). Return the maximum total value and the endpoints of the chosen subarrays?","answer":"To solve, use DP with prefix sums. Let dp[i][t] be max value using first i elements split into t blocks, and par[i][t] the previous cut. Recurrence: dp[i][t] = max_{p in [t-1..i-1]} dp[p][t-1] + (pref","explanation":"## Why This Is Asked\nTests dynamic programming with partitioning and a segment cost that combines a sum component with a range-min component, plus reconstruction.\n\n## Key Concepts\n- DP over partitions\n- Segment cost: sum minus min\n- Prefix sums for O(1) subarray sums\n- RMQ to query min(A[l..r]) in O(1)\n- Path reconstruction via parent pointers\n\n## Code Example\n```javascript\n// DP skeleton (illustrative, not full implementation)\nfunction maxValue(A, k){\n  const n = A.length;\n  const pref = new Array(n+1).fill(0);\n  for(let i=1;i<=n;i++) pref[i] = pref[i-1] + A[i-1];\n  // dp and par would be filled here with O(n^2 k) approach\n}\n```\n\n## Follow-up Questions\n- How would you optimize to near O(nk) using divide-and-conquer or monotone queue techniques if the cost satisfies quadrangle inequality?\n- How would you handle ties in reconstruction and memory-limited environments?","diagram":"flowchart TD\n  Start[Start] --> DP[DP over i,t]\n  DP --> RMQ[RMQ min(A[l..r])]\n  RMQ --> Reconst[Reconstruction of cuts]\n  Reconst --> End[End]","difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","LinkedIn","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T07:27:02.040Z","createdAt":"2026-01-24T07:27:02.042Z"},{"id":"q-6575","question":"You manage a CDN and have hourly revenue A[0..n-1]. You can place at most k maintenance windows, each a contiguous block with length between minLen and maxLen inclusive. Windows must be non-overlapping. You want to minimize the total revenue lost during maintenance, i.e., the sum of A over all chosen windows. Return the minimum lost revenue and the windows (endpoints). Propose a DP formulation with states i, t and reconstruction plan, including recurrences and base cases, and discuss time/space complexity?","answer":"DP idea: compute prefix sums pref[i]. Define dp[i][t] = minimum lost revenue for first i hours using t windows. Recurrence: dp[i][t] = min(dp[i-1][t], min_{L<=len<=R} dp[i-len][t-1] + (pref[i]-pref[i-","explanation":"## Why This Is Asked\nCDN maintenance planning with bounded window lengths and non-overlap is a practical DP pattern: a constrained range transition with reconstruction.\n\n## Key Concepts\n- DP with range-length transitions across i and t\n- Prefix sums for O(1) interval costs\n- Reconstruction pointers for actual windows\n- Time/space tradeoffs and potential optimizations\n\n## Code Example\n```python\n# minimal sketch\ndef min_loss(A, k, L, R):\n    n = len(A)\n    pref = [0]*(n+1)\n    for i in range(n): pref[i+1] = pref[i] + A[i]\n    INF = 10**18\n    dp = [[INF]*(k+1) for _ in range(n+1)]\n    par = [[-1]*(k+1) for _ in range(n+1)]\n    dp[0][0] = 0\n    for i in range(1, n+1):\n        for t in range(0, k+1):\n            dp[i][t] = min(dp[i][t], dp[i-1][t])\n        for t in range(1, k+1):\n            for length in range(L, min(R, i)+1):\n                cand = dp[i-length][t-1] + (pref[i]-pref[i-length])\n                if cand < dp[i][t]:\n                    dp[i][t] = cand\n                    par[i][t] = length\n    return dp[n][0], par\n```\n\n## Follow-up Questions\n- How to optimize to O(n*k) with a sliding minimum over i-L..i-R?\n- How would constraints change if some windows carry different costs or mandatory coverage?","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Coinbase"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T08:46:18.432Z","createdAt":"2026-01-24T08:46:18.433Z"},{"id":"q-6676","question":"You're given an array A of length n and an integer k. You must select exactly k non-overlapping, contiguous subarrays to maximize the sum over blocks of value(l,r) = (sum(A[l..r])) * (min(A[l..r])). Return the maximum total value and the endpoints of the k subarrays?","answer":"Precompute V[l][r] = (sum A[l..r]) * (min A[l..r]) for all 0<=l<=r<n. Then DP: dp[i][t] = max value using first i elements with exactly t blocks, with dp[i][t] = max(dp[i-1][t], max_{j<i}(dp[j][t-1] +","explanation":"## Why This Is Asked\n\nThis question introduces a non-linear block value that combines sum and minimum, forcing a DP that accounts for subarray metrics and partition points. It also tests reconstruction of exact k segments and handling of large intermediate data.\n\n## Key Concepts\n\n- Non-linear block cost: (sum) * (min)\n- Precomputation of all subarray metrics V[l][r]\n- DP over prefixes with exactly k blocks\n- Path reconstruction from predecessor pointers\n- Time/space trade-offs: O(n^2 k) time, O(n^2) space (reducible to O(nk))\n\n## Code Example\n\n```javascript\nfunction maxKSubarrays(A, k){\n  const n = A.length;\n  const pref = Array(n+1).fill(0);\n  for(let i=0;i<n;i++) pref[i+1] = pref[i] + A[i];\n  const V = Array.from({length:n}, ()=> Array(n).fill(0));\n  for(let l=0;l<n;l++){\n    let mn = Infinity;\n    for(let r=l;r<n;r++){\n      mn = Math.min(mn, A[r]);\n      const sum = pref[r+1]-pref[l];\n      V[l][r] = sum * mn;\n    }\n  }\n  const NEG = -1e18;\n  const dp = Array.from({length:n+1}, ()=> Array(k+1).fill(NEG));\n  const pre = Array.from({length:n+1}, ()=> Array(k+1).fill(-1));\n  dp[0][0] = 0;\n  for(let i=1;i<=n;i++) dp[i][0] = NEG;\n  for(let i=1;i<=n;i++){\n    for(let t=1;t<=k;t++){\n      dp[i][t] = dp[i-1][t];\n      pre[i][t] = pre[i-1][t];\n      for(let j=0;j<i;j++){\n        const val = dp[j][t-1] + V[j][i-1];\n        if(val > dp[i][t]){ dp[i][t] = val; pre[i][t] = j; }\n      }\n    }\n  }\n  let blocks = [];\n  let i = n, t = k;\n  while(t>0){\n    const j = pre[i][t];\n    blocks.push([j, i-1]);\n    i = j; t--;\n  }\n  blocks.reverse();\n  return { value: dp[n][k], blocks };\n}\n```\n\n## Follow-up Questions\n\n- How would you reduce memory to O(nk) with a streaming recomputation of V? \n- How would the approach adapt if k is large and n up to 2e5 (any pruning or heuristic)?","diagram":"flowchart TD\n  A[Subarray Start] --> B[Compute Sum]\n  B --> C[Compute Min]\n  C --> D[DP Transition]\n  D --> E[Record Endpoints]","difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T13:15:17.207Z","createdAt":"2026-01-24T13:15:17.207Z"},{"id":"q-679","question":"In a warehouse grid of size n x m, each cell has a traversal cost. You can move only right or down from (0,0) to (n-1,m-1). You have a one-time token to halve the cost of exactly one visited cell. Design an O(nm) DP to compute the minimum path cost after optimally using the discount, and describe the recurrences and a space-optimized implementation?","answer":"Maintain two DP arrays: best without using the discount (dp0) and best with the discount already used (dp1). For grid costs c[i][j], set:\ndp0[i][j] = c[i][j] + min(dp0[i-1][j], dp0[i][j-1]);\ndp1[i][j]","explanation":"## Why This Is Asked\nTests real DP design with an extra state (discount used) and careful recurrence.\n\n## Key Concepts\n- 2D DP with a binary state (discount used or not)\n- Transitions combine taking cost with/without discount\n- Space optimization using rolling arrays\n\n## Code Example\n```javascript\nfunction minCostWithDiscount(grid){\n  const n = grid.length, m = grid[0].length;\n  const INF = 1e15;\n  let dp0 = new Array(m).fill(INF);\n  let dp1 = new Array(m).fill(INF);\n  dp0[0] = grid[0][0];\n  dp1[0] = Math.floor(grid[0][0] / 2);\n  for (let j = 1; j < m; j++) {\n    dp0[j] = grid[0][j] + dp0[j-1];\n    dp1[j] = Math.min(grid[0][j] + dp1[j-1], Math.floor(grid[0][j]/2) + dp0[j-1]);\n  }\n  for (let i = 1; i < n; i++) {\n    dp0[0] += grid[i][0];\n    dp1[0] = Math.min(grid[i][0] + dp1[0], Math.floor(grid[i][0]/2) + dp0[0-1]);\n    for (let j = 1; j < m; j++) {\n      const v = grid[i][j];\n      dp1[j] = Math.min(v + Math.min(dp1[j], dp1[j-1]), Math.floor(v/2) + Math.min(dp0[j], dp0[j-1]));\n      dp0[j] = v + Math.min(dp0[j], dp0[j-1]);\n    }\n  }\n  return dp1[m-1];\n}\n```\n\n## Follow-up Questions\n- How would you support multiple discounts or varying discount values?\n- How does this adapt if diagonal moves are allowed or costs can be negative?","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Snap","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T15:57:04.021Z","createdAt":"2026-01-11T15:57:04.021Z"},{"id":"q-691","question":"You're planning a delivery route along a straight street of n blocks. At block i you can advance up to jumps[i] blocks (at least 1). How many distinct routes reach block n-1 from block 0? If unreachable, return 0. Propose a dynamic-programming approach with dp[i] as ways to reach i and outline its time/space complexity, edge cases, and a brief correctness justification. How would you implement it?","answer":"Use a 1D DP: dp[i] is number of ways to reach i. Initialize dp[0] = 1. For i from 0 to n-1, let maxJump = min(jumps[i], n-1-i); for s from 1 to maxJump, dp[i+s] = (dp[i+s] + dp[i]) % 1000000007. Retur","explanation":"## Why This Is Asked\nTests counting paths with variable step lengths using DP, a common interview pattern in operations and logistics contexts.\n\n## Key Concepts\n- 1D DP for path counting\n- Handling variable jump lengths\n- Modulo arithmetic for large counts\n\n## Code Example\n```javascript\nfunction countWays(jumps){\n  const n = jumps.length;\n  const MOD = 1000000007;\n  const dp = new Array(n).fill(0);\n  dp[0] = 1;\n  for(let i = 0; i < n; i++){\n    const maxJump = Math.min(jumps[i], n - 1 - i);\n    for(let s = 1; s <= maxJump; s++){\n      dp[i + s] = (dp[i + s] + dp[i]) % MOD;\n    }\n  }\n  return dp[n - 1] || 0;\n}\n```\n\n## Follow-up Questions\n- How would you optimize to O(n) time if maxJump can be large but jumps form a sliding window of contributions?\n- How would you adjust for different termination criteria or multiple destinations?","diagram":"flowchart TD\n  Start([Start]) --> Init[dp[0] = 1]\n  Init --> Loop[for i in 0..n-1]\n  Loop --> Update[dp[i+s] += dp[i] for s<=maxJump]\n  Update --> End([Return dp[n-1]])","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Meta","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T16:24:20.467Z","createdAt":"2026-01-11T16:24:20.467Z"},{"id":"q-693","question":"You're building a daily workout planner. Over n days, you can pick Light (L) or Heavy (H) workouts, with a cooldown: after a Heavy, you must skip the next two days (no workouts). Given integers n and r, how many length-n sequences contain exactly r Heavy workouts and satisfy the cooldown rule? Provide a DP formulation with state dp[i][c][t] (days processed, cooldown days left, heavies used) and outline time/space complexity, edge cases, and a brief correctness justification?","answer":"DP state: dp[i][c][t] = ways to schedule first i days with c cooldown days left and t heavies used. If c>0, dp[i+1][c-1][t] += dp[i][c][t]. If c==0, Light gives dp[i+1][0][t] += dp[i][0][t], Heavy (t<","explanation":"## Why This Is Asked\nTests modeling of a constrained scheduling problem with cooldowns and counting exact occurrences, a staple DP pattern.\n\n## Key Concepts\n- Multidimensional DP with state: day, cooldown, heavies used\n- Transition logic for cooldown and action choices\n- Edge cases: maximum possible heavies, r bounds, unreachable states\n\n## Code Example\n```javascript\n// Pseudo-implementation sketch for DP planning\n```\n\n## Follow-up Questions\n- How would you adapt if cooldowns varied by the number of consecutive heavies?\n- How would you optimize space further for large n?","diagram":"flowchart TD\n  Start[Start] --> A[Initialize dp[0][0][0]=1]\n  A --> B{i from 0 to n-1}\n  B --> C[If c>0, carry to i+1 with c-1]\n  B --> D[If c==0, add Light to i+1 with c=0, t]\n  B --> E[If c==0, add Heavy to i+1 with c=2, t+1 if t<r]\n  C --> End1[Aggregate to dp[i+1]]\n  D --> End2\n  E --> End3\n  End1 --> End\n  End2 --> End\n  End3 --> End","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Google","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T17:15:40.264Z","createdAt":"2026-01-11T17:15:40.264Z"},{"id":"q-6971","question":"You are given an array A of length n and an integer k. You must partition A into exactly k non-empty contiguous subarrays. For each subarray [l..r], score = number of distinct values present in A[l..r]. Return the maximum total score and the k-1 partition indices. Propose a DP: dp[i][t] = max over p in [t-1..i-1] of dp[p][t-1] + distinctCount(p+1, i). Include precomputation of distinct counts, base cases, and reconstruction. Explain time/space?","answer":"Precompute distinctCount for all subarray ranges (l, r) in O(n²) by iterating from each start index l and tracking unique values as end index r expands. DP formulation: dp[i][t] = max_{p=t-1..i-1} dp[p][t-1] + dist[p+1][i], with base case dp[i][1] = dist[1][i].","explanation":"## Why This Is Asked\nTests ability to handle partition DP with subarray distinct value counting; combines precomputation optimization with reconstruction techniques not covered in standard partition problems.\n\n## Key Concepts\n- Partition DP with subarray metrics\n- Precompute distinct counts (O(n²))\n- Reconstruction via parent pointers\n\n## Code Example\n```python\ndef max_distinct_partition(A, k):\n    n = len(A)\n    # Precompute distinct counts\n    dist = [[0]*(n+2) for _ in range(n+2)]\n    for l in range(1, n+1):\n        freq = {}\n        seen = 0\n        for r in range(l, n+1):\n            x = A[r-1]\n            if x not in freq:\n                freq[x] = 1\n                seen += 1\n            dist[l][r] = seen\n    \n    # DP with parent tracking\n    dp = [[-float('inf')]*(k+1) for _ in range(n+1)]\n    parent = [[-1]*(k+1) for _ in range(n+1)]\n    \n    # Base cases\n    for i in range(1, n+1):\n        dp[i][1] = dist[1][i]\n    \n    # Fill DP\n    for t in range(2, k+1):\n        for i in range(t, n+1):\n            for p in range(t-1, i):\n                val = dp[p][t-1] + dist[p+1][i]\n                if val > dp[i][t]:\n                    dp[i][t] = val\n                    parent[i][t] = p\n    \n    # Reconstruct partitions\n    partitions = []\n    i, t = n, k\n    while t > 1:\n        p = parent[i][t]\n        partitions.append(p)\n        i, t = p, t-1\n    partitions.reverse()\n    \n    return dp[n][k], partitions\n```\n\n## Time/Space Complexity\nTime: O(n² + n²k) = O(n²k) - O(n²) for precomputation, O(n²k) for DP\nSpace: O(n² + nk) - O(n²) for distinct counts, O(nk) for DP and parent pointers","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","LinkedIn","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T05:16:26.785Z","createdAt":"2026-01-25T02:50:26.796Z"},{"id":"q-703","question":"You're navigating a warehouse grid of size n x m. Each cell (i, j) has a risk value r[i][j] ≥ 0, where higher means less safe. You may move only right or down from (0,0) to (n-1,m-1). Devise a dynamic-programming solution to minimize the maximum risk encountered on the path (i.e., minimize max(r[i][j]) along the path). Define a suitable dp[i][j], give the recurrence and base cases, describe reconstruction of the path, and analyze time/space complexity. How would you handle blocked cells by setting r[i][j] = INF?","answer":"Proposed DP: define dp[i][j] as the minimum possible maximum risk along any path from (0,0) to (i,j). Recurrence: dp[i][j] = min( max(dp[i-1][j], r[i][j]), max(dp[i][j-1], r[i][j]) ). Base: dp[0][0] =","explanation":"## Why This Is Asked\nThis question tests DP on grids with a minimax objective, reconstruction, and practical edge handling (blocked cells).\n\n## Key Concepts\n- DP on 2D grid with a minimax recurrence\n- Path reconstruction via predecessor tracking\n- Space optimization opportunities (1D row/column DP)\n- INF handling for blockers\n\n## Code Example\n```javascript\nfunction minMaxRisk(r) {\n  const n = r.length, m = r[0].length;\n  const INF = Number.POSITIVE_INFINITY;\n  const dp = Array.from({length: n}, () => Array(m).fill(INF));\n  const from = Array.from({length: n}, () => Array(m).fill(-1));\n  dp[0][0] = r[0][0];\n  for (let j = 1; j < m; j++) { dp[0][j] = Math.max(dp[0][j-1], r[0][j]); from[0][j] = 0; }\n  for (let i = 1; i < n; i++) { dp[i][0] = Math.max(dp[i-1][0], r[i][0]); from[i][0] = 1; }\n  for (let i = 1; i < n; i++) {\n    for (let j = 1; j < m; j++) {\n      const up = Math.max(dp[i-1][j], r[i][j]);\n      const left = Math.max(dp[i][j-1], r[i][j]);\n      if (up <= left) { dp[i][j] = up; from[i][j] = 0; } else { dp[i][j] = left; from[i][j] = 1; }\n    }\n  }\n  return {minMaxRisk: dp[n-1][m-1], parent: from};\n}\n```\n\n## Follow-up Questions\n- How would you extend to allow diagonal moves?\n- How would you adapt for multiple starting points or 3D grids?","diagram":"flowchart TD\n  A[Start] --> B[Compute dp per cell]\n  B --> C[Store predecessor for reconstruction]\n  C --> D[Reach (n-1,m-1)]\n  D --> E[Return minimal max risk]","difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["NVIDIA","Scale Ai","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T18:26:59.828Z","createdAt":"2026-01-11T18:26:59.828Z"},{"id":"q-7039","question":"You're given an array A of length n representing daily demand forecasts. Partition the array into exactly k non-empty, non-overlapping contiguous campaigns. For a block [l..r], its value is (r-l+1) * max(A[l..r]) - sum(A[l..r]). Return the maximum total value and the k blocks (endpoints). Propose a DP formulation with dp[i][t] representing max value using first i days and t campaigns, including transitions and reconstruction?","answer":"State dp[i][t] as the best value for first i days with t campaigns; precompute blockVal(j,i) = (i-j+1) * max(A[j..i]) - (pref[i]-pref[j-1]). Then dp[i][t] = max(dp[i-1][t], max_{1<=j<=i} dp[j-1][t-1] ","explanation":"## Why This Is Asked\n\nTests ability to design a DP over partitions where block value depends on both max and sum, plus reconstruction of segments. Encourages discussion on precomputation of range maxima and efficient transitions.\n\n## Key Concepts\n\n- DP over partitioning with fixed number of segments\n- Block value using max and sum requires precomputation\n- Path reconstruction for exact endpoints\n\n## Code Example\n\n```javascript\nfunction maxBlockPartition(A, k){\n  const n=A.length;\n  const pref=new Array(n+1).fill(0);\n  for(let i=0;i<n;i++) pref[i+1]=pref[i]+A[i];\n  // precompute max for all subarrays\n  const maxSub=Array.from({length:n},()=>Array(n).fill(0));\n  for(let i=0;i<n;i++){ let m=A[i]; for(let j=i;j<n;j++){ m=Math.max(m,A[j]); maxSub[i][j]=m; } }\n  const blockVal=(l,r)=> (r-l+1)*maxSub[l][r] - (pref[r+1]-pref[l]);\n  const dp=Array.from({length:n+1},()=>Array(k+1).fill(-Infinity));\n  const par=Array.from({length:n+1},()=>Array(k+1).fill(null));\n  dp[0][0]=0;\n  for(let i=1;i<=n;i++){\n    for(let t=1;t<=k;t++){\n      dp[i][t]=dp[i-1][t];\n      par[i][t]=[i-1,t];\n      for(let s=1;s<=i;s++){\n        const val=dp[s-1][t-1] + blockVal(s-1,i-1);\n        if(val>dp[i][t]){ dp[i][t]=val; par[i][t]=[s-1,t-1]; }\n      }\n    }\n  }\n  // reconstruction would backtrack from (n,k) using par\n  return {best: dp[n][k], par};\n}\n```\n\n## Follow-up Questions\n\n- How would you optimize to avoid O(n^2 k) in practice?  \n- How does reconstruction behave with negative block values?","diagram":"flowchart TD\n  A[Input: A, n, k] --> B[Precompute maxSub and pref]\n  B --> C[DP transitions: dp[i][t] = max(dp[i-1][t], max_j dp[j-1][t-1] + blockVal(j,i))]\n  C --> D[Backtrack to recover k blocks]\n  D --> E[Return endpoints and total value]","difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Stripe","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T06:59:27.885Z","createdAt":"2026-01-25T06:59:27.885Z"},{"id":"q-7062","question":"You're given a DAG with N nodes and M weighted edges, a start node s, an end node t, and an integer K. Find the maximum total weight of a path from s to t that uses exactly K edges. Return the weight and the path (node sequence). Propose a DP formulation with states DP[v][e], recurrences, base cases, reconstruction, and discuss time/space?","answer":"Let DP[v][e] be max weight of a path from s to v with exactly e edges; initialize DP[s][0]=0 and others to -INF. For each edge u->v with weight w, update DP[v][e] = max(DP[v][e], DP[u][e-1]+w) for e=1","explanation":"## Why This Is Asked\nTests ability to design DP over a graph with an exact-edge constraint and reconstruction. Requires handling topological order and unreachable cases.\n\n## Key Concepts\n- DP on DAG with exact edges\n- Path reconstruction via parent pointers\n- Time/space tradeoffs: O(K*M) time, O(N*K) space\n\n## Code Example\n```javascript\nfunction maxPathKEdges(N, edges, s, t, K) {\n  // Build adjacency, topologically sort, then compute DP[v][e]\n  // Initialize DP with -Infinity; DP[s][0] = 0\n  // For each edge u -> v with weight w, for e from 1 to K: DP[v][e] = max(DP[v][e], DP[u][e-1] + w)\n  // Keep parent[v][e] for reconstruction\n  // Return DP[t][K] and reconstruct path\n}\n```\n\n## Follow-up Questions\n- How to reduce memory to O(N) with rolling arrays?\n- How to handle multiple optimal paths during reconstruction?","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Plaid","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T07:43:43.062Z","createdAt":"2026-01-25T07:43:43.062Z"},{"id":"q-7118","question":"You're given a rooted tree with N nodes, each node v has weight w[v]. Choose exactly K pairwise-disjoint connected subtrees (each subtree non-empty) to maximize the sum of weights of all covered nodes. Return the maximum total weight and the K subtrees' roots. Provide a DP formulation with per-node states, recurrences, and a reconstruction plan?","answer":"Use a two‑state tree DP. For each node v, maintain: dp0[v][t]: max sum in v's subtree with t closed components, v not in any chosen component. dp1[v][t]: max sum with t components where a component co","explanation":"## Why This Is Asked\nTests tree DP with multi-state knapsack, requiring reconstruction of K roots.\n\n## Key Concepts\n- Tree DP with open/closed components\n- Knapsack-like merge across children\n- Explicit reconstruction of components\n\n## Code Example\n```javascript\nfunction dfs(v, p){\n  dp0[v] = Array(K+1).fill(-INF);\n  dp1[v] = Array(K+1).fill(-INF);\n  dp0[v][0] = 0;\n  dp1[v][0] = w[v];\n  for (let u of children[v]){\n    dfs(u, v);\n    // merge dp states (sketch)\n  }\n}\n```\n\n## Follow-up Questions\n- How to optimize space to O(nK)?\n- How to reconstruct the K roots from the DP tables?","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T09:45:34.979Z","createdAt":"2026-01-25T09:45:34.979Z"},{"id":"q-7135","question":"You're given an array A of length n and an integer k (1 ≤ k ≤ n). Partition A into exactly k non-empty, contiguous segments. Define cost(l, r) = max(A[l..r]) - min(A[l..r]). Return the minimum total cost achievable and the k segment endpoints (start and end indices for each segment). Propose a dynamic programming formulation with appropriate states, recurrences, base cases, and reconstruction plan; discuss time and space complexity and possible optimizations?","answer":"Let cost[l][r] = max(A[l..r]) - min(A[l..r]) precomputed in O(n^2). Define dp[i][t] = min cost to partition A[1..i] into t non-empty segments. Recurrence: dp[i][t] = min_{l from t-1 to i-1} dp[l][t-1]","explanation":"## Why This Is Asked\nExplores a fresh DP angle: exact partition into k segments with a segment cost defined by range, forcing precomputation and backtracking to recover segment boundaries.\n\n## Key Concepts\n- Range-based segment cost (max-min)\n- Exact partition DP: dp[i][t]\n- Precomputation of cost[l][r]\n- Backtracking reconstruction\n\n## Code Example\n```javascript\n// pseudocode for core DP (not complete):\nfor i in 1..n:\n  dp[i][1] = cost[1][i]\nfor t in 2..k:\n  for i in t..n:\n    dp[i][t] = min_{l=t-1..i-1} dp[l][t-1] + cost[l+1][i]\n    par[i][t] = argmin\n```\n\n## Follow-up Questions\n- Can you optimize to O(nk) with divide-and-conquer if cost satisfies quadrangle inequality?\n- How would you adapt for 0/1-based indexing and streaming inputs?","diagram":"flowchart TD\n  A[Partitioning DP] --> B[Precompute cost]\n  B --> C[Compute dp[i][t]]\n  C --> D[Backtrack boundaries]\n  D --> E[Return result]","difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Meta","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T10:39:12.001Z","createdAt":"2026-01-25T10:39:12.001Z"},{"id":"q-716","question":"You're building a text formatter. Given a list of word lengths L = [l1, l2, ..., ln] and a maximum line width W, wrap the words into lines so that all lines except the last incur a penalty of (W - usedWidth)^2, where usedWidth = sum of word lengths on the line plus spaces between words. The last line has 0 penalty. Propose a dynamic programming solution with dp[i] representing the minimum penalty for words i..n-1, specify the recurrence, reconstruction method, and time/space complexity. How would you implement it?","answer":"DP on prefixes: dp[i] = minimum penalty for words i..n-1, with dp[n] = 0. For each i, extend line to j>=i; width = sum(len[i..j]) + (j - i); if width <= W then cost = (W - width)^2 + dp[j+1]. Take min","explanation":"## Why This Is Asked\\nThis gauges ability to cast a line-wrapping task into a clear 1D DP with a non-linear line cost and a reconstruction path. It tests handling of last-line quirks and feasibility checks.\\n\\n## Key Concepts\\n- 1D DP over word indices; dp[n] = 0 as base.\\n- Prefix sums to compute line width in O(1) per extension.\\n- Cost function uses squared unused space; last line excluded.\\n- Reconstruct solution via next indices.\\n- Time: O(n^2); Space: O(n).\\n\\n## Code Example\\n```javascript\\nfunction minWrap(words, W) {\\n  const n = words.length;\\n  const pref = new Array(n + 1).fill(0);\\n  for (let i = 0; i < n; i++) pref[i + 1] = pref[i] + words[i];\\n  const dp = new Array(n + 1).fill(Infinity);\\n  const nxt = new Array(n).fill(-1);\\n  dp[n] = 0;\\n  for (let i = n - 1; i >= 0; i--) {\\n    for (let j = i; j < n; j++) {\\n      const width = (pref[j + 1] - pref[i]) + (j - i);\\n      if (width <= W) {\\n        const cost = (W - width) * (W - width) + dp[j + 1];\\n        if (cost < dp[i]) { dp[i] = cost; nxt[i] = j + 1; }\\n      } else break;\\n    }\\n  }\\n  // reconstruction omitted for brevity\\n  return { minPenalty: dp[0], next: nxt };\\n}\\n```\\n\\n## Follow-up Questions\\n- How would you modify to penalize the last line as well?\\n- How would you incorporate tie-breaking to prefer fewer lines?\\n","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","DoorDash","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T19:18:59.844Z","createdAt":"2026-01-11T19:18:59.844Z"},{"id":"q-7174","question":"You're given an array A of length n with non-negative integers. You must select exactly k non-overlapping, non-empty subarrays in order (i1 <= j1 < i2 <= j2 < ... < ik <= n). The value of a subarray [l..r] is sum(A[l..r]) - max(A[l..r]). Return the maximum total value and the endpoints (l, r) of each of the k subarrays. Propose a DP formulation with dp[i][t] = max total value using first i elements partitioned into t subarrays, where the t-th subarray ends at i, including recurrence, base cases, reconstruction, and time/space discussion?","answer":"Define dp[i][t] as the max value using first i elements with t subarrays, where the t-th ends at i. Recurrence: dp[i][t] = max_{l=t..i} dp[l-1][t-1] + (pref[i]-pref[l-1]) - maxVal(l,i). Base: dp[i][1]","explanation":"## Why This Is Asked\nNew angle on subarray optimization mixing sum and max, testing DP over partitions with a per-end constraint and a reconstruction path. It challenges handling max(l..i) inside a max over l and tracking predecessor for exact k blocks. It also probes time/space trade-offs and potential RMQ optimizations.\n\n## Key Concepts\n- DP over partitions of array\n- Subarray value uses (sum - max)\n- Reconstruction of k blocks, base cases\n\n## Code Example\n```javascript\nfunction maxValueKSubarrays(A, k) {\n  const n = A.length;\n  const pref = new Array(n+1).fill(0);\n  for (let i=1; i<=n; i++) pref[i] = pref[i-1] + A[i-1];\n  // dp[i][t]: max value for first i, with t blocks, t-th ends at i\n  // naive O(n^2 k) implementation omitted\n  return null;\n}\n```\n\n## Follow-up Questions\n- How would you optimize maxVal(l,i) queries, and what would be the resulting time complexity?\n- How would you adapt if subarray value were sum - min instead of max?","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Goldman Sachs"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T12:58:40.932Z","createdAt":"2026-01-25T12:58:40.932Z"},{"id":"q-718","question":"You're given an array A[1..n] and an integer k. Partition into exactly k contiguous segments. The cost of a segment [t+1..i] is (sum(A[t+1..i]))^2. Return the minimum total cost and the partition indices. Propose DP: P as prefix sums, dp[i][j] = min_{t in [j-1..i-1]} dp[t][j-1] + (P[i]-P[t])^2, with base dp[0][0]=0. Explain reconstruction and discuss naive vs. optimized time, space, and edge cases?","answer":"DP formulation: P is prefix sums, dp[i][j] = min_{t in [j-1..i-1]} dp[t][j-1] + (P[i]-P[t])^2, with dp[0][0]=0; base dp[i][1] = P[i]^2. Reconstruct via argmin cuts. Naive O(n^2 k); with Divide-and-Con","explanation":"## Why This Is Asked\n\nTests DP over partitioning with a convex cost and requires reconstruction, while prompting awareness of optimizations for large n.\n\n## Key Concepts\n\n- DP on partitioning\n- Prefix sums\n- Cost convexity and optimization\n- Reconstruction of cuts\n\n## Code Example\n\n```javascript\n// skeleton: compute P, fill dp with divide-and-conquer optimization template\n```\n\n## Follow-up Questions\n\n- How would negative numbers affect correctness?\n- How would you implement the optimization in a streaming setting?","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T20:21:28.699Z","createdAt":"2026-01-11T20:21:28.699Z"},{"id":"q-7234","question":"You're given a string s of length n (lowercase) and an integer k. Partition s into exactly k non-empty contiguous substrings. Each substring's value is the number of distinct characters within it. Return the maximum total value and the substring endpoints. Provide a DP formulation and reconstruction approach?","answer":"Use DP over i (prefix length) and t (segments). Precompute distinctCount(l,r) for all substrings in O(n^2) by expanding right boundary with a 26-letter freq. Then dp[i][t] = max_{p from t-1 to i-1} dp","explanation":"## Why This Is Asked\nTests a partition DP where segment values depend on a non-trivial per-substring metric (distinct counts). It extends simple sum-based DP to a more nuanced local score.\n\n## Key Concepts\n- DP over i and t to build up k segments\n- Precompute distinctCount(l,r) for all substrings\n- Backpointers to recover exact endpoints\n\n## Code Example\n```javascript\nfunction maxDistinctSegments(s, k) {\n  const n = s.length;\n  const cnt = Array.from({length: n}, () => Array(n).fill(0));\n  for (let L = 0; L < n; L++) {\n    const freq = new Array(26).fill(0);\n    let d = 0;\n    for (let R = L; R < n; R++) {\n      const idx = s.charCodeAt(R) - 97;\n      if (freq[idx]++ === 0) d++;\n      cnt[L][R] = d;\n    }\n  }\n  const dp = Array.from({length: n+1}, () => Array(k+1).fill(-Infinity));\n  const par = Array.from({length: n+1}, () => Array(k+1).fill(-1));\n  dp[0][0] = 0;\n  for (let i = 1; i <= n; i++) {\n    for (let t = 1; t <= Math.min(i, k); t++) {\n      for (let p = t-1; p <= i-1; p++) {\n        const val = dp[p][t-1] + cnt[p][i-1];\n        if (val > dp[i][t]) { dp[i][t] = val; par[i][t] = p; }\n      }\n    }\n  }\n  // reconstruct endpoints from par\n}\n```\n\n## Follow-up Questions\n- How to reduce memory to O(nk) while keeping reconstruction?\n- How adapt to larger alphabets or different segment metrics?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Goldman Sachs","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T14:48:57.434Z","createdAt":"2026-01-25T14:48:57.434Z"},{"id":"q-7255","question":"You're given an array A[1..n] of daily potential revenue numbers. You may select exactly k non-empty, non-overlapping contiguous windows [l_j..r_j] for promotions, in order. Each window yields revenue sum(A[l_j..r_j]) * (r_j - l_j + 1). Return the maximum total revenue and the endpoints of the k windows. Propose a DP formulation with dp[i][t] representing the max revenue for first i days using t windows, the recurrence, base cases, and a reconstruction plan?","answer":"Use S[i] = sum(A[1..i]). Define dp[i][t] as max revenue for first i days using t blocks. If last block is (p+1..i), value = dp[p][t-1] + (S[i]-S[p])*(i-p). Then dp[i][t] = max over p in [t-1..i-1]. Ba","explanation":"## Why This Is Asked\nTests the ability to model partitioning with a non-linear block value, a common DP pattern in beginner interviews. Requires prefix sums for O(1) block sums, a clear state definition over prefix length and blocks, and backtracking to output endpoints.\n\n## Key Concepts\n- DP on partitions with exact k blocks\n- Prefix sums for subarray sums\n- State: dp[i][t], parent pointers for reconstruction\n\n## Code Example\n```javascript\nfunction maxRevenue(A, k) {\n  const n = A.length;\n  const S = Array(n+1).fill(0);\n  for (let i=1;i<=n;i++) S[i] = S[i-1] + A[i-1];\n  const dp = Array.from({length:n+1}, ()=>Array(k+1).fill(-Infinity));\n  const par = Array.from({length:n+1}, ()=>Array(k+1).fill(-1));\n  for (let i=1;i<=n;i++) dp[i][1] = S[i]*i;\n  for (let t=2;t<=k;t++) {\n    for (let i=t;i<=n;i++) {\n      for (let p=t-1;p<=i-1;p++) {\n        const val = dp[p][t-1] + (S[i]-S[p])*(i-p);\n        if (val > dp[i][t]) { dp[i][t] = val; par[i][t] = p; }\n      }\n    }\n  }\n  // reconstruction\n  let i=n, t=k; const ends=[];\n  while (t>0) { const p = par[i][t]; ends.push([p+1, i]); i = p; t--; }\n  ends.reverse();\n  return {value: dp[n][k], windows: ends};\n}\n```\n\n## Follow-up Questions\n- How would you optimize to O(nk) time using a trick for monotone optima?\n- How would you adapt if windows could overlap or if k is variable?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T15:34:53.407Z","createdAt":"2026-01-25T15:34:53.407Z"},{"id":"q-731","question":"You're given an array A of length n with non-negative integers representing daily story points. You must partition the days into consecutive weeks, each containing 2–7 days. The cost of a week is (sum of that week's points − W)^2 where W is a fixed target. Return the minimum total cost to cover all days or INF if impossible. Propose a DP with dp[i] as min cost for first i days; dp[i] = min_{k=2..7, i-k>=0} dp[i-k] + (sum(i-k+1..i) − W)^2, using prefix sums for O(1) range sums. Reconstruct weeks and analyze time/space?","answer":"dp[i] = min over k in [2,7] of dp[i-k] + (pref[i]-pref[i-k] - W)^2, using pref for O(1) range sums. Base dp[0]=0; dp[i]=INF for invalid i. Reconstruct weeks via a parent pointer. Time: O(7n). Space: O","explanation":"## Why This Is Asked\nRealistic sprint planning with bounded weekly windows; tests ability to form and optimize DP with small constant branching and reconstruction.\n\n## Key Concepts\n- Prefix sums for fast range totals\n- DP with fixed window length (2..7)\n- Path reconstruction via parent pointers\n- Time O(n) with a small constant, Space O(n)\n\n## Code Example\n```javascript\nfunction minWeeklyCost(A, W) {\n  const n = A.length;\n  const pref = new Array(n+1).fill(0);\n  for (let i=1;i<=n;i++) pref[i] = pref[i-1] + A[i-1];\n  const INF = 1e18;\n  const dp = new Array(n+1).fill(INF);\n  const par = new Array(n+1).fill(-1);\n  dp[0] = 0;\n  for (let i=2; i<=n; i++) {\n    for (let k=2; k<=7; k++) {\n      if (i-k < 0) break;\n      const sum = pref[i] - pref[i-k];\n      const cost = dp[i-k] + (sum - W)*(sum - W);\n      if (cost < dp[i]) { dp[i] = cost; par[i] = i-k; }\n    }\n  }\n  // reconstruction would follow using par[]\n  return {cost: dp[n], prev: par[n]};\n}\n```\n\n## Follow-up Questions\n- How would you handle negative A values if allowed? \n- What changes if weeks must start on a specific weekday?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Salesforce","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T21:19:28.014Z","createdAt":"2026-01-11T21:19:28.014Z"},{"id":"q-7315","question":"Partition string s of length n into exactly k non-empty contiguous substrings, where each substring's cost is the number of distinct characters it contains; what is the minimum total cost and the cut positions?","answer":"Partition string s of length n into exactly k non-empty contiguous substrings. Each substring cost is the number of distinct characters it contains. Use DP: dp[i][t] = min_{p in [t-1..i-1]} dp[p][t-1]","explanation":"## Why This Is Asked\nA new DP partitioning angle tests meticulous state definition, reconstruction, and a practical distinct-count helper.\n\n## Key Concepts\n- DP over partitions; substring distinct counts; reconstruction. \n- Complexity considerations and basic optimizations for small alphabets.\n\n## Code Example\n```python\ndef min_cost(s,k):\n    n=len(s)\n    INF=10**9\n    dp=[[INF]*(k+1) for _ in range(n+1)]\n    parent=[[-1]*(k+1) for _ in range(n+1)]\n    dp[0][0]=0\n    for i in range(1,n+1):\n        for t in range(1,min(k,i)+1):\n            distinct=0\n            seen=[0]*26\n            for p in range(i-1,t-2,-1):\n                idx=ord(s[p])-97\n                if not seen[idx]:\n                    seen[idx]=1\n                    distinct+=1\n                if dp[p][t-1]+distinct < dp[i][t]:\n                    dp[i][t]=dp[p][t-1]+distinct\n                    parent[i][t]=p\n    # reconstruction omitted for brevity\n```\n\n## Follow-up Questions\n- How would you optimize to O(n^2) or O(nk) in practice for larger alphabets?\n- How would you modify if substrings must be of bounded length?","diagram":"flowchart TD\n  A[Start] --> B[DP state dp[i][t]]\n  B --> C[For each i,t iterate p]\n  C --> D[Update distinct(s[p+1..i])] \n  D --> E[Compute min and set parent]\n  E --> F[Reconstruct cut indices]","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","LinkedIn","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T17:48:08.025Z","createdAt":"2026-01-25T17:48:08.025Z"},{"id":"q-7327","question":"You're given an array A of length n and a non-negative daily cost c. You may schedule up to k non-overlapping campaigns, each campaign is a contiguous segment [l..r], and its profit equals sum(A[l..r]) - c*(r-l+1). Return the maximum total profit and the segments used. Propose a DP formulation and a reconstruction plan?","answer":"Transform to B[i] = A[i] - c and compute up to k non-overlapping subarrays with DP: end[i][t] = max(end[i-1][t] + B[i], best[i-1][t-1] + B[i]); best[i][t] = max(best[i-1][t], end[i][t]). Answer is max","explanation":"## Why This Is Asked\n\nTests ability to model budgeted multi-interval optimization where a fixed daily cost incentivizes shorter campaigns. Requires stateful DP with reconstruction.\n\n## Key Concepts\n\n- Up to k non-overlapping subarrays\n- Per-element cost transformation: B[i] = A[i] - c\n- DP states: end[i][t], best[i][t]\n- Recurrences: end[i][t] = max(end[i-1][t] + B[i], best[i-1][t-1] + B[i]); best[i][t] = max(best[i-1][t], end[i][t])\n- Reconstruction via backpointers\n\n## Code Example\n\n```javascript\nfunction maxKSubarraysWithCost(A, k, c) {\n  const n = A.length;\n  const B = A.map(x => x - c);\n  const end = Array.from({length: n+1}, () => Array(k+1).fill(-Infinity));\n  const best = Array.from({length: n+1}, () => Array(k+1).fill(-Infinity));\n  const prevEnd = Array.from({length: n+1}, () => Array(k+1).fill(null));\n\n  best[0][0] = 0;\n  for (let i = 1; i <= n; i++) {\n    end[i][0] = -Infinity;\n    best[i][0] = 0;\n    for (let t = 1; t <= k; t++) {\n      const extend = end[i-1][t] + B[i-1];\n      const startNew = best[i-1][t-1] + B[i-1];\n      end[i][t] = Math.max(extend, startNew);\n      if (best[i-1][t] >= end[i][t]) {\n        best[i][t] = best[i-1][t];\n      } else {\n        best[i][t] = end[i][t];\n        prevEnd[i][t] = true;\n      }\n    }\n  }\n\n  let bestVal = -Infinity, bestT = 0;\n  for (let t = 0; t <= k; t++) {\n    if (best[n][t] > bestVal) { bestVal = best[n][t]; bestT = t; }\n  }\n  return {profit: bestVal, segments: []};\n}\n```\n\n## Follow-up Questions\n\n- How would reconstruction of exact segments be implemented with explicit pointers?\n- How would you handle varying campaign setup costs or penalties per segment length?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","LinkedIn","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T18:50:02.747Z","createdAt":"2026-01-25T18:50:02.747Z"},{"id":"q-736","question":"You're given an n x m grid. Each cell (i, j) has a color c[i][j] in [0, C-1] and a non-negative cost w[i][j]. Start at (0,0) and move to (n-1,m-1) with only right or down moves. You must visit at least one cell of every color that appears in the grid along your path. Return the minimum total cost to do so, or -1 if impossible. Describe a DP using dp[i][j][mask] where mask tracks visited colors; explain base cases, transitions from top/left, how to reconstruct the path, and complexity?","answer":"dp[i][j][mask] = min cost to reach (i,j) with colors mask; colorBit = 1<<c[i][j]. Only masks with (mask & colorBit) != 0 are valid. From top/left you may keep mask or use mask ^ colorBit to reflect co","explanation":"## Why This Is Asked\n\nTests DP with bitmask over colors along a grid path, forcing a nontrivial state and reconstruction.\n\n## Key Concepts\n- DP on Grid\n- Bitmask state compression\n- Transition handling when color is collected here vs earlier\n- Path reconstruction\n\n## Code Example\n\n```javascript\n// high-level outline for dp[i][j][mask]\n```\n\n## Follow-up Questions\n- How to scale when C is large (e.g., >20)?\n- How would you reconstruct the path from the dp table?","diagram":"flowchart TD\n  S(Start) --> A[dp[i][j][mask]]\n  A --> B{from top/left}\n  B --> C[dp[i-1][j][mask]]\n  B --> D[dp[i][j-1][mask]]\n  A --> E[compute min]\n  E --> F[store dp[i][j][mask]]","difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Netflix","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T22:19:51.690Z","createdAt":"2026-01-11T22:19:51.690Z"},{"id":"q-7399","question":"Given an array A of length n and an integer k, select exactly k non-empty contiguous subarrays such that no two are adjacent (there is at least one index between blocks). For each block [l..r], its value is max(A[l..r]). Return the maximum total value and the endpoints of the k blocks. Propose a DP formulation with dp[i][t] representing the best value using first i elements with t blocks, define the transition to enforce the required gap, include reconstruction pointers, and discuss time and space?","answer":"Use dynamic programming with dp[i][t] representing the maximum total value achievable using the first i elements with exactly t non-adjacent blocks. For each position i, we have two options: either skip element i, yielding dp[i-1][t], or end a block at position i starting at some position s ≤ i-2 (enforcing the required gap), giving max(A[s..i]) + dp[s-2][t-1]. The transition ensures blocks remain non-adjacent by requiring at least one index between them.","explanation":"## Why This Is Asked\nThis problem tests a sophisticated dynamic programming variant where the non-adjacency constraint introduces complexity beyond standard interval selection problems. It requires careful state design and transition logic to maintain separation between blocks.\n\n## Key Concepts\n- Dynamic programming with separation constraints between selected intervals\n- Efficient computation of range maxima for subarray value calculation\n- Backpointer implementation for reconstructing optimal block endpoints\n- Time-space trade-off analysis: O(n²k) time complexity with O(nk) space when using precomputed range maximum queries\n\n## Code Example\n```javascript\nfunction maxBlocks(A, k) {\n  const n = A.length;\n  const dp = Array(n+1).fill().map(() => Array(k+1).fill(-Infinity));\n  const prev = Array(n+1).fill().map(() => Array(k+1).fill(-1));\n  \n  // Precompute range maxima\n  const rangeMax = Array(n).fill().map(() => Array(n).fill(0));\n  for (let i = 0; i < n; i++) {\n    let currentMax = A[i];\n    for (let j = i; j < n; j++) {\n      currentMax = Math.max(currentMax, A[j]);\n      rangeMax[i][j] = currentMax;\n    }\n  }\n  \n  // Base case: 0 blocks\n  for (let i = 0; i <= n; i++) dp[i][0] = 0;\n  \n  // Fill DP table\n  for (let i = 1; i <= n; i++) {\n    for (let t = 1; t <= k; t++) {\n      // Skip i\n      if (dp[i-1][t] > dp[i][t]) {\n        dp[i][t] = dp[i-1][t];\n      }\n      \n      // End block at i\n      for (let s = 1; s <= i-1; s++) {\n        const prevIdx = s-2 >= 0 ? s-2 : 0;\n        if (dp[prevIdx][t-1] !== -Infinity) {\n          const val = rangeMax[s-1][i-1] + dp[prevIdx][t-1];\n          if (val > dp[i][t]) {\n            dp[i][t] = val;\n            prev[i][t] = s-1;\n          }\n        }\n      }\n    }\n  }\n  \n  return { maxValue: dp[n][k], reconstruct: () => reconstructBlocks(prev, n, k) };\n}\n```\n\n## Follow-up Questions\n- How can we optimize the time complexity to O(nk) using a monotonic queue or segment tree structure?\n- How does the solution adapt to different indexing conventions (1-based vs 0-based) and handle edge cases where n < 2k-1?\n- What modifications are needed if we allow adjacent blocks or change the objective function?","diagram":"flowchart TD\n  A[dp[i][t]] --> B[End last block at i with s <= i-2]\n  B --> C[max(A[s..i])]\n  C --> D[dp[s-2][t-1]]\n  A --> E[Skip i: dp[i-1][t]]","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Scale Ai","Snap","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T05:15:34.772Z","createdAt":"2026-01-25T21:36:12.509Z"},{"id":"q-743","question":"You're given a list of n task durations L. Partition the tasks into consecutive days (each day at least one task); the cost of a day is the maximum duration on that day. Devise a DP to minimize the total cost across all days. Define dp[i] as the minimum cost for the first i tasks, provide the recurrence, reconstruction method, and complexity. How would you implement it?","answer":"We partition tasks into days; day cost is the maximum duration on that day. Let dp[0]=0 and for i from 1..n, dp[i]=min_{1<=k<=i}(dp[i-k]+max(L[i-k..i-1])); track cut[i]=k to reconstruct day boundaries","explanation":"## Why This Is Asked\nScheduling perspective: minimize peak workload across days; the DP is a straightforward partition DP with a range max cost. It tests understanding of maintaining running max within inner loop and reconstruction.\n\n## Key Concepts\n- DP over prefixes\n- Range max within an inner loop\n- Path reconstruction via cut[]\n- Edge cases: empty input, large n, identical durations\n\n## Code Example\n```javascript\nfunction minCostPartition(L){\n  const n=L.length;\n  const dp=new Array(n+1).fill(Infinity);\n  const cut=new Array(n+1).fill(0);\n  dp[0]=0;\n  for(let i=1;i<=n;i++){\n    let curMax=0;\n    for(let k=1;k<=i;k++){\n      curMax = Math.max(curMax, L[i-k]);\n      const val = dp[i-k] + curMax;\n      if(val < dp[i]){ dp[i] = val; cut[i] = k; }\n    }\n  }\n  const days=[];\n  let i=n;\n  while(i>0){\n    const k=cut[i];\n    days.push(L.slice(i-k, i));\n    i -= k;\n  }\n  days.reverse();\n  return {cost: dp[n], days};\n}\n```\n\n## Follow-up Questions\n- How would you adapt for a 2D grid of tasks with row/day semantics?\n- Can you optimize the inner loop to O(n) using a data structure for range max?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Slack","Stripe","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T23:18:27.166Z","createdAt":"2026-01-11T23:18:27.166Z"},{"id":"q-7519","question":"You're given an array A of length n of temperatures. You must partition into exactly k non-empty contiguous segments. The cost of a segment [l..r] is (max(A[l..r]) - min(A[l..r])) * (r-l+1). Return the minimum total cost and the partition endpoints. Propose a DP formulation with dp[i][t] = min_{p in [t-1..i-1]} dp[p][t-1] + (range(p+1,i)) * (i-p). Include base cases and reconstruction; discuss time/space?","answer":"Precompute max and min for all subarrays: maxv[l][r], minv[l][r]. DP: base dp[i][1] = (maxv[0][i-1]-minv[0][i-1]) * i. For t>1, dp[i][t] = min_{p in [t-1..i-1]} dp[p][t-1] + (maxv[p+1][i-1]-minv[p+1][","explanation":"## Why This Is Asked\nTests partition DP with a subarray range cost, requiring precomputation of subarray extrema and careful reconstruction. It adds a different objective than prior questions by using (max-min) rather than a function of endpoints or a fixed multiplier. \n\n## Key Concepts\n- DP over partitions with exact-k segments\n- Subarray range queries (max-min) via precomputation\n- Path reconstruction from parent pointers\n- Time/space trade-offs for small to mid-size n\n\n## Code Example\n```javascript\nfunction minCostPartition(A, k) {\n  const n = A.length;\n  const maxv = Array.from({length: n}, () => Array(n).fill(0));\n  const minv = Array.from({length: n}, () => Array(n).fill(0));\n  for (let i = 0; i < n; i++) {\n    maxv[i][i] = A[i];\n    minv[i][i] = A[i];\n    for (let j = i + 1; j < n; j++) {\n      maxv[i][j] = Math.max(maxv[i][j-1], A[j]);\n      minv[i][j] = Math.min(minv[i][j-1], A[j]);\n    }\n  }\n  const INF = 1e18;\n  const dp = Array.from({length: n+1}, () => Array(k+1).fill(INF));\n  const par = Array.from({length: n+1}, () => Array(k+1).fill(-1));\n  dp[0][0] = 0;\n  for (let i = 1; i <= n; i++) dp[i][1] = (maxv[0][i-1]-minv[0][i-1]) * i, par[i][1] = 0;\n  for (let t = 2; t <= k; t++) {\n    for (let i = t; i <= n; i++) {\n      for (let p = t-1; p <= i-1; p++) {\n        const cost = (maxv[p][i-1]-minv[p][i-1]) * (i-p);\n        if (dp[p][t-1] + cost < dp[i][t]) {\n          dp[i][t] = dp[p][t-1] + cost;\n          par[i][t] = p;\n        }\n      }\n    }\n  }\n  let idx = n, rem = k, cuts = [];\n  while (rem > 0) {\n    const p = par[idx][rem];\n    cuts.push([p, idx-1]);\n    idx = p; rem--;\n  }\n  cuts.reverse();\n  return {cost: dp[n][k], blocks: cuts};\n}\n```\n","diagram":"flowchart TD\n  A[Start] --> B[Precompute max/min ranges]\n  B --> C[DP over i and t]\n  C --> D[Reconstruct partitions]\n  D --> E[Return result]","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Hugging Face","LinkedIn"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T05:44:05.254Z","createdAt":"2026-01-26T05:44:05.254Z"},{"id":"q-7532","question":"You're given an array A of length n and an integer k. You may select exactly k non-empty, non-overlapping subarrays in increasing order. Each subarray's value is the sum of its elements. Return the maximum total sum and the endpoints of the k subarrays. Propose a DP formulation with dp[i][t] representing the best sum using the first i elements with t blocks, the transitions, base cases, and how to reconstruct the endpoints; discuss time and space?","answer":"Let pref be prefix sums. DP: dp[i][t] = max sum using first i elements with exactly t blocks, either skip i or end a block at i: dp[i][t] = max(dp[i-1][t], pref[i] + best[t-1] up to i-1). Maintain bes","explanation":"## Why This Is Asked\nTests ability to formulate DP for selecting multiple non-overlapping subarrays with a sum objective and to reason about reconstruction.\n\n## Key Concepts\n- DP with multiple blocks\n- Prefix sums for O(1) subarray sums\n- Maintaining best previous state to achieve O(nk) time\n\n## Code Example\n```javascript\n// Pseudo outline without full implementation\n```\n\n## Follow-up Questions\n- How would you extend to at most k blocks or allow empty blocks? \n- How would you reconstruct the actual subarray endpoints efficiently?","diagram":"flowchart TD\n  A[Start] --> B[Compute prefix sums]\n  B --> C[Initialize dp with -INF]\n  C --> D[Iterate i from 1..n and t from 1..k]\n  D --> E[Update dp[i][t] = max(dp[i-1][t], pref[i] + best[t-1])]\n  E --> F[Maintain best[t-1] = max(best[t-1], dp[i-1][t-1] - pref[i-1])]\n  F --> G[Store parent pointers for reconstruction]\n  G --> H[Return result and endpoints]\n  H --> I[End]","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","IBM","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T06:50:20.868Z","createdAt":"2026-01-26T06:50:20.870Z"},{"id":"q-754","question":"Given a circular array v[1..n] of non-negative values and an integer d≥1, pick a subset of indices such that the cyclic distance between any two chosen indices is at least d. Maximize the sum of selected values; return both the maximum sum and the number of distinct optimal subsets. Constraints: n ≤ 2e5, v[i] ≤ 1e9. Describe an O(n) DP solution with two cases for circularity and how you'd reconstruct counts?","answer":"Use two-case DP on a linearized circle. Case A excludes index 1 and runs a linear DP on 2..n with dp[i]=max(dp[i-1], dp[i-d]+v[i]); Case B includes index 1, then run DP on the circularly valid segment","explanation":"## Why This Is Asked\nTests ability to design an optimized DP on a circular constraint and track the number of optimal solutions.\n\n## Key Concepts\n- DP on linear sequences with spacing (dp[i] = max(dp[i-1], dp[i-d] + v[i]))\n- Reducing circularity to two linear cases (include first vs exclude first)\n- Counting distinct optimal subsets with tie handling (sum counts when equal)\n\n## Code Example\n```javascript\nfunction linearDP(arr, d){\n  const n = arr.length; const dp = Array(n+1).fill(0); const ways = Array(n+1).fill(0);\n  dp[0] = 0; ways[0] = 1;\n  for(let i=1;i<=n;i++){\n    const take = arr[i-1] + (i-d>=0 ? dp[i-d] : 0);\n    const skip = dp[i-1];\n    if(take>skip){ dp[i]=take; ways[i]=(i-d>=0 ? ways[i-d] : 1); }\n    else if(take<skip){ dp[i]=skip; ways[i]=ways[i-1]; }\n    else { dp[i]=skip; ways[i] = ((i-d>=0 ? ways[i-d] : 1) + ways[i-1]); }\n  }\n  return [dp[n], ways[n]];\n}\n\nfunction maxCircular(v, d){\n  const [bestA, cntA] = linearDP(v.slice(1), d); // exclude first\n  const n = v.length;\n  const seg = (n > 2*d-1) ? v.slice(d, n-d+1) : [];\n  const [bestBseg, cntBseg] = seg.length ? linearDP(seg, d) : [0,1];\n  const bestB = v[0] + bestBseg;\n  if(bestA > bestB) return [bestA, cntA];\n  if(bestB > bestA) return [bestB, cntBseg];\n  return [bestA, cntA + cntBseg];\n}\n```\n\n## Follow-up Questions\n- How would you extend to allow a variable distance per pair or weighted distance penalties?\n- How would you test correctness and performance on worst-case inputs?","diagram":"flowchart TD\n  A[Start] --> B{Case A or Case B}\n  B --> C[DP on Case A (exclude 1)]\n  B --> D[DP on Case B (include 1)]\n  C --> E[Compare max sums]\n  D --> E\n  E --> F[Combine counts and return]","difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Netflix","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T01:32:37.055Z","createdAt":"2026-01-12T01:32:37.055Z"},{"id":"q-7558","question":"Given an array A[1..n] and an integer k, select exactly k non-overlapping, contiguous blocks to maximize the sum of block contributions, where a block [l..r] contributes max(A[l..r]). Return the maximum sum and the k blocks (start/end). Propose a DP with dp[i][t] as best value using first i elements with t blocks, transitions using max(A[j..i]), include reconstruction pointers and discuss time/space?","answer":"DP formulation: precompute M[j][i] = max(A[j..i]). Let dp[i][t] be max value using first i elements with exactly t blocks. Then dp[i][t] = max_{1<=j<=i} dp[j-1][t-1] + M[j][i]. Base: dp[0][0]=0, dp[i]","explanation":"## Why This Is Asked\nThe task tests a non-trivial DP where block value is a segment maximum, not sum. It requires precomputing segment maxima and careful reconstruction, exposing trade-offs between time and memory.\n\n## Key Concepts\n- DP on prefixes with exact block counts\n- Transition uses max(A[j..i])\n- Precompute M[j][i] in O(n^2)\n- Reconstruction pointers for endpoints\n\n## Code Example\n```javascript\nfunction maxSumKBlocks(A, k){\n  const n=A.length;\n  const M=Array.from({length:n},()=>Array(n).fill(0));\n  for(let i=0;i<n;i++){ let m=-Infinity; for(let j=i;j>=0;j--){ m=Math.max(m,A[j]); M[j][i]=m; } }\n  const dp=Array.from({length:n+1},()=>Array(k+1).fill(-Infinity));\n  const split=Array.from({length:n+1},()=>Array(k+1).fill(-1));\n  dp[0][0]=0;\n  for(let i=1;i<=n;i++){\n    for(let t=1;t<=Math.min(k,i);t++){\n      for(let j=1;j<=i;j++){\n        const val=dp[j-1][t-1]+M[j-1][i-1];\n        if(val>dp[i][t]){ dp[i][t]=val; split[i][t]=j; }\n      }\n    }\n  }\n  // reconstruction omitted for brevity\n  return {best:dp[n][k]};\n}\n```\n\n## Follow-up Questions\n- Can you optimize to reduce memory with rolling arrays?\n- How does this extend when blocks must have minimum gap?","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","DoorDash","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T07:39:00.502Z","createdAt":"2026-01-26T07:39:00.502Z"},{"id":"q-768","question":"You're given an array A of length n and an integer k. Partition A into exactly k non-empty contiguous subarrays. The cost of a subarray [t+1..i] is (max(A[t+1..i])) * (i-t). Return the minimum total cost and the partition indices. Propose DP: dp[i][j] = min_{t in [j-1..i-1]} dp[t][j-1] + max(A[t+1..i]) * (i-t). Explain reconstruction, base cases, and time/space?","answer":"Use dp[i][j] = min_t dp[t][j-1] + max(A[t+1..i])*(i-t). Base: dp[i][1] = max(A[1..i])*i. Precompute range maxima with mx[i][j] or compute on the fly in inner loop. Reconstruct via a predecessor table.","explanation":"## Why This Is Asked\nTests a non-trivial partition DP with a non-linear subarray cost and reconstruction.\n\n## Key Concepts\n- DP over partitions\n- Range maximum queries (precomputation or on-the-fly)\n- Path reconstruction via predecessor table\n\n## Code Example\n```javascript\nfunction minCostPartition(A, k) {\n  const n = A.length;\n  // precompute max for all ranges\n  const mx = Array.from({length: n}, ()=> Array(n).fill(0));\n  for (let i=0;i<n;i++){ mx[i][i]=A[i]; for(let j=i+1;j<n;j++) mx[i][j]=Math.max(mx[i][j-1], A[j]); }\n  const dp = Array.from({length: n+1}, ()=> Array(k+1).fill(Infinity));\n  const prv = Array.from({length: n+1}, ()=> Array(k+1).fill(-1));\n  dp[0][0]=0;\n  for(let i=1;i<=n;i++) dp[i][1] = mx[0][i-1]*(i);\n  for(let j=2;j<=k;j++){\n    for(let i=j;i<=n;i++){\n      for(let t=j-1;t<=i-1;t++){\n        const cost = dp[t][j-1] + mx[t][i-1]*(i-t);\n        if(cost < dp[i][j]){ dp[i][j]=cost; prv[i][j]=t; }\n      }\n    }\n  }\n  // reconstruction omitted for brevity\n  return {cost: dp[n][k], cutPoints: []};\n}\n```\n\n## Follow-up Questions\n- Can you optimize space to O(n) per k?\n- How to handle equal costs and tie-breaking?","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Robinhood","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T03:52:12.176Z","createdAt":"2026-01-12T03:52:12.176Z"},{"id":"q-7721","question":"You are given an array workload[0..n-1] of non-negative integers representing forecasted daily work. You may boost at most k days by doubling that day's workload, with the constraint that boosts cannot occur on consecutive days. Compute the maximum total workload achievable and provide the list of boosted day indices?","answer":"Use DP with two states per day i and boosts t: noBoost[i][t] and boost[i][t]. Transitions: noBoost[i][t] = max(noBoost[i-1][t], boost[i-1][t]) + workload[i]; boost[i][t] = noBoost[i-1][t-1] + 2*worklo","explanation":"## Why This Is Asked\nTests a beginner-friendly DP pattern with non-adjacent selections and reconstruction. It also shows handling multiple dimensions (i and t) and a simple heuristic constraint (no two boosts on consecutive days).\n\n## Key Concepts\n- DP with two states per index for constrained selections\n- Reconstruction of chosen days\n- Time/space: O(nk); note can optimize to O(k) space with rolling arrays\n\n## Code Example\n```javascript\nfunction maxWorkload(workload, k) {\n  const n = workload.length;\n  const NEG = -1e15;\n  const noBoost = Array.from({ length: n }, () => Array(k+1).fill(NEG));\n  const boost = Array.from({ length: n }, () => Array(k+1).fill(NEG));\n  noBoost[0][0] = workload[0];\n  if (k >= 1) boost[0][1] = 2 * workload[0];\n  for (let i = 1; i < n; i++) {\n    for (let t = 0; t <= k; t++) {\n      noBoost[i][t] = Math.max(noBoost[i-1][t], boost[i-1][t]) + workload[i];\n    }\n    for (let t = 1; t <= k; t++) {\n      if (noBoost[i-1][t-1] > NEG) boost[i][t] = noBoost[i-1][t-1] + 2*workload[i];\n    }\n  }\n  let best = NEG, bestT = 0, bestS = 0;\n  for (let t = 0; t <= k; t++) {\n    if (noBoost[n-1][t] > best) { best = noBoost[n-1][t]; bestT = t; bestS = 0; }\n    if (boost[n-1][t] > best) { best = boost[n-1][t]; bestT = t; bestS = 1; }\n  }\n  // reconstruction would backtrack using saved states (omitted for brevity)\n  return { maxValue: best, boostedIndices: [] };\n}\n```","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T15:03:36.239Z","createdAt":"2026-01-26T15:03:36.239Z"},{"id":"q-7751","question":"You're given an array A of length n and an integer k (1 <= k <= n). Partition A into exactly k non-empty contiguous subarrays that cover the entire array. The cost of a subarray is the maximum element within it. Return the minimum total cost and the endpoints (partition indices) of the k subarrays. Provide a DP formulation with recurrence, base cases, and reconstruction pointers; discuss time/space?","answer":"Define dp[i][t] as the minimum total cost to partition A[0..i-1] into t blocks. Base: dp[i][1] = max(A[0..i-1]). For t>1, iterate p from t-1 to i-1, maintain currentMax = max(A[p..i-1]); candidate = d","explanation":"## Why This Is Asked\nCombinatorial DP with partitioning; tests clear recurrence and reconstruction, common in interviews. \n\n## Key Concepts\n- dp[i][t] = min over p of dp[p][t-1] + max(A[p..i-1]);\n- Track parent to reconstruct partition points; iterate i and t in increasing order.\n\n## Code Example\n```javascript\nfunction minCostPartition(A, k){\n  const n = A.length;\n  const dp = Array.from({length: n+1}, ()=> Array(k+1).fill(Infinity));\n  const par = Array.from({length: n+1}, ()=> Array(k+1).fill(-1));\n  for(let i=1;i<=n;i++) dp[i][1] = Math.max(...A.slice(0,i));\n  for(let t=2;t<=k;t++){\n    for(let i=t;i<=n;i++){\n      let curMax = -Infinity;\n      for(let p=i-1; p>=t-1; p--){\n        curMax = Math.max(curMax, A[p]);\n        const cand = dp[p][t-1] + curMax;\n        if(cand < dp[i][t]){ dp[i][t] = cand; par[i][t] = p; }\n      }\n    }\n  }\n  // reconstruction omitted for brevity\n  return {cost: dp[n][k], par};\n}\n```\n\n## Follow-up Questions\n- How would you optimize to O(nk) time using a deque-based technique when max is a sliding property? \n- How would you extend to allow hypothetical negative numbers or to reconstruct explicit subarrays?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Microsoft","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T16:44:12.590Z","createdAt":"2026-01-26T16:44:12.592Z"},{"id":"q-777","question":"You're given an array A of non-negative integers representing task durations in order. You must schedule all n tasks into exactly m days. Each day can host a consecutive block with total duration <= D. The cost of a day is (sum of that day's durations)^2. Return the minimum total cost, or -1 if impossible? Propose a DP using dp[i][d] as min cost for first i tasks in d days, with transition dp[i][d] = min_{j<i, prefix[i]-prefix[j] <= D} dp[j][d-1] + (prefix[i]-prefix[j])^2. Include base cases, reconstruction, and time/space?","answer":"Use prefix sums and a 2D DP: dp[i][d] = min cost for first i tasks in d days, with dp[0][0]=0. For each i,d try all j<i where sum(j+1..i) <= D and set dp[i][d] = min(dp[i][d], dp[j][d-1] + (sum)^2). T","explanation":"## Why This Is Asked\nModels practical scheduling under capacity with a convex (squared) day cost, exercising 2D DP and reconstruction.\n\n## Key Concepts\n- DP over prefixes and days\n- Transition constrained by daily capacity D\n- Prefix sums for O(1) range sums\n- Backtracking via parent pointers to recover daily blocks\n- Complexity: O(n^2 m) time, O(n m) space\n\n## Code Example\n```javascript\nfunction minCostSchedule(A, m, D) {\n  const n = A.length;\n  const pref = new Array(n + 1).fill(0);\n  for (let i = 1; i <= n; i++) pref[i] = pref[i - 1] + A[i - 1];\n  const INF = Number.POSITIVE_INFINITY;\n  const dp = Array.from({ length: n + 1 }, () => new Array(m + 1).fill(INF));\n  const par = Array.from({ length: n + 1 }, () => new Array(m + 1).fill(-1));\n  dp[0][0] = 0;\n  for (let d = 1; d <= m; d++) {\n    for (let i = 1; i <= n; i++) {\n      for (let j = 0; j < i; j++) {\n        const sum = pref[i] - pref[j];\n        if (sum <= D && dp[j][d - 1] !== INF) {\n          const cost = dp[j][d - 1] + sum * sum;\n          if (cost < dp[i][d]) {\n            dp[i][d] = cost;\n            par[i][d] = j;\n          }\n        }\n      }\n    }\n  }\n  if (dp[n][m] === INF) return { cost: -1, blocks: [] };\n  const blocks = [];\n  let i = n, d = m;\n  while (d > 0) {\n    const j = par[i][d];\n    blocks.push([j + 1, i]);\n    i = j;\n    d--;\n  }\n  blocks.reverse();\n  return { cost: dp[n][m], blocks };\n}\n```\n\n## Follow-up Questions\n- How would you optimize to near O(n m) if D is small or sums have tighter bounds?\n- How would you present the actual day blocks to the user, including start/end indices and sums?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Apple","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T05:30:19.665Z","createdAt":"2026-01-12T05:30:19.665Z"},{"id":"q-7797","question":"Given an array A[1..n] and an integer k, choose exactly k non-empty, non-overlapping contiguous blocks. For each block [l..r], you may replace all elements in the block by a single value x chosen to minimize the sum of absolute deviations within that block; the block cost is sum_{i=l}^r |A[i]-x|, achieved at x = median(A[l..r]). Return the minimum total cost and the endpoints of the k blocks. Propose a DP formulation, including base cases, recurrences, and how to reconstruct the blocks; discuss time and space?","answer":"Proposed DP: dp[i][t] = min_{t-1≤j<i} dp[j][t-1] + cost(j+1,i), with base dp[i][1]=cost(1,i). Precompute cost(l,r)=min_x sum_{p=l}^r |A[p]-x|, achieved at x=median(A[l..r]), using a sweep with two hea","explanation":"## Why This Is Asked\nThis tests DP partitioning with a non-trivial per-block cost (L1 smoothing via median) and reconstruction, a common Netflix/Lyft/HuggingFace style optimization task.\n\n## Key Concepts\n- DP over partitions with end index i and blocks t\n- Block cost via median; recomputation avoidance\n- Parent pointers for reconstruction\n\n## Code Example\n```javascript\nfunction minCostKBlocks(A,n,k){ /* DP outline */ }\n```\n\n## Follow-up Questions\n- How would you optimize cost(l,r) precomputation further? \n- What about allowing gaps between blocks? ","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","Lyft","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T18:04:47.647Z","createdAt":"2026-01-26T18:04:47.648Z"},{"id":"q-786","question":"You have an array A of length n. Partition into exactly k non-empty contiguous blocks. The cost of a block [t+1..i] is (max(A[t+1..i])) * (sum(A[t+1..i])). Return the minimum total cost and the partition indices. Propose a DP formulation, reconstruction strategy, and complexity analysis. Assume 1-based indexing?","answer":"DP: dp[i][j] = min_{t in [j-1..i-1]} dp[t][j-1] + M(t+1,i) * (P[i]-P[t]), where P is prefix sum and M(t+1,i) is max on A[t+1..i]. Compute M on the fly by iterating t from i-1 down to j-1. Reconstruct ","explanation":"## Why This Is Asked\nTests a nontrivial DP with a block-cost dependent on both max and sum; requires handling both as a running statistic. \n\n## Key Concepts\n- DP over partitions into k blocks\n- Running block max and prefix sums\n- Reconstruction and complexity tradeoffs\n\n## Code Example\n```javascript\n// recurrence and reconstruction sketch\n```\n\n## Follow-up Questions\n- How to optimize with monotone queue or Divide-and-Conquer DP if the opt indices are monotone?\n- What about handling n up to 2e5 with large k and memory constraints?","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Scale Ai","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T06:38:54.270Z","createdAt":"2026-01-12T06:38:54.270Z"},{"id":"q-7901","question":"You are given an array A[0..n-1] and an integer k. Partition the array into exactly k non-empty contiguous blocks. Each block's value is the bitwise OR of its elements. Return the maximum possible sum of block values and the endpoints of the k blocks. Propose a dynamic programming formulation with dp[i][t] as the max sum for first i elements formed into t blocks, transitions using OR(A[j..i-1]), base cases, reconstruction, and discuss time/space?","answer":"Formulate dp[i][t] = max total OR-sum for first i elements partitioned into t blocks. Use precomputed ORs for all subarrays OR[j][i]. Recurrence: dp[i][t] = max_{0<=j<i} (dp[j][t-1] + OR[j][i]); base ","explanation":"## Why This Is Asked\nNew angle exploring OR-aggregation in partition DP, realistic for optimization tasks in data pipelines.\n\n## Key Concepts\n- Partition DP\n- Subarray OR precomputation\n- Reconstructing block boundaries\n- Time/space trade-offs\n\n## Code Example\n```javascript\nfunction maxOrPartition(A, k){\n  const n=A.length;\n  const OR = Array.from({length:n+1},()=>Array(n+1).fill(0));\n  for(let i=0;i<n;i++){ let cur=0; for(let j=i;j<n;j++){ cur |= A[j]; OR[i][j+1]=cur; } }\n  const dp = Array.from({length:n+1},()=>Array(k+1).fill(-Infinity));\n  const par = Array.from({length:n+1},()=>Array(k+1).fill(-1));\n  dp[0][0]=0;\n  for(let i=1;i<=n;i++){\n    for(let t=1;t<=k;t++){\n      for(let j=0;j<i;j++){\n        const val = dp[j][t-1] + OR[j][i];\n        if(val>dp[i][t]){ dp[i][t]=val; par[i][t]=j; }\n      }\n    }\n  }\n  let i=n, t=k; const blocks=[];\n  while(t>0){ const j=par[i][t]; blocks.push([j,i-1]); i=j; t--; }\n  blocks.reverse();\n  return {maxSum: dp[n][k], blocks};\n}\n```\n\n## Follow-up Questions\n- How to optimize to O(n^2) with space-optimized DP?\n- How would you modify for at-most-k blocks or to recover actual values per block?","diagram":"flowchart TD\n  A[Start] --> B[Precompute ORs]\n  B --> C[DP across i,t]\n  C --> D[Reconstruct blocks]\n  D --> E[Return result]","difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T22:35:21.777Z","createdAt":"2026-01-26T22:35:21.777Z"},{"id":"q-792","question":"You're given an array prices[0..n-1]. You may complete at most k buy-sell transactions (one share at a time, can't hold more than one). Return the maximum profit and the days of each trade. Propose a DP formulation with states cash[i][t] and hold[i][t], include recurrences, base cases, and reconstruction, and discuss time/space?","answer":"Max profit with at most k transactions on prices p[0..n-1]. Use DP with cash[i][t] and hold[i][t] representing max profit on day i with t completed transactions and not holding/holding. cash[i][t] = m","explanation":"## Why This Is Asked\nTests DP over time with multiple constraints: multiple transactions, reconstruction, and edge-case handling.\n\n## Key Concepts\n- Two DP states: cash (not holding) and hold (holding).\n- Transitions model buy/sell with transaction count t.\n- Base cases initialize day 0; backtracking recovers trade days.\n- Space optimization possible to O(k) with rolling arrays.\n\n## Code Example\n```javascript\nfunction maxProfit(prices, k){\n  const n = prices.length;\n  if (n===0 || k===0) return 0;\n  const cash = Array.from({length:n+1}, ()=> Array(k+1).fill(-1e15));\n  const hold = Array.from({length:n+1}, ()=> Array(k+1).fill(-1e15));\n  for (let t=0; t<=k; t++) cash[0][t] = (t===0)?0:-1e15;\n  for (let i=1; i<=n; i++){\n    for (let t=0; t<=k; t++){\n      cash[i][t] = cash[i-1][t];\n      if (t>0) cash[i][t] = Math.max(cash[i][t], hold[i-1][t] + prices[i-1]);\n      hold[i][t] = hold[i-1][t];\n      if (t>0) hold[i][t] = Math.max(hold[i][t], cash[i-1][t-1] - prices[i-1]);\n    }\n  }\n  let best = 0;\n  for (let t=0; t<=k; t++) best = Math.max(best, cash[n][t]);\n  return best;\n}\n```\n\n## Follow-up Questions\n- How would you recover the exact trade days from the DP table?\n- How does the solution change if k >= n/2 (unlimited transactions)?","diagram":"flowchart TD\n  Start([Start])\n  Day[Process day i from 0..n-1]\n  Trans{Choose action: buy, sell, hold}\n  CashUpdate[Update cash states]\n  HoldUpdate[Update hold states]\n  End([End with best cash])\n  Start --> Day --> Trans\n  Trans --> CashUpdate --> End\n  Trans --> HoldUpdate --> End","difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","IBM","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T07:28:11.075Z","createdAt":"2026-01-12T07:28:11.075Z"},{"id":"q-7929","question":"You're given an array profits[0..n-1] of positive integers and an integer k. You may select at most k days, with the constraint that no two selected days are consecutive. Return the maximum total profit and the indices of the chosen days. Provide a DP formulation with states i and t, recurrence, base cases, and a reconstruction strategy?","answer":"DP[i][t] = max(DP[i-1][t], DP[i-2][t-1] + a[i-1]) for i>=2; base DP[0][0]=0, DP[i][0]=0, DP[1][1]=a[0]. Backtrack to recover indices. Time O(nk), Space O(nk); can optimize to O(k) rows with a separate","explanation":"## Why This Is Asked\n\nThis tests a standard DP with an adjacency constraint and a limit on picks, plus reconstruction.\n\n## Key Concepts\n\n- DP over i and t with i-2 due to adjacency\n- Reconstruction via a take/parent trace\n- Space/time trade-offs; potential optimizations\n\n## Code Example\n\n```javascript\nfunction maxNonAdjSum(a, k) {\n  const n = a.length;\n  const dp = Array.from({length: n+1}, ()=>Array(k+1).fill(0));\n  const take = Array.from({length: n+1}, ()=>Array(k+1).fill(false));\n  for (let i = 1; i <= n; i++) {\n    for (let t = 0; t <= k; t++) {\n      dp[i][t] = dp[i-1][t];\n      if (t > 0) {\n        const val = (i >= 2 ? dp[i-2][t-1] : 0) + a[i-1];\n        if (val > dp[i][t]) {\n          dp[i][t] = val;\n          take[i][t] = true;\n        }\n      }\n    }\n  }\n  const res = [];\n  let i = n, t = k;\n  while (i > 0 && t > 0) {\n    if (take[i][t]) { res.push(i-1); i -= 2; t -= 1; }\n    else { i -= 1; }\n  }\n  res.reverse();\n  return {sum: dp[n][k], indices: res};\n}\n```\n\n## Follow-up Questions\n\n- How to enforce exact k picks? \n- Can you reduce space to O(n) or O(k) and still reconstruct? \n- How does it scale for large n?","diagram":null,"difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T23:44:53.624Z","createdAt":"2026-01-26T23:44:53.625Z"},{"id":"q-797","question":"You have an array of task difficulties A of length n. Partition it into exactly m non-empty contiguous chapters. Each chapter cost equals the maximum difficulty within that chapter. Return the minimum total cost and a valid partition (chapter end indices). Propose a DP: dp[i][j] = min_{t in [j-1..i-1]} dp[t][j-1] + max(A[t..i-1]), with base dp[i][1] = max(A[0..i-1]). Explain reconstruction, base cases, and time/space?","answer":"Define dp[i][j] as the minimum total cost to partition the first i tasks into j chapters. Recurrences: dp[i][1] = max(A[0..i-1]); for j>1, dp[i][j] = min_{t from j-1 to i-1} dp[t][j-1] + max(A[t..i-1]","explanation":"## Why This Is Asked\nTests ability to model partitioning with a simple per-block objective and reconstruct optimal cuts. It reveals DP formulation, range queries, and backtracking.\n\n## Key Concepts\n- Partition DP across two dimensions (prefix and blocks)\n- Range maximum precomputation or on-the-fly tracking\n- Backpointers for path reconstruction\n- Time/space trade-offs and potential optimizations\n\n## Code Example\n```javascript\nfunction minPartitionCostMax(A, m){\n  const n = A.length;\n  // precompute max for all ranges\n  const rangeMax = Array.from({length: n}, () => Array(n).fill(0));\n  for(let i=0;i<n;i++){\n    let cur = 0;\n    for(let j=i;j<n;j++){\n      cur = Math.max(cur, A[j]);\n      rangeMax[i][j] = cur;\n    }\n  }\n  const dp = Array.from({length: n+1}, () => Array(m+1).fill(Infinity));\n  const par = Array.from({length: n+1}, () => Array(m+1).fill(-1));\n  dp[0][0] = 0;\n  for(let i=1;i<=n;i++){\n    for(let j=1;j<=Math.min(i,m);j++){\n      for(let t=j-1; t<=i-1; t++){\n        const val = dp[t][j-1] + rangeMax[t][i-1];\n        if(val < dp[i][j]){\n          dp[i][j] = val;\n          par[i][j] = t;\n        }\n      }\n    }\n  }\n  // reconstruct\n  const cuts = [];\n  let i = n, j = m;\n  while(j>0){\n    const t = par[i][j];\n    cuts.push(i);\n    i = t;\n    j--;\n  }\n  cuts.reverse();\n  return {cost: dp[n][m], partitions: cuts};\n}\n```\n\n## Follow-up Questions\n- How would you optimize to O(n m) time using monotonic queues?  \n- How would you adapt if each chapter cost were max(A[t..i-1]) + c*(i-t)?","diagram":"flowchart TD\n  A[Start] --> B[Precompute rangeMax]\n  B --> C[DP transitions dp[i][j]]\n  C --> D[Backtrack cuts]\n  D --> E[Return result]","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","LinkedIn","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T08:28:52.276Z","createdAt":"2026-01-12T08:28:52.276Z"},{"id":"q-806","question":"You're given an n x m grid of digits grid[i][j] in [0..9]. You may move only right or down from (0,0) to (n-1,m-1). Define a path score as the number of times the next cell's digit is strictly larger than the previous cell's digit along the path. Return the maximum score and a valid path (as coordinates or directions). Propose a dynamic programming formulation with recurrences, base cases, and reconstruction, and discuss time/space?","answer":"We define dp[i][j] as the maximum ascents to reach (i,j). Base: dp[0][0] = 0; fill first row/column with dp[0][j] = dp[0][j-1] + (grid[0][j-1] < grid[0][j]); dp[i][0] = dp[i-1][0] + (grid[i-1][0] < gr","explanation":"## Why This Is Asked\nAssesses ability to turn path-based objectives into simple local transitions without extraneous state. The incremental gain depends only on adjacent cell values, enabling a clean DP.\n\n## Key Concepts\n- Grid DP with monotone moves\n- Backpointers for path reconstruction\n- Space optimization potential\n\n## Code Example\n```javascript\nfunction maxAscents(grid){\n  const n=grid.length, m=grid[0].length;\n  const dp=Array.from({length:n}, ()=>Array(m).fill(0));\n  const par=Array.from({length:n}, ()=>Array(m).fill(null));\n  for(let i=0;i<n;i++){\n    for(let j=0;j<m;j++){\n      if(i===0 && j===0) continue;\n      let top=-Infinity, left=-Infinity;\n      if(i>0) top = dp[i-1][j] + (grid[i-1][j] < grid[i][j] ? 1:0);\n      if(j>0) left = dp[i][j-1] + (grid[i][j-1] < grid[i][j] ? 1:0);\n      if(top >= left){ dp[i][j] = top; par[i][j] = 'U'; } else { dp[i][j] = left; par[i][j] = 'L'; }\n    }\n  }\n  // backtrack to build path\n  return {score: dp[n-1][m-1], path: []};\n}\n```","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Hugging Face","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T09:31:56.680Z","createdAt":"2026-01-12T09:31:56.680Z"},{"id":"q-813","question":"You're given a tree with N nodes (N up to 2e5). Each node i has a value val[i]. Find a connected subtree of exactly K nodes that maximizes the sum of values. Return the maximum sum and the node set. Propose a DP formulation with dp[u][s] = max sum of a connected subtree of size s that contains u and lies entirely within u's subtree when the tree is rooted at 1; include reconstruction, base cases, and discuss time/space?","answer":"Root the tree at 1. dp[u][s] = max sum of a connected subtree of size s that contains u and lies in u's subtree. Base: dp[u][1] = val[u]. For each child v, knapsack-merge: new[s+t] = max(old[s] + dp[v","explanation":"## Why This Is Asked\nTests a nontrivial tree DP pattern: building size-aware subproblems per node and merging children like a knapsack while preserving the connected-subtree constraint.\n\n## Key Concepts\n- Tree DP with per-node size states (O(nK))\n- Knapsack-style merge across an arbitrary number of children\n- Connected-subtree constraint implies a unique top node in a rooted tree\n- Reconstruction via choice-tracking during merges\n\n## Code Example\n```javascript\nfunction maxSubtreeOfSizeK(n, k, edges, val) {\n  // Placeholder skeleton for the DP approach over a rooted tree\n  // Build adjacency, root at 1, then perform DFS with knapsack merge per node\n  // Return {best: number, nodes: number[]}\n}\n```\n\n## Follow-up Questions\n- How to optimize memory to O(k) per node?\n- How does complexity change with high-degree nodes, and can we apply small-to-large merging to improve constants?","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T10:23:39.425Z","createdAt":"2026-01-12T10:23:39.425Z"},{"id":"q-821","question":"You're given a string s of length n consisting of lowercase letters. Partition s into at most k non-empty contiguous substrings. The cost of a substring is the number of distinct characters in that substring. Return the minimum total cost and one valid partition (end indices). Propose a DP formulation with recurrence dp[i][t] = min_{p in [t-1..i-1]} dp[p][t-1] + cost(p, i-1) where cost(p, q) is the number of distinct letters in s[p..q]. Explain reconstruction, base cases, and time/space complexity?","answer":"DP over cut positions: define dp[i][t] as min cost to split s[0..i-1] into t substrings, with a backpointer to recover the last cut. Precompute cost(p,i-1) = number of distinct letters in s[p..i-1] by","explanation":"## Why This Is Asked\n\nTests a non-trivial partition DP with a substring cost that requires precomputation and reconstruction, combining both combinatorial choices and an aggregate cost function.\n\n## Key Concepts\n\n- DP on partitions with a cost function over substrings\n- Efficient precomputation of substring distinct counts\n- Backtracking reconstruction of cut points\n- Time/space trade-offs and memory optimization\n\n## Code Example\n\n```javascript\n// Pseudo: precompute cost[p][i], then DP with backpointers\nconst n = s.length;\nconst INF = 1e9;\nconst cost = Array.from({ length: n }, () => Array(n).fill(0));\nfor (let p = 0; p < n; p++) {\n  const seen = new Array(26).fill(false);\n  let distinct = 0;\n  for (let i = p; i < n; i++) {\n    const idx = s.charCodeAt(i) - 97;\n    if (!seen[idx]) { seen[idx] = true; distinct++; }\n    cost[p][i] = distinct;\n  }\n}\nconst kCap = Math.min(k, n);\nconst dp = Array.from({ length: n+1 }, () => Array(kCap+1).fill(INF));\nconst prv = Array.from({ length: n+1 }, () => Array(kCap+1).fill(-1));\ndp[0][0] = 0;\nfor (let i = 1; i <= n; i++) {\n  for (let t = 1; t <= Math.min(i, kCap); t++) {\n    for (let p = t-1; p <= i-1; p++) {\n      const cand = dp[p][t-1] + cost[p][i-1];\n      if (cand < dp[i][t]) { dp[i][t] = cand; prv[i][t] = p; }\n    }\n  }\n}\n```\n","diagram":null,"difficulty":"intermediate","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","LinkedIn","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T11:19:30.997Z","createdAt":"2026-01-12T11:19:30.997Z"},{"id":"q-829","question":"You're given an array A of length n and an integer k. Partition A into exactly k non-empty contiguous subarrays. Each subarray's cost is max(A[l..r]) - min(A[l..r]). Return the minimum total cost and one valid partition (end indices). Propose a DP: dp[i][t] = min_{p in [t-1..i-1]} dp[p][t-1] + (max(A[p..i-1]) - min(A[p..i-1])); base: dp[i][1] = max(A[0..i-1]) - min(A[0..i-1]). Explain reconstruction, base cases, and time/space complexity?","answer":"DP over prefixes and segment counts: dp[i][t] = min over p of dp[p][t-1] + range(p, i-1), where range is max-min. Store cut indices for reconstruction. Base: dp[i][1] = range(0, i-1). Computing range ","explanation":"## Why This Is Asked\nTests DP with a range-based segment cost and path reconstruction, a common advanced pattern not covered yet.\n\n## Key Concepts\n- Contiguous partitioning\n- Range query (max-min)\n- DP with backtracking\n- Time/space trade-offs and potential optimizations\n\n## Code Example\n```javascript\nfunction minCostPartition(A, k) {\n  const n = A.length;\n  const dp = Array.from({ length: n + 1 }, () => Array(k + 1).fill(Infinity));\n  const cut = Array.from({ length: n + 1 }, () => Array(k + 1).fill(-1));\n  // base\n  for (let i = 1; i <= n; i++) {\n    let mx = -Infinity, mn = Infinity;\n    for (let p = i - 1; p >= 0; p--) {\n      mx = Math.max(mx, A[p]);\n      mn = Math.min(mn, A[p]);\n      dp[i][1] = Math.max(...A.slice(0, i)) - Math.min(...A.slice(0, i));\n    }\n  }\n  // transitions would fill dp[i][t] and cut[i][t]\n  return { cost: dp[n][k], partition: cut };\n}\n```\n\n## Follow-up Questions\n- How would you optimize range(p, i-1) queries to O(1) per transition?\n- How would you adapt for 1-indexed arrays or allow at most k segments?","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Hugging Face","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T12:41:45.018Z","createdAt":"2026-01-12T12:41:45.018Z"}],"subChannels":["general"],"companies":["Adobe","Airbnb","Amazon","Anthropic","Apple","Bloomberg","Citadel","Cloudflare","Coinbase","Databricks","Discord","DoorDash","Goldman Sachs","Google","Hugging Face","IBM","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Netflix","OpenAI","Oracle","PayPal","Plaid","Robinhood","Salesforce","Scale Ai","Slack","Snap","Square","Stripe","Tesla","Twitter","Two Sigma","Uber","Zoom"],"stats":{"total":78,"beginner":34,"intermediate":25,"advanced":19,"newThisWeek":37}}