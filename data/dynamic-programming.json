{"questions":[{"id":"q-679","question":"In a warehouse grid of size n x m, each cell has a traversal cost. You can move only right or down from (0,0) to (n-1,m-1). You have a one-time token to halve the cost of exactly one visited cell. Design an O(nm) DP to compute the minimum path cost after optimally using the discount, and describe the recurrences and a space-optimized implementation?","answer":"Maintain two DP arrays: best without using the discount (dp0) and best with the discount already used (dp1). For grid costs c[i][j], set:\ndp0[i][j] = c[i][j] + min(dp0[i-1][j], dp0[i][j-1]);\ndp1[i][j]","explanation":"## Why This Is Asked\nTests real DP design with an extra state (discount used) and careful recurrence.\n\n## Key Concepts\n- 2D DP with a binary state (discount used or not)\n- Transitions combine taking cost with/without discount\n- Space optimization using rolling arrays\n\n## Code Example\n```javascript\nfunction minCostWithDiscount(grid){\n  const n = grid.length, m = grid[0].length;\n  const INF = 1e15;\n  let dp0 = new Array(m).fill(INF);\n  let dp1 = new Array(m).fill(INF);\n  dp0[0] = grid[0][0];\n  dp1[0] = Math.floor(grid[0][0] / 2);\n  for (let j = 1; j < m; j++) {\n    dp0[j] = grid[0][j] + dp0[j-1];\n    dp1[j] = Math.min(grid[0][j] + dp1[j-1], Math.floor(grid[0][j]/2) + dp0[j-1]);\n  }\n  for (let i = 1; i < n; i++) {\n    dp0[0] += grid[i][0];\n    dp1[0] = Math.min(grid[i][0] + dp1[0], Math.floor(grid[i][0]/2) + dp0[0-1]);\n    for (let j = 1; j < m; j++) {\n      const v = grid[i][j];\n      dp1[j] = Math.min(v + Math.min(dp1[j], dp1[j-1]), Math.floor(v/2) + Math.min(dp0[j], dp0[j-1]));\n      dp0[j] = v + Math.min(dp0[j], dp0[j-1]);\n    }\n  }\n  return dp1[m-1];\n}\n```\n\n## Follow-up Questions\n- How would you support multiple discounts or varying discount values?\n- How does this adapt if diagonal moves are allowed or costs can be negative?","diagram":null,"difficulty":"advanced","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Snap","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T15:57:04.021Z","createdAt":"2026-01-11T15:57:04.021Z"},{"id":"q-691","question":"You're planning a delivery route along a straight street of n blocks. At block i you can advance up to jumps[i] blocks (at least 1). How many distinct routes reach block n-1 from block 0? If unreachable, return 0. Propose a dynamic-programming approach with dp[i] as ways to reach i and outline its time/space complexity, edge cases, and a brief correctness justification. How would you implement it?","answer":"Use a 1D DP: dp[i] is number of ways to reach i. Initialize dp[0] = 1. For i from 0 to n-1, let maxJump = min(jumps[i], n-1-i); for s from 1 to maxJump, dp[i+s] = (dp[i+s] + dp[i]) % 1000000007. Retur","explanation":"## Why This Is Asked\nTests counting paths with variable step lengths using DP, a common interview pattern in operations and logistics contexts.\n\n## Key Concepts\n- 1D DP for path counting\n- Handling variable jump lengths\n- Modulo arithmetic for large counts\n\n## Code Example\n```javascript\nfunction countWays(jumps){\n  const n = jumps.length;\n  const MOD = 1000000007;\n  const dp = new Array(n).fill(0);\n  dp[0] = 1;\n  for(let i = 0; i < n; i++){\n    const maxJump = Math.min(jumps[i], n - 1 - i);\n    for(let s = 1; s <= maxJump; s++){\n      dp[i + s] = (dp[i + s] + dp[i]) % MOD;\n    }\n  }\n  return dp[n - 1] || 0;\n}\n```\n\n## Follow-up Questions\n- How would you optimize to O(n) time if maxJump can be large but jumps form a sliding window of contributions?\n- How would you adjust for different termination criteria or multiple destinations?","diagram":"flowchart TD\n  Start([Start]) --> Init[dp[0] = 1]\n  Init --> Loop[for i in 0..n-1]\n  Loop --> Update[dp[i+s] += dp[i] for s<=maxJump]\n  Update --> End([Return dp[n-1]])","difficulty":"beginner","tags":["dynamic-programming"],"channel":"dynamic-programming","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Meta","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T16:24:20.467Z","createdAt":"2026-01-11T16:24:20.467Z"}],"subChannels":["general"],"companies":["Anthropic","DoorDash","Meta","Snap","Square","Twitter"],"stats":{"total":2,"beginner":1,"intermediate":0,"advanced":1,"newThisWeek":2}}