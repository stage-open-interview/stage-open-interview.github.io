{"questions":[{"id":"q-258","question":"How would you design a reactive Android ViewModel using StateFlow with sealed classes to handle network API responses, ensuring proper error handling and loading states?","answer":"Use MutableStateFlow<UiState> with sealed class (Loading/Success/Error) and collect with catch operator for error handling in coroutine scope.","explanation":"## Concept Overview\nCombining StateFlow with sealed classes creates a type-safe, reactive state management pattern perfect for handling API responses. The StateFlow holds the current UI state while sealed classes define all possible states, enabling compile-time safety when handling different scenarios.\n\n## Implementation Details\n\n### 1. Define Sealed Class for UI States\n```kotlin\nsealed class UiState<out T> {\n    object Loading : UiState<Nothing>()\n    data class Success<T>(val data: T) : UiState<T>()\n    data class Error(val exception: Throwable) : UiState<Nothing>()\n}\n```\n\n### 2. ViewModel Implementation\n```kotlin\nclass UserRepository @Inject constructor(\n    private val apiService: ApiService\n) {\n    private val _usersState = MutableStateFlow<UiState<List<User>>>(UiState.Loading)\n    val usersState: StateFlow<UiState<List<User>>> = _usersState.asStateFlow()\n\n    fun fetchUsers() {\n        viewModelScope.launch {\n            _usersState.value = UiState.Loading\n            apiService.getUsers()\n                .catch { exception ->\n                    _usersState.value = UiState.Error(exception)\n                }\n                .collect { users ->\n                    _usersState.value = UiState.Success(users)\n                }\n        }\n    }\n}\n```\n\n### 3. Activity/Fragment Collection\n```kotlin\nlifecycleScope.launch {\n    viewModel.usersState.collect { state ->\n        when (state) {\n            is UiState.Loading -> showProgressBar()\n            is UiState.Success -> showUsers(state.data)\n            is UiState.Error -> showError(state.exception.message)\n        }\n    }\n}\n```\n\n## Common Pitfalls\n- **Memory Leaks**: Always use `viewModelScope` or `lifecycleScope` for coroutines\n- **State Conflation**: StateFlow is conflated by default - rapid updates may be lost\n- **Backpressure**: Use `buffer()` or `conflate() strategically for high-frequency updates\n- **Initial State**: Always initialize StateFlow with a meaningful default state\n- **Error Propagation**: Don't forget the `catch` operator to prevent cancellation","diagram":"graph TD\n    A[User Action] --> B[ViewModel.fetchUsers]\n    B --> C[_usersState.value = Loading]\n    C --> D[API Service Call]\n    D --> E{Response}\n    E -->|Success| F[_usersState.value = Success]\n    E -->|Error| G[_usersState.value = Error]\n    F --> H[UI Updates with Data]\n    G --> I[UI Shows Error Message]\n    C --> J[UI Shows Loading]\n    J --> K[StateFlow.collect in Activity]\n    K --> L[when statement handles state]\n    L --> M{State Type}\n    M -->|Loading| N[Show ProgressBar]\n    M -->|Success| O[Display Data]\n    M -->|Error| P[Show Error]","difficulty":"intermediate","tags":["coroutines","flow","sealed-classes"],"channel":"android","subChannel":"architecture","sourceUrl":"https://medium.com/@dharmakshetri/robust-error-handling-in-android-7aedf5b6a878","videos":{"shortVideo":"https://www.youtube.com/watch?v=rnRsUiI3W9o","longVideo":"https://www.youtube.com/watch?v=5OrK81ZRoNY"},"companies":["Airbnb","Google","Meta","Microsoft","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"lastUpdated":"2025-12-22T08:33:46.738Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-452","question":"How would you implement a RecyclerView with multiple view types while maintaining smooth scrolling performance on large datasets?","answer":"Use RecyclerView.Adapter with getItemViewType() to return different view types. Implement ViewHolder pattern for each type, use DiffUtil for efficient updates, and enable setHasFixedSize(true). For la","explanation":"## Multiple View Types Implementation\n- Override getItemViewType() to return different integers based on data\n- Create separate ViewHolder classes for each view type\n- Use onCreateViewHolder() with view type parameter\n\n## Performance Optimization\n- Implement DiffUtil for efficient list updates\n- Use setHasFixedSize(true) when item sizes are constant\n- Enable RecyclerView.RecycledViewPool for view reuse\n\n## Large Dataset Handling\n- Implement Paging3 library for infinite scrolling\n- Use ViewHolder pattern to avoid view inflation\n- Consider using ConcatAdapter for combining multiple adapters","diagram":"flowchart TD\n  A[Data List] --> B[getItemViewType]\n  B --> C{View Type?}\n  C -->|Type 1| D[ViewHolder1]\n  C -->|Type 2| E[ViewHolder2]\n  C -->|Type 3| F[ViewHolder3]\n  D --> G[Bind Data]\n  E --> G\n  F --> G\n  G --> H[RecyclerView Display]","difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Citadel","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"lastUpdated":"2025-12-24T02:44:45.362Z","createdAt":"2025-12-26 12:51:05"},{"id":"q-482","question":"How would you handle Activity lifecycle when screen rotates and you need to preserve user input data?","answer":"Use ViewModel with LiveData to preserve data across configuration changes. Save critical state in onSaveInstanceState() for process death. For simple UI state, use onSaveInstanceState() with Bundle. F","explanation":"## Key Concepts\n- **Configuration Changes**: Screen rotation destroys/recreates Activity\n- **ViewModel**: Survives configuration changes, holds UI state\n- **LiveData**: Observable data holder that respects lifecycle\n\n## Implementation Options\n- **ViewModel + LiveData**: Best for most UI state\n- **onSaveInstanceState()**: For small amounts of data\n- **Room Database**: For persistent data storage\n\n## Best Practices\n- Never store Context in ViewModel\n- Use dependency injection for ViewModels\n- Clear LiveData in onDestroy() if needed","diagram":"flowchart TD\n  A[Screen Rotation] --> B[Activity Destroyed]\n  B --> C[ViewModel Preserved]\n  C --> D[Activity Recreated]\n  D --> E[UI Restored from ViewModel]\n  E --> F[LiveData Updates UI]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"lastUpdated":"2025-12-25T01:13:01.194Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-512","question":"How would you implement a simple RecyclerView in Android to display a list of user profiles with name and email?","answer":"Create a RecyclerView with a custom adapter extending RecyclerView.Adapter. Use ViewHolder pattern with data binding for name/email TextViews. Implement onCreateViewHolder to inflate item layout, onBi","explanation":"## RecyclerView Implementation\n\n- Create item layout XML with TextViews for name and email\n- Extend RecyclerView.Adapter with custom ViewHolder class\n- Override three required methods: onCreateViewHolder, onBindViewHolder, getItemCount\n- Use ViewHolder pattern to avoid repeated findViewById calls\n- Set adapter and LayoutManager on RecyclerView in Activity/Fragment\n\n## Key Components\n\n- **ViewHolder**: Holds references to view components\n- **Adapter**: Bridges data with RecyclerView\n- **LayoutManager**: Positions items (LinearLayoutManager for lists)\n- **Data Binding**: Optional but recommended for cleaner code\n\n```kotlin\nclass UserAdapter(private val users: List<User>) : \n    RecyclerView.Adapter<UserAdapter.UserViewHolder>() {\n    \n    class UserViewHolder(view: View) : RecyclerView.ViewHolder(view) {\n        val nameText: TextView = view.findViewById(R.id.name)\n        val emailText: TextView = view.findViewById(R.id.email)\n    }\n    \n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): UserViewHolder {\n        val view = LayoutInflater.from(parent.context)\n            .inflate(R.layout.item_user, parent, false)\n        return UserViewHolder(view)\n    }\n    \n    override fun onBindViewHolder(holder: UserViewHolder, position: Int) {\n        val user = users[position]\n        holder.nameText.text = user.name\n        holder.emailText.text = user.email\n    }\n    \n    override fun getItemCount() = users.size\n}\n```","diagram":"flowchart TD\n    A[Activity/Fragment] --> B[RecyclerView]\n    B --> C[LayoutManager]\n    B --> D[UserAdapter]\n    D --> E[ViewHolder]\n    E --> F[Item Layout XML]\n    D --> G[User Data List]\n    F --> H[Name TextView]\n    F --> I[Email TextView]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Tesla","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"lastUpdated":"2025-12-25T14:59:09.193Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-541","question":"How would you implement a RecyclerView with ViewHolder pattern to display a list of user profiles efficiently?","answer":"Use RecyclerView with ViewHolder pattern: create custom ViewHolder extending RecyclerView.ViewHolder, implement onCreateViewHolder to inflate item layout, onBindViewHolder to bind data, and use DiffUt","explanation":"## RecyclerView Implementation\n\n- **ViewHolder Pattern**: Reuses view objects to avoid expensive findViewById calls\n- **DiffUtil**: Calculates differences between old and new lists for efficient updates\n- **Layout Manager**: Manages item positioning (LinearLayoutManager for lists)\n\n```kotlin\nclass ProfileAdapter : ListAdapter<Profile, ProfileAdapter.ViewHolder>(DiffCallback()) {\n    \n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {\n        val view = LayoutInflater.from(parent.context)\n            .inflate(R.layout.item_profile, parent, false)\n        return ViewHolder(view)\n    }\n    \n    override fun onBindViewHolder(holder: ViewHolder, position: Int) {\n        holder.bind(getItem(position))\n    }\n    \n    class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {\n        fun bind(profile: Profile) {\n            // Bind data to views\n        }\n    }\n}\n```","diagram":"flowchart TD\n  A[Data List] --> B[DiffUtil]\n  B --> C[RecyclerView.Adapter]\n  C --> D[onCreateViewHolder]\n  C --> E[onBindViewHolder]\n  D --> F[ViewHolder]\n  E --> F\n  F --> G[Item Views]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Goldman Sachs","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"lastUpdated":"2025-12-27T05:32:25.066Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-205","question":"How would you implement Compose Navigation with nested graphs, shared ViewModels, configuration change handling, and deep linking in a production Android app?","answer":"Use NavHost with nested NavGraphs, HiltViewModel for scoped VMs, SavedStateHandle for deep link parameters, and rememberSaveable for state preservation across configuration changes.","explanation":"## Implementation Strategy\n\n**Navigation Setup:**\n```kotlin\n@Composable\nfun AppNavigation() {\n    val navController = rememberNavController()\n    NavHost(\n        navController = navController,\n        startDestination = \"home\"\n    ) {\n        navigation(\"home\", \"home_graph\") {\n            composable(\"detail/{id}\") { backStackEntry ->\n                val viewModel: SharedViewModel = hiltViewModel()\n                DetailScreen(viewModel, backStackEntry.arguments?.getString(\"id\"))\n            }\n        }\n    }\n}\n```\n\n**ViewModel Scoping:**\n- Use `hiltViewModel()` for NavGraph-scoped ViewModels\n- Share ViewModels across nested navigation graphs\n- Leverage `@HiltViewModel` and `@Inject` for dependency injection\n\n**Configuration Changes:**\n- `rememberSaveable` for UI state preservation\n- ViewModel automatically survives configuration changes\n- Use `SavedStateHandle` for navigation parameter persistence\n\n**Deep Linking:**\n```kotlin\ncomposable(\n    \"detail/{id}\",\n    deepLinks = listOf(navDeepLink {\n        uriPattern = \"app://detail/{id}\"\n    })\n) { backStackEntry ->\n    val id = backStackEntry.arguments?.getString(\"id\")\n    val viewModel: SharedViewModel = hiltViewModel()\n    viewModel.loadDetails(id)\n}\n```\n\n**Key Considerations:**\n- Handle back stack properly with nested graphs\n- Use `popUpTo` for navigation flow control\n- Implement proper state restoration with `SavedStateHandle`\n- Consider memory leaks with long-lived ViewModels","diagram":"graph TD\n    A[NavHost] --> B[Home Graph]\n    A --> C[Profile Graph]\n    A --> D[Settings Graph]\n    C --> E[Profile Screen]\n    C --> F[Edit Profile]\n    E --> G[ProfileViewModel]\n    F --> G\n    H[Deep Link] --> I[SavedStateHandle]\n    I --> G\n    J[Config Change] --> K[rememberSaveable]\n    K --> G","difficulty":"intermediate","tags":["composables","state","navigation"],"channel":"android","subChannel":"jetpack-compose","sourceUrl":null,"videos":{"longVideo":"https://www.youtube.com/watch?v=FIEnIBq7Ups"},"companies":["Amazon","Google","Meta","Microsoft","Netflix","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":["compose navigation","navhost","nested navgraphs","hiltviewmodel","savedstatehandle","remembersaveable","configuration changes"],"voiceSuitable":true,"lastUpdated":"2025-12-27T05:45:37.585Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-182","question":"What is the first lifecycle method called when an Android Activity is created, and what critical initialization tasks must be performed within it?","answer":"onCreate() is the first lifecycle method called when an Activity is created. It receives a Bundle savedInstanceState parameter containing previous state data for activity recreation. You must call super.onCreate(savedInstanceState) first, then setContentView() to initialize the UI, followed by component initialization, view setup, and data binding. This method runs only once per activity instance unless recreated by the system.","explanation":"## Interview Context\nThis question tests understanding of Android Activity lifecycle fundamentals and proper initialization patterns. Candidates should demonstrate knowledge of state management and recreation scenarios.\n\n## Key Points\n- **onCreate()** is always the first lifecycle method called\n- **Bundle savedInstanceState** preserves state during activity recreation\n- **super.onCreate()** must be called before any other operations\n- **setContentView()** should be called early to establish the UI hierarchy\n- **One-time initialization** like adapters, listeners, and data loading\n\n## Code Example\n```java\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState); // Must be first\n    setContentView(R.layout.activity_main); // UI setup\n    \n    // Initialize components\n    initializeViews();\n    setupListeners();\n    \n    // Restore state if available\n    if (savedInstanceState != null) {\n        restoreData(savedInstanceState);\n    }\n}\n```\n\n## Follow-up Questions\n- What happens if you don't call super.onCreate()?\n- When would savedInstanceState be null vs non-null?\n- What's the difference between onCreate() and onRestart()?\n- How do you handle configuration changes in onCreate()?","diagram":"graph TD\n    A[onCreate] --> B[onStart]\n    B --> C[onResume]\n    C --> D[Running]\n    D --> E[onPause]\n    E --> F[onStop]\n    F --> G[onDestroy]","difficulty":"beginner","tags":["lifecycle","components"],"channel":"android","subChannel":"lifecycle","sourceUrl":null,"videos":null,"companies":["Amazon","Google","Meta","Microsoft","Netflix","Uber"],"eli5":"Imagine you're building with LEGOs! When you start making a new toy, the first thing you do is open the LEGO box and lay out all your pieces. That's exactly what onCreate() does - it's like opening the toy box and getting everything ready before you start playing. Just like you need to see all your LEGO pieces first before you can build your castle, an Android app needs to call onCreate() first to get all its pieces ready before it can show you the screen and start working!","relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"lastUpdated":"2025-12-25T16:45:33.939Z","createdAt":"2025-12-26 12:51:07"}],"subChannels":["architecture","general","jetpack-compose","lifecycle"],"companies":["Adobe","Airbnb","Amazon","Citadel","Databricks","Goldman Sachs","Google","Meta","Microsoft","MongoDB","Netflix","Oracle","Tesla","Two Sigma","Uber"],"stats":{"total":7,"beginner":4,"intermediate":3,"advanced":0,"newThisWeek":7}}