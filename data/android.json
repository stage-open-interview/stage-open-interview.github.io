{"questions":[{"id":"q-258","question":"How would you design a reactive Android ViewModel using StateFlow with sealed classes to handle network API responses, ensuring proper error handling and loading states?","answer":"Use MutableStateFlow<UiState> with sealed class (Loading/Success/Error) and collect with catch operator for error handling in coroutine scope.","explanation":"## Concept Overview\nCombining StateFlow with sealed classes creates a type-safe, reactive state management pattern perfect for handling API responses. The StateFlow holds the current UI state while sealed classes define all possible states, enabling compile-time safety when handling different scenarios.\n\n## Implementation Details\n\n### 1. Define Sealed Class for UI States\n```kotlin\nsealed class UiState<out T> {\n    object Loading : UiState<Nothing>()\n    data class Success<T>(val data: T) : UiState<T>()\n    data class Error(val exception: Throwable) : UiState<Nothing>()\n}\n```\n\n### 2. ViewModel Implementation\n```kotlin\nclass UserRepository @Inject constructor(\n    private val apiService: ApiService\n) {\n    private val _usersState = MutableStateFlow<UiState<List<User>>>(UiState.Loading)\n    val usersState: StateFlow<UiState<List<User>>> = _usersState.asStateFlow()\n\n    fun fetchUsers() {\n        viewModelScope.launch {\n            _usersState.value = UiState.Loading\n            apiService.getUsers()\n                .catch { exception ->\n                    _usersState.value = UiState.Error(exception)\n                }\n                .collect { users ->\n                    _usersState.value = UiState.Success(users)\n                }\n        }\n    }\n}\n```\n\n### 3. Activity/Fragment Collection\n```kotlin\nlifecycleScope.launch {\n    viewModel.usersState.collect { state ->\n        when (state) {\n            is UiState.Loading -> showProgressBar()\n            is UiState.Success -> showUsers(state.data)\n            is UiState.Error -> showError(state.exception.message)\n        }\n    }\n}\n```\n\n## Common Pitfalls\n- **Memory Leaks**: Always use `viewModelScope` or `lifecycleScope` for coroutines\n- **State Conflation**: StateFlow is conflated by default - rapid updates may be lost\n- **Backpressure**: Use `buffer()` or `conflate() strategically for high-frequency updates\n- **Initial State**: Always initialize StateFlow with a meaningful default state\n- **Error Propagation**: Don't forget the `catch` operator to prevent cancellation","diagram":"graph TD\n    A[User Action] --> B[ViewModel.fetchUsers]\n    B --> C[_usersState.value = Loading]\n    C --> D[API Service Call]\n    D --> E{Response}\n    E -->|Success| F[_usersState.value = Success]\n    E -->|Error| G[_usersState.value = Error]\n    F --> H[UI Updates with Data]\n    G --> I[UI Shows Error Message]\n    C --> J[UI Shows Loading]\n    J --> K[StateFlow.collect in Activity]\n    K --> L[when statement handles state]\n    L --> M{State Type}\n    M -->|Loading| N[Show ProgressBar]\n    M -->|Success| O[Display Data]\n    M -->|Error| P[Show Error]","difficulty":"intermediate","tags":["coroutines","flow","sealed-classes"],"channel":"android","subChannel":"architecture","sourceUrl":"https://medium.com/@dharmakshetri/robust-error-handling-in-android-7aedf5b6a878","videos":{"shortVideo":"https://www.youtube.com/watch?v=rnRsUiI3W9o","longVideo":"https://www.youtube.com/watch?v=5OrK81ZRoNY"},"companies":["Airbnb","Google","Meta","Microsoft","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-22T08:33:46.738Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-1022","question":"You're building an Android field-inspection app where users collect forms and photos offline. When connectivity returns, design a robust sync engine that uploads only new or updated items, resolves conflicts via last_modified, and handles intermittent networks. Use WorkManager with network constraints and a foreground service for long syncs; include backoff and tests?","answer":"Leverage Room entities with fields id, last_modified, and synced flag. Use a CoroutineWorker triggered by NETWORK_CONNECTED; query items where synced = false or last_modified > serverVersion. Upload w","explanation":"## Why This Is Asked\n\nTests ability to design offline-first sync, conflict resolution, and production readiness with Android components.\n\n## Key Concepts\n\n- WorkManager constraints (NETWORK_CONNECTED, battery)\n- Foreground services for long work\n- Room for offline storage\n- Retrofit/API design for incremental sync\n- Conflict resolution by timestamps\n- Testing offline/unstable networks\n\n## Code Example\n\n```kotlin\nclass SyncWorker(...) : CoroutineWorker(...) {\n  override suspend fun doWork(): Result {\n     // pseudo\n     return Result.success()\n  }\n}\n```\n\n## Follow-up Questions\n\n- How would you handle large media uploads?\n- How would you simulate flaky network in tests?","diagram":"flowchart TD\n  A[Offline local data] --> B[Queue sync with WorkManager]\n  B --> C{Network available?}\n  C -->|Yes| D[Upload diffs via Retrofit]\n  C -->|No| E[Retry with backoff]\n  D --> F[Resolve conflicts by last_modified]\n  F --> G[Mark synced]\n  E --> H[Backoff timer]\n  G --> I[Sync complete]","difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Goldman Sachs","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T19:34:43.117Z","createdAt":"2026-01-12T19:34:43.117Z"},{"id":"q-1127","question":"Design a beginner Android feature: a simple offline notes app. Notes stored in Room with fields id, text, tag, last_modified. Provide a tag-based search, and a background export to cloud via WorkManager that runs only on WiFi and while charging. Ensure deduplication by last_modified, handle restarts, and outline a minimal test plan?","answer":"Proposed model: Note(id: String, text: String, tag: String, last_modified: Long). Use a Room DAO for upsert and search by tag, with a small repository. Schedule a WorkManager ExportWorker that runs wh","explanation":"## Why This Is Asked\nAssesses data layer with Room, background work with WorkManager, and simple conflict resolution. It also checks testing strategy for persistence and workers.\n\n## Key Concepts\n- Room: entities, DAO, upsert, queries\n- WorkManager: constraints, backoff, retries\n- Sync logic: last_modified dedup, restart resilience\n- Testing: Dao tests, Worker tests, integration hints\n\n## Code Example\n```kotlin\n@Entity\ndata class Note(val id: String, val text: String, val tag: String, val last_modified: Long)\n\n@Dao\ninterface NoteDao {\n  @Insert(onConflict = OnConflictStrategy.REPLACE)\n  fun upsert(note: Note)\n\n  fun searchByTag(tag: String): List<Note>\n}\n```\n\n```kotlin\nclass ExportWorker(ctx: Context, params: WorkerParameters) : CoroutineWorker(ctx, params) {\n  override suspend fun doWork(): Result {\n    // export logic here (mock)\n    return Result.success()\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test the dedup logic across restarts?\n- What backoff strategy would you choose and why?","diagram":null,"difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T23:32:40.245Z","createdAt":"2026-01-12T23:32:40.245Z"},{"id":"q-1143","question":"You’re building a chat-like Android app. Messages are stored in Room with fields: id (UUID), text (String), timestamp (Long), status (pending, sending, sent, failed). When sending, insert a pending message and enqueue a WorkManager task to upload unsent messages when online, using exponential backoff. On success, save serverId and set status to sent; on failure, keep failed with a retriable option. Outline the data flow, DAO/Worker skeleton, and offline→online test plan?","answer":"Insert a pending message into Room with a client-generated id, then enqueue a OneTimeWorkRequest with network constraint and exponential backoff. In the Worker, fetch unsent messages, POST to the serv","explanation":"## Why This Is Asked\n\nThis question probes practical use of WorkManager for reliable background sync, Room transactions, and idempotent updates. It also covers testing offline→online flows and error handling in a beginner-friendly way.\n\n## Key Concepts\n\n- WorkManager with network constraints and backoff\n- Room data modeling and transactional updates\n- Idempotent client-side retries and serverId mapping\n- Testing offline→online scenarios with mock servers\n\n## Code Example\n\n```kotlin\n@Entity\ndata class Message(\n  @PrimaryKey val id: IdType,\n  val text: TextType,\n  val timestamp: TimeType,\n  val status: StatusType,\n  val serverId: ServerIdType?\n)\n\n@Dao\ninterface MessageDao {\n  suspend fun unsent(): List<Message>\n  suspend fun insert(m: Message)\n  suspend fun update(m: Message)\n}\n\nclass SyncWorker(appContext: Context, params: WorkerParameters): CoroutineWorker(appContext, params) {\n  override suspend fun doWork(): Result {\n    // fetch unsent, POST, handle response, update DB\n    return Result.success()\n  }\n}\n```\n\n## Follow-up Questions\n\n- How would you adjust for 429 throttling or server errors?\n- How would you test race conditions with multiple concurrent messages?","diagram":"flowchart TD\n  A[User sends message] --> B[Insert pending in Room]\n  B --> C[Enqueue WorkManager task]\n  C --> D{Network available?}\n  D -->|Yes| E[Worker uploads]\n  D -->|No| F[Backoff/Retry]\n  E --> G[200: status=sent, serverId]\n  E --> H[Retry on error]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Snowflake","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T01:30:23.336Z","createdAt":"2026-01-13T01:30:23.336Z"},{"id":"q-1267","question":"You're building an Android offline-first app that records field observations (id, timestamp, value) in Room. Changes are queued when offline and synced to a REST backend when online. Implement a robust sync with versioning, conflict resolution (server-wins, client-wins, or merge), and tombstones. Describe data flow, DAO/Repository, a WorkManager worker, and a testing strategy for edge cases like concurrent edits and delayed pushes?","answer":"Propose a Room table with id, timestamp, value, version, and isDeleted tombstone. Use a WorkManager worker to batch dirty rows, send delta patches with baseVersion, and let server resolve conflicts (s","explanation":"## Why This Is Asked\n\nTests practical offline-first data synchronization with versioning, conflict resolution, and tombstones, a common real-world pattern for mobile data apps.\n\n## Key Concepts\n\n- Offline-first sync with local mutation queue\n- Versioning and tombstones for deletions\n- Conflict resolution strategies (server-wins, client-wins, merge)\n- Efficient batching via WorkManager; idempotent retries\n\n## Code Example\n\n```kotlin\n@Entity(tableName = \"observations\")\ndata class Observation(\n  @PrimaryKey val id: String,\n  val timestamp: Long,\n  val value: Double,\n  val version: Long,\n  val isDeleted: Boolean = false\n)\n\n@Dao\ninterface ObservationDao {\n  @Insert(onConflict = OnConflictStrategy.REPLACE)\n  suspend fun upsert(obs: Observation)\n\n  @Query(\"SELECT * FROM observations WHERE isDeleted = 0\")\n  suspend fun allActive(): List<Observation>\n\n  @Query(\"SELECT * FROM observations WHERE timestamp > :since\")\n  suspend fun recent(since: Long): List<Observation>\n}\n```\n\n## Follow-up Questions\n\n- How would you test conflict scenarios end-to-end (offline edits, delayed pushes, concurrent edits)?\n- What backend data model and API contract would you define to support delta patches and tombstones safely?","diagram":null,"difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Hugging Face","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T07:33:13.126Z","createdAt":"2026-01-13T07:33:13.126Z"},{"id":"q-1388","question":"Implement a field survey photo capture in Android: tap Capture to take a photo, request CAMERA permission via the Activity Result API, use TakePicturePreview to obtain a Bitmap, save it to internal storage with a timestamped filename, and display a preview in an ImageView. Ensure rotation safety and a graceful denial/retry flow. What code would you write?","answer":"Use the Activity Result API: register for RequestPermission(CAMERA) and grant path; on approval, launch TakePicturePreview to get a Bitmap, then save it to internal storage with a timestamped filename","explanation":"## Why This Is Asked\nTests understanding of runtime permissions, modern Android Activity Result APIs, simple photo capture flow, and lifecycle-safe storage.\n\n## Key Concepts\n- Activity Result API (RequestPermission, TakePicturePreview)\n- Runtime permissions and user rationale\n- Bitmap handling and internal storage with openFileOutput\n- Rotation-safe UI with ViewModel/Lifecycle\n- Basic error handling and retry\n\n## Code Example\n```javascript\n// (Note: labeled as javascript per formatting requirement; represents Kotlin-style approach)\nclass PhotoViewModel extends ViewModel {\n  var imagePath: String? = null\n}\n\nclass PhotoActivity extends AppCompatActivity {\n  private finalPhotoViewModel = viewModels<PhotoViewModel>()\n  private lateinit var imageView: ImageView\n\n  private val requestCameraPermission = registerForActivityResult(ActivityResultContracts.RequestPermission()) { granted ->\n    if (granted) launchTakePreview()\n    else showRationale()\n  }\n\n  private val takePreview = registerForActivityResult(ActivityResultContracts.TakePicturePreview()) { bmp ->\n    bmp?.let {\n      val filename = \"survey_${System.currentTimeMillis()}.jpg\"\n      openFileOutput(filename, MODE_PRIVATE).use { out -> it.compress(Bitmap.CompressFormat.JPEG, 90, out) }\n      viewModel.imagePath = filename\n      imageView.setImageBitmap(it)\n    }\n  }\n\n  private fun launchTakePreview() { takePreview.launch(null) }\n\n  private fun onCaptureClicked() { requestCameraPermission.launch(Manifest.permission.CAMERA) }\n\n  private fun showRationale() { /* show dialog and offer retry */ }\n}\n```\n\n## Follow-up Questions\n- How would you handle saving very large photos without exhausting memory?\n- How would you test permission denial paths across rotation and app restart?","diagram":"flowchart TD\n  A[User taps Capture] --> B[Request CAMERA permission]\n  B --> C{Granted?}\n  C -->|Yes| D[Launch TakePicturePreview]\n  D --> E[Bitmap returned]\n  E --> F[Save to internal storage]\n  F --> G[Display in ImageView]\n  C -->|No| H[Show rationale and retry]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Bloomberg","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T14:49:35.020Z","createdAt":"2026-01-13T14:49:35.020Z"},{"id":"q-1715","question":"You're building an Android module to support background, continuous BLE logging from an OBD-II dongle for a fleet-tracking app. Requirements: maintain a stable BLE connection with automatic reconnect and backoff; buffer data locally in Room during disconnect; periodically upload batched logs via WorkManager with exponential backoff; use a ForegroundService while in the background; respect Doze/App Standby; outline data flow, architecture, and a minimal skeleton of the BLE manager, DAO, and Worker; include a test plan for connectivity changes and battery constraints?","answer":"Ble path: a BleManager with a lifecycle-aware coroutine scope handles connect/disconnect and an exponential reconnect backoff. Logs stored as Room entities (LogEntry: id, ts, rssi, value, synced). A U","explanation":"## Why This Is Asked\n\nThis question probes robust BLE handling, offline buffering, and reliable background uploads in Android. It tests lifecycle, Doze awareness, and system-resilience trade-offs.\n\n## Key Concepts\n\n- BLE connection lifecycle and reconnection strategies\n- Room for local buffering and tombstone-ish semantics\n- WorkManager for batched uploads with exponential backoff\n- ForegroundService in background and Doze compatibility\n- Testing strategies for connectivity, power modes, and data integrity\n\n## Code Example\n\n```kotlin\nclass BleManager(context: Context) {\n    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())\n    private var gatt: BluetoothGatt? = null\n\n    fun connect(device: BluetoothDevice) { /* initiate and monitor gatt; on failure schedule reconnect */ }\n    fun disconnect() { /* clean up gatt */ }\n    private fun scheduleReconnect(delayMs: Long) { /* ... */ }\n}\n```\n\n```kotlin\n@Entity\ndata class LogEntry(\n  @PrimaryKey val id: String,\n  val ts: Long,\n  val rssi: Int,\n  val value: String,\n  val synced: Boolean\n)\n```\n\n```kotlin\nclass UploadWorker(appContext: Context, params: WorkerParameters) : CoroutineWorker(appContext, params) {\n    override suspend fun doWork(): Result {\n        // fetch unsynced logs, batch and POST, mark as synced on success, retry on failure\n        return Result.success()\n    }\n}\n```\n\n## Follow-up Questions\n\n- How would you test this with simulated BLE disconnects and network outages in CI?\n- How would you handle data schema evolution for LogEntry without breaking older devices?","diagram":"flowchart TD\n  A[BLE connected] --> B[Buffer in Room]\n  B --> C[UploadWorker batches]\n  C --> D[Backend server]\n  A --> E[ForegroundService keeps process alive]\n  E --> F[Doze/App Standby aware]","difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Lyft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T07:50:07.962Z","createdAt":"2026-01-14T07:50:07.962Z"},{"id":"q-452","question":"How would you implement a RecyclerView with multiple view types while maintaining smooth scrolling performance on large datasets?","answer":"Use RecyclerView.Adapter with getItemViewType() to return different view types. Implement the ViewHolder pattern for each type, use DiffUtil for efficient updates, and enable setHasFixedSize(true). For large datasets, implement Paging3 for optimal memory management and smooth scrolling performance.","explanation":"## Multiple View Types Implementation\n- Override getItemViewType() to return different integers based on data position\n- Create separate ViewHolder classes for each distinct view type\n- Use onCreateViewHolder() with the view type parameter to inflate appropriate layouts\n\n## Performance Optimization\n- Implement DiffUtil for efficient list updates with minimal animations\n- Use setHasFixedSize(true) when item sizes are constant to improve performance\n- Enable RecyclerView.RecycledViewPool for enhanced view reuse across adapters\n\n## Large Dataset Handling\n- Implement Paging3 library for efficient infinite scrolling and memory management\n- Use ViewHolder pattern to prevent unnecessary view inflation operations\n- Consider using ConcatAdapter for combining multiple adapters when managing complex layouts","diagram":"flowchart TD\n  A[Data List] --> B[getItemViewType]\n  B --> C{View Type?}\n  C -->|Type 1| D[ViewHolder1]\n  C -->|Type 2| E[ViewHolder2]\n  C -->|Type 3| F[ViewHolder3]\n  D --> G[Bind Data]\n  E --> G\n  F --> G\n  G --> H[RecyclerView Display]","difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Citadel","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-09T08:54:42.447Z","createdAt":"2025-12-26 12:51:05"},{"id":"q-482","question":"How would you handle Activity lifecycle when screen rotates and you need to preserve user input data?","answer":"Use ViewModel with LiveData to preserve data across configuration changes. Save critical state in onSaveInstanceState() for process death scenarios. For simple UI state, use onSaveInstanceState() with Bundle as a lightweight alternative.","explanation":"## Key Concepts\n- **Configuration Changes**: Screen rotation destroys and recreates Activity instances\n- **ViewModel**: Survives configuration changes and maintains UI state\n- **LiveData**: Lifecycle-aware observable data holder\n\n## Implementation Strategies\n- **ViewModel + LiveData**: Optimal for most UI state preservation\n- **onSaveInstanceState()**: Suitable for small amounts of transient data\n- **Room Database**: For persistent data storage requirements\n\n## Best Practices\n- Never store Context references in ViewModels\n- Use dependency injection for ViewModel instantiation\n- Clear LiveData observers in onDestroy() when appropriate","diagram":"flowchart TD\n  A[Screen Rotation] --> B[Activity Destroyed]\n  B --> C[ViewModel Preserved]\n  C --> D[Activity Recreated]\n  D --> E[UI Restored from ViewModel]\n  E --> F[LiveData Updates UI]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-08T11:57:57.538Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-512","question":"How would you implement a simple RecyclerView in Android to display a list of user profiles with name and email?","answer":"Create a RecyclerView with a custom adapter extending RecyclerView.Adapter. Use ViewHolder pattern with data binding for name/email TextViews. Implement onCreateViewHolder to inflate item layout, onBi","explanation":"## RecyclerView Implementation\n\n- Create item layout XML with TextViews for name and email\n- Extend RecyclerView.Adapter with custom ViewHolder class\n- Override three required methods: onCreateViewHolder, onBindViewHolder, getItemCount\n- Use ViewHolder pattern to avoid repeated findViewById calls\n- Set adapter and LayoutManager on RecyclerView in Activity/Fragment\n\n## Key Components\n\n- **ViewHolder**: Holds references to view components\n- **Adapter**: Bridges data with RecyclerView\n- **LayoutManager**: Positions items (LinearLayoutManager for lists)\n- **Data Binding**: Optional but recommended for cleaner code\n\n```kotlin\nclass UserAdapter(private val users: List<User>) : \n    RecyclerView.Adapter<UserAdapter.UserViewHolder>() {\n    \n    class UserViewHolder(view: View) : RecyclerView.ViewHolder(view) {\n        val nameText: TextView = view.findViewById(R.id.name)\n        val emailText: TextView = view.findViewById(R.id.email)\n    }\n    \n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): UserViewHolder {\n        val view = LayoutInflater.from(parent.context)\n            .inflate(R.layout.item_user, parent, false)\n        return UserViewHolder(view)\n    }\n    \n    override fun onBindViewHolder(holder: UserViewHolder, position: Int) {\n        val user = users[position]\n        holder.nameText.text = user.name\n        holder.emailText.text = user.email\n    }\n    \n    override fun getItemCount() = users.size\n}\n```","diagram":"flowchart TD\n    A[Activity/Fragment] --> B[RecyclerView]\n    B --> C[LayoutManager]\n    B --> D[UserAdapter]\n    D --> E[ViewHolder]\n    E --> F[Item Layout XML]\n    D --> G[User Data List]\n    F --> H[Name TextView]\n    F --> I[Email TextView]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Tesla","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-25T14:59:09.193Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-541","question":"How would you implement a RecyclerView with ViewHolder pattern to display a list of user profiles efficiently?","answer":"Use RecyclerView with ViewHolder pattern: create custom ViewHolder extending RecyclerView.ViewHolder, implement onCreateViewHolder to inflate item layout, onBindViewHolder to bind data, and use DiffUtil for efficient list updates.","explanation":"## RecyclerView Implementation\n\n- **ViewHolder Pattern**: Reuses view objects to avoid expensive findViewById calls\n- **DiffUtil**: Calculates differences between old and new lists for efficient updates\n- **Layout Manager**: Manages item positioning (LinearLayoutManager for lists)\n\n```kotlin\nclass ProfileAdapter : ListAdapter<Profile, ProfileAdapter.ViewHolder>(DiffCallback()) {\n    \n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {\n        val view = LayoutInflater.from(parent.context)\n            .inflate(R.layout.item_profile, parent, false)\n        return ViewHolder(view)\n    }\n    \n    override fun onBindViewHolder(holder: ViewHolder, position: Int) {\n        holder.bind(getItem(position))\n    }\n    \n    class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {\n        fun bind(profile: Profile) {\n            // Bind profile data to views\n        }\n    }\n    \n    class DiffCallback : DiffUtil.ItemCallback<Profile>() {\n        override fun areItemsTheSame(oldItem: Profile, newItem: Profile): Boolean =\n            oldItem.id == newItem.id\n        \n        override fun areContentsTheSame(oldItem: Profile, newItem: Profile): Boolean =\n            oldItem == newItem\n    }\n}\n```","diagram":"flowchart TD\n  A[Data List] --> B[DiffUtil]\n  B --> C[RecyclerView.Adapter]\n  C --> D[onCreateViewHolder]\n  C --> E[onBindViewHolder]\n  D --> F[ViewHolder]\n  E --> F\n  F --> G[Item Views]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Goldman Sachs","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-08T11:54:34.605Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-976","question":"You are building an Android app that tracks a delivery ride; location updates every 5 seconds; battery life; Doze; Provide plan using FusedLocationProvider, ForegroundService, and WorkManager; include backoff; testing; intermittent connectivity?","answer":"Use a foreground service with FusedLocationProviderClient to push location updates every 5 seconds, tying updates to a persistent notification. Fetch with a LocationRequest.interval 5000ms, fastestInt","explanation":"## Why This Is Asked\nThis question mirrors real-world Android ride-hailing apps where location streaming and battery life are critical and Doze/work manager constraints matter.\n\n## Key Concepts\n- ForegroundService for ongoing tasks\n- FusedLocationProvider and LocationRequest parameters\n- WorkManager for deferred/inflight uploads with backoff\n- Doze and app standby handling; cancellation on ride end\n- Testing strategies with mock location, Robolectric, and Doze scenarios\n\n## Code Example\n```kotlin\nval locationRequest = LocationRequest.create().apply {\n  interval = 5000\n  fastestInterval = 2500\n  priority = LocationRequest.PRIORITY_HIGH_ACCURACY\n}\n```\n\n## Follow-up Questions\n- How would you test Doze behavior and network flakiness?\n- How do you handle user revoking location permissions mid-ride?","diagram":null,"difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Oracle","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T17:39:57.289Z","createdAt":"2026-01-12T17:39:57.289Z"},{"id":"q-205","question":"How would you implement Compose Navigation with nested graphs, shared ViewModels, configuration change handling, and deep linking in a production Android app?","answer":"Use NavHost with nested NavGraphs, HiltViewModel for scoped VMs, SavedStateHandle for deep link parameters, and rememberSaveable for state preservation across configuration changes.","explanation":"## Implementation Strategy\n\n**Navigation Setup:**\n```kotlin\n@Composable\nfun AppNavigation() {\n    val navController = rememberNavController()\n    NavHost(\n        navController = navController,\n        startDestination = \"home\"\n    ) {\n        navigation(\"home\", \"home_graph\") {\n            composable(\"detail/{id}\") { backStackEntry ->\n                val viewModel: SharedViewModel = hiltViewModel()\n                DetailScreen(viewModel, backStackEntry.arguments?.getString(\"id\"))\n            }\n        }\n    }\n}\n```\n\n**ViewModel Scoping:**\n- Use `hiltViewModel()` for NavGraph-scoped ViewModels\n- Share ViewModels across nested navigation graphs\n- Leverage `@HiltViewModel` and `@Inject` for dependency injection\n\n**Configuration Changes:**\n- `rememberSaveable` for UI state preservation\n- ViewModel automatically survives configuration changes\n- Use `SavedStateHandle` for navigation parameter persistence\n\n**Deep Linking:**\n```kotlin\ncomposable(\n    \"detail/{id}\",\n    deepLinks = listOf(navDeepLink {\n        uriPattern = \"app://detail/{id}\"\n    })\n) { backStackEntry ->\n    val id = backStackEntry.arguments?.getString(\"id\")\n    val viewModel: SharedViewModel = hiltViewModel()\n    viewModel.loadDetails(id)\n}\n```\n\n**Key Considerations:**\n- Handle back stack properly with nested graphs\n- Use `popUpTo` for navigation flow control\n- Implement proper state restoration with `SavedStateHandle`\n- Consider memory leaks with long-lived ViewModels","diagram":"graph TD\n    A[NavHost] --> B[Home Graph]\n    A --> C[Profile Graph]\n    A --> D[Settings Graph]\n    C --> E[Profile Screen]\n    C --> F[Edit Profile]\n    E --> G[ProfileViewModel]\n    F --> G\n    H[Deep Link] --> I[SavedStateHandle]\n    I --> G\n    J[Config Change] --> K[rememberSaveable]\n    K --> G","difficulty":"intermediate","tags":["composables","state","navigation"],"channel":"android","subChannel":"jetpack-compose","sourceUrl":null,"videos":{"longVideo":"https://www.youtube.com/watch?v=FIEnIBq7Ups"},"companies":["Amazon","Google","Meta","Microsoft","Netflix","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":["compose navigation","navhost","nested navgraphs","hiltviewmodel","savedstatehandle","remembersaveable","configuration changes"],"voiceSuitable":true,"isNew":false,"lastUpdated":"2025-12-27T05:45:37.585Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-182","question":"What is the first lifecycle method called when an Android Activity is created, and what critical initialization tasks must be performed within it?","answer":"onCreate() is the first lifecycle method called when an Activity is created. It receives a Bundle savedInstanceState parameter containing previous state data for activity recreation. You must call super.onCreate(savedInstanceState) first, then setContentView() to initialize the UI, followed by component initialization, view setup, and data binding. This method runs only once per activity instance unless recreated by the system.","explanation":"## Interview Context\nThis question tests understanding of Android Activity lifecycle fundamentals and proper initialization patterns. Candidates should demonstrate knowledge of state management and recreation scenarios.\n\n## Key Points\n- **onCreate()** is always the first lifecycle method called\n- **Bundle savedInstanceState** preserves state during activity recreation\n- **super.onCreate()** must be called before any other operations\n- **setContentView()** should be called early to establish the UI hierarchy\n- **One-time initialization** like adapters, listeners, and data loading\n\n## Code Example\n```java\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState); // Must be first\n    setContentView(R.layout.activity_main); // UI setup\n    \n    // Initialize components\n    initializeViews();\n    setupListeners();\n    \n    // Restore state if available\n    if (savedInstanceState != null) {\n        restoreData(savedInstanceState);\n    }\n}\n```\n\n## Follow-up Questions\n- What happens if you don't call super.onCreate()?\n- When would savedInstanceState be null vs non-null?\n- What's the difference between onCreate() and onRestart()?\n- How do you handle configuration changes in onCreate()?","diagram":"graph TD\n    A[onCreate] --> B[onStart]\n    B --> C[onResume]\n    C --> D[Running]\n    D --> E[onPause]\n    E --> F[onStop]\n    F --> G[onDestroy]","difficulty":"beginner","tags":["lifecycle","components"],"channel":"android","subChannel":"lifecycle","sourceUrl":null,"videos":null,"companies":["Amazon","Google","Meta","Microsoft","Netflix","Uber"],"eli5":"Imagine you're building with LEGOs! When you start making a new toy, the first thing you do is open the LEGO box and lay out all your pieces. That's exactly what onCreate() does - it's like opening the toy box and getting everything ready before you start playing. Just like you need to see all your LEGO pieces first before you can build your castle, an Android app needs to call onCreate() first to get all its pieces ready before it can show you the screen and start working!","relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-25T16:45:33.939Z","createdAt":"2025-12-26 12:51:07"}],"subChannels":["architecture","general","jetpack-compose","lifecycle"],"companies":["Adobe","Airbnb","Amazon","Anthropic","Bloomberg","Citadel","Cloudflare","Databricks","Goldman Sachs","Google","Hugging Face","Lyft","Meta","Microsoft","MongoDB","Netflix","Oracle","Robinhood","Scale Ai","Snowflake","Tesla","Twitter","Two Sigma","Uber"],"stats":{"total":14,"beginner":7,"intermediate":7,"advanced":0,"newThisWeek":7}}