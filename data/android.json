{"questions":[{"id":"q-258","question":"How would you design a reactive Android ViewModel using StateFlow with sealed classes to handle network API responses, ensuring proper error handling and loading states?","answer":"Use MutableStateFlow<UiState> with sealed class (Loading/Success/Error) and collect with catch operator for error handling in coroutine scope.","explanation":"## Concept Overview\nCombining StateFlow with sealed classes creates a type-safe, reactive state management pattern perfect for handling API responses. The StateFlow holds the current UI state while sealed classes define all possible states, enabling compile-time safety when handling different scenarios.\n\n## Implementation Details\n\n### 1. Define Sealed Class for UI States\n```kotlin\nsealed class UiState<out T> {\n    object Loading : UiState<Nothing>()\n    data class Success<T>(val data: T) : UiState<T>()\n    data class Error(val exception: Throwable) : UiState<Nothing>()\n}\n```\n\n### 2. ViewModel Implementation\n```kotlin\nclass UserRepository @Inject constructor(\n    private val apiService: ApiService\n) {\n    private val _usersState = MutableStateFlow<UiState<List<User>>>(UiState.Loading)\n    val usersState: StateFlow<UiState<List<User>>> = _usersState.asStateFlow()\n\n    fun fetchUsers() {\n        viewModelScope.launch {\n            _usersState.value = UiState.Loading\n            apiService.getUsers()\n                .catch { exception ->\n                    _usersState.value = UiState.Error(exception)\n                }\n                .collect { users ->\n                    _usersState.value = UiState.Success(users)\n                }\n        }\n    }\n}\n```\n\n### 3. Activity/Fragment Collection\n```kotlin\nlifecycleScope.launch {\n    viewModel.usersState.collect { state ->\n        when (state) {\n            is UiState.Loading -> showProgressBar()\n            is UiState.Success -> showUsers(state.data)\n            is UiState.Error -> showError(state.exception.message)\n        }\n    }\n}\n```\n\n## Common Pitfalls\n- **Memory Leaks**: Always use `viewModelScope` or `lifecycleScope` for coroutines\n- **State Conflation**: StateFlow is conflated by default - rapid updates may be lost\n- **Backpressure**: Use `buffer()` or `conflate() strategically for high-frequency updates\n- **Initial State**: Always initialize StateFlow with a meaningful default state\n- **Error Propagation**: Don't forget the `catch` operator to prevent cancellation","diagram":"graph TD\n    A[User Action] --> B[ViewModel.fetchUsers]\n    B --> C[_usersState.value = Loading]\n    C --> D[API Service Call]\n    D --> E{Response}\n    E -->|Success| F[_usersState.value = Success]\n    E -->|Error| G[_usersState.value = Error]\n    F --> H[UI Updates with Data]\n    G --> I[UI Shows Error Message]\n    C --> J[UI Shows Loading]\n    J --> K[StateFlow.collect in Activity]\n    K --> L[when statement handles state]\n    L --> M{State Type}\n    M -->|Loading| N[Show ProgressBar]\n    M -->|Success| O[Display Data]\n    M -->|Error| P[Show Error]","difficulty":"intermediate","tags":["coroutines","flow","sealed-classes"],"channel":"android","subChannel":"architecture","sourceUrl":"https://medium.com/@dharmakshetri/robust-error-handling-in-android-7aedf5b6a878","videos":{"shortVideo":"https://www.youtube.com/watch?v=rnRsUiI3W9o","longVideo":"https://www.youtube.com/watch?v=5OrK81ZRoNY"},"companies":["Airbnb","Google","Meta","Microsoft","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-22T08:33:46.738Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-1022","question":"You're building an Android field-inspection app where users collect forms and photos offline. When connectivity returns, design a robust sync engine that uploads only new or updated items, resolves conflicts via last_modified, and handles intermittent networks. Use WorkManager with network constraints and a foreground service for long syncs; include backoff and tests?","answer":"Leverage Room entities with fields id, last_modified, and synced flag. Use a CoroutineWorker triggered by NETWORK_CONNECTED; query items where synced = false or last_modified > serverVersion. Upload w","explanation":"## Why This Is Asked\n\nTests ability to design offline-first sync, conflict resolution, and production readiness with Android components.\n\n## Key Concepts\n\n- WorkManager constraints (NETWORK_CONNECTED, battery)\n- Foreground services for long work\n- Room for offline storage\n- Retrofit/API design for incremental sync\n- Conflict resolution by timestamps\n- Testing offline/unstable networks\n\n## Code Example\n\n```kotlin\nclass SyncWorker(...) : CoroutineWorker(...) {\n  override suspend fun doWork(): Result {\n     // pseudo\n     return Result.success()\n  }\n}\n```\n\n## Follow-up Questions\n\n- How would you handle large media uploads?\n- How would you simulate flaky network in tests?","diagram":"flowchart TD\n  A[Offline local data] --> B[Queue sync with WorkManager]\n  B --> C{Network available?}\n  C -->|Yes| D[Upload diffs via Retrofit]\n  C -->|No| E[Retry with backoff]\n  D --> F[Resolve conflicts by last_modified]\n  F --> G[Mark synced]\n  E --> H[Backoff timer]\n  G --> I[Sync complete]","difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Goldman Sachs","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T19:34:43.117Z","createdAt":"2026-01-12T19:34:43.117Z"},{"id":"q-1127","question":"Design a beginner Android feature: a simple offline notes app. Notes stored in Room with fields id, text, tag, last_modified. Provide a tag-based search, and a background export to cloud via WorkManager that runs only on WiFi and while charging. Ensure deduplication by last_modified, handle restarts, and outline a minimal test plan?","answer":"Proposed model: Note(id: String, text: String, tag: String, last_modified: Long). Use a Room DAO for upsert and search by tag, with a small repository. Schedule a WorkManager ExportWorker that runs wh","explanation":"## Why This Is Asked\nAssesses data layer with Room, background work with WorkManager, and simple conflict resolution. It also checks testing strategy for persistence and workers.\n\n## Key Concepts\n- Room: entities, DAO, upsert, queries\n- WorkManager: constraints, backoff, retries\n- Sync logic: last_modified dedup, restart resilience\n- Testing: Dao tests, Worker tests, integration hints\n\n## Code Example\n```kotlin\n@Entity\ndata class Note(val id: String, val text: String, val tag: String, val last_modified: Long)\n\n@Dao\ninterface NoteDao {\n  @Insert(onConflict = OnConflictStrategy.REPLACE)\n  fun upsert(note: Note)\n\n  fun searchByTag(tag: String): List<Note>\n}\n```\n\n```kotlin\nclass ExportWorker(ctx: Context, params: WorkerParameters) : CoroutineWorker(ctx, params) {\n  override suspend fun doWork(): Result {\n    // export logic here (mock)\n    return Result.success()\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test the dedup logic across restarts?\n- What backoff strategy would you choose and why?","diagram":null,"difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T23:32:40.245Z","createdAt":"2026-01-12T23:32:40.245Z"},{"id":"q-1143","question":"You’re building a chat-like Android app. Messages are stored in Room with fields: id (UUID), text (String), timestamp (Long), status (pending, sending, sent, failed). When sending, insert a pending message and enqueue a WorkManager task to upload unsent messages when online, using exponential backoff. On success, save serverId and set status to sent; on failure, keep failed with a retriable option. Outline the data flow, DAO/Worker skeleton, and offline→online test plan?","answer":"Insert a pending message into Room with a client-generated id, then enqueue a OneTimeWorkRequest with network constraint and exponential backoff. In the Worker, fetch unsent messages, POST to the serv","explanation":"## Why This Is Asked\n\nThis question probes practical use of WorkManager for reliable background sync, Room transactions, and idempotent updates. It also covers testing offline→online flows and error handling in a beginner-friendly way.\n\n## Key Concepts\n\n- WorkManager with network constraints and backoff\n- Room data modeling and transactional updates\n- Idempotent client-side retries and serverId mapping\n- Testing offline→online scenarios with mock servers\n\n## Code Example\n\n```kotlin\n@Entity\ndata class Message(\n  @PrimaryKey val id: IdType,\n  val text: TextType,\n  val timestamp: TimeType,\n  val status: StatusType,\n  val serverId: ServerIdType?\n)\n\n@Dao\ninterface MessageDao {\n  suspend fun unsent(): List<Message>\n  suspend fun insert(m: Message)\n  suspend fun update(m: Message)\n}\n\nclass SyncWorker(appContext: Context, params: WorkerParameters): CoroutineWorker(appContext, params) {\n  override suspend fun doWork(): Result {\n    // fetch unsent, POST, handle response, update DB\n    return Result.success()\n  }\n}\n```\n\n## Follow-up Questions\n\n- How would you adjust for 429 throttling or server errors?\n- How would you test race conditions with multiple concurrent messages?","diagram":"flowchart TD\n  A[User sends message] --> B[Insert pending in Room]\n  B --> C[Enqueue WorkManager task]\n  C --> D{Network available?}\n  D -->|Yes| E[Worker uploads]\n  D -->|No| F[Backoff/Retry]\n  E --> G[200: status=sent, serverId]\n  E --> H[Retry on error]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Snowflake","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T01:30:23.336Z","createdAt":"2026-01-13T01:30:23.336Z"},{"id":"q-1267","question":"You're building an Android offline-first app that records field observations (id, timestamp, value) in Room. Changes are queued when offline and synced to a REST backend when online. Implement a robust sync with versioning, conflict resolution (server-wins, client-wins, or merge), and tombstones. Describe data flow, DAO/Repository, a WorkManager worker, and a testing strategy for edge cases like concurrent edits and delayed pushes?","answer":"Propose a Room table with id, timestamp, value, version, and isDeleted tombstone. Use a WorkManager worker to batch dirty rows, send delta patches with baseVersion, and let server resolve conflicts (s","explanation":"## Why This Is Asked\n\nTests practical offline-first data synchronization with versioning, conflict resolution, and tombstones, a common real-world pattern for mobile data apps.\n\n## Key Concepts\n\n- Offline-first sync with local mutation queue\n- Versioning and tombstones for deletions\n- Conflict resolution strategies (server-wins, client-wins, merge)\n- Efficient batching via WorkManager; idempotent retries\n\n## Code Example\n\n```kotlin\n@Entity(tableName = \"observations\")\ndata class Observation(\n  @PrimaryKey val id: String,\n  val timestamp: Long,\n  val value: Double,\n  val version: Long,\n  val isDeleted: Boolean = false\n)\n\n@Dao\ninterface ObservationDao {\n  @Insert(onConflict = OnConflictStrategy.REPLACE)\n  suspend fun upsert(obs: Observation)\n\n  @Query(\"SELECT * FROM observations WHERE isDeleted = 0\")\n  suspend fun allActive(): List<Observation>\n\n  @Query(\"SELECT * FROM observations WHERE timestamp > :since\")\n  suspend fun recent(since: Long): List<Observation>\n}\n```\n\n## Follow-up Questions\n\n- How would you test conflict scenarios end-to-end (offline edits, delayed pushes, concurrent edits)?\n- What backend data model and API contract would you define to support delta patches and tombstones safely?","diagram":null,"difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Hugging Face","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T07:33:13.126Z","createdAt":"2026-01-13T07:33:13.126Z"},{"id":"q-1388","question":"Implement a field survey photo capture in Android: tap Capture to take a photo, request CAMERA permission via the Activity Result API, use TakePicturePreview to obtain a Bitmap, save it to internal storage with a timestamped filename, and display a preview in an ImageView. Ensure rotation safety and a graceful denial/retry flow. What code would you write?","answer":"Use the Activity Result API: register for RequestPermission(CAMERA) and grant path; on approval, launch TakePicturePreview to get a Bitmap, then save it to internal storage with a timestamped filename","explanation":"## Why This Is Asked\nTests understanding of runtime permissions, modern Android Activity Result APIs, simple photo capture flow, and lifecycle-safe storage.\n\n## Key Concepts\n- Activity Result API (RequestPermission, TakePicturePreview)\n- Runtime permissions and user rationale\n- Bitmap handling and internal storage with openFileOutput\n- Rotation-safe UI with ViewModel/Lifecycle\n- Basic error handling and retry\n\n## Code Example\n```javascript\n// (Note: labeled as javascript per formatting requirement; represents Kotlin-style approach)\nclass PhotoViewModel extends ViewModel {\n  var imagePath: String? = null\n}\n\nclass PhotoActivity extends AppCompatActivity {\n  private finalPhotoViewModel = viewModels<PhotoViewModel>()\n  private lateinit var imageView: ImageView\n\n  private val requestCameraPermission = registerForActivityResult(ActivityResultContracts.RequestPermission()) { granted ->\n    if (granted) launchTakePreview()\n    else showRationale()\n  }\n\n  private val takePreview = registerForActivityResult(ActivityResultContracts.TakePicturePreview()) { bmp ->\n    bmp?.let {\n      val filename = \"survey_${System.currentTimeMillis()}.jpg\"\n      openFileOutput(filename, MODE_PRIVATE).use { out -> it.compress(Bitmap.CompressFormat.JPEG, 90, out) }\n      viewModel.imagePath = filename\n      imageView.setImageBitmap(it)\n    }\n  }\n\n  private fun launchTakePreview() { takePreview.launch(null) }\n\n  private fun onCaptureClicked() { requestCameraPermission.launch(Manifest.permission.CAMERA) }\n\n  private fun showRationale() { /* show dialog and offer retry */ }\n}\n```\n\n## Follow-up Questions\n- How would you handle saving very large photos without exhausting memory?\n- How would you test permission denial paths across rotation and app restart?","diagram":"flowchart TD\n  A[User taps Capture] --> B[Request CAMERA permission]\n  B --> C{Granted?}\n  C -->|Yes| D[Launch TakePicturePreview]\n  D --> E[Bitmap returned]\n  E --> F[Save to internal storage]\n  F --> G[Display in ImageView]\n  C -->|No| H[Show rationale and retry]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Bloomberg","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T14:49:35.020Z","createdAt":"2026-01-13T14:49:35.020Z"},{"id":"q-1715","question":"You're building an Android module to support background, continuous BLE logging from an OBD-II dongle for a fleet-tracking app. Requirements: maintain a stable BLE connection with automatic reconnect and backoff; buffer data locally in Room during disconnect; periodically upload batched logs via WorkManager with exponential backoff; use a ForegroundService while in the background; respect Doze/App Standby; outline data flow, architecture, and a minimal skeleton of the BLE manager, DAO, and Worker; include a test plan for connectivity changes and battery constraints?","answer":"Ble path: a BleManager with a lifecycle-aware coroutine scope handles connect/disconnect and an exponential reconnect backoff. Logs stored as Room entities (LogEntry: id, ts, rssi, value, synced). A U","explanation":"## Why This Is Asked\n\nThis question probes robust BLE handling, offline buffering, and reliable background uploads in Android. It tests lifecycle, Doze awareness, and system-resilience trade-offs.\n\n## Key Concepts\n\n- BLE connection lifecycle and reconnection strategies\n- Room for local buffering and tombstone-ish semantics\n- WorkManager for batched uploads with exponential backoff\n- ForegroundService in background and Doze compatibility\n- Testing strategies for connectivity, power modes, and data integrity\n\n## Code Example\n\n```kotlin\nclass BleManager(context: Context) {\n    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())\n    private var gatt: BluetoothGatt? = null\n\n    fun connect(device: BluetoothDevice) { /* initiate and monitor gatt; on failure schedule reconnect */ }\n    fun disconnect() { /* clean up gatt */ }\n    private fun scheduleReconnect(delayMs: Long) { /* ... */ }\n}\n```\n\n```kotlin\n@Entity\ndata class LogEntry(\n  @PrimaryKey val id: String,\n  val ts: Long,\n  val rssi: Int,\n  val value: String,\n  val synced: Boolean\n)\n```\n\n```kotlin\nclass UploadWorker(appContext: Context, params: WorkerParameters) : CoroutineWorker(appContext, params) {\n    override suspend fun doWork(): Result {\n        // fetch unsynced logs, batch and POST, mark as synced on success, retry on failure\n        return Result.success()\n    }\n}\n```\n\n## Follow-up Questions\n\n- How would you test this with simulated BLE disconnects and network outages in CI?\n- How would you handle data schema evolution for LogEntry without breaking older devices?","diagram":"flowchart TD\n  A[BLE connected] --> B[Buffer in Room]\n  B --> C[UploadWorker batches]\n  C --> D[Backend server]\n  A --> E[ForegroundService keeps process alive]\n  E --> F[Doze/App Standby aware]","difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Lyft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T07:50:07.962Z","createdAt":"2026-01-14T07:50:07.962Z"},{"id":"q-1880","question":"You’re building an Android app that streams live telemetry video from a drone's camera over an unstable network. Using CameraX, encoding with H.264, and a hybrid UDP/TCP transport, design a solution that includes buffering and backpressure, a foreground service with Doze-friendly behavior, adaptive bitrate, and robust error handling. Provide data flow, key classes (StreamingManager, PacketSender), and a skeleton implementation plus an end-to-end test plan for packet loss and latency?","answer":"Implement a bounded circular frame buffer, encode frames with MediaCodec to H.264, stream data via UDP with FEC and a TCP channel for control, and use a ForegroundService with WakeLock to persist in D","explanation":"## Why This Is Asked\nTests ability to design resilient media streaming over unreliable networks on Android, balancing power, latency, and data integrity.\n\n## Key Concepts\n- CameraX and MediaCodec for H.264\n- UDP/TCP hybrid transport with backpressure\n- ForegroundService, WakeLock, Doze compatibility\n- Adaptive bitrate using RTT and packet loss\n- Testing for jitter, drops, and backoffs\n\n## Code Example\n```javascript\nclass StreamingManager {\n  constructor(bufferCapacity = 1024) {}\n  start() {}\n  pushFrame(frame) {}\n}\nclass PacketSender {\n  constructor() {}\n  sendFrame(frame) {}\n}\n```\n\n## Follow-up Questions\n- How would you measure and log end-to-end latency in production?\n- What failure modes would you test (outages, jitter, reordering) and how would you simulate them?","diagram":"flowchart TD\n  A[Camera Frame] --> B[Buffer] \n  B --> C[StreamingManager] \n  C --> D[PacketSender] \n  D --> E[Network (UDP/TCP)]","difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T15:40:17.817Z","createdAt":"2026-01-14T15:40:17.817Z"},{"id":"q-2076","question":"You're building a beginner Android app that logs field visits. The main screen shows a list of visits (id, siteName, timestamp). Implement adding a visit via a dialog, persist with Room, and a DataStore-backed sort toggle (timestamp ascending/descending) that preserves the choice across rotations. Describe data flow, DAO/Repository, ViewModel, and a minimal UI test plan?","answer":"Use MVVM with Room and DataStore. Visit entity(id, siteName, timestamp). DAO supports insert and query with sort order. Repository mediates. ViewModel exposes LiveData<List<Visit>> driven by a sortOrder preference from DataStore. Dialog collects input, inserts via Repository, and list updates automatically.","explanation":"## Why This Is Asked\n\nTests practical Android fundamentals: MVVM, Room persistence, DataStore for simple state, and rotation handling with UI state. It also probes testing strategy for data layers and small UI flows.\n\n## Key Concepts\n\n- Room: Entity, DAO, and queries with dynamic sort\n- DataStore: simple, persistent sort preference\n- MVVM: ViewModel + LiveData + Repository pattern\n- Rotation handling: preserving list state and dialog input flows\n\n## Code Example\n\n```kotlin\n@Entity data class Visit(val id: Long, val siteName: String, val timestamp: Long)\n@Dao interface VisitDao {\n    @Insert suspend fun insert(visit: Visit)\n    @Query(\"SELECT * FROM Visit ORDER BY timestamp :sortOrder\")\n    fun getAllVisits(sortOrder: String): LiveData<List<Visit>>\n}\n\nclass VisitRepository(\n    private val dao: VisitDao,\n    private val dataStore: DataStore<Preferences>\n) {\n    private val SORT_KEY = stringPreferencesKey(\"sort_order\")\n    \n    val sortOrder: Flow<String> = dataStore.data.map { it[SORT_KEY] ?: \"ASC\" }\n    \n    suspend fun insert(visit: Visit) = dao.insert(visit)\n    suspend fun setSortOrder(order: String) {\n        dataStore.edit { it[SORT_KEY] = order }\n    }\n    \n    fun getVisits(): LiveData<List<Visit>> {\n        return sortOrder.flatMapLatest { order ->\n            dao.getAllVisits(order)\n        }.asLiveData()\n    }\n}\n\nclass VisitViewModel(\n    private val repository: VisitRepository\n) : ViewModel() {\n    val visits: LiveData<List<Visit>> = repository.getVisits()\n    val sortOrder: LiveData<String> = repository.sortOrder.asLiveData()\n    \n    fun addVisit(siteName: String) {\n        viewModelScope.launch {\n            val visit = Visit(\n                id = System.currentTimeMillis(),\n                siteName = siteName,\n                timestamp = System.currentTimeMillis()\n            )\n            repository.insert(visit)\n        }\n    }\n    \n    fun toggleSort() {\n        viewModelScope.launch {\n            val current = sortOrder.value ?: \"ASC\"\n            repository.setSortOrder(if (current == \"ASC\") \"DESC\" else \"ASC\")\n        }\n    }\n}\n```\n\n## Data Flow\n\n1. **Dialog Input** → ViewModel.addVisit() → Repository.insert() → Room DAO → Database\n2. **Sort Toggle** → ViewModel.toggleSort() → Repository.setSortOrder() → DataStore → Triggers LiveData refresh\n3. **List Display** → ViewModel.visits LiveData → UI observes → Automatic updates on data/sort changes\n4. **Rotation** → DataStore preserves sort preference → LiveData maintains list state → UI restores seamlessly\n\n## UI Test Plan\n\n1. **Add Visit Test**: Verify dialog opens, input accepted, and list updates with new entry\n2. **Sort Toggle Test**: Confirm sort button changes order and persists across rotation\n3. **Persistence Test**: Check data survives app restart and sort preference remains\n4. **Edge Cases**: Test empty list, duplicate entries, and rapid sort changes","diagram":"flowchart TD\nA[User adds Visit] --> B{Data Flow}\nB --> C[VisitDao.insert(Visit)]\nC --> D[LiveData updates List<Visit>]\nD --> E[UI List Rerenders]\nA --> F[Toggle Sort] --> G[DataStore save sort]\nG --> H[ViewModel requeryVisits]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Salesforce","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T05:32:43.683Z","createdAt":"2026-01-14T23:29:57.485Z"},{"id":"q-2143","question":"You're building a beginner Android checklist app: store items in Room (id, title, completed, dueDate), display them in a RecyclerView, and support add/edit/delete. Implement a one-time reminder using WorkManager that triggers a Notification at dueDate, with a backoff if scheduling fails or the device is asleep. Describe data flow (DAO/Repository), Worker implementation, and a test plan for offline item creation and overdue reminders?","answer":"Notes live in Room with fields id, title, completed, dueDate; a Repository exposes a Flow<List<Note>> consumed by a ViewModel and observed by the UI. ReminderWorker schedules a one-time work with an i","explanation":"## Why This Is Asked\nTests local persistence, MVVM, and background work; verifies handling of Doze and backoff; covers testing offline flows.\n\n## Key Concepts\n- Room: DAO, entities, Flow\n- Repository + ViewModel + RecyclerView\n- WorkManager: OneTimeWorkRequest, initialDelay, backoff\n- Notifications and channels\n- Testing offline and timer-based flows\n\n## Code Example\n```javascript\nclass ReminderWorker(appContext: Context, params: WorkerParameters) : CoroutineWorker(appContext, params) {\n  override suspend fun doWork(): Result {\n    // fetch due item, post notification, return Result.success() or retry()\n    return Result.success()\n  }\n}\n```\n\n## Follow-up Questions\n- How to handle time zones and daylight saving changes?\n- How to update or cancel a reminder when dueDate changes?\n","diagram":"flowchart TD\nA[Add item] --> B[Room insert]\nB --> C[Flow emits]\nC --> D[UI updates RecyclerView]\nD --> E[Schedule Reminder with WorkManager]\nE --> F[Notification shown]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T04:23:10.683Z","createdAt":"2026-01-15T04:23:10.683Z"},{"id":"q-2195","question":"You're building an Android field tool app used by technicians to annotate images and run on-device ML for scene classification with offline-first data collection. The app must train a lightweight model locally from user-labeled samples, support incremental model updates delivered from the backend, and handle intermittent connectivity. Design end-to-end architecture and data flow using Room, DataStore, WorkManager, and TensorFlow Lite. Address offline training, model versioning, delta updates, rollback, and testing under Doze and flaky networks?","answer":"Approach: store labeled samples in Room; train a compact TensorFlow Lite model on-device; deliver incremental delta-weights via backend updates; track modelVersion in DataStore; apply updates with ide","explanation":"## Why This Is Asked\n\nTests on-device ML integration, offline-first data, and robust model update workflows—critical for scalable mobile apps.\n\n## Key Concepts\n\n- On-device ML with TensorFlow Lite and delta updates\n- Offline data pipeline with Room and DataStore\n- Scheduled syncs and backoff with WorkManager\n- Versioning, rollback, and conflict resolution strategies\n\n## Code Example\n\n```kotlin\ndata class ModelDelta(val weights: ByteArray, val version: Int)\nfun applyDelta(base: ByteArray, delta: ModelDelta): ByteArray {\n    // merge weights carefully; ensure determinism and integrity checks\n    return merge(base, delta.weights)\n}\n```\n\n## Follow-up Questions\n\n- How would you design schema/version metadata to support seamless rollback?\n- What tests would you add for offline training convergence and update conflicts?","diagram":null,"difficulty":"advanced","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","Lyft","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T07:03:13.640Z","createdAt":"2026-01-15T07:03:13.640Z"},{"id":"q-2216","question":"You're building an Android offline-first note app that provides fast full-text search across local notes and syncs with a central server. Implement using Room + FTS for search on title/content, a tombstone strategy, and a versioned sync via WorkManager with exponential backoff. Describe the data model (Note: id, title, content, updatedAt, version, tombstone), DAO/FTS setup, sync flow, and a test plan for offline edits, conflicts, and index consistency?","answer":"Use Room with an FTS4 index for notes (id, title, content, updatedAt, version, tombstone). Maintain a searchable mirror and reindex on updates. Sync via WorkManager: push local changes with exponentia","explanation":"## Why This Is Asked\n\nAssesses ability to design offline-first search with robust sync, conflict handling, and tombstone tracking—critical for mobile apps that must operate in flaky networks.\n\n## Key Concepts\n\n- Room + FTS for local search\n- Tombstone pattern for deletes\n- Versioned sync with WorkManager\n- Exponential backoff strategy\n- Conflict resolution (server-wins + client-merge)\n\n## Code Example\n\n```javascript\n// Pseudocode: data model and sync flow\n```\n\n## Follow-up Questions\n\n- How would you test conflict resolution across devices?\n- How would you validate index reindexing after large note updates?","diagram":"flowchart TD\n  A[Local Change] --> B[Room DB]\n  B --> C[WorkManager Sync]\n  C --> D[Server]\n  D --> E[Remote Changes]\n  E --> F[WorkManager Sync]\n  F --> G[Room DB]\n  G --> H[Search Index Updated]","difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Hashicorp","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T07:43:43.794Z","createdAt":"2026-01-15T07:43:43.794Z"},{"id":"q-2447","question":"Design an Android enterprise app feature delivery strategy using dynamic feature modules and server-driven flags. Describe how you would (1) ship features on demand with Play Feature Delivery, (2) implement server-driven flags with offline caching, versioning, and safe rollbacks, (3) support canary and percentage rollout per device, (4) ensure startup safety and crash resilience, and (5) validate with test plans and telemetry?","answer":"Leverage Play Feature Delivery for dynamic features and a server-driven flag service (Remote Config or REST). Cache flags in Proto DataStore with a version tag; refresh via WorkManager; determine cana","explanation":"## Why This Is Asked\nThis question probes practical mastery of modular delivery, server-driven configuration, and robust offline behavior in Android at scale.\n\n## Key Concepts\n- Dynamic feature modules and Play Feature Delivery\n- Server-driven feature flags and offline caching\n- Versioning, canaries, and safe rollback\n- Startup safety, crash resilience, and telemetry\n- Testing: unit, instrumentation, and end-to-end validation\n\n## Code Example\n```kotlin\nfun isFeatureEnabled(flag: Flag): Boolean {\n  // Read from Proto DataStore; fallback to default if offline\n  // Compare version and treat device-specific canary accordingly\n  return flag.enabled && flag.version == currentVersion\n}\n```\n\n## Follow-up Questions\n- How would you handle schema migrations for features toggled off/on mid-release?\n- What metrics would you collect to evaluate rollout success and stability?","diagram":"flowchart TD\n  A[Device] -->|Fetch flags| B[FlagService]\n  B --> C{Feature enabled}\n  C --> D[Activate Feature]\n  C --> E[Graceful fallback]","difficulty":"advanced","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T18:52:37.629Z","createdAt":"2026-01-15T18:52:37.629Z"},{"id":"q-2547","question":"Design an Android module that performs on-device NLP inference using a Hugging Face model for chat intent detection. Build a ModelManager with components: ModelRepo (versioned storage), InferenceEngine (off-UI thread), MemoryMonitor, and Updater (WorkManager with backoff). It should load from internal storage, download updates when online, switch between a large and compact model based on memory, support cancellation with timeouts, and rollback on failure. Describe architecture, data flow, and a concrete test plan for offline updates, memory pressure, and model-load failure?","answer":"ModelManager orchestrates a comprehensive on-device NLP inference system with versioned model management. The ModelRepo component provides versioned storage in internal app storage, while the MemoryMonitor continuously tracks available memory to dynamically select between large and compact models. The InferenceEngine processes chat intent detection requests on background threads with cancellation and timeout capabilities, ensuring responsive UI performance. The Updater leverages WorkManager with exponential backoff to seamlessly download and deploy new model versions when connectivity permits. During failures, the system automatically initiates rollback to the previous stable version, maintaining uninterrupted service reliability.","explanation":"## Why This Is Asked\nTests advanced on-device ML lifecycle management including versioned model caching, memory-adaptive loading strategies, background update mechanisms, and robust rollback protocols.\n\n## Key Concepts\n- On-device inference with versioned ModelRepo architecture\n- Memory-aware model selection using real-time MemoryMonitor\n- Background updates via WorkManager with exponential backoff strategy\n- Safe rollback mechanisms and comprehensive failure recovery\n\n## Code Example\n```kotlin\nclass ModelRepo {\n    fun load(version: String): Model?\n    fun save(version: String, data: ByteArray) {}\n}\n\nclass InferenceEngine(private val repo: ModelRepo) {\n    suspend fun infer(input: String): Re","diagram":null,"difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Hugging Face"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T05:30:11.527Z","createdAt":"2026-01-15T22:36:00.244Z"},{"id":"q-2587","question":"You're building a beginner Android feature that records in-app interactions as Event records (id, screen, action, ts) in Room. When online, batch-upload unsynced events to a REST API via WorkManager with a network constraint and exponential backoff. Show your data model, DAO/repository, how you mark events synced, batch sizing, and a basic test plan for offline queueing and retry behavior?","answer":"Define an Event entity with id: String, screen: String, action: String, ts: Long, synced: Boolean. DAO: insertEvent, getUnsynced(limit), markSynced(ids). Repository: saveEvent(...) and enqueueBatch()","explanation":"Why This Is Asked\n\nTests understanding of local persistence, background work, and reliability without real-time network; ensures familiarity with Room, WorkManager, and basic error-handling.\n\nKey Concepts\n\n- Room entities and DAOs\n- WorkManager constraints and backoff\n- State management (synced flag)\n- Batch processing and idempotency\n\nCode Example\n\n```javascript\n// Kotlin-like pseudocode\n@Entity(tableName = \"events\")\ndata class Event(\n  @PrimaryKey val id: String,\n  val screen: String,\n  val action: String,\n  val ts: Long,\n  val synced: Boolean = false\n)\n\n@Dao\ninterface EventDao {\n  @Insert(onConflict = REPLACE)\n  suspend fun insertEvent(event: Event)\n  \n  @Query(\"SELECT * FROM events WHERE synced = 0 LIMIT :limit\")\n  suspend fun getUnsynced(limit: Int): List<Event>\n  \n  @Query(\"UPDATE events SET synced = 1 WHERE id IN (:ids)\")\n  suspend fun markSynced(ids: List<String>)\n}\n\nclass EventRepository(private val dao: EventDao) {\n  suspend fun saveEvent(screen: String, action: String) {\n    dao.insertEvent(Event(UUID.randomUUID().toString(), screen, action, System.currentTimeMillis()))\n    enqueueBatch()\n  }\n  \n  private fun enqueueBatch() {\n    WorkManager.getInstance().enqueueUniqueWork(\n      \"EventUpload\",\n      ExistingWorkPolicy.REPLACE,\n      OneTimeWorkRequestBuilder<EventUploadWorker>()\n        .setConstraints(Constraints.Builder().setRequiredNetworkType(NetworkType.CONNECTED).build())\n        .setBackoffCriteria(BackoffPolicy.EXPONENTIAL, 30, TimeUnit.SECONDS)\n        .build()\n    )\n  }\n}\n\nclass EventUploadWorker(appContext: Context, workerParams: WorkerParameters) : CoroutineWorker(appContext, workerParams) {\n  override suspend fun doWork(): Result {\n    val dao = EventDatabase.getInstance(applicationContext).eventDao()\n    val batchSize = 50\n    \n    return try {\n      val events = dao.getUnsynced(batchSize)\n      if (events.isEmpty()) return Result.success()\n      \n      apiClient.uploadEvents(events)\n      dao.markSynced(events.map { it.id })\n      Result.success()\n    } catch (e: Exception) {\n      Result.retry()\n    }\n  }\n}\n```\n\nTest Plan\n\n1. Unit test DAO operations for insert/query/update\n2. Test repository saves events locally and enqueues work\n3. Verify WorkManager respects network constraint\n4. Simulate offline → create events → online → verify batch upload\n5. Test retry behavior with failed network calls\n6. Verify synced flag prevents duplicate uploads","diagram":"flowchart TD\n  A[Event Created] --> B[Room Insert]\n  B --> C[Queue in Unsynced]\n  C --> D[WorkManager Batch Upload]\n  D --> E[Server OK] --> F[Mark Synced]\n  D --> G[Retry with Backoff]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Instacart","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T05:08:20.856Z","createdAt":"2026-01-15T23:45:49.074Z"},{"id":"q-2664","question":"You're building an Android module for real-time, offline-first collaborative document editing. Each document uses a CRDT to merge concurrent edits locally and remotely. The app syncs with a central server over WebSocket with a REST fallback; local changes are persisted in Room; security via per-document encryption keys. Describe architecture, data model, CRDT design, sync protocol, and testing plan?","answer":"Propose an architecture that stores per-document CRDT state in Room, uses a lightweight CRDT (e.g., Add-Wins OR-Set) to merge concurrent local edits, and syncs via WebSocket with a REST fallback. Incl","explanation":"## Why This Is Asked\nAssesses the ability to design offline-first, real-time collaboration on mobile, including CRDT data models, sync protocols, conflict resolution, and security.\n\n## Key Concepts\n- CRDTs (Add-Wins / OR-Set)\n- Room persistence\n- WebSocket sync with REST fallback\n- Tombstones and delete semantics\n- Per-document encryption keys\n\n## Code Example\n```kotlin\n// Minimal Add-Wins CRDT sketch\ndata class Dot(val actor: String, val clock: Long)\nclass AddWinsCRDT {\n  private val adds = mutableMapOf<String, MutableSet<Long>>()\n  fun add(e: String, d: Dot) { adds.computeIfAbsent(e) { mutableSetOf() }.add(d.clock) }\n  fun value(): Set<String> = adds.filter { it.value.isNotEmpty() }.keys\n}\n```\n\n## Follow-up Questions\n- How would you handle offline deletes and tombstones?\n- How would you test consistency across multiple clients with network partitions?","diagram":"flowchart TD\nA[Client Edit] --> B[CRDT Merge]\nB --> C[Local Room State]\nC --> D[WebSocket Sync]\nD --> E[Server CRDT State]\nE --> F[Broadcast Updates]","difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T05:47:03.586Z","createdAt":"2026-01-16T05:47:03.587Z"},{"id":"q-2715","question":"Design an Android chat module that delivers end-to-end encrypted real-time messaging for a multi-device collaboration app. Implement a Signal-like ratchet, store device keys in Android Keystore, perform nightly ephemeral key rotation, and queue outgoing messages in Room for offline delivery. Describe architecture, data flow, storage schema, and a test plan for offline queuing, key rotation, and out-of-order delivery under churn?","answer":"Implement a Signal-like ratchet using per-device X25519 keys stored in Android Keystore, with nightly ephemeral key rotation. Derive a fresh session key per contact and encrypt payloads with AES-GCM. ","explanation":"## Why This Is Asked\n\nTests advanced Android security patterns: E2EE, key management on Keystore, offline-first messaging, and device/session revocation in multi-device scenarios.\n\n## Key Concepts\n\n- End-to-end encryption with forward secrecy via a Signal-like ratchet\n- Android Keystore for per-device keys\n- Ephemeral key rotation and session management\n- Room-based offline queue and TLS transport with pinning\n- Revocation and rejoining flows, conflict handling\n\n## Code Example\n\n```javascript\n// Pseudo: derive new shared secret and rotate session\nconst shared = X25519.derive(privateKey, peerPublicKey)\nconst newKey = HKDF(shared, \"message\", 32)\n```\n\n## Follow-up Questions\n\n- How to test key revocation and cross-device sync at scale?\n- How to measure protocol security properties under packet loss?","diagram":"flowchart TD\n  A[Message compose] --> B[Encrypt with session key]\n  B --> C[Store in Room queue]\n  C --> D[Send when online]\n  D --> E[Recipient decrypts with session]\n  E --> F[Session update on recipient]","difficulty":"advanced","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","MongoDB","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T07:47:54.990Z","createdAt":"2026-01-16T07:47:54.990Z"},{"id":"q-2809","question":"Design an Android module that streams a live collaborative whiteboard using WebRTC data channels for real-time updates, with offline queuing when network is unavailable, persisting events in Room, and ensuring eventual consistency under churn. Include architecture, data model, delta-encoding, and a test plan for offline/online transitions?","answer":"Implement a WebRTC data channel-based whiteboard with a Room-backed log. Data model: WhiteboardEvent(id, docId, userId, seq, op, payload, tombstone, synced). Use per-document causal ordering via seq, ","explanation":"## Why This Is Asked\n\nThis question tests practical real-time collaboration on Android, WebRTC integration, offline-first persistence, and conflict resolution under churn.\n\n## Key Concepts\n\n- WebRTC DataChannel usage for real-time events\n- Local persistence with Room and tombstones\n- Delta-encoding and vector-clock-like sequencing\n- Conflict resolution strategy (last-writer-wins by field)\n- Offline-first queueing and retry with backoff\n\n## Code Example\n\n```javascript\n// Pseudo: event encode and apply\nclass WhiteboardEvent { val docId: String; val seq: Long; val op: String; val payload: String; val tombstone: Boolean }\n```\n\n## Follow-up Questions\n\n- How would signaling, authentication, and encryption be integrated?\n- How to scale for many peers and handle network churn?","diagram":"flowchart TD\n  A[User action] --> B[Encode event]\n  B --> C[Queue in Room]\n  C --> D[WebRTC DataChannel]\n  D --> E[Peers receive and apply events]","difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Slack","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T13:13:22.898Z","createdAt":"2026-01-16T13:13:22.899Z"},{"id":"q-2824","question":"Design an Android module for offline-first, real-time co-op game state using CRDTs to merge concurrent updates; use Room for local persistence, WebSocket for server sync, and per-user encryption keys stored in Android Keystore with nightly ephemeral key rotation. Describe architecture, data model, CRDT design, sync protocol, and a test plan for latency, churn, and conflict resolution?","answer":"Propose a CRDT-based approach (state-based OR-Set + MVRegister) to model per-entity state. Each device signs ops with a per-user key in Keystore; store encrypted deltas locally in Room; sync via WebSo","explanation":"## Why This Is Asked\n\nTests understanding of offline-first CRDT design, encryption, key rotation, and practical trade-offs in a mobile environment.\n\n## Key Concepts\n\n- CRDT types (OR-Set, MVRegister)\n- End-to-end encryption with Android Keystore\n- Room-based offline persistence\n- WebSocket-based sync with anti-entropy\n- Key rotation strategy and impact on data at rest\n\n## Code Example\n\n```kotlin\ndata class MVRegister<T>(val value: T, val ts: Long)\n\nfun <T> merge(a: MVRegister<T>, b: MVRegister<T>): MVRegister<T> = if (a.ts > b.ts) a else b\n```\n\n## Follow-up Questions\n\n- How would you handle tombstones to bound memory?\n- How would you verify multi-device convergence under churn?","diagram":"flowchart TD\n  A[Client] --> B[CRDT Core]\n  B --> C[Room Local Store]\n  A --> D[WebSocket Sync]\n  D --> E[Server CRDT Replica]","difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Goldman Sachs","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T13:57:47.792Z","createdAt":"2026-01-16T13:57:47.793Z"},{"id":"q-2944","question":"Design an Android module to support dynamic, per-user feature flags delivered via Play Feature Delivery. Include: a per-user flag cache in Room, a module loader with SplitCompat, a policy for safe rollout/rollback, and a testing strategy for offline-first fetch and partial module failures. How would you structure components and data flow?","answer":"Leverage Play Core Dynamic Delivery with SplitCompat. Build a FeatureFlagManager that caches per-user flags in Room, falls back to defaults offline, and uses WorkManager with backoff to refresh flags.","explanation":"## Why This Is Asked\nTests expertise in dynamic delivery, offline resilience, and safe rollouts using Android's Play Core, SplitCompat, and Room. It also probes rollback strategies and test planning for real-world churn.\n\n## Key Concepts\n- Play Core Dynamic Delivery\n- SplitCompat and dynamic feature loading\n- Room-based config cache\n- WorkManager with backoff for refreshes\n- Rollback + crash-safe workflows\n\n## Code Example\n```kotlin\n// Skeleton core components\nclass FeatureFlagManager(private val repo: ConfigRepo, private val wm: WorkManager) {\n  fun isEnabled(flag: String): Boolean = false\n}\nclass ModuleRouter(private val loader: DynamicModuleLoader) {\n  fun loadIfEnabled(feature: String) { /* ... */ }\n}\n```\n\n## Follow-up Questions\n- How would you test rollout drift and rollback latency?\n- How do you handle a feature flag changing while a module is being loaded?","diagram":"flowchart TD\n  A[Fetch flags] --> B[Cache in Room]\n  B --> C[ModuleRouter decides]\n  C --> D[SplitCompat load module]\n  D --> E[Flag evaluation for UI]\n","difficulty":"advanced","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Microsoft","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T18:48:56.916Z","createdAt":"2026-01-16T18:48:56.917Z"},{"id":"q-3082","question":"Design an Android module for a messaging app that delivers messages primarily through device-to-device P2P (Nearby Connections or WebRTC data channels) when devices are in proximity, with seamless server fallback. Requirements: Kotlin, Coroutines, Room-based offline log, per-device keys stored in Android Keystore with nightly rotation, and a WorkManager-based reconciliation when online. Define data model, conflict resolution, and a concrete test plan for proximity churn, out-of-order delivery, and offline queues?","answer":"Design a modular Android architecture that enables offline-first messaging through device-to-device P2P communication (Nearby Connections or WebRTC data channels) when devices are in proximity, with seamless server fallback. Implement a CRDT-inspired append-only log structure using Room for offline persistence, per-device cryptographic keys managed via Android Keystore with automated nightly rotation, and WorkManager-based reconciliation for server synchronization when connectivity is restored.","explanation":"## Why This Is Asked\nThis question evaluates the ability to architect hybrid P2P/server messaging systems with strong offline guarantees, robust cryptographic key management, and sophisticated conflict resolution mechanisms.\n\n## Key Concepts\n- Device-to-device P2P communication paths (Nearby Connections, WebRTC data channels)\n- CRDT-inspired append-only log for offline message persistence\n- Room database integration with Android Keystore for per-device key management\n- Automated key rotation scheduling and secure key storage\n- WorkManager implementation for server reconciliation and conflict resolution\n- Advanced handling of message deduplication, tombstone management, and ordered delivery\n\n## Technical Implementation\n```kotlin\ndata class MessageLogEntry(\n  val id: String,\n  val content: String,\n  val timestamp: Long,\n  val deviceId: String,\n  val isTombstone: Boolean = false,\n  val isDelivered: Boolean = false,\n  val signature: String\n)\n```","diagram":"flowchart TD\n  A[Device A] -->|P2P DataChannel| B[Local CRDT Log]\n  B --> C[Room Persistence]\n  C --> D[Server Sync]\n  D --> E[Device B local log]","difficulty":"advanced","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T05:10:40.534Z","createdAt":"2026-01-16T23:49:50.964Z"},{"id":"q-3159","question":"Design an Android module for a privacy-first group audio chat app (3+ participants) with end-to-end encryption. Use per-device ephemeral keys rotated nightly in Android Keystore, a group-key envelope for media, and WebRTC for low-latency audio with a jitter buffer. Signaling can fallback to a server. Transcripts stored in Room for offline access. Describe architecture, key management, data flow, and a concrete test plan for membership changes, rotation, offline queueing, and audio dropout?","answer":"Propose a privacy-first Android module for group audio chat (3+ participants) with E2EE: per-device ephemeral keys rotated nightly in Android Keystore, a group-key envelope, and WebRTC for low-latency","explanation":"## Why This Is Asked\n\nTests ability to design end-to-end encrypted, multi-party voice with dynamic membership, offline resilience, and production-ready media handling. It probes WebRTC, key management, and data persistence trade-offs across devices.\n\n## Key Concepts\n\n- WebRTC for multi-party audio and signaling flow\n- End-to-end encryption with per-device keys and a group-key envelope\n- Nightly key rotation via Android Keystore and secure key derivation\n- Offline transcripts using Room; offline-first UX\n- Audio quality: jitter buffer, AGC, and network adaptivity\n\n## Code Example\n\n```kotlin\n// Kotlin: schedule nightly key rotation in WorkManager (pseudo)\nclass KeyRotationWorker(ctx: Context, params: WorkerParameters): Worker(ctx, params) {\n  override fun doWork(): Result {\n    // rotate per-device ephemeral keys and recompute group envelope\n    return Result.success()\n  }\n}\n```\n\n## Follow-up Questions\n\n- How would you handle dynamic membership changes with re-keying and minimal disruption?\n- How would you test audio dropout under packet loss and jitter, and validate offline transcripts remain consistent?","diagram":"flowchart TD\n  A[Android App] --> B[Signaling Server if WebRTC fails]\n  B --> C[WebRTC Peer Connections]\n  C --> D[Media Pipeline with Jitter Buffer/AGC]\n  A --> E[Room (Local Transcript)]\n  F[Keystore (Keys)] --> A\n  G[Nightly Rotation Job] --> F\n  C --> H[Group Envelope for Keys]\n  H --> I[End-to-End Encryption Guard]\n  I --> C\n  I --> D","difficulty":"advanced","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","DoorDash","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T04:54:15.230Z","createdAt":"2026-01-17T04:54:15.231Z"},{"id":"q-3214","question":"Design an Android module for an offline-first wallet that queues card-present payments while offline and reconciles them when online, guaranteeing no duplicate charges. Use Kotlin, Coroutines, Room for local log, per-device signing keys in Android Keystore with nightly rotation, and a WorkManager-based reconciliation flow. Describe data model, idempotency strategy, conflict resolution, and a test plan for offline queues, replays, and out-of-order delivery?","answer":"Implement a local payments log in Room with fields: id, amount, cardId, status, sequence, txnId; sign each entry with a per-device key from Android Keystore; rotate keys nightly and publish public key","explanation":"## Why This Is Asked\nThis question probes end-to-end reliability for offline-first payments with strong deduplication guarantees and key rotation. It tests reasoning about reconciliation boundaries, idempotency, and secure per-device signing in Android.\n\n## Key Concepts\n- Offline-first data flow and idempotent reconciliation\n- Android Keystore for per-device signing with nightly rotation\n- Room persistence and WorkManager orchestration\n- Handling duplicates, replays, and out-of-order deliveries\n\n## Code Example\n```kotlin\n@Entity\ndata class PaymentLog(\n  @PrimaryKey val id: String,\n  val txnId: String,\n  val amount: Long,\n  val status: String,\n  val sequence: Long,\n  val signedPayload: String\n)\n```\n\n## Follow-up Questions\n- How would you handle server downtime during reconciliation and ensure ledger consistency?\n- How would you test rotation impact on in-flight payments and reconciliations?","diagram":"flowchart TD\nA[Offline payment queued in Room] --> B[Sign with per-device key]\nB --> C[Assign sequence + txnId]\nC --> D[Reconcile on connect via WorkManager]\nD --> E[Server deduplicates by txnId]\nE --> F[Ledger updated]","difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T07:28:04.923Z","createdAt":"2026-01-17T07:28:04.923Z"},{"id":"q-3273","question":"Design an Android module for a real-time, offline-first collaborative data editor (like a shared spreadsheet) that uses CRDTs to merge edits across devices when online, supports per-device cryptographic identities stored in Android Keystore with nightly rotation, and reconciles with a central server via WebSocket. Describe data model, conflict resolution, offline queues, and test plan for churn, out-of-order edits, and data integrity?","answer":"Adopt a CRDT-based collaborative editor. Use a two CRDT approach: an Op-based CRDT for cell edits and an OR-Set for row/column inserts/deletes. Ops buffered in Room with per-edit tombstones; on reconn","explanation":"## Why This Is Asked\n\nTests depth in offline-first systems, CRDTs, security, and real-time sync; evaluates thinking about data integrity and rotation strategy.\n\n## Key Concepts\n\n- CRDT-based collaboration\n- Android Keystore device identity rotation\n- Room-based offline log\n- WebSocket-based server reconciliation\n- Idempotent merges and conflict resolution\n\n## Code Example\n\n```javascript\n// Pseudo-code: simple OR-Set style CRDT merge skeleton\n```\n\n## Follow-up Questions\n\n- How would you model tombstones for deletions to avoid blow-up?\n- How would you validate consistency under network partitions and restarts?","diagram":"flowchart TD\n  A[Local Edit] --> B[Buffer in Room]\n  B --> C[Merge via CRDT]\n  C --> D[WebSocket Sync]\n  D --> E[Server State]\n  E --> F[Remote Edits Merge]","difficulty":"advanced","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Instacart","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T09:37:50.860Z","createdAt":"2026-01-17T09:37:50.860Z"},{"id":"q-3459","question":"Design an Android module for offline-first moderation flags: users can flag posts while offline; flags stored in Room with per-device signing keys in Android Keystore (nightly rotation); on connectivity, reconcile with a central moderation service via REST; ensure idempotent submissions, deduplication, and conflict resolution when devices assign different verdicts. Describe data model, sync protocol, and a test plan for offline queues, duplicates, and reconciliation latency?","answer":"Design an offline-first moderation queue: store flags in Room with fields contentId, flaggerDeviceId, timestamp, verdict, and a per-device signing key in Android Keystore (nightly rotation). Submissio","explanation":"## Why This Is Asked\n\nExplores offline resilience, privacy-conscious signing, and cross-device reconciliation for moderation data—challenging in real-time apps where latency and data integrity matter.\n\n## Key Concepts\n\n- Offline-first persistence with Room\n- Android Keystore per-device keys and nightly rotation\n- Idempotent flag submissions and deduplication\n- WorkManager-based batched synchronization with REST\n- Conflict resolution and auditability\n\n## Code Example\n\n```kotlin\n@Entity\ndata class FlagEntity(\n  @PrimaryKey val id: String,\n  val contentId: String,\n  val deviceId: String,\n  val verdict: String,\n  val timestamp: Long,\n  val signature: String\n)\n```\n\n## Follow-up Questions\n\n- How would you test idempotency and conflict resolution under high churn?\n- What metrics would you collect to monitor reconciliation latency and queue growth?\n","diagram":"flowchart TD\n  A[Offline Flags] --> B[Room Queue]\n  B --> C[Keystore Signed]\n  C --> D[WorkManager Batch]\n  D --> E[Server Reconcile]\n  E --> F[Conflict Resolution Audit]","difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","MongoDB","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T17:24:59.184Z","createdAt":"2026-01-17T17:24:59.184Z"},{"id":"q-3679","question":"Design an Android module for a live, synchronized music player that allows nearby devices to form a low-latency playback mesh using Nearby Connections, while seamlessly falling back to a central streaming server when devices are out of range. Requirements: Kotlin, Coroutines, ExoPlayer for playback, Room for an offline queue, per-device signing keys stored in Android Keystore with nightly rotation, and a WorkManager-based reconciliation when back online. Describe architecture, data flow, synchronization protocol for drift, conflict resolution, and a concrete test plan for clock drift, churn, and offline queue recovery?","answer":"Implement a playback orchestrator that uses a LocalMeshController (Nearby Connections) for synchronized audio, with ExoPlayer as the playback engine and a Room queue for offline buffering. Sign playhe","explanation":"## Why This Is Asked\n\nTests ability to design a distributed playback system with proximity networking, crypto identity, and robust offline handling, balancing latency, consistency, and failure modes.\n\n## Key Concepts\n\n- Proximity mesh control with Nearby Connections\n- Time synchronization and drift handling\n- Key management in Android Keystore with rotating keys\n- ExoPlayer integration and Room-backed offline queue\n- WorkManager reconciliation\n\n## Code Example\n\n```javascript\n// sketch: updatePlayhead(peerId, timestamp)\n```\n\n## Follow-up Questions\n\n- How would you resolve conflicting playhead updates?\n- How would you handle devices joining/leaving the mesh?\n- How would you test network partitions and offline recovery?","diagram":null,"difficulty":"advanced","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Netflix","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T05:32:34.832Z","createdAt":"2026-01-18T05:32:34.833Z"},{"id":"q-3714","question":"Design an Android module for privacy-preserving offline sensor data collection: collect accelerometer, gyroscope, and GPS samples locally; store in Room with per-device cryptographic identity in Android Keystore with nightly rotation; batch and upload when online via REST, applying privacy transforms before sending; ensure dedup, data integrity, and minimal battery impact. Describe data model, privacy pipeline, sync protocol, and tests for data drift and rotation?","answer":"Store sensor samples in Room with fields: id, ts, accX/accY/accZ, gyrX/gyrY/gyrZ, lat, lon, deviceHash. Encrypt payload with a nightly-rotated Android Keystore key; re-encrypt batches using new keys. ","explanation":"## Why This Is Asked\n\nTests ability to design a privacy-conscious offline data module on Android, combining Room schemas, Keystore key rotation, and reliable batch uploads under intermittent connectivity.\n\n## Key Concepts\n\n- Android Keystore with nightly key rotation for per-device identity\n- Room schema for time-series sensor data with privacy fields\n- Batch processing and idempotent REST upload\n- Battery-aware background work and minimal CPU usage\n\n## Code Example\n\n```kotlin\ndata class SensorSample(\n  @PrimaryKey val id: String,\n  val ts: Long,\n  val accX: Float, val accY: Float, val accZ: Float,\n  val gyrX: Float, val gyrY: Float, val gyrZ: Float,\n  val lat: Double?, val lon: Double?\n)\n// Pseudo: encrypt payload using per-device key before insert\nval payload = encrypt(serialize(sample), deviceKey)\n```\n\n## Follow-up Questions\n\n- How would you test the nightly rotation impact on in-flight uploads?\n- How would you verify deduplication and data integrity after reconnecting from multiple intermittent sessions?","diagram":"flowchart TD\n  A[Raw Samples] --> B[Room Storage]\n  B --> C[Batcher] \n  C --> D[Encrypt with Keystore key (rotates nightly)]\n  D --> E[Upload Service on connectivity]\n  E --> F[Server Reconcile & Acknowledgement]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T06:50:26.758Z","createdAt":"2026-01-18T06:50:26.758Z"},{"id":"q-3766","question":"Design an Android module for an offline-first, privacy-preserving feature-flag system for a delivery app. Each device signs flag changes with a per-device key stored in Android Keystore, rotated nightly. Flags are stored locally (Room or DataStore). When online, reconcile with the central service via REST/WebSocket, ensuring idempotent updates and cross-device conflict resolution within the same account. Include data model, sync protocol, and a test plan for offline toggles and churn?","answer":"Leverage DataStore/Room for local flags; sign updates with a per-device key in Android Keystore and rotate nightly. Represent each flag with a version vector; merge remotely using vector clocks to res","explanation":"## Why This Is Asked\nAssess ability to design offline-first, cryptographically signed feature flags with conflict resolution and test planning for real-world distribution.\n\n## Key Concepts\n- Offline-first state synchronization\n- Per-device keys in Android Keystore with nightly rotation\n- Data modeling: Flag, Version Vector, Operation ID\n- Sync protocol: REST/WebSocket reconciliation, idempotence\n- Conflict resolution strategies and testing\n\n## Code Example\n```kotlin\ndata class FlagState(val name: String, val enabled: Boolean, val vector: Map<String, Long>)\ndata class FlagEvent(val name: String, val enabled: Boolean, val opId: String, val deviceId: String, val vectorDelta: Map<String, Long>)\nfun mergeFlags(local: FlagState, remote: FlagState): FlagState {\n  val lv = local.vector.values.maxOrNull() ?: 0\n  val rv = remote.vector.values.maxOrNull() ?: 0\n  return if (rv > lv) remote else local\n}\n```\n\n## Follow-up Questions\n- How to store vector clocks efficiently in Room/DataStore?\n- How to revoke a device or rotate keys without breaking reconciliation?","diagram":"flowchart TD\n  A[Device signs local flag change with per-device key]\n  B[Local signed flag entry in Room/DataStore]\n  C[Nightly rotation of keys in Keystore]\n  D[On connectivity, reconcile with central service via REST/WebSocket]\n  E[Server returns merged flags]\n  F[Local apply merged flags]\n  A-->B\n  B-->C\n  C-->D\n  D-->E\n  E-->F","difficulty":"advanced","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Lyft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T08:46:38.481Z","createdAt":"2026-01-18T08:46:38.481Z"},{"id":"q-3807","question":"Design an Android module for offline-first code-review feedback in a mobile code-review app used by engineers at Goldman Sachs and IBM. Allow creating threads with comments and replies while offline; store in Room; sign edits with per-device keys in Android Keystore with nightly rotation; reconcile with a central server via WorkManager when online. Describe data model, idempotency, conflict resolution, and a test plan for offline queues, replays, and out-of-order edits?","answer":"Implement an offline-first code-review module: use Room for a Thread/Comment/Reply model, sign edits with per-device keys from Android Keystore, rotate nightly. Queue create/update/delete actions loca","explanation":"## Why This Is Asked\nTests offline-first syncing and secure per-device signing in a realistic code-review workflow.\n\n## Key Concepts\n- Offline queues with Room\n- Per-device Android Keystore signing and rotation\n- Conflict resolution via versioned threads\n- WorkManager-based reconciliation and idempotent payloads\n\n## Code Example\n```kotlin\n@Entity(tableName = \\\"threads\\\")\ndata class ThreadEntity(@PrimaryKey val id: String, val createdAt: Long, val rootCommentId: String?, val version: Long)\n@Entity(tableName = \\\"comments\\\")\ndata class CommentEntity(@PrimaryKey val id: String, val threadId: String, val body: String, val authorKey: String, val createdAt: Long, val version: Long)\n```\n\n## Follow-up Questions\n- How would you test concurrent edits from two devices?\n- How would you handle key rotation impacting in-flight edits?","diagram":null,"difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","IBM"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T10:34:34.570Z","createdAt":"2026-01-18T10:34:34.570Z"},{"id":"q-3857","question":"Design an Android analytics module for a DoorDash-like app that collects user events offline and uploads in batches while preserving tenant isolation. Include per-device identity in Android Keystore with nightly rotation, a Room-based append-only log, and encrypted at-rest storage. Detail data schema, encryption/signing, batch sizing, and a WorkManager-driven upload with retry, plus a test plan for offline bursts and rotation?","answer":"AnalyticsSDK uses Room as an append-only event queue; per-device identity stored in Keystore with nightly rotation; each event encrypted with AES-GCM and signed; batch size 1000 events or 5 minutes; u","explanation":"## Why This Is Asked\nTests offline analytics design, device identity lifecycle, data security at rest, batching strategy, and multi-tenant isolation under real network constraints.\n\n## Key Concepts\n- On-device identity and nightly rotation in Android Keystore\n- Room append-only log for offline event buffering\n- AES-GCM encryption and event signing\n- Batch sizing: size vs time window\n- WorkManager with backoff for uploads and retry semantics\n- Dedup/replay protection and tenant isolation\n\n## Code Example\n```javascript\n// Example: simple client-side payload envelope for a single event\nconst envelope = { id: \"evt_123\", ts: Date.now(), payload: { action: \"click\" }, tenant: \"tenantA\" };\n```\n\n## Follow-up Questions\n- How would you measure privacy risk and enforce DP guarantees in storage/transport?\n- How would you handle key rotation impact on in-flight uploads and replay safety?","diagram":null,"difficulty":"advanced","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T13:01:45.667Z","createdAt":"2026-01-18T13:01:45.667Z"},{"id":"q-452","question":"How would you implement a RecyclerView with multiple view types while maintaining smooth scrolling performance on large datasets?","answer":"Use RecyclerView.Adapter with getItemViewType() to return different view types. Implement the ViewHolder pattern for each type, use DiffUtil for efficient updates, and enable setHasFixedSize(true). For large datasets, implement Paging3 for optimal memory management and smooth scrolling performance.","explanation":"## Multiple View Types Implementation\n- Override getItemViewType() to return different integers based on data position\n- Create separate ViewHolder classes for each distinct view type\n- Use onCreateViewHolder() with the view type parameter to inflate appropriate layouts\n\n## Performance Optimization\n- Implement DiffUtil for efficient list updates with minimal animations\n- Use setHasFixedSize(true) when item sizes are constant to improve performance\n- Enable RecyclerView.RecycledViewPool for enhanced view reuse across adapters\n\n## Large Dataset Handling\n- Implement Paging3 library for efficient infinite scrolling and memory management\n- Use ViewHolder pattern to prevent unnecessary view inflation operations\n- Consider using ConcatAdapter for combining multiple adapters when managing complex layouts","diagram":"flowchart TD\n  A[Data List] --> B[getItemViewType]\n  B --> C{View Type?}\n  C -->|Type 1| D[ViewHolder1]\n  C -->|Type 2| E[ViewHolder2]\n  C -->|Type 3| F[ViewHolder3]\n  D --> G[Bind Data]\n  E --> G\n  F --> G\n  G --> H[RecyclerView Display]","difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Citadel","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-09T08:54:42.447Z","createdAt":"2025-12-26 12:51:05"},{"id":"q-482","question":"How would you handle Activity lifecycle when screen rotates and you need to preserve user input data?","answer":"Use ViewModel with LiveData to preserve data across configuration changes. Save critical state in onSaveInstanceState() for process death scenarios. For simple UI state, use onSaveInstanceState() with Bundle as a lightweight alternative.","explanation":"## Key Concepts\n- **Configuration Changes**: Screen rotation destroys and recreates Activity instances\n- **ViewModel**: Survives configuration changes and maintains UI state\n- **LiveData**: Lifecycle-aware observable data holder\n\n## Implementation Strategies\n- **ViewModel + LiveData**: Optimal for most UI state preservation\n- **onSaveInstanceState()**: Suitable for small amounts of transient data\n- **Room Database**: For persistent data storage requirements\n\n## Best Practices\n- Never store Context references in ViewModels\n- Use dependency injection for ViewModel instantiation\n- Clear LiveData observers in onDestroy() when appropriate","diagram":"flowchart TD\n  A[Screen Rotation] --> B[Activity Destroyed]\n  B --> C[ViewModel Preserved]\n  C --> D[Activity Recreated]\n  D --> E[UI Restored from ViewModel]\n  E --> F[LiveData Updates UI]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-08T11:57:57.538Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-512","question":"How would you implement a simple RecyclerView in Android to display a list of user profiles with name and email?","answer":"Create a RecyclerView with a custom adapter extending RecyclerView.Adapter. Use ViewHolder pattern with data binding for name/email TextViews. Implement onCreateViewHolder to inflate item layout, onBi","explanation":"## RecyclerView Implementation\n\n- Create item layout XML with TextViews for name and email\n- Extend RecyclerView.Adapter with custom ViewHolder class\n- Override three required methods: onCreateViewHolder, onBindViewHolder, getItemCount\n- Use ViewHolder pattern to avoid repeated findViewById calls\n- Set adapter and LayoutManager on RecyclerView in Activity/Fragment\n\n## Key Components\n\n- **ViewHolder**: Holds references to view components\n- **Adapter**: Bridges data with RecyclerView\n- **LayoutManager**: Positions items (LinearLayoutManager for lists)\n- **Data Binding**: Optional but recommended for cleaner code\n\n```kotlin\nclass UserAdapter(private val users: List<User>) : \n    RecyclerView.Adapter<UserAdapter.UserViewHolder>() {\n    \n    class UserViewHolder(view: View) : RecyclerView.ViewHolder(view) {\n        val nameText: TextView = view.findViewById(R.id.name)\n        val emailText: TextView = view.findViewById(R.id.email)\n    }\n    \n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): UserViewHolder {\n        val view = LayoutInflater.from(parent.context)\n            .inflate(R.layout.item_user, parent, false)\n        return UserViewHolder(view)\n    }\n    \n    override fun onBindViewHolder(holder: UserViewHolder, position: Int) {\n        val user = users[position]\n        holder.nameText.text = user.name\n        holder.emailText.text = user.email\n    }\n    \n    override fun getItemCount() = users.size\n}\n```","diagram":"flowchart TD\n    A[Activity/Fragment] --> B[RecyclerView]\n    B --> C[LayoutManager]\n    B --> D[UserAdapter]\n    D --> E[ViewHolder]\n    E --> F[Item Layout XML]\n    D --> G[User Data List]\n    F --> H[Name TextView]\n    F --> I[Email TextView]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Tesla","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-25T14:59:09.193Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-541","question":"How would you implement a RecyclerView with ViewHolder pattern to display a list of user profiles efficiently?","answer":"Use RecyclerView with ViewHolder pattern: create custom ViewHolder extending RecyclerView.ViewHolder, implement onCreateViewHolder to inflate item layout, onBindViewHolder to bind data, and use DiffUtil for efficient list updates.","explanation":"## RecyclerView Implementation\n\n- **ViewHolder Pattern**: Reuses view objects to avoid expensive findViewById calls\n- **DiffUtil**: Calculates differences between old and new lists for efficient updates\n- **Layout Manager**: Manages item positioning (LinearLayoutManager for lists)\n\n```kotlin\nclass ProfileAdapter : ListAdapter<Profile, ProfileAdapter.ViewHolder>(DiffCallback()) {\n    \n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {\n        val view = LayoutInflater.from(parent.context)\n            .inflate(R.layout.item_profile, parent, false)\n        return ViewHolder(view)\n    }\n    \n    override fun onBindViewHolder(holder: ViewHolder, position: Int) {\n        holder.bind(getItem(position))\n    }\n    \n    class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {\n        fun bind(profile: Profile) {\n            // Bind profile data to views\n        }\n    }\n    \n    class DiffCallback : DiffUtil.ItemCallback<Profile>() {\n        override fun areItemsTheSame(oldItem: Profile, newItem: Profile): Boolean =\n            oldItem.id == newItem.id\n        \n        override fun areContentsTheSame(oldItem: Profile, newItem: Profile): Boolean =\n            oldItem == newItem\n    }\n}\n```","diagram":"flowchart TD\n  A[Data List] --> B[DiffUtil]\n  B --> C[RecyclerView.Adapter]\n  C --> D[onCreateViewHolder]\n  C --> E[onBindViewHolder]\n  D --> F[ViewHolder]\n  E --> F\n  F --> G[Item Views]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Goldman Sachs","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-08T11:54:34.605Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-976","question":"You are building an Android app that tracks a delivery ride; location updates every 5 seconds; battery life; Doze; Provide plan using FusedLocationProvider, ForegroundService, and WorkManager; include backoff; testing; intermittent connectivity?","answer":"Use a foreground service with FusedLocationProviderClient to push location updates every 5 seconds, tying updates to a persistent notification. Fetch with a LocationRequest.interval 5000ms, fastestInt","explanation":"## Why This Is Asked\nThis question mirrors real-world Android ride-hailing apps where location streaming and battery life are critical and Doze/work manager constraints matter.\n\n## Key Concepts\n- ForegroundService for ongoing tasks\n- FusedLocationProvider and LocationRequest parameters\n- WorkManager for deferred/inflight uploads with backoff\n- Doze and app standby handling; cancellation on ride end\n- Testing strategies with mock location, Robolectric, and Doze scenarios\n\n## Code Example\n```kotlin\nval locationRequest = LocationRequest.create().apply {\n  interval = 5000\n  fastestInterval = 2500\n  priority = LocationRequest.PRIORITY_HIGH_ACCURACY\n}\n```\n\n## Follow-up Questions\n- How would you test Doze behavior and network flakiness?\n- How do you handle user revoking location permissions mid-ride?","diagram":null,"difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Oracle","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T17:39:57.289Z","createdAt":"2026-01-12T17:39:57.289Z"},{"id":"q-205","question":"How would you implement Compose Navigation with nested graphs, shared ViewModels, configuration change handling, and deep linking in a production Android app?","answer":"Use NavHost with nested NavGraphs, HiltViewModel for scoped VMs, SavedStateHandle for deep link parameters, and rememberSaveable for state preservation across configuration changes.","explanation":"## Implementation Strategy\n\n**Navigation Setup:**\n```kotlin\n@Composable\nfun AppNavigation() {\n    val navController = rememberNavController()\n    NavHost(\n        navController = navController,\n        startDestination = \"home\"\n    ) {\n        navigation(\"home\", \"home_graph\") {\n            composable(\"detail/{id}\") { backStackEntry ->\n                val viewModel: SharedViewModel = hiltViewModel()\n                DetailScreen(viewModel, backStackEntry.arguments?.getString(\"id\"))\n            }\n        }\n    }\n}\n```\n\n**ViewModel Scoping:**\n- Use `hiltViewModel()` for NavGraph-scoped ViewModels\n- Share ViewModels across nested navigation graphs\n- Leverage `@HiltViewModel` and `@Inject` for dependency injection\n\n**Configuration Changes:**\n- `rememberSaveable` for UI state preservation\n- ViewModel automatically survives configuration changes\n- Use `SavedStateHandle` for navigation parameter persistence\n\n**Deep Linking:**\n```kotlin\ncomposable(\n    \"detail/{id}\",\n    deepLinks = listOf(navDeepLink {\n        uriPattern = \"app://detail/{id}\"\n    })\n) { backStackEntry ->\n    val id = backStackEntry.arguments?.getString(\"id\")\n    val viewModel: SharedViewModel = hiltViewModel()\n    viewModel.loadDetails(id)\n}\n```\n\n**Key Considerations:**\n- Handle back stack properly with nested graphs\n- Use `popUpTo` for navigation flow control\n- Implement proper state restoration with `SavedStateHandle`\n- Consider memory leaks with long-lived ViewModels","diagram":"graph TD\n    A[NavHost] --> B[Home Graph]\n    A --> C[Profile Graph]\n    A --> D[Settings Graph]\n    C --> E[Profile Screen]\n    C --> F[Edit Profile]\n    E --> G[ProfileViewModel]\n    F --> G\n    H[Deep Link] --> I[SavedStateHandle]\n    I --> G\n    J[Config Change] --> K[rememberSaveable]\n    K --> G","difficulty":"intermediate","tags":["composables","state","navigation"],"channel":"android","subChannel":"jetpack-compose","sourceUrl":null,"videos":{"longVideo":"https://www.youtube.com/watch?v=FIEnIBq7Ups"},"companies":["Amazon","Google","Meta","Microsoft","Netflix","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":["compose navigation","navhost","nested navgraphs","hiltviewmodel","savedstatehandle","remembersaveable","configuration changes"],"voiceSuitable":true,"isNew":false,"lastUpdated":"2025-12-27T05:45:37.585Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-182","question":"What is the first lifecycle method called when an Android Activity is created, and what critical initialization tasks must be performed within it?","answer":"onCreate() is the first lifecycle method called when an Activity is created. It receives a Bundle savedInstanceState parameter containing previous state data for activity recreation. You must call super.onCreate(savedInstanceState) first, then setContentView() to initialize the UI, followed by component initialization, view setup, and data binding. This method runs only once per activity instance unless recreated by the system.","explanation":"## Interview Context\nThis question tests understanding of Android Activity lifecycle fundamentals and proper initialization patterns. Candidates should demonstrate knowledge of state management and recreation scenarios.\n\n## Key Points\n- **onCreate()** is always the first lifecycle method called\n- **Bundle savedInstanceState** preserves state during activity recreation\n- **super.onCreate()** must be called before any other operations\n- **setContentView()** should be called early to establish the UI hierarchy\n- **One-time initialization** like adapters, listeners, and data loading\n\n## Code Example\n```java\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState); // Must be first\n    setContentView(R.layout.activity_main); // UI setup\n    \n    // Initialize components\n    initializeViews();\n    setupListeners();\n    \n    // Restore state if available\n    if (savedInstanceState != null) {\n        restoreData(savedInstanceState);\n    }\n}\n```\n\n## Follow-up Questions\n- What happens if you don't call super.onCreate()?\n- When would savedInstanceState be null vs non-null?\n- What's the difference between onCreate() and onRestart()?\n- How do you handle configuration changes in onCreate()?","diagram":"graph TD\n    A[onCreate] --> B[onStart]\n    B --> C[onResume]\n    C --> D[Running]\n    D --> E[onPause]\n    E --> F[onStop]\n    F --> G[onDestroy]","difficulty":"beginner","tags":["lifecycle","components"],"channel":"android","subChannel":"lifecycle","sourceUrl":null,"videos":null,"companies":["Amazon","Google","Meta","Microsoft","Netflix","Uber"],"eli5":"Imagine you're building with LEGOs! When you start making a new toy, the first thing you do is open the LEGO box and lay out all your pieces. That's exactly what onCreate() does - it's like opening the toy box and getting everything ready before you start playing. Just like you need to see all your LEGO pieces first before you can build your castle, an Android app needs to call onCreate() first to get all its pieces ready before it can show you the screen and start working!","relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-25T16:45:33.939Z","createdAt":"2025-12-26 12:51:07"}],"subChannels":["architecture","general","jetpack-compose","lifecycle"],"companies":["Adobe","Airbnb","Amazon","Anthropic","Apple","Bloomberg","Citadel","Cloudflare","Databricks","Discord","DoorDash","Goldman Sachs","Google","Hashicorp","Hugging Face","IBM","Instacart","Lyft","Meta","Microsoft","MongoDB","Netflix","Oracle","PayPal","Plaid","Robinhood","Salesforce","Scale Ai","Slack","Snap","Snowflake","Square","Tesla","Twitter","Two Sigma","Uber","Zoom"],"stats":{"total":37,"beginner":12,"intermediate":15,"advanced":10,"newThisWeek":30}}