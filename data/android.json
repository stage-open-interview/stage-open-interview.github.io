{"questions":[{"id":"q-258","question":"How would you design a reactive Android ViewModel using StateFlow with sealed classes to handle network API responses, ensuring proper error handling and loading states?","answer":"Use MutableStateFlow<UiState> with sealed class (Loading/Success/Error) and collect with catch operator for error handling in coroutine scope.","explanation":"## Concept Overview\nCombining StateFlow with sealed classes creates a type-safe, reactive state management pattern perfect for handling API responses. The StateFlow holds the current UI state while sealed classes define all possible states, enabling compile-time safety when handling different scenarios.\n\n## Implementation Details\n\n### 1. Define Sealed Class for UI States\n```kotlin\nsealed class UiState<out T> {\n    object Loading : UiState<Nothing>()\n    data class Success<T>(val data: T) : UiState<T>()\n    data class Error(val exception: Throwable) : UiState<Nothing>()\n}\n```\n\n### 2. ViewModel Implementation\n```kotlin\nclass UserRepository @Inject constructor(\n    private val apiService: ApiService\n) {\n    private val _usersState = MutableStateFlow<UiState<List<User>>>(UiState.Loading)\n    val usersState: StateFlow<UiState<List<User>>> = _usersState.asStateFlow()\n\n    fun fetchUsers() {\n        viewModelScope.launch {\n            _usersState.value = UiState.Loading\n            apiService.getUsers()\n                .catch { exception ->\n                    _usersState.value = UiState.Error(exception)\n                }\n                .collect { users ->\n                    _usersState.value = UiState.Success(users)\n                }\n        }\n    }\n}\n```\n\n### 3. Activity/Fragment Collection\n```kotlin\nlifecycleScope.launch {\n    viewModel.usersState.collect { state ->\n        when (state) {\n            is UiState.Loading -> showProgressBar()\n            is UiState.Success -> showUsers(state.data)\n            is UiState.Error -> showError(state.exception.message)\n        }\n    }\n}\n```\n\n## Common Pitfalls\n- **Memory Leaks**: Always use `viewModelScope` or `lifecycleScope` for coroutines\n- **State Conflation**: StateFlow is conflated by default - rapid updates may be lost\n- **Backpressure**: Use `buffer()` or `conflate() strategically for high-frequency updates\n- **Initial State**: Always initialize StateFlow with a meaningful default state\n- **Error Propagation**: Don't forget the `catch` operator to prevent cancellation","diagram":"graph TD\n    A[User Action] --> B[ViewModel.fetchUsers]\n    B --> C[_usersState.value = Loading]\n    C --> D[API Service Call]\n    D --> E{Response}\n    E -->|Success| F[_usersState.value = Success]\n    E -->|Error| G[_usersState.value = Error]\n    F --> H[UI Updates with Data]\n    G --> I[UI Shows Error Message]\n    C --> J[UI Shows Loading]\n    J --> K[StateFlow.collect in Activity]\n    K --> L[when statement handles state]\n    L --> M{State Type}\n    M -->|Loading| N[Show ProgressBar]\n    M -->|Success| O[Display Data]\n    M -->|Error| P[Show Error]","difficulty":"intermediate","tags":["coroutines","flow","sealed-classes"],"channel":"android","subChannel":"architecture","sourceUrl":"https://medium.com/@dharmakshetri/robust-error-handling-in-android-7aedf5b6a878","videos":{"shortVideo":"https://www.youtube.com/watch?v=rnRsUiI3W9o","longVideo":"https://www.youtube.com/watch?v=5OrK81ZRoNY"},"companies":["Airbnb","Google","Meta","Microsoft","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-22T08:33:46.738Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-1022","question":"You're building an Android field-inspection app where users collect forms and photos offline. When connectivity returns, design a robust sync engine that uploads only new or updated items, resolves conflicts via last_modified, and handles intermittent networks. Use WorkManager with network constraints and a foreground service for long syncs; include backoff and tests?","answer":"Leverage Room entities with fields id, last_modified, and synced flag. Use a CoroutineWorker triggered by NETWORK_CONNECTED; query items where synced = false or last_modified > serverVersion. Upload w","explanation":"## Why This Is Asked\n\nTests ability to design offline-first sync, conflict resolution, and production readiness with Android components.\n\n## Key Concepts\n\n- WorkManager constraints (NETWORK_CONNECTED, battery)\n- Foreground services for long work\n- Room for offline storage\n- Retrofit/API design for incremental sync\n- Conflict resolution by timestamps\n- Testing offline/unstable networks\n\n## Code Example\n\n```kotlin\nclass SyncWorker(...) : CoroutineWorker(...) {\n  override suspend fun doWork(): Result {\n     // pseudo\n     return Result.success()\n  }\n}\n```\n\n## Follow-up Questions\n\n- How would you handle large media uploads?\n- How would you simulate flaky network in tests?","diagram":"flowchart TD\n  A[Offline local data] --> B[Queue sync with WorkManager]\n  B --> C{Network available?}\n  C -->|Yes| D[Upload diffs via Retrofit]\n  C -->|No| E[Retry with backoff]\n  D --> F[Resolve conflicts by last_modified]\n  F --> G[Mark synced]\n  E --> H[Backoff timer]\n  G --> I[Sync complete]","difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Goldman Sachs","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T19:34:43.117Z","createdAt":"2026-01-12T19:34:43.117Z"},{"id":"q-1127","question":"Design a beginner Android feature: a simple offline notes app. Notes stored in Room with fields id, text, tag, last_modified. Provide a tag-based search, and a background export to cloud via WorkManager that runs only on WiFi and while charging. Ensure deduplication by last_modified, handle restarts, and outline a minimal test plan?","answer":"Proposed model: Note(id: String, text: String, tag: String, last_modified: Long). Use a Room DAO for upsert and search by tag, with a small repository. Schedule a WorkManager ExportWorker that runs wh","explanation":"## Why This Is Asked\nAssesses data layer with Room, background work with WorkManager, and simple conflict resolution. It also checks testing strategy for persistence and workers.\n\n## Key Concepts\n- Room: entities, DAO, upsert, queries\n- WorkManager: constraints, backoff, retries\n- Sync logic: last_modified dedup, restart resilience\n- Testing: Dao tests, Worker tests, integration hints\n\n## Code Example\n```kotlin\n@Entity\ndata class Note(val id: String, val text: String, val tag: String, val last_modified: Long)\n\n@Dao\ninterface NoteDao {\n  @Insert(onConflict = OnConflictStrategy.REPLACE)\n  fun upsert(note: Note)\n\n  fun searchByTag(tag: String): List<Note>\n}\n```\n\n```kotlin\nclass ExportWorker(ctx: Context, params: WorkerParameters) : CoroutineWorker(ctx, params) {\n  override suspend fun doWork(): Result {\n    // export logic here (mock)\n    return Result.success()\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test the dedup logic across restarts?\n- What backoff strategy would you choose and why?","diagram":null,"difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T23:32:40.245Z","createdAt":"2026-01-12T23:32:40.245Z"},{"id":"q-1143","question":"You’re building a chat-like Android app. Messages are stored in Room with fields: id (UUID), text (String), timestamp (Long), status (pending, sending, sent, failed). When sending, insert a pending message and enqueue a WorkManager task to upload unsent messages when online, using exponential backoff. On success, save serverId and set status to sent; on failure, keep failed with a retriable option. Outline the data flow, DAO/Worker skeleton, and offline→online test plan?","answer":"Insert a pending message into Room with a client-generated id, then enqueue a OneTimeWorkRequest with network constraint and exponential backoff. In the Worker, fetch unsent messages, POST to the serv","explanation":"## Why This Is Asked\n\nThis question probes practical use of WorkManager for reliable background sync, Room transactions, and idempotent updates. It also covers testing offline→online flows and error handling in a beginner-friendly way.\n\n## Key Concepts\n\n- WorkManager with network constraints and backoff\n- Room data modeling and transactional updates\n- Idempotent client-side retries and serverId mapping\n- Testing offline→online scenarios with mock servers\n\n## Code Example\n\n```kotlin\n@Entity\ndata class Message(\n  @PrimaryKey val id: IdType,\n  val text: TextType,\n  val timestamp: TimeType,\n  val status: StatusType,\n  val serverId: ServerIdType?\n)\n\n@Dao\ninterface MessageDao {\n  suspend fun unsent(): List<Message>\n  suspend fun insert(m: Message)\n  suspend fun update(m: Message)\n}\n\nclass SyncWorker(appContext: Context, params: WorkerParameters): CoroutineWorker(appContext, params) {\n  override suspend fun doWork(): Result {\n    // fetch unsent, POST, handle response, update DB\n    return Result.success()\n  }\n}\n```\n\n## Follow-up Questions\n\n- How would you adjust for 429 throttling or server errors?\n- How would you test race conditions with multiple concurrent messages?","diagram":"flowchart TD\n  A[User sends message] --> B[Insert pending in Room]\n  B --> C[Enqueue WorkManager task]\n  C --> D{Network available?}\n  D -->|Yes| E[Worker uploads]\n  D -->|No| F[Backoff/Retry]\n  E --> G[200: status=sent, serverId]\n  E --> H[Retry on error]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Snowflake","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T01:30:23.336Z","createdAt":"2026-01-13T01:30:23.336Z"},{"id":"q-1267","question":"You're building an Android offline-first app that records field observations (id, timestamp, value) in Room. Changes are queued when offline and synced to a REST backend when online. Implement a robust sync with versioning, conflict resolution (server-wins, client-wins, or merge), and tombstones. Describe data flow, DAO/Repository, a WorkManager worker, and a testing strategy for edge cases like concurrent edits and delayed pushes?","answer":"Propose a Room table with id, timestamp, value, version, and isDeleted tombstone. Use a WorkManager worker to batch dirty rows, send delta patches with baseVersion, and let server resolve conflicts (s","explanation":"## Why This Is Asked\n\nTests practical offline-first data synchronization with versioning, conflict resolution, and tombstones, a common real-world pattern for mobile data apps.\n\n## Key Concepts\n\n- Offline-first sync with local mutation queue\n- Versioning and tombstones for deletions\n- Conflict resolution strategies (server-wins, client-wins, merge)\n- Efficient batching via WorkManager; idempotent retries\n\n## Code Example\n\n```kotlin\n@Entity(tableName = \"observations\")\ndata class Observation(\n  @PrimaryKey val id: String,\n  val timestamp: Long,\n  val value: Double,\n  val version: Long,\n  val isDeleted: Boolean = false\n)\n\n@Dao\ninterface ObservationDao {\n  @Insert(onConflict = OnConflictStrategy.REPLACE)\n  suspend fun upsert(obs: Observation)\n\n  @Query(\"SELECT * FROM observations WHERE isDeleted = 0\")\n  suspend fun allActive(): List<Observation>\n\n  @Query(\"SELECT * FROM observations WHERE timestamp > :since\")\n  suspend fun recent(since: Long): List<Observation>\n}\n```\n\n## Follow-up Questions\n\n- How would you test conflict scenarios end-to-end (offline edits, delayed pushes, concurrent edits)?\n- What backend data model and API contract would you define to support delta patches and tombstones safely?","diagram":null,"difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Hugging Face","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T07:33:13.126Z","createdAt":"2026-01-13T07:33:13.126Z"},{"id":"q-1388","question":"Implement a field survey photo capture in Android: tap Capture to take a photo, request CAMERA permission via the Activity Result API, use TakePicturePreview to obtain a Bitmap, save it to internal storage with a timestamped filename, and display a preview in an ImageView. Ensure rotation safety and a graceful denial/retry flow. What code would you write?","answer":"Use the Activity Result API: register for RequestPermission(CAMERA) and grant path; on approval, launch TakePicturePreview to get a Bitmap, then save it to internal storage with a timestamped filename","explanation":"## Why This Is Asked\nTests understanding of runtime permissions, modern Android Activity Result APIs, simple photo capture flow, and lifecycle-safe storage.\n\n## Key Concepts\n- Activity Result API (RequestPermission, TakePicturePreview)\n- Runtime permissions and user rationale\n- Bitmap handling and internal storage with openFileOutput\n- Rotation-safe UI with ViewModel/Lifecycle\n- Basic error handling and retry\n\n## Code Example\n```javascript\n// (Note: labeled as javascript per formatting requirement; represents Kotlin-style approach)\nclass PhotoViewModel extends ViewModel {\n  var imagePath: String? = null\n}\n\nclass PhotoActivity extends AppCompatActivity {\n  private finalPhotoViewModel = viewModels<PhotoViewModel>()\n  private lateinit var imageView: ImageView\n\n  private val requestCameraPermission = registerForActivityResult(ActivityResultContracts.RequestPermission()) { granted ->\n    if (granted) launchTakePreview()\n    else showRationale()\n  }\n\n  private val takePreview = registerForActivityResult(ActivityResultContracts.TakePicturePreview()) { bmp ->\n    bmp?.let {\n      val filename = \"survey_${System.currentTimeMillis()}.jpg\"\n      openFileOutput(filename, MODE_PRIVATE).use { out -> it.compress(Bitmap.CompressFormat.JPEG, 90, out) }\n      viewModel.imagePath = filename\n      imageView.setImageBitmap(it)\n    }\n  }\n\n  private fun launchTakePreview() { takePreview.launch(null) }\n\n  private fun onCaptureClicked() { requestCameraPermission.launch(Manifest.permission.CAMERA) }\n\n  private fun showRationale() { /* show dialog and offer retry */ }\n}\n```\n\n## Follow-up Questions\n- How would you handle saving very large photos without exhausting memory?\n- How would you test permission denial paths across rotation and app restart?","diagram":"flowchart TD\n  A[User taps Capture] --> B[Request CAMERA permission]\n  B --> C{Granted?}\n  C -->|Yes| D[Launch TakePicturePreview]\n  D --> E[Bitmap returned]\n  E --> F[Save to internal storage]\n  F --> G[Display in ImageView]\n  C -->|No| H[Show rationale and retry]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Bloomberg","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T14:49:35.020Z","createdAt":"2026-01-13T14:49:35.020Z"},{"id":"q-1715","question":"You're building an Android module to support background, continuous BLE logging from an OBD-II dongle for a fleet-tracking app. Requirements: maintain a stable BLE connection with automatic reconnect and backoff; buffer data locally in Room during disconnect; periodically upload batched logs via WorkManager with exponential backoff; use a ForegroundService while in the background; respect Doze/App Standby; outline data flow, architecture, and a minimal skeleton of the BLE manager, DAO, and Worker; include a test plan for connectivity changes and battery constraints?","answer":"Ble path: a BleManager with a lifecycle-aware coroutine scope handles connect/disconnect and an exponential reconnect backoff. Logs stored as Room entities (LogEntry: id, ts, rssi, value, synced). A U","explanation":"## Why This Is Asked\n\nThis question probes robust BLE handling, offline buffering, and reliable background uploads in Android. It tests lifecycle, Doze awareness, and system-resilience trade-offs.\n\n## Key Concepts\n\n- BLE connection lifecycle and reconnection strategies\n- Room for local buffering and tombstone-ish semantics\n- WorkManager for batched uploads with exponential backoff\n- ForegroundService in background and Doze compatibility\n- Testing strategies for connectivity, power modes, and data integrity\n\n## Code Example\n\n```kotlin\nclass BleManager(context: Context) {\n    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())\n    private var gatt: BluetoothGatt? = null\n\n    fun connect(device: BluetoothDevice) { /* initiate and monitor gatt; on failure schedule reconnect */ }\n    fun disconnect() { /* clean up gatt */ }\n    private fun scheduleReconnect(delayMs: Long) { /* ... */ }\n}\n```\n\n```kotlin\n@Entity\ndata class LogEntry(\n  @PrimaryKey val id: String,\n  val ts: Long,\n  val rssi: Int,\n  val value: String,\n  val synced: Boolean\n)\n```\n\n```kotlin\nclass UploadWorker(appContext: Context, params: WorkerParameters) : CoroutineWorker(appContext, params) {\n    override suspend fun doWork(): Result {\n        // fetch unsynced logs, batch and POST, mark as synced on success, retry on failure\n        return Result.success()\n    }\n}\n```\n\n## Follow-up Questions\n\n- How would you test this with simulated BLE disconnects and network outages in CI?\n- How would you handle data schema evolution for LogEntry without breaking older devices?","diagram":"flowchart TD\n  A[BLE connected] --> B[Buffer in Room]\n  B --> C[UploadWorker batches]\n  C --> D[Backend server]\n  A --> E[ForegroundService keeps process alive]\n  E --> F[Doze/App Standby aware]","difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Lyft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T07:50:07.962Z","createdAt":"2026-01-14T07:50:07.962Z"},{"id":"q-1880","question":"You’re building an Android app that streams live telemetry video from a drone's camera over an unstable network. Using CameraX, encoding with H.264, and a hybrid UDP/TCP transport, design a solution that includes buffering and backpressure, a foreground service with Doze-friendly behavior, adaptive bitrate, and robust error handling. Provide data flow, key classes (StreamingManager, PacketSender), and a skeleton implementation plus an end-to-end test plan for packet loss and latency?","answer":"Implement a bounded circular frame buffer, encode frames with MediaCodec to H.264, stream data via UDP with FEC and a TCP channel for control, and use a ForegroundService with WakeLock to persist in D","explanation":"## Why This Is Asked\nTests ability to design resilient media streaming over unreliable networks on Android, balancing power, latency, and data integrity.\n\n## Key Concepts\n- CameraX and MediaCodec for H.264\n- UDP/TCP hybrid transport with backpressure\n- ForegroundService, WakeLock, Doze compatibility\n- Adaptive bitrate using RTT and packet loss\n- Testing for jitter, drops, and backoffs\n\n## Code Example\n```javascript\nclass StreamingManager {\n  constructor(bufferCapacity = 1024) {}\n  start() {}\n  pushFrame(frame) {}\n}\nclass PacketSender {\n  constructor() {}\n  sendFrame(frame) {}\n}\n```\n\n## Follow-up Questions\n- How would you measure and log end-to-end latency in production?\n- What failure modes would you test (outages, jitter, reordering) and how would you simulate them?","diagram":"flowchart TD\n  A[Camera Frame] --> B[Buffer] \n  B --> C[StreamingManager] \n  C --> D[PacketSender] \n  D --> E[Network (UDP/TCP)]","difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T15:40:17.817Z","createdAt":"2026-01-14T15:40:17.817Z"},{"id":"q-2076","question":"You're building a beginner Android app that logs field visits. The main screen shows a list of visits (id, siteName, timestamp). Implement adding a visit via a dialog, persist with Room, and a DataStore-backed sort toggle (timestamp ascending/descending) that preserves the choice across rotations. Describe data flow, DAO/Repository, ViewModel, and a minimal UI test plan?","answer":"Use MVVM with Room and DataStore. Visit entity(id, siteName, timestamp). DAO supports insert and query with sort order. Repository mediates. ViewModel exposes LiveData<List<Visit>> driven by a sortOrder preference from DataStore. Dialog collects input, inserts via Repository, and list updates automatically.","explanation":"## Why This Is Asked\n\nTests practical Android fundamentals: MVVM, Room persistence, DataStore for simple state, and rotation handling with UI state. It also probes testing strategy for data layers and small UI flows.\n\n## Key Concepts\n\n- Room: Entity, DAO, and queries with dynamic sort\n- DataStore: simple, persistent sort preference\n- MVVM: ViewModel + LiveData + Repository pattern\n- Rotation handling: preserving list state and dialog input flows\n\n## Code Example\n\n```kotlin\n@Entity data class Visit(val id: Long, val siteName: String, val timestamp: Long)\n@Dao interface VisitDao {\n    @Insert suspend fun insert(visit: Visit)\n    @Query(\"SELECT * FROM Visit ORDER BY timestamp :sortOrder\")\n    fun getAllVisits(sortOrder: String): LiveData<List<Visit>>\n}\n\nclass VisitRepository(\n    private val dao: VisitDao,\n    private val dataStore: DataStore<Preferences>\n) {\n    private val SORT_KEY = stringPreferencesKey(\"sort_order\")\n    \n    val sortOrder: Flow<String> = dataStore.data.map { it[SORT_KEY] ?: \"ASC\" }\n    \n    suspend fun insert(visit: Visit) = dao.insert(visit)\n    suspend fun setSortOrder(order: String) {\n        dataStore.edit { it[SORT_KEY] = order }\n    }\n    \n    fun getVisits(): LiveData<List<Visit>> {\n        return sortOrder.flatMapLatest { order ->\n            dao.getAllVisits(order)\n        }.asLiveData()\n    }\n}\n\nclass VisitViewModel(\n    private val repository: VisitRepository\n) : ViewModel() {\n    val visits: LiveData<List<Visit>> = repository.getVisits()\n    val sortOrder: LiveData<String> = repository.sortOrder.asLiveData()\n    \n    fun addVisit(siteName: String) {\n        viewModelScope.launch {\n            val visit = Visit(\n                id = System.currentTimeMillis(),\n                siteName = siteName,\n                timestamp = System.currentTimeMillis()\n            )\n            repository.insert(visit)\n        }\n    }\n    \n    fun toggleSort() {\n        viewModelScope.launch {\n            val current = sortOrder.value ?: \"ASC\"\n            repository.setSortOrder(if (current == \"ASC\") \"DESC\" else \"ASC\")\n        }\n    }\n}\n```\n\n## Data Flow\n\n1. **Dialog Input** → ViewModel.addVisit() → Repository.insert() → Room DAO → Database\n2. **Sort Toggle** → ViewModel.toggleSort() → Repository.setSortOrder() → DataStore → Triggers LiveData refresh\n3. **List Display** → ViewModel.visits LiveData → UI observes → Automatic updates on data/sort changes\n4. **Rotation** → DataStore preserves sort preference → LiveData maintains list state → UI restores seamlessly\n\n## UI Test Plan\n\n1. **Add Visit Test**: Verify dialog opens, input accepted, and list updates with new entry\n2. **Sort Toggle Test**: Confirm sort button changes order and persists across rotation\n3. **Persistence Test**: Check data survives app restart and sort preference remains\n4. **Edge Cases**: Test empty list, duplicate entries, and rapid sort changes","diagram":"flowchart TD\nA[User adds Visit] --> B{Data Flow}\nB --> C[VisitDao.insert(Visit)]\nC --> D[LiveData updates List<Visit>]\nD --> E[UI List Rerenders]\nA --> F[Toggle Sort] --> G[DataStore save sort]\nG --> H[ViewModel requeryVisits]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Salesforce","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T05:32:43.683Z","createdAt":"2026-01-14T23:29:57.485Z"},{"id":"q-2143","question":"You're building a beginner Android checklist app: store items in Room (id, title, completed, dueDate), display them in a RecyclerView, and support add/edit/delete. Implement a one-time reminder using WorkManager that triggers a Notification at dueDate, with a backoff if scheduling fails or the device is asleep. Describe data flow (DAO/Repository), Worker implementation, and a test plan for offline item creation and overdue reminders?","answer":"Notes live in Room with fields id, title, completed, dueDate; a Repository exposes a Flow<List<Note>> consumed by a ViewModel and observed by the UI. ReminderWorker schedules a one-time work with an i","explanation":"## Why This Is Asked\nTests local persistence, MVVM, and background work; verifies handling of Doze and backoff; covers testing offline flows.\n\n## Key Concepts\n- Room: DAO, entities, Flow\n- Repository + ViewModel + RecyclerView\n- WorkManager: OneTimeWorkRequest, initialDelay, backoff\n- Notifications and channels\n- Testing offline and timer-based flows\n\n## Code Example\n```javascript\nclass ReminderWorker(appContext: Context, params: WorkerParameters) : CoroutineWorker(appContext, params) {\n  override suspend fun doWork(): Result {\n    // fetch due item, post notification, return Result.success() or retry()\n    return Result.success()\n  }\n}\n```\n\n## Follow-up Questions\n- How to handle time zones and daylight saving changes?\n- How to update or cancel a reminder when dueDate changes?\n","diagram":"flowchart TD\nA[Add item] --> B[Room insert]\nB --> C[Flow emits]\nC --> D[UI updates RecyclerView]\nD --> E[Schedule Reminder with WorkManager]\nE --> F[Notification shown]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T04:23:10.683Z","createdAt":"2026-01-15T04:23:10.683Z"},{"id":"q-2195","question":"You're building an Android field tool app used by technicians to annotate images and run on-device ML for scene classification with offline-first data collection. The app must train a lightweight model locally from user-labeled samples, support incremental model updates delivered from the backend, and handle intermittent connectivity. Design end-to-end architecture and data flow using Room, DataStore, WorkManager, and TensorFlow Lite. Address offline training, model versioning, delta updates, rollback, and testing under Doze and flaky networks?","answer":"Approach: store labeled samples in Room; train a compact TensorFlow Lite model on-device; deliver incremental delta-weights via backend updates; track modelVersion in DataStore; apply updates with ide","explanation":"## Why This Is Asked\n\nTests on-device ML integration, offline-first data, and robust model update workflows—critical for scalable mobile apps.\n\n## Key Concepts\n\n- On-device ML with TensorFlow Lite and delta updates\n- Offline data pipeline with Room and DataStore\n- Scheduled syncs and backoff with WorkManager\n- Versioning, rollback, and conflict resolution strategies\n\n## Code Example\n\n```kotlin\ndata class ModelDelta(val weights: ByteArray, val version: Int)\nfun applyDelta(base: ByteArray, delta: ModelDelta): ByteArray {\n    // merge weights carefully; ensure determinism and integrity checks\n    return merge(base, delta.weights)\n}\n```\n\n## Follow-up Questions\n\n- How would you design schema/version metadata to support seamless rollback?\n- What tests would you add for offline training convergence and update conflicts?","diagram":null,"difficulty":"advanced","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","Lyft","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T07:03:13.640Z","createdAt":"2026-01-15T07:03:13.640Z"},{"id":"q-2216","question":"You're building an Android offline-first note app that provides fast full-text search across local notes and syncs with a central server. Implement using Room + FTS for search on title/content, a tombstone strategy, and a versioned sync via WorkManager with exponential backoff. Describe the data model (Note: id, title, content, updatedAt, version, tombstone), DAO/FTS setup, sync flow, and a test plan for offline edits, conflicts, and index consistency?","answer":"Use Room with an FTS4 index for notes (id, title, content, updatedAt, version, tombstone). Maintain a searchable mirror and reindex on updates. Sync via WorkManager: push local changes with exponentia","explanation":"## Why This Is Asked\n\nAssesses ability to design offline-first search with robust sync, conflict handling, and tombstone tracking—critical for mobile apps that must operate in flaky networks.\n\n## Key Concepts\n\n- Room + FTS for local search\n- Tombstone pattern for deletes\n- Versioned sync with WorkManager\n- Exponential backoff strategy\n- Conflict resolution (server-wins + client-merge)\n\n## Code Example\n\n```javascript\n// Pseudocode: data model and sync flow\n```\n\n## Follow-up Questions\n\n- How would you test conflict resolution across devices?\n- How would you validate index reindexing after large note updates?","diagram":"flowchart TD\n  A[Local Change] --> B[Room DB]\n  B --> C[WorkManager Sync]\n  C --> D[Server]\n  D --> E[Remote Changes]\n  E --> F[WorkManager Sync]\n  F --> G[Room DB]\n  G --> H[Search Index Updated]","difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Hashicorp","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T07:43:43.794Z","createdAt":"2026-01-15T07:43:43.794Z"},{"id":"q-2447","question":"Design an Android enterprise app feature delivery strategy using dynamic feature modules and server-driven flags. Describe how you would (1) ship features on demand with Play Feature Delivery, (2) implement server-driven flags with offline caching, versioning, and safe rollbacks, (3) support canary and percentage rollout per device, (4) ensure startup safety and crash resilience, and (5) validate with test plans and telemetry?","answer":"Leverage Play Feature Delivery for dynamic features and a server-driven flag service (Remote Config or REST). Cache flags in Proto DataStore with a version tag; refresh via WorkManager; determine cana","explanation":"## Why This Is Asked\nThis question probes practical mastery of modular delivery, server-driven configuration, and robust offline behavior in Android at scale.\n\n## Key Concepts\n- Dynamic feature modules and Play Feature Delivery\n- Server-driven feature flags and offline caching\n- Versioning, canaries, and safe rollback\n- Startup safety, crash resilience, and telemetry\n- Testing: unit, instrumentation, and end-to-end validation\n\n## Code Example\n```kotlin\nfun isFeatureEnabled(flag: Flag): Boolean {\n  // Read from Proto DataStore; fallback to default if offline\n  // Compare version and treat device-specific canary accordingly\n  return flag.enabled && flag.version == currentVersion\n}\n```\n\n## Follow-up Questions\n- How would you handle schema migrations for features toggled off/on mid-release?\n- What metrics would you collect to evaluate rollout success and stability?","diagram":"flowchart TD\n  A[Device] -->|Fetch flags| B[FlagService]\n  B --> C{Feature enabled}\n  C --> D[Activate Feature]\n  C --> E[Graceful fallback]","difficulty":"advanced","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T18:52:37.629Z","createdAt":"2026-01-15T18:52:37.629Z"},{"id":"q-2547","question":"Design an Android module that performs on-device NLP inference using a Hugging Face model for chat intent detection. Build a ModelManager with components: ModelRepo (versioned storage), InferenceEngine (off-UI thread), MemoryMonitor, and Updater (WorkManager with backoff). It should load from internal storage, download updates when online, switch between a large and compact model based on memory, support cancellation with timeouts, and rollback on failure. Describe architecture, data flow, and a concrete test plan for offline updates, memory pressure, and model-load failure?","answer":"ModelManager orchestrates a comprehensive on-device NLP inference system with versioned model management. The ModelRepo component provides versioned storage in internal app storage, while the MemoryMonitor continuously tracks available memory to dynamically select between large and compact models. The InferenceEngine processes chat intent detection requests on background threads with cancellation and timeout capabilities, ensuring responsive UI performance. The Updater leverages WorkManager with exponential backoff to seamlessly download and deploy new model versions when connectivity permits. During failures, the system automatically initiates rollback to the previous stable version, maintaining uninterrupted service reliability.","explanation":"## Why This Is Asked\nTests advanced on-device ML lifecycle management including versioned model caching, memory-adaptive loading strategies, background update mechanisms, and robust rollback protocols.\n\n## Key Concepts\n- On-device inference with versioned ModelRepo architecture\n- Memory-aware model selection using real-time MemoryMonitor\n- Background updates via WorkManager with exponential backoff strategy\n- Safe rollback mechanisms and comprehensive failure recovery\n\n## Code Example\n```kotlin\nclass ModelRepo {\n    fun load(version: String): Model?\n    fun save(version: String, data: ByteArray) {}\n}\n\nclass InferenceEngine(private val repo: ModelRepo) {\n    suspend fun infer(input: String): Re","diagram":null,"difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Hugging Face"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T05:30:11.527Z","createdAt":"2026-01-15T22:36:00.244Z"},{"id":"q-2587","question":"You're building a beginner Android feature that records in-app interactions as Event records (id, screen, action, ts) in Room. When online, batch-upload unsynced events to a REST API via WorkManager with a network constraint and exponential backoff. Show your data model, DAO/repository, how you mark events synced, batch sizing, and a basic test plan for offline queueing and retry behavior?","answer":"Define an Event entity with id: String, screen: String, action: String, ts: Long, synced: Boolean. DAO: insertEvent, getUnsynced(limit), markSynced(ids). Repository: saveEvent(...) and enqueueBatch()","explanation":"Why This Is Asked\n\nTests understanding of local persistence, background work, and reliability without real-time network; ensures familiarity with Room, WorkManager, and basic error-handling.\n\nKey Concepts\n\n- Room entities and DAOs\n- WorkManager constraints and backoff\n- State management (synced flag)\n- Batch processing and idempotency\n\nCode Example\n\n```javascript\n// Kotlin-like pseudocode\n@Entity(tableName = \"events\")\ndata class Event(\n  @PrimaryKey val id: String,\n  val screen: String,\n  val action: String,\n  val ts: Long,\n  val synced: Boolean = false\n)\n\n@Dao\ninterface EventDao {\n  @Insert(onConflict = REPLACE)\n  suspend fun insertEvent(event: Event)\n  \n  @Query(\"SELECT * FROM events WHERE synced = 0 LIMIT :limit\")\n  suspend fun getUnsynced(limit: Int): List<Event>\n  \n  @Query(\"UPDATE events SET synced = 1 WHERE id IN (:ids)\")\n  suspend fun markSynced(ids: List<String>)\n}\n\nclass EventRepository(private val dao: EventDao) {\n  suspend fun saveEvent(screen: String, action: String) {\n    dao.insertEvent(Event(UUID.randomUUID().toString(), screen, action, System.currentTimeMillis()))\n    enqueueBatch()\n  }\n  \n  private fun enqueueBatch() {\n    WorkManager.getInstance().enqueueUniqueWork(\n      \"EventUpload\",\n      ExistingWorkPolicy.REPLACE,\n      OneTimeWorkRequestBuilder<EventUploadWorker>()\n        .setConstraints(Constraints.Builder().setRequiredNetworkType(NetworkType.CONNECTED).build())\n        .setBackoffCriteria(BackoffPolicy.EXPONENTIAL, 30, TimeUnit.SECONDS)\n        .build()\n    )\n  }\n}\n\nclass EventUploadWorker(appContext: Context, workerParams: WorkerParameters) : CoroutineWorker(appContext, workerParams) {\n  override suspend fun doWork(): Result {\n    val dao = EventDatabase.getInstance(applicationContext).eventDao()\n    val batchSize = 50\n    \n    return try {\n      val events = dao.getUnsynced(batchSize)\n      if (events.isEmpty()) return Result.success()\n      \n      apiClient.uploadEvents(events)\n      dao.markSynced(events.map { it.id })\n      Result.success()\n    } catch (e: Exception) {\n      Result.retry()\n    }\n  }\n}\n```\n\nTest Plan\n\n1. Unit test DAO operations for insert/query/update\n2. Test repository saves events locally and enqueues work\n3. Verify WorkManager respects network constraint\n4. Simulate offline → create events → online → verify batch upload\n5. Test retry behavior with failed network calls\n6. Verify synced flag prevents duplicate uploads","diagram":"flowchart TD\n  A[Event Created] --> B[Room Insert]\n  B --> C[Queue in Unsynced]\n  C --> D[WorkManager Batch Upload]\n  D --> E[Server OK] --> F[Mark Synced]\n  D --> G[Retry with Backoff]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Instacart","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T05:08:20.856Z","createdAt":"2026-01-15T23:45:49.074Z"},{"id":"q-2664","question":"You're building an Android module for real-time, offline-first collaborative document editing. Each document uses a CRDT to merge concurrent edits locally and remotely. The app syncs with a central server over WebSocket with a REST fallback; local changes are persisted in Room; security via per-document encryption keys. Describe architecture, data model, CRDT design, sync protocol, and testing plan?","answer":"Propose an architecture that stores per-document CRDT state in Room, uses a lightweight CRDT (e.g., Add-Wins OR-Set) to merge concurrent local edits, and syncs via WebSocket with a REST fallback. Incl","explanation":"## Why This Is Asked\nAssesses the ability to design offline-first, real-time collaboration on mobile, including CRDT data models, sync protocols, conflict resolution, and security.\n\n## Key Concepts\n- CRDTs (Add-Wins / OR-Set)\n- Room persistence\n- WebSocket sync with REST fallback\n- Tombstones and delete semantics\n- Per-document encryption keys\n\n## Code Example\n```kotlin\n// Minimal Add-Wins CRDT sketch\ndata class Dot(val actor: String, val clock: Long)\nclass AddWinsCRDT {\n  private val adds = mutableMapOf<String, MutableSet<Long>>()\n  fun add(e: String, d: Dot) { adds.computeIfAbsent(e) { mutableSetOf() }.add(d.clock) }\n  fun value(): Set<String> = adds.filter { it.value.isNotEmpty() }.keys\n}\n```\n\n## Follow-up Questions\n- How would you handle offline deletes and tombstones?\n- How would you test consistency across multiple clients with network partitions?","diagram":"flowchart TD\nA[Client Edit] --> B[CRDT Merge]\nB --> C[Local Room State]\nC --> D[WebSocket Sync]\nD --> E[Server CRDT State]\nE --> F[Broadcast Updates]","difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T05:47:03.586Z","createdAt":"2026-01-16T05:47:03.587Z"},{"id":"q-2715","question":"Design an Android chat module that delivers end-to-end encrypted real-time messaging for a multi-device collaboration app. Implement a Signal-like ratchet, store device keys in Android Keystore, perform nightly ephemeral key rotation, and queue outgoing messages in Room for offline delivery. Describe architecture, data flow, storage schema, and a test plan for offline queuing, key rotation, and out-of-order delivery under churn?","answer":"Implement a Signal-like ratchet using per-device X25519 keys stored in Android Keystore, with nightly ephemeral key rotation. Derive a fresh session key per contact and encrypt payloads with AES-GCM. ","explanation":"## Why This Is Asked\n\nTests advanced Android security patterns: E2EE, key management on Keystore, offline-first messaging, and device/session revocation in multi-device scenarios.\n\n## Key Concepts\n\n- End-to-end encryption with forward secrecy via a Signal-like ratchet\n- Android Keystore for per-device keys\n- Ephemeral key rotation and session management\n- Room-based offline queue and TLS transport with pinning\n- Revocation and rejoining flows, conflict handling\n\n## Code Example\n\n```javascript\n// Pseudo: derive new shared secret and rotate session\nconst shared = X25519.derive(privateKey, peerPublicKey)\nconst newKey = HKDF(shared, \"message\", 32)\n```\n\n## Follow-up Questions\n\n- How to test key revocation and cross-device sync at scale?\n- How to measure protocol security properties under packet loss?","diagram":"flowchart TD\n  A[Message compose] --> B[Encrypt with session key]\n  B --> C[Store in Room queue]\n  C --> D[Send when online]\n  D --> E[Recipient decrypts with session]\n  E --> F[Session update on recipient]","difficulty":"advanced","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","MongoDB","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T07:47:54.990Z","createdAt":"2026-01-16T07:47:54.990Z"},{"id":"q-452","question":"How would you implement a RecyclerView with multiple view types while maintaining smooth scrolling performance on large datasets?","answer":"Use RecyclerView.Adapter with getItemViewType() to return different view types. Implement the ViewHolder pattern for each type, use DiffUtil for efficient updates, and enable setHasFixedSize(true). For large datasets, implement Paging3 for optimal memory management and smooth scrolling performance.","explanation":"## Multiple View Types Implementation\n- Override getItemViewType() to return different integers based on data position\n- Create separate ViewHolder classes for each distinct view type\n- Use onCreateViewHolder() with the view type parameter to inflate appropriate layouts\n\n## Performance Optimization\n- Implement DiffUtil for efficient list updates with minimal animations\n- Use setHasFixedSize(true) when item sizes are constant to improve performance\n- Enable RecyclerView.RecycledViewPool for enhanced view reuse across adapters\n\n## Large Dataset Handling\n- Implement Paging3 library for efficient infinite scrolling and memory management\n- Use ViewHolder pattern to prevent unnecessary view inflation operations\n- Consider using ConcatAdapter for combining multiple adapters when managing complex layouts","diagram":"flowchart TD\n  A[Data List] --> B[getItemViewType]\n  B --> C{View Type?}\n  C -->|Type 1| D[ViewHolder1]\n  C -->|Type 2| E[ViewHolder2]\n  C -->|Type 3| F[ViewHolder3]\n  D --> G[Bind Data]\n  E --> G\n  F --> G\n  G --> H[RecyclerView Display]","difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Citadel","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-09T08:54:42.447Z","createdAt":"2025-12-26 12:51:05"},{"id":"q-482","question":"How would you handle Activity lifecycle when screen rotates and you need to preserve user input data?","answer":"Use ViewModel with LiveData to preserve data across configuration changes. Save critical state in onSaveInstanceState() for process death scenarios. For simple UI state, use onSaveInstanceState() with Bundle as a lightweight alternative.","explanation":"## Key Concepts\n- **Configuration Changes**: Screen rotation destroys and recreates Activity instances\n- **ViewModel**: Survives configuration changes and maintains UI state\n- **LiveData**: Lifecycle-aware observable data holder\n\n## Implementation Strategies\n- **ViewModel + LiveData**: Optimal for most UI state preservation\n- **onSaveInstanceState()**: Suitable for small amounts of transient data\n- **Room Database**: For persistent data storage requirements\n\n## Best Practices\n- Never store Context references in ViewModels\n- Use dependency injection for ViewModel instantiation\n- Clear LiveData observers in onDestroy() when appropriate","diagram":"flowchart TD\n  A[Screen Rotation] --> B[Activity Destroyed]\n  B --> C[ViewModel Preserved]\n  C --> D[Activity Recreated]\n  D --> E[UI Restored from ViewModel]\n  E --> F[LiveData Updates UI]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-08T11:57:57.538Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-512","question":"How would you implement a simple RecyclerView in Android to display a list of user profiles with name and email?","answer":"Create a RecyclerView with a custom adapter extending RecyclerView.Adapter. Use ViewHolder pattern with data binding for name/email TextViews. Implement onCreateViewHolder to inflate item layout, onBi","explanation":"## RecyclerView Implementation\n\n- Create item layout XML with TextViews for name and email\n- Extend RecyclerView.Adapter with custom ViewHolder class\n- Override three required methods: onCreateViewHolder, onBindViewHolder, getItemCount\n- Use ViewHolder pattern to avoid repeated findViewById calls\n- Set adapter and LayoutManager on RecyclerView in Activity/Fragment\n\n## Key Components\n\n- **ViewHolder**: Holds references to view components\n- **Adapter**: Bridges data with RecyclerView\n- **LayoutManager**: Positions items (LinearLayoutManager for lists)\n- **Data Binding**: Optional but recommended for cleaner code\n\n```kotlin\nclass UserAdapter(private val users: List<User>) : \n    RecyclerView.Adapter<UserAdapter.UserViewHolder>() {\n    \n    class UserViewHolder(view: View) : RecyclerView.ViewHolder(view) {\n        val nameText: TextView = view.findViewById(R.id.name)\n        val emailText: TextView = view.findViewById(R.id.email)\n    }\n    \n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): UserViewHolder {\n        val view = LayoutInflater.from(parent.context)\n            .inflate(R.layout.item_user, parent, false)\n        return UserViewHolder(view)\n    }\n    \n    override fun onBindViewHolder(holder: UserViewHolder, position: Int) {\n        val user = users[position]\n        holder.nameText.text = user.name\n        holder.emailText.text = user.email\n    }\n    \n    override fun getItemCount() = users.size\n}\n```","diagram":"flowchart TD\n    A[Activity/Fragment] --> B[RecyclerView]\n    B --> C[LayoutManager]\n    B --> D[UserAdapter]\n    D --> E[ViewHolder]\n    E --> F[Item Layout XML]\n    D --> G[User Data List]\n    F --> H[Name TextView]\n    F --> I[Email TextView]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Tesla","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-25T14:59:09.193Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-541","question":"How would you implement a RecyclerView with ViewHolder pattern to display a list of user profiles efficiently?","answer":"Use RecyclerView with ViewHolder pattern: create custom ViewHolder extending RecyclerView.ViewHolder, implement onCreateViewHolder to inflate item layout, onBindViewHolder to bind data, and use DiffUtil for efficient list updates.","explanation":"## RecyclerView Implementation\n\n- **ViewHolder Pattern**: Reuses view objects to avoid expensive findViewById calls\n- **DiffUtil**: Calculates differences between old and new lists for efficient updates\n- **Layout Manager**: Manages item positioning (LinearLayoutManager for lists)\n\n```kotlin\nclass ProfileAdapter : ListAdapter<Profile, ProfileAdapter.ViewHolder>(DiffCallback()) {\n    \n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {\n        val view = LayoutInflater.from(parent.context)\n            .inflate(R.layout.item_profile, parent, false)\n        return ViewHolder(view)\n    }\n    \n    override fun onBindViewHolder(holder: ViewHolder, position: Int) {\n        holder.bind(getItem(position))\n    }\n    \n    class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {\n        fun bind(profile: Profile) {\n            // Bind profile data to views\n        }\n    }\n    \n    class DiffCallback : DiffUtil.ItemCallback<Profile>() {\n        override fun areItemsTheSame(oldItem: Profile, newItem: Profile): Boolean =\n            oldItem.id == newItem.id\n        \n        override fun areContentsTheSame(oldItem: Profile, newItem: Profile): Boolean =\n            oldItem == newItem\n    }\n}\n```","diagram":"flowchart TD\n  A[Data List] --> B[DiffUtil]\n  B --> C[RecyclerView.Adapter]\n  C --> D[onCreateViewHolder]\n  C --> E[onBindViewHolder]\n  D --> F[ViewHolder]\n  E --> F\n  F --> G[Item Views]","difficulty":"beginner","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Goldman Sachs","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-08T11:54:34.605Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-976","question":"You are building an Android app that tracks a delivery ride; location updates every 5 seconds; battery life; Doze; Provide plan using FusedLocationProvider, ForegroundService, and WorkManager; include backoff; testing; intermittent connectivity?","answer":"Use a foreground service with FusedLocationProviderClient to push location updates every 5 seconds, tying updates to a persistent notification. Fetch with a LocationRequest.interval 5000ms, fastestInt","explanation":"## Why This Is Asked\nThis question mirrors real-world Android ride-hailing apps where location streaming and battery life are critical and Doze/work manager constraints matter.\n\n## Key Concepts\n- ForegroundService for ongoing tasks\n- FusedLocationProvider and LocationRequest parameters\n- WorkManager for deferred/inflight uploads with backoff\n- Doze and app standby handling; cancellation on ride end\n- Testing strategies with mock location, Robolectric, and Doze scenarios\n\n## Code Example\n```kotlin\nval locationRequest = LocationRequest.create().apply {\n  interval = 5000\n  fastestInterval = 2500\n  priority = LocationRequest.PRIORITY_HIGH_ACCURACY\n}\n```\n\n## Follow-up Questions\n- How would you test Doze behavior and network flakiness?\n- How do you handle user revoking location permissions mid-ride?","diagram":null,"difficulty":"intermediate","tags":["android"],"channel":"android","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Oracle","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T17:39:57.289Z","createdAt":"2026-01-12T17:39:57.289Z"},{"id":"q-205","question":"How would you implement Compose Navigation with nested graphs, shared ViewModels, configuration change handling, and deep linking in a production Android app?","answer":"Use NavHost with nested NavGraphs, HiltViewModel for scoped VMs, SavedStateHandle for deep link parameters, and rememberSaveable for state preservation across configuration changes.","explanation":"## Implementation Strategy\n\n**Navigation Setup:**\n```kotlin\n@Composable\nfun AppNavigation() {\n    val navController = rememberNavController()\n    NavHost(\n        navController = navController,\n        startDestination = \"home\"\n    ) {\n        navigation(\"home\", \"home_graph\") {\n            composable(\"detail/{id}\") { backStackEntry ->\n                val viewModel: SharedViewModel = hiltViewModel()\n                DetailScreen(viewModel, backStackEntry.arguments?.getString(\"id\"))\n            }\n        }\n    }\n}\n```\n\n**ViewModel Scoping:**\n- Use `hiltViewModel()` for NavGraph-scoped ViewModels\n- Share ViewModels across nested navigation graphs\n- Leverage `@HiltViewModel` and `@Inject` for dependency injection\n\n**Configuration Changes:**\n- `rememberSaveable` for UI state preservation\n- ViewModel automatically survives configuration changes\n- Use `SavedStateHandle` for navigation parameter persistence\n\n**Deep Linking:**\n```kotlin\ncomposable(\n    \"detail/{id}\",\n    deepLinks = listOf(navDeepLink {\n        uriPattern = \"app://detail/{id}\"\n    })\n) { backStackEntry ->\n    val id = backStackEntry.arguments?.getString(\"id\")\n    val viewModel: SharedViewModel = hiltViewModel()\n    viewModel.loadDetails(id)\n}\n```\n\n**Key Considerations:**\n- Handle back stack properly with nested graphs\n- Use `popUpTo` for navigation flow control\n- Implement proper state restoration with `SavedStateHandle`\n- Consider memory leaks with long-lived ViewModels","diagram":"graph TD\n    A[NavHost] --> B[Home Graph]\n    A --> C[Profile Graph]\n    A --> D[Settings Graph]\n    C --> E[Profile Screen]\n    C --> F[Edit Profile]\n    E --> G[ProfileViewModel]\n    F --> G\n    H[Deep Link] --> I[SavedStateHandle]\n    I --> G\n    J[Config Change] --> K[rememberSaveable]\n    K --> G","difficulty":"intermediate","tags":["composables","state","navigation"],"channel":"android","subChannel":"jetpack-compose","sourceUrl":null,"videos":{"longVideo":"https://www.youtube.com/watch?v=FIEnIBq7Ups"},"companies":["Amazon","Google","Meta","Microsoft","Netflix","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":["compose navigation","navhost","nested navgraphs","hiltviewmodel","savedstatehandle","remembersaveable","configuration changes"],"voiceSuitable":true,"isNew":false,"lastUpdated":"2025-12-27T05:45:37.585Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-182","question":"What is the first lifecycle method called when an Android Activity is created, and what critical initialization tasks must be performed within it?","answer":"onCreate() is the first lifecycle method called when an Activity is created. It receives a Bundle savedInstanceState parameter containing previous state data for activity recreation. You must call super.onCreate(savedInstanceState) first, then setContentView() to initialize the UI, followed by component initialization, view setup, and data binding. This method runs only once per activity instance unless recreated by the system.","explanation":"## Interview Context\nThis question tests understanding of Android Activity lifecycle fundamentals and proper initialization patterns. Candidates should demonstrate knowledge of state management and recreation scenarios.\n\n## Key Points\n- **onCreate()** is always the first lifecycle method called\n- **Bundle savedInstanceState** preserves state during activity recreation\n- **super.onCreate()** must be called before any other operations\n- **setContentView()** should be called early to establish the UI hierarchy\n- **One-time initialization** like adapters, listeners, and data loading\n\n## Code Example\n```java\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState); // Must be first\n    setContentView(R.layout.activity_main); // UI setup\n    \n    // Initialize components\n    initializeViews();\n    setupListeners();\n    \n    // Restore state if available\n    if (savedInstanceState != null) {\n        restoreData(savedInstanceState);\n    }\n}\n```\n\n## Follow-up Questions\n- What happens if you don't call super.onCreate()?\n- When would savedInstanceState be null vs non-null?\n- What's the difference between onCreate() and onRestart()?\n- How do you handle configuration changes in onCreate()?","diagram":"graph TD\n    A[onCreate] --> B[onStart]\n    B --> C[onResume]\n    C --> D[Running]\n    D --> E[onPause]\n    E --> F[onStop]\n    F --> G[onDestroy]","difficulty":"beginner","tags":["lifecycle","components"],"channel":"android","subChannel":"lifecycle","sourceUrl":null,"videos":null,"companies":["Amazon","Google","Meta","Microsoft","Netflix","Uber"],"eli5":"Imagine you're building with LEGOs! When you start making a new toy, the first thing you do is open the LEGO box and lay out all your pieces. That's exactly what onCreate() does - it's like opening the toy box and getting everything ready before you start playing. Just like you need to see all your LEGO pieces first before you can build your castle, an Android app needs to call onCreate() first to get all its pieces ready before it can show you the screen and start working!","relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-25T16:45:33.939Z","createdAt":"2025-12-26 12:51:07"}],"subChannels":["architecture","general","jetpack-compose","lifecycle"],"companies":["Adobe","Airbnb","Amazon","Anthropic","Apple","Bloomberg","Citadel","Cloudflare","Databricks","Goldman Sachs","Google","Hashicorp","Hugging Face","IBM","Instacart","Lyft","Meta","Microsoft","MongoDB","Netflix","Oracle","Robinhood","Salesforce","Scale Ai","Snowflake","Tesla","Twitter","Two Sigma","Uber","Zoom"],"stats":{"total":24,"beginner":10,"intermediate":11,"advanced":3,"newThisWeek":17}}