{"questions":[{"id":"do-3","question":"What is Infrastructure as Code (IaC) and why is Terraform preferred over manual infrastructure management?","answer":"Infrastructure as Code automates infrastructure provisioning through machine-readable definition files, enabling version control, repeatability, and collaboration. Terraform provides cloud-agnostic declarative configuration, state management, and resource dependency resolution, making it superior to manual infrastructure management for consistency, scalability, and team collaboration.","explanation":"## Why Asked\nTests understanding of modern DevOps practices and infrastructure automation principles. Essential for SRE/DevOps roles where infrastructure scalability and reliability are critical.\n\n## Key Concepts\n- Declarative vs imperative infrastructure management\n- Infrastructure reproducibility and version control\n- Terraform state management and remote backends\n- Resource dependencies and graph-based execution\n- Multi-cloud provider support\n- Infrastructure drift detection\n\n## Code Example\n```\n# main.tf - EC2 instance with security group\nresource \"aws_instance\" \"web\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t3.micro\"\n  \n  tags = {\n    Name = \"WebServer\"\n    Environment = \"production\"\n  }\n}\n\nresource \"aws_security_group\" \"web_sg\" {\n  name        = \"web-sg\"\n  description = \"Allow HTTP/HTTPS traffic\"\n  \n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n  \n  ingress {\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n```\n\n## Interview Tips\n- Emphasize Terraform's declarative approach vs imperative scripting\n- Discuss state file importance and remote backend benefits\n- Mention provider ecosystem and multi-cloud capabilities\n- Highlight infrastructure as code benefits: audit trails, peer reviews, automated testing","diagram":"flowchart TD\n  A[Code Definition] --> B[Terraform Plan]\n  B --> C[Approval]\n  C --> D[Terraform Apply]\n  D --> E[Infrastructure Created]\n  E --> F[State File Updated]\n  F --> G[Drift Detection]\n  G --> H{Changes Needed?}\n  H -->|Yes| A\n  H -->|No| G","difficulty":"beginner","tags":["infra","automation","terraform"],"channel":"terraform","subChannel":"basics","sourceUrl":null,"videos":{"shortVideo":"https://youtube.com/watch?v=h6rkauDhDUM","longVideo":"https://youtube.com/watch?v=3aiRthAYosE"},"companies":["Airbnb","Amazon","Google","Meta","Microsoft","Netflix","Stripe","Uber"],"eli5":"Imagine you're building with LEGOs. Instead of putting each block together by hand every time, you write down the exact steps on paper. Anyone can follow your paper to build the same LEGO castle perfectly! Infrastructure as Code is like that LEGO instruction book for computers. Terraform is like having a magic LEGO instruction book that works with any LEGO set - whether it's LEGO City, LEGO Star Wars, or LEGO Friends. You write your instructions once, and Terraform builds it exactly the same way every time, no mistakes! It's way better than building by hand because you can share your instructions, fix them easily, and build the same thing over and over without forgetting any pieces.","relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-30T01:45:59.187Z","createdAt":"2025-12-26 12:51:05"},{"id":"gh-17","question":"What is Terraform and how does it implement Infrastructure as Code (IaC) workflows?","answer":"Terraform is an open-source Infrastructure as Code (IaC) tool by HashiCorp that allows you to define, provision, and manage cloud infrastructure using declarative configuration files.","explanation":"Terraform enables infrastructure management through:\n\n- **Declarative Configuration**: Uses HCL (HashiCorp Configuration Language) to define desired infrastructure state\n- **Provider Architecture**: Supports multiple cloud providers (AWS, Azure, GCP, etc.) through plugins\n- **State Management**: Maintains a state file to track infrastructure resources and changes\n- **Workflow**: Follows plan-apply-destroy lifecycle for safe infrastructure changes\n- **Modularity**: Supports modules for reusable infrastructure components\n\n**Key Benefits**:\n- Version control infrastructure alongside application code\n- Automated provisioning and consistent deployments\n- Cost management through resource tracking\n- Multi-cloud and hybrid cloud support","diagram":"graph TD\n    A[Write HCL Configuration] --> B[terraform init]\n    B --> C[terraform plan]\n    C --> D{Review Changes}\n    D -->|Approved| E[terraform apply]\n    D -->|Reject| F[Modify Configuration]\n    E --> G[Provision Resources]\n    G --> H[Update State File]\n    F --> A\n    H --> I[terraform destroy]\n    I --> J[Clean up Resources]","difficulty":"beginner","tags":["iac","terraform","ansible"],"channel":"terraform","subChannel":"basics","sourceUrl":null,"videos":{"shortVideo":"https://www.youtube.com/watch?v=tomUWcQ0P3k","longVideo":"https://www.youtube.com/watch?v=hrwZ-iND3bs"},"companies":["Airbnb","Databricks","Goldman Sachs","Microsoft","Snowflake"],"eli5":"Imagine you're building with LEGOs! Terraform is like having a special instruction book that tells you exactly how to build your LEGO castle. Instead of building it by hand each time, you write down the steps once, and Terraform builds it for you perfectly every time. If you want to add a tower or change a wall, you just update your instruction book, and Terraform knows exactly what to change. It's like having a magic LEGO builder who follows your plans and never makes mistakes!","relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-24T13:03:26.044Z","createdAt":"2025-12-26 12:51:05"},{"id":"de-137","question":"You have a Terraform configuration that creates an AWS S3 bucket. After running 'terraform apply', you realize you need to add versioning to the bucket. What's the safest way to modify your existing infrastructure?","answer":"Add the versioning configuration block to the existing S3 bucket resource, run `terraform plan` to review the proposed changes, then execute `terraform apply` to update the bucket in-place without recreation.","explanation":"## Safe Infrastructure Updates with Terraform\n\nWhen modifying existing Terraform resources, follow this systematic approach:\n\n1. **Update the configuration**: Add the versioning block to your existing `aws_s3_bucket` resource\n2. **Plan before applying**: Run `terraform plan` to preview all changes and verify the operation type\n3. **Validate the approach**: Ensure Terraform indicates an \"update in-place\" operation rather than destroy/recreate\n4. **Apply the changes**: Execute `terraform apply` to modify the existing bucket safely\n\n### Example Configuration:\n```hcl\nresource \"aws_s3_bucket\" \"example\" {\n  bucket = \"my-example-bucket\"\n}\n\nresource \"aws_s3_bucket_versioning\" \"example\" {\n  bucket = aws_s3_bucket.example.id\n  versioning_configuration {\n    status = \"Enabled\"\n  }\n}\n```\n\nThis methodology ensures infrastructure changes are predictable, non-disruptive, and maintain data integrity throughout the update process.","diagram":"graph TD\n    A[Existing S3 Bucket] --> B[Modify Terraform Config]\n    B --> C[Add Versioning Block]\n    C --> D[terraform plan]\n    D --> E{Review Changes}\n    E -->|Safe Update| F[terraform apply]\n    E -->|Destructive Change| G[Revise Configuration]\n    G --> D\n    F --> H[Updated S3 Bucket with Versioning]\n    \n    style A fill:#e1f5fe\n    style H fill:#c8e6c9\n    style D fill:#fff3e0\n    style F fill:#f3e5f5","difficulty":"beginner","tags":["terraform","iac"],"channel":"terraform","subChannel":"best-practices","sourceUrl":null,"videos":{"shortVideo":"https://www.youtube.com/watch?v=gxPykhPxRW0","longVideo":"https://www.youtube.com/watch?v=v_7Vzh4oGhk"},"companies":["Amazon","Google","Hashicorp","Microsoft","Netflix"],"eli5":"Imagine you built a cool Lego castle. Now you want to add a flag on top! You don't need to smash the whole castle and rebuild it. Just carefully add the flag piece right where it belongs. That's what you do with your S3 bucket - you just add the versioning feature like adding a new Lego piece to your existing creation. First check your plan (like reading the Lego instructions), then add the new piece safely!","relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-08T11:24:24.395Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-272","question":"How would you implement a DRY Terraform configuration using Terragrunt and Atlantis for multi-environment deployments?","answer":"Use Terragrunt include blocks to inherit common configs, remote_state for backend, and Atlantis workflows for PR automation.","explanation":"## Concept\nTerragrunt eliminates code duplication by using hierarchical configurations with include blocks that inherit parent settings. Atlantis automates Terraform workflows through GitHub pull requests, providing plan/apply automation with policy enforcement.\n\n## Implementation\n```hcl\n# terragrunt.hcl (root)\nremote_state {\n  backend = \"s3\"\n  config = {\n    bucket         = \"company-terraform-state\"\n    key            = \"${path_relative_to_include()}/terraform.tfstate\"\n    region         = \"us-east-1\"\n    encrypt        = true\n    dynamodb_table = \"terraform-locks\"\n  }\n}\n\ngenerate \"provider\" {\n  path = \"provider.tf\"\n  if_exists = \"overwrite_terragrunt\"\n  contents = <<EOF\nprovider \"aws\" {\n  region = local.aws_region\n}\nEOF\n}\n\n# prod/app/terragrunt.hcl\ninclude {\n  path = find_in_parent_folders()\n}\n\nterraform {\n  source = \"../../../modules//app\"\n}\n\ninputs = {\n  environment = \"prod\"\n  instance_count = 3\n}\n```\n\n```yaml\n# atlantis.yaml\nworkflows:\n  terragrunt:\n    plan:\n      steps:\n        - env:\n            name: TERRAGRUNT_TFPATH\n            command: 'echo \"terraform${ATLANTIS_TERRAFORM_VERSION}\"'\n        - run: terragrunt run-all plan -input=false -out=$PLANFILE\n        - run: terragrunt run-all show -json $PLANFILE > $SHOWFILE\n    apply:\n      steps:\n        - run: terragrunt run-all apply -input=false $PLANFILE\n```\n\n## Trade-offs\n**Pros:** Eliminates code duplication, centralized state management, automated PR workflows, consistent configurations across environments.\n\n**Cons:** Added complexity with Terragrunt layer, learning curve for team members, additional dependency management.\n\n## Pitfalls\n- Circular dependencies in include chains\n- State locking conflicts without DynamoDB\n- Over-abstracting configurations making debugging difficult\n- Inconsistent Terragrunt versions across environments","diagram":"flowchart TD\n    A[GitHub PR] --> B[Atlantis Webhook]\n    B --> C[Generate Workflow]\n    C --> D[Terragrunt Init]\n    D --> E[Remote State S3 + DynamoDB]\n    E --> F[Include Parent Configs]\n    F --> G[Run Plan]\n    G --> H[Show JSON Output]\n    H --> I[Comment on PR]\n    I --> J{Merge?}\n    J -->|Yes| K[Run Apply]\n    J -->|No| L[Discard Plan]\n    K --> M[Update State]\n    M --> N[Deploy Resources]","difficulty":"intermediate","tags":["dry","terragrunt","atlantis"],"channel":"terraform","subChannel":"best-practices","sourceUrl":"https://www.gruntwork.io/blog/terragrunt-how-to-keep-your-terraform-code-dry-and-maintainable","videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Netflix","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":["dry","terragrunt","include blocks","remote_state","atlantis","multi-environment","workflows"],"voiceSuitable":true,"isNew":false,"lastUpdated":"2025-12-27T05:32:12.725Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-284","question":"Design a production-grade Terraform architecture for a multi-environment AWS infrastructure with 100+ resources, including state management, CI/CD integration, and security controls. How would you handle state locking, workspace strategy, and deployment validation?","answer":"Implement S3 backend with DynamoDB locking, separate workspaces per environment, IAM role assumption via OIDC, GitHub Actions with terraform plan/apply, cost estimation via infracost, and policy validation with checkov and tflint.","explanation":"## State Management\n- **S3 + DynamoDB**: Versioned S3 bucket with DynamoDB table for state locking prevents concurrent modifications\n- **Remote state configuration**: Configure backend block with encryption, access logging, and lifecycle policies\n\n## Workspace Strategy\n- **Environment isolation**: Separate workspaces for dev/staging/prod with distinct state files\n- **Shared modules**: Common infrastructure components in reusable modules with versioning\n\n## CI/CD Integration\n- **GitHub Actions workflow**: Plan stage with PR comments, apply stage on merge to main branch\n- **Validation steps**: tflint for style, checkov for security, infracost for cost estimation\n- **IAM role assumption**: OIDC federation for secure credential management without long-lived keys\n\n## Security Controls\n- **Least privilege**: Granular IAM policies per workspace/role\n- **Encryption**: Server-side encryption for state and sensitive variables\n- **Audit logging**: CloudTrail integration for all Terraform operations\n\n## Cost Management\n- **Resource tagging**: Mandatory tags for cost allocation and governance\n- **Budget alerts**: Cost estimation in PRs with automated approval thresholds","diagram":"flowchart TD\n  A[Dev Workspace] --> D[Remote State Backend]\n  B[Staging Workspace] --> D\n  C[Prod Workspace] --> D\n  D --> E[CI/CD Pipeline]\n  E --> F[Terraform Plan/Apply]","difficulty":"advanced","tags":["infrastructure-as-code","automation","best-practices"],"channel":"terraform","subChannel":"best-practices","sourceUrl":null,"videos":null,"companies":["Amazon","Google","Hashicorp","Microsoft","Netflix","Snowflake"],"eli5":"Imagine you're building with LEGO blocks for different playgrounds - one for school, one for home, and one for the park. You keep your building instructions in a special book that everyone can see, but only you can change. You have separate boxes for each playground, and you use the same building blocks but arrange them differently. Before you build, you check with your friends to make sure everything looks good. You also have special name tags so only certain people can build in certain areas. This way, every playground gets exactly what it needs, and nothing breaks by accident!","relevanceScore":null,"voiceKeywords":["terraform","state management","ci/cd","state locking","workspaces","aws","security controls"],"voiceSuitable":true,"isNew":false,"lastUpdated":"2025-12-27T04:54:15.411Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-1049","question":"In a multi-account AWS setup, a core Terraform module is versioned in a private registry and consumed by 12 workspaces. A regional failover requires a safe rollback to the previous core module version without drift. Describe the end-to-end strategy, including version pinning, CI validation, and state/rollback mechanisms?","answer":"Pin module versions in a private registry and force per-workspace version locking. Before rollout, CI runs a full plan in all 12 workspaces with -upgrade and a serialized apply; for rollback, revert t","explanation":"## Why This Is Asked\nThis probes real-world control-plane challenges at scale: module versioning, cross-workspace coordination, and safe rollback under outages.\n\n## Key Concepts\n- Terraform modules and private registries\n- Workspace isolation and CI-driven validation\n- State security: S3 versioning and DynamoDB locking\n- Rollback sequencing and drift boundaries\n\n## Code Example\n```hcl\n# Example pin in core module usage\nmodule \"core\" {\n  source  = \"private-registry/core/aws\"\n  version = \"1.1.0\"\n}\n```\n\n## Follow-up Questions\n- How would you handle breaking changes in a core module?\n- What tests would you include in CI to catch drift before apply?","diagram":null,"difficulty":"advanced","tags":["terraform"],"channel":"terraform","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Goldman Sachs","Lyft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T20:34:41.822Z","createdAt":"2026-01-12T20:34:41.822Z"},{"id":"q-1197","question":"In a multi-account AWS setup, a single Terraform repo provisions VPCs and IAM roles per environment using provider aliases. A governance rule requires per-environment tagging and automatic drift detection that blocks non-Terraform changes. Describe a concrete pattern to enforce per-account isolation, tagging, and drift guardrails, including provider aliasing, remote state per environment, and a PR-based drift test workflow?","answer":"Use a per-environment provider alias and per-env backend (state file per account), enforce required_tags in a central module, and enable drift guards with lifecycle prevent_destroy on critical resourc","explanation":"## Why This Is Asked\nTests the candidate's ability to enforce multi-account isolation, tagging policy enforcement, and automated drift guardrails in CI.\n\n## Key Concepts\n- Provider aliasing per environment\n- Per-environment remote state backends\n- Centralized tagging policy in modules\n- Drift detection and governance gates\n- CI integration with PR workflows\n\n## Code Example\n```javascript\n# Example provider/config sketch (Terraform HCL-like)\nprovider \"aws\" {\n  alias  = \"dev\"\n  region = \"us-west-2\"\n}\nprovider \"aws\" {\n  alias  = \"prod\"\n  region = \"us-east-1\"\n}\nmodule \"vpc_dev\" {\n  source = \"./modules/vpc\"\n  providers = { aws = aws.dev }\n  tags = { Environment = \"dev\" }\n}\n```\n\n## Follow-up Questions\n- How would you test drift remediation in a PR without affecting prod?\n- What are trade-offs of using lifecycle rules vs drift import in a live environment?","diagram":"flowchart TD\n  A[Env Request] --> B[Configure Alias]\n  B --> C[Choose Backend]\n  C --> D[CI Plan Gate]\n  D --> E[Apply/Lock]","difficulty":"intermediate","tags":["terraform"],"channel":"terraform","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T04:47:14.160Z","createdAt":"2026-01-13T04:47:14.160Z"},{"id":"q-1271","question":"You have a Terraform project that provisions an AWS VPC and a small app stack. You want developers to run the same config against their own environments using per-environment secrets (DB_PASSWORD, APP_SSH_KEY) that are never stored in git. Outline a minimal structure (files, vars, and commands) to supply these secrets safely, and explain how you prevent secrets from triggering plan changes or drift?","answer":"Use per-environment tfvars loaded automatically and kept out of git. Create secrets/dev.auto.tfvars and secrets/prod.auto.tfvars with: db_password = \"...\"; app_ssh_key = \"...\". Mark variables as sensi","explanation":"## Why This Is Asked\n\nTests understanding of safe secret handling and environment isolation in Terraform without changing core config.\n\n## Key Concepts\n\n- Environment-specific tfvars and automatic loading\n- Sensitive variable handling in Terraform\n- Gitignore strategy for secrets\n- Minimal, non-disruptive apply workflow\n\n## Code Example\n\n```hcl\nvariable \"db_password\" {\n  type      = string\n  sensitive = true\n}\nvariable \"app_ssh_key\" {\n  type      = string\n  sensitive = true\n}\n\nresource \"aws_db_instance\" \"db\" {\n  # ...\n  password = var.db_password\n}\n```\n\n## Follow-up Questions\n\n- How would you handle rotating these secrets across environments?\n- What changes if you switch to Terraform Cloud/Remote Backends for env isolation?","diagram":null,"difficulty":"beginner","tags":["terraform"],"channel":"terraform","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","Microsoft","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T07:37:32.453Z","createdAt":"2026-01-13T07:37:32.453Z"},{"id":"q-479","question":"You're managing a multi-region infrastructure with 50+ Terraform modules. How would you design a strategy to handle state locking, drift detection, and safe deployments across regions while minimizing downtime?","answer":"Implement remote state with S3 + DynamoDB for locking. Use Terraform Cloud workspaces for per-region isolation. Configure drift detection via scheduled runs. Use canary deployments with blue-green strategy to minimize downtime during deployments.","explanation":"## State Management\n- S3 backend with DynamoDB table for ACID locks\n- Separate state files per region/environment\n- State versioning and encryption at rest\n\n## Deployment Strategy\n- Terraform Cloud workspaces for isolation\n- CI/CD pipeline with plan/apply stages\n- Manual approval gates for production changes\n- Canary deployments with traffic shifting\n\n## Drift Detection\n- Scheduled drift detection runs\n- Automated alerts for configuration changes\n- Integration with monitoring systems\n\n## Safety Measures\n- Terraform plan output reviews\n- Resource dependency validation\n- Rollback procedures and backup strategies","diagram":"flowchart TD\n  A[CI/CD Trigger] --> B[Terraform Plan]\n  B --> C[Manual Review]\n  C --> D[State Lock]\n  D --> E[Apply Changes]\n  E --> F[Drift Detection]\n  F --> G[Monitoring]\n  G --> H[Rollback if needed]","difficulty":"advanced","tags":["terraform"],"channel":"terraform","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-10T03:28:51.837Z","createdAt":"2025-12-26 12:51:05"},{"id":"q-508","question":"You have a Terraform configuration that creates multiple EC2 instances across different availability zones. How would you implement a blue-green deployment strategy using Terraform workspaces and what are the key considerations?","answer":"Use Terraform workspaces to manage separate blue and green environments. Create two workspaces (blue and green) with identical infrastructure but different configurations. Implement a load balancer that routes traffic between environments based on deployment status, and utilize workspace-specific variables to differentiate between environments while maintaining infrastructure consistency.","explanation":"## Blue-Green Deployment with Terraform\n\n- **Workspace Strategy**: Separate workspaces for blue and green environments\n- **Resource Naming**: Use workspace interpolation to avoid naming conflicts\n- **Load Balancer**: Configure ALB/NLB to route traffic to active environment\n- **Database Handling**: Implement read replicas or canary database updates\n- **Traffic Switching**: Use automated health checks and weighted routing\n\n## Implementation Considerations\n\n- **State Management**: Each workspace maintains separate state file\n- **Cost**: Double infrastructure during deployment\n- **Rollback**: Instant rollback by switching load balancer target\n- **Testing**: Comprehensive testing in green environment before traffic switch\n- **Monitoring**: Implement robust monitoring and alerting for both environments","diagram":"flowchart TD\n  A[Terraform Apply] --> B[Create Green Workspace]\n  B --> C[Deploy Infrastructure]\n  C --> D[Run Health Checks]\n  D --> E{Health Checks Pass?}\n  E -->|Yes| F[Switch Traffic to Green]\n  E -->|No| G[Rollback to Blue]\n  F --> H[Monitor Performance]\n  H --> I[Cleanup Blue Resources]\n  G --> J[Debug Issues]","difficulty":"intermediate","tags":["terraform"],"channel":"terraform","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","PayPal","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":["blue-green deployment","terraform workspaces","load balancer","availability zones","separate environments","identical infrastructure","configuration management"],"voiceSuitable":true,"isNew":false,"lastUpdated":"2026-01-08T11:42:33.236Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-563","question":"You're deploying a simple web application using Terraform. How would you create an AWS EC2 instance with a security group that allows HTTP traffic on port 80?","answer":"Use the `aws_instance` resource configured with an AMI, instance type, and a reference to a security group. Create an `aws_security_group` resource with an ingress rule that permits HTTP traffic on port 80 from CIDR block 0.0.0.0/0, then reference the security group's ID in the EC2 instance configuration.","explanation":"## Terraform EC2 Instance with Security Group\n\n### Core Resources\n- `aws_instance`: Creates the EC2 virtual machine\n- `aws_security_group`: Defines firewall rules for network access\n\n### Implementation Example\n```hcl\nresource \"aws_security_group\" \"web\" {\n  name        = \"web-sg\"\n  description = \"Allow HTTP traffic\"\n\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n\nresource \"aws_instance\" \"web\" {\n  ami           = \"ami-12345678\"\n  instance_type = \"t3.micro\"\n  vpc_security_group_ids = [aws_security_group.web.id]\n}\n```\n\n### Best Practices\n- Use variables for AMI IDs and instance types to improve reusability\n- Consider restricting CIDR blocks in production environments\n- Add egress rules if specific outbound traffic control is needed\n- Include tags for resource organization and cost allocation","diagram":"flowchart TD\n  A[Terraform Apply] --> B[Create Security Group]\n  B --> C[Add HTTP Ingress Rule]\n  C --> D[Create EC2 Instance]\n  D --> E[Attach Security Group]\n  E --> F[Instance Ready]","difficulty":"beginner","tags":["terraform"],"channel":"terraform","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Discord","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-08T11:57:08.155Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-592","question":"How would you use Terraform variables to manage different environments (dev/staging/prod) while keeping your configuration DRY?","answer":"I would implement a structured approach using input variables with environment-specific .tfvars files. First, define all variables in variables.tf with proper type constraints and descriptions. Then create separate .tfvars files for each environment (dev.tfvars, staging.tfvars, prod.tfvars) containing the environment-specific values. Finally, deploy using terraform apply -var-file=environment.tfvars to target the specific environment.","explanation":"## Variable Management\n- Define input variables in variables.tf with appropriate type constraints and descriptions\n- Create dedicated .tfvars files for each environment (dev.tfvars, staging.tfvars, prod.tfvars)\n- Execute deployments with terraform apply -var-file=environment.tfvars\n\n## Workspace Strategy\n- Utilize terraform workspace new dev/staging/prod for environment isolation\n- Each workspace maintains its own state file automatically\n- Prevents accidental cross-environment resource modifications\n\n## DRY Implementation\n- Employ locals.tf for computed and derived values\n- Reference variables consistently across all resource blocks\n- Restrict environment-specific values exclusively to .tfvars files\n- Maintain shared configuration logic in the main .tf files","diagram":"flowchart TD\n  A[variables.tf] --> B[dev.tfvars]\n  A --> C[staging.tfvars]\n  A --> D[prod.tfvars]\n  B --> E[terraform apply -var-file=dev.tfvars]\n  C --> F[terraform apply -var-file=staging.tfvars]\n  D --> G[terraform apply -var-file=prod.tfvars]","difficulty":"beginner","tags":["terraform"],"channel":"terraform","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Oracle","Snowflake","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":["terraform","input variables","tfvars files","dry","environments","configuration"],"voiceSuitable":true,"isNew":false,"lastUpdated":"2026-01-08T11:47:46.100Z","createdAt":"2025-12-27T01:15:14.075Z"},{"id":"q-854","question":"In a Terraform Cloud setup spanning AWS and GCP, you must enforce a cross-cloud policy: every resource must carry a non-empty 'cost-center' tag and new regions must not auto-create default VPCs. How would you implement drift detection, policy gating, and automatic remediation across workspaces without downtime?","answer":"Leverage Terraform Cloud Run Tasks with a centralized Sentinel policy that enforces a non-empty cost-center tag on all resources and forbids default VPCs in new regions. Gate applies on plan output, u","explanation":"## Why This Is Asked\nThis question probes governance, cross-cloud policy enforcement, and drift remediation at scale.\n\n## Key Concepts\n- Terraform Cloud Run Tasks\n- Sentinel policies across providers\n- Drift detection and remediation\n- Automation runs and alerting\n\n## Code Example\n```sentinel\nimport 'tfplan/v1' as tfplan\n\npolicy 'require_cost_center_tag' {\n  // pseudo example: ensures tag exists on all resources\n  all_resources := tfplan.resource_changes.filter(r -> r.change.after != null)\n  all_resources.all(r -> r.change.after.tags['cost-center'] != '')\n}\n```\n\n## Follow-up Questions\n- How would you test policy changes in a multi-tenant environment?\n- How would you handle exceptions for legitimate auto-generated resources?","diagram":"flowchart TD\n  A[Terraform Plan] --> B[Run Task (Sentinel)]\n  B --> C{Policy Pass?}\n  C -- Yes --> D[Apply]\n  C -- No --> E[Fail & Notify]","difficulty":"intermediate","tags":["terraform"],"channel":"terraform","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Discord","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T13:37:23.857Z","createdAt":"2026-01-12T13:37:23.858Z"},{"id":"q-983","question":"In a Terraform project that provisions an AWS S3 bucket, add a new boolean variable enable_sse to toggle server-side encryption; when enable_sse is true, the bucket should have server-side encryption AES256 enabled. How would you implement this in the bucket resource using Terraform 0.12+ syntax, ensuring existing deployments remain stable and the plan doesn't force unnecessary changes?","answer":"Use a dynamic block on server_side_encryption_configuration inside the aws_s3_bucket resource gated by var.enable_sse. For example, dynamic \"server_side_encryption_configuration\" { for_each = var.enab","explanation":"## Why This Is Asked\nTests practical use of conditional Terraform blocks, ensuring safe incremental changes and plan stability when toggling a feature flag.\n\n## Key Concepts\n- Dynamic blocks in Terraform\n- Conditional resource configuration\n- AWS S3 server-side encryption basics\n- Plan drift and backward compatibility\n\n## Code Example\n```javascript\nresource \"aws_s3_bucket\" \"b\" {\n  bucket = var.bucket_name\n  dynamic \"server_side_encryption_configuration\" {\n    for_each = var.enable_sse ? [1] : []\n    content {\n      rule {\n        apply_server_side_encryption_by_default {\n          sse_algorithm = \"AES256\"\n        }\n      }\n    }\n  }\n}\n```\n\n## Follow-up Questions\n- How would you extend this to support SSE with a customer-managed key (KMS) via kms_master_key_id?\n- What tests would you add to validate idempotency when toggling the flag across environments?","diagram":"flowchart TD\n  A[Start] --> B{SSE enabled?}\n  B -->|Yes| C[Apply AES256 SSE via dynamic block]\n  B -->|No| D[No SSE changes]\n  C --> E[Plan shows AES256 rule]\n  D --> E[Plan shows no SSE changes]","difficulty":"beginner","tags":["terraform"],"channel":"terraform","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T17:47:22.938Z","createdAt":"2026-01-12T17:47:22.938Z"},{"id":"gh-105","question":"What is Infrastructure Drift and how do you detect and prevent it?","answer":"Infrastructure Drift occurs when actual infrastructure state diverges from the desired state defined in code, typically due to manual changes or concurrent modifications.","explanation":"## Why Asked\nInterviewers ask this to assess your understanding of infrastructure management best practices and your ability to maintain consistency between code and actual infrastructure.\n\n## Key Concepts\n- State divergence between code and reality\n- Manual changes vs automated deployments\n- Configuration management principles\n- Compliance and security implications\n\n## Code Example\n```\n# Detect drift with Terraform\nterraform plan\n\n# Prevent drift with policies\nterraform fmt -check\nterraform validate\n\n# Automated drift detection\nterraform state show\n```\n\n## Follow-up Questions\n- How do you handle drift when detected?\n- What tools help prevent infrastructure drift?\n- How do you educate teams about drift prevention?","diagram":"flowchart TD\n  A[Infrastructure Code] --> B[Desired State]\n  B --> C[Deployed Infrastructure]\n  C --> D[Manual Changes]\n  D --> E{Drift Detected?}\n  E -->|Yes| F[State Comparison]\n  E -->|No| G[No Drift]\n  F --> H[Drift Report]\n  H --> I[Remediation Plan]\n  I --> J[Automated Fix]\n  J --> K[State Reconciliation]\n  K --> C\n  L[Monitoring Tools] --> E\n  M[Configuration Scanner] --> F","difficulty":"advanced","tags":["advanced","cloud"],"channel":"terraform","subChannel":"state-management","sourceUrl":null,"videos":null,"companies":["Amazon","Google","Microsoft","Netflix","Stripe"],"eli5":"Imagine you have a LEGO instruction booklet that shows exactly how to build a cool spaceship. You follow the steps perfectly and build your spaceship exactly like the picture. But then your little brother comes and moves a few blue blocks to different places, or adds a red block that wasn't in the original plan. Your spaceship now looks a little different from what the instructions said - that's infrastructure drift! It's when your real-life creation starts to look different from the original plan because someone made small changes without telling anyone. Just like how you'd want to fix your spaceship to match the instructions again, computer people need to fix their 'building blocks' to match their original plans.","relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-21T04:40:36.290Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-175","question":"You have a Terraform configuration with multiple developers working on the same infrastructure. How would you implement remote state locking to prevent state corruption and enable team collaboration?","answer":"Configure a remote backend with state locking capabilities (such as S3 with DynamoDB, Terraform Cloud, or Azure Blob Storage) to prevent concurrent modifications and enable team collaboration.","explanation":"Remote state management is essential for team collaboration in Terraform. When multiple developers work on the same infrastructure, local state files create conflicts and potential corruption. Remote backends address these challenges by providing:\n\n1. **Centralized Storage**: State is stored in a shared, accessible location (S3, Azure Blob, etc.)\n2. **State Locking**: Prevents multiple users from modifying state simultaneously\n3. **Version Control**: Maintains a complete history of state changes\n4. **Security**: Provides controlled access to sensitive state data\n\n**Implementation Options:**\n- **AWS**: S3 bucket with DynamoDB table for locking\n- **Azure**: Blob Storage with built-in locking capabilities\n- **Terraform Cloud**: Managed solution with integrated state locking\n- **Other**: GCS Cloud Storage, Consul, or PostgreSQL backends","diagram":"graph TD\n    A[Developer 1] --> B[Terraform Apply]\n    C[Developer 2] --> D[Terraform Apply]\n    B --> E[Remote Backend]\n    D --> E\n    E --> F[State Lock Check]\n    F --> G{Lock Available?}\n    G -->|Yes| H[Acquire Lock]\n    G -->|No| I[Wait/Retry]\n    H --> J[Update State]\n    J --> K[Release Lock]\n    I --> F\n    E --> L[S3/Azure Blob Storage]\n    E --> M[DynamoDB/Locking Service]","difficulty":"intermediate","tags":["state","backend"],"channel":"terraform","subChannel":"state-management","sourceUrl":null,"videos":{"shortVideo":"https://www.youtube.com/watch?v=gxPykhPxRW0","longVideo":"https://www.youtube.com/watch?v=GgQE85Aq2z4"},"companies":["Amazon","Google","Microsoft","Stripe","Uber"],"eli5":"Imagine you and your friends are building a giant LEGO castle together. If everyone tries to add blocks at the same time, the castle might get wobbly and fall! So you use a special 'building pass' - only one person can hold it at a time. When you have the pass, you can add your blocks. When you're done, you give it to the next friend. This way, the castle stays strong and everyone knows what parts are already built. Terraform does the same thing with computer buildings - it uses a special lock so only one person can make changes at a time, keeping everything safe and organized!","relevanceScore":null,"voiceKeywords":["remote backend","state locking","dynamodb","terraform cloud","azure blob storage","concurrent modifications"],"voiceSuitable":true,"isNew":false,"lastUpdated":"2026-01-08T11:26:55.266Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-221","question":"How would you implement a zero-downtime blue-green deployment strategy using Terraform workspaces, remote state locking, and Atlantis for production-scale microservices?","answer":"Implement separate Terraform workspaces for blue and green environments, configure remote state with locking to ensure consistency, and use Atlantis for automated PR-based deployments with comprehensive health checks before traffic switching.","explanation":"## Concept Overview\n\nBlue-green deployment maintains two identical production environments, enabling zero-downtime deployments by routing traffic between them while Terraform manages infrastructure state and consistency.\n\n## Implementation Details\n\n- **Workspaces**: Create dedicated `blue` and `green` Terraform workspaces with identical infrastructure configurations\n- **State Management**: Configure remote backend with state locking to prevent concurrent modifications and ensure state consistency\n- **Atlantis Integration**: Set up PR-based workflows that deploy to the inactive workspace first, with automated validation and approval gates\n- **Traffic Routing**: Implement load balancer target groups to seamlessly switch traffic after passing comprehensive health checks\n\n## Code Example\n\n```hcl\n# workspace configuration\nterraform {\n  backend \"remote\" {\n    organization = \"your-org\"\n    workspaces {\n      blue = \"blue-prod\"\n      green = \"green-prod\"\n    }\n  }\n}\n```","diagram":"flowchart LR\n    A[Developer PR] --> B[Atlantis Plan]\n    B --> C[Non-active Workspace]\n    C --> D[Terraform Apply]\n    D --> E[Health Checks]\n    E --> F{Healthy?}\n    F -->|Yes| G[Traffic Switch]\n    F -->|No| H[Rollback]\n    G --> I[Active Workspace Update]\n    I --> J[Cleanup Old Resources]","difficulty":"advanced","tags":["dry","terragrunt","atlantis"],"channel":"terraform","subChannel":"state-management","sourceUrl":null,"videos":null,"companies":["Amazon","Google Cloud","Microsoft","Stripe","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":["blue-green deployment","terraform workspaces","state locking","atlantis","pr-based deployments","health checks"],"voiceSuitable":true,"isNew":false,"lastUpdated":"2025-12-29T08:48:13.859Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-247","question":"How does Terraform remote state prevent conflicts when multiple team members work on the same infrastructure, and what are the key mechanisms involved?","answer":"Remote state stores state files in centralized backends (S3, Azure Blob, GCS) with locking mechanisms (DynamoDB, Consul, etcd) to prevent simultaneous writes. Locks ensure only one user can modify state at a time, preventing corruption. Backends provide state encryption, versioning, and access control for team collaboration.","explanation":"## Core Conflict Prevention\n\n**State Locking**: Remote backends implement distributed locking using DynamoDB (AWS), Consul, or etcd. When `terraform apply` runs, it acquires an exclusive lock, blocking other operations until completion.\n\n**Backend Implementations**:\n```hcl\n# S3 with DynamoDB locking\nterraform {\n  backend \"s3\" {\n    bucket         = \"tf-state\"\n    key            = \"prod/terraform.tfstate\"\n    region         = \"us-east-1\"\n    dynamodb_table = \"tf-locks\"\n    encrypt        = true\n  }\n}\n```\n\n## Security & Reliability\n\n**State Encryption**: S3/Azure Blob/GCS provide server-side encryption. State files contain sensitive data (passwords, keys) requiring protection.\n\n**Versioning & Backups**: Enable bucket versioning for automatic state backups. Critical for disaster recovery and rollback scenarios.\n\n## Advanced Patterns\n\n**Workspaces**: Separate environments (dev/staging/prod) using workspaces or state file keys. Prevents cross-environment conflicts.\n\n**State Isolation**: Use different state files for different organizational units or environments to minimize blast radius.\n\n## Edge Cases\n\n- **Stale Locks**: Manual lock removal required when processes crash\n- **Network Partitions**: Can leave locks in inconsistent state\n- **Backend Migration**: Requires careful state file transfer\n\n## Real-World Impact\n\nWithout remote state, teams face state file corruption, lost changes, and infrastructure drift. Remote state with locking enables safe collaboration, audit trails, and consistent infrastructure management across distributed teams.","diagram":"graph TD\n    A[Developer A] --> B[Remote State Backend]\n    C[Developer B] --> B\n    D[State Lock Service] --> B\n    B --> E[S3 Bucket]\n    D --> F[DynamoDB Table]\n    G[apply command] --> H{Lock Acquired?}\n    H -->|Yes| I[Apply Changes]\n    H -->|No| J[Wait/Retry]\n    I --> K[Update State]\n    K --> L[Release Lock]","difficulty":"beginner","tags":["remote-state","locking","workspaces"],"channel":"terraform","subChannel":"state-management","sourceUrl":null,"videos":null,"companies":["Amazon","Hashicorp","Microsoft","Netflix","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":["remote state","locking mechanisms","dynamodb","state encryption","versioning","access control"],"voiceSuitable":true,"isNew":false,"lastUpdated":"2025-12-27T05:50:11.587Z","createdAt":"2025-12-26 12:51:07"}],"subChannels":["basics","best-practices","general","state-management"],"companies":["Airbnb","Amazon","Citadel","Coinbase","Databricks","Discord","Goldman Sachs","Google","Google Cloud","Hashicorp","LinkedIn","Lyft","Meta","Microsoft","Netflix","Oracle","PayPal","Scale Ai","Slack","Snowflake","Stripe","Tesla","Twitter","Uber"],"stats":{"total":18,"beginner":8,"intermediate":5,"advanced":5,"newThisWeek":5}}