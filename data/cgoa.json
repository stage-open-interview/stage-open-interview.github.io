{"questions":[{"id":"q-842","question":"You have a Go service using cgo to wrap a C API. A C function 'char* fetch_data(int id)' returns a malloc-allocated string or NULL on error. Design a safe Go wrapper that converts the result to a Go string, ensures the C allocation is freed, handles NULL with a meaningful error, and notes CGO thread-safety considerations. What implementation would you write?","answer":"Check for NULL, copy with GoString, then free with C.free(unsafe.Pointer(ptr)). Return (string, error). Include <stdlib.h> and declare the C function. Avoid using the original pointer after free; ensu","explanation":"## Why This Is Asked\nAssess memory management, error handling, and CGO pitfalls in real-world bindings.\n\n## Key Concepts\n- CGO memory ownership\n- NULL handling and errors\n- Safe string conversion\n- Thread-safety and allocation\n\n## Code Example\n```javascript\n// Implementation code here\n```\n\n## Follow-up Questions\n- How would you handle multi-string results and encoding issues?\n- How would you test this wrapper for leaks and concurrency?\n","diagram":"flowchart TD\n  A[Wrapper] --> B[Call C.fetch_data]\n  B --> C{ptr != NULL}\n  C -->|Yes| D[GoString & free]\n  C -->|No| E[Return error]","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","PayPal","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T13:26:43.632Z","createdAt":"2026-01-12T13:26:43.632Z"},{"id":"q-870","question":"Design a Go wrapper for a C API with mallocâ€™d results that must be freed, exploring a new angle: ensure thread-safe, single-point ownership transfer for each call and robust error handling when the C call returns a non-zero code or NULL. API: typedef struct { int code; const char* msg; } ScanResult; ScanResult* perform_scan(const char* query); void free_scan_result(ScanResult*); Implement function: func Scan(query string) (string, error)?","answer":"Serialize CGO calls with a mutex, copy the C message to Go, free the C result, and return meaningful errors when nil or code != 0. Pass query as C string and free it. Ensure no Go pointers escape into","explanation":"## Why This Is Asked\nTests memory ownership, error propagation, and CGO threading. It verifies that the candidate safely consumes C-allocated data, prevents leaks, and handles non-thread-safe C APIs in Go.\n\n## Key Concepts\n- CGO memory management and ownership transfer\n- Error handling from C to Go\n- Thread-safety and mutex usage for non-thread-safe C calls\n- Avoiding Go pointers in C and ensuring proper lifetimes\n- Resource finalization patterns\n\n## Code Example\n```go\npackage main\n\n/*\ntypedef struct { int code; const char* msg; } ScanResult;\nScanResult* perform_scan(const char* query);\nvoid free_scan_result(ScanResult*);\n*/\nimport \"C\"\nimport (\n  \"errors\"\n  \"sync\"\n  \"unsafe\"\n)\n\nvar scanMu sync.Mutex\n\nfunc Scan(query string) (string, error) {\n  cQuery := C.CString(query)\n  defer C.free(unsafe.Pointer(cQuery))\n\n  scanMu.Lock()\n  defer scanMu.Unlock()\n\n  res := C.perform_scan(cQuery)\n  if res == nil {\n    return \"\", errors.New(\"nil ScanResult from C\")\n  }\n  defer C.free_scan_result(res)\n\n  if res.code != 0 {\n    msg := C.GoString(res.msg)\n    return \"\", fmt.Errorf(\"scan failed code=%d: %s\", res.code, msg)\n  }\n  out := C.GoString(res.msg)\n  return out, nil\n}\n```\n\n## Follow-up Questions\n- How would you adapt this for a streaming callback API from C?\n- How would you test with race detector and verify memory safety across CGO calls?","diagram":"flowchart TD\n  A[Go calls Scan] --> B[Convert query to C string]\n  B --> C[Call perform_scan]\n  C --> D{Res != NULL}\n  D -->|no| E[Return error]\n  D -->|yes| F{Res.code == 0}\n  F -->|yes| G[Copy Msg, Free res, Return string]\n  F -->|no| H[Copy error, Free res, Return error]\n","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T13:52:40.902Z","createdAt":"2026-01-12T13:52:40.902Z"},{"id":"q-914","question":"Using cgo, how would you wrap a C function that allocates a string (char*) and returns it, ensuring memory is freed by Go code without leaks, and provide a minimal working example?","answer":"Declare the C function in a preamble, call it from Go, convert the returned char* with C.GoString, and defer C.free(ptr) to avoid leaks. Prefer a small wrapper that owns the allocation and exposes a d","explanation":"## Why This Is Asked\nTests understanding of memory ownership across language boundaries and safe interop.\n\n## Key Concepts\n- cgo memory management\n- Go-C interop patterns\n- Safe wrapper design\n\n## Code Example\n\n```go\n/*\n#include <stdlib.h>\nchar* alloc_str(size_t n) {\n  char* p = (char*)malloc(n+1);\n  if (p) p[n] = '\\0';\n  return p;\n}\n*/\nimport \"C\"\n\nfunc example() {\n  p := C.alloc_str(10)\n  s := C.GoString(p)\n  C.free(p)\n  _ = s\n}\n```\n\n## Follow-up Questions\n- How would you handle allocation failures?\n- How can you avoid GC cross-issue with large strings?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Snap","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T15:27:13.812Z","createdAt":"2026-01-12T15:27:13.812Z"}],"subChannels":["general"],"companies":["Instacart","Meta","Netflix","PayPal","Snap","Snowflake","Twitter"],"stats":{"total":3,"beginner":1,"intermediate":2,"advanced":0,"newThisWeek":3}}