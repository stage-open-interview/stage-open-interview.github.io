{"questions":[{"id":"q-1026","question":"Design a CGOA wrapper for a C library that provides two symbols: int* generate_seq(int n) which allocates an int array of length n via malloc filled with 0..n-1, and void free_seq(int* p) to free it. Provide the C header, the Go binding using CGO, and a small Go program that concurrently requests arrays of sizes 4 and 8, validates contents, and frees them. Include exact build steps?","answer":"Use C to own the allocated memory and expose two symbols: generate_seq and free_seq. Go binds via CGO, calling into C to obtain a raw *C.int and later frees it with free_seq. Two goroutines race-safe ","explanation":"## Why This Is Asked\nTests memory ownership and boundary safety when mixing Go and C. Candidates must implement correct allocation/free on the C side and valid binding in Go, ensuring no Go pointers cross into C and that allocations are freed.\n\n## Key Concepts\n- CGO memory ownership across boundaries\n- CGO pointer rules: avoid passing Go pointers to C\n- Concurrency safety with CGO calls\n- Leak prevention via paired malloc/free\n\n## Code Example\n```c\n// cg_seq.h\nint* generate_seq(int n);\nvoid free_seq(int* p);\n```\n\n```go\n// go_bind.go\n/*\n#cgo CFLAGS: -I.\n#include \"cg_seq.h\"\n*/\nimport \"C\"\n\nfunc GenerateSeq(n int) *C.int { return C.generate_seq(C.int(n)) }\nfunc FreeSeq(p *C.int) { C.free_seq(p) }\n```\n\n## Follow-up Questions\n- How would you return the length safely alongside the pointer?\n- How to detect leaks in tests with tools like valgrind or Go race detector?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Coinbase","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T19:37:48.180Z","createdAt":"2026-01-12T19:37:48.180Z"},{"id":"q-1099","question":"Given a C library with an asynchronous API: \n\n- void run_async(const char* input, void (*cb)(int status, const char* data, void* user), void* user);\n\nwhere the callback runs on a worker thread and data is malloc-allocated or NULL on error. Design a CGO-based Go wrapper that exposes RunAsync(input string, cb func(status int, data string, err error)). The wrapper must: manage the Go callback safely across C boundaries, free C data, map non-zero status to errors, and handle thread attachment; provide header + binding + minimal test harness to demonstrate safety?","answer":"Design a CGO bridge that stores per-call state with a Go callback and uses a cgo.Handle to pass a Go function across the boundary. Implement RunAsync(input string, cb func(int, string, error)) which c","explanation":"## Why This Is Asked\n\nTests ability to bridge asynchronous C callbacks to Go safely, including memory ownership, cross-thread invocation, and error mapping. It also checks how well the candidate uses cgo.Handle, runtime.LockOSThread, and memory management to avoid leaks or panics crossing boundaries.\n\n## Key Concepts\n\n- CGO callback bridging across threads\n- Memory ownership of malloc'd C strings\n- cgo.Handle lifetime management\n- runtime.LockOSThread and thread-affinity considerations\n- Error translation from C to Go\n\n## Code Example\n\n```javascript\n// Header (C)\n#include <stdlib.h>\nvoid run_async(const char* input, void (*cb)(int status, const char* data, void* user), void* user);\n```\n\n```javascript\n// Go binding sketch (CGO)\n// This is a conceptual outline; actual code would be Go with //export callbacks.\n```\n\n## Follow-up Questions\n\n- How would you implement cancellation and timeouts?\n- How would you test for memory leaks and callback ordering under contention?","diagram":"flowchart TD\n  A[Go API calls RunAsync] --> B[C wrapper calls run_async]\n  B --> C[Worker thread executes callback]\n  C --> D[Callback passes status/data to Go via handle]\n  D --> E[Go callback invoked]\n  E --> F[Data freed and handle cleared]","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","LinkedIn","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T22:31:14.811Z","createdAt":"2026-01-12T22:31:14.811Z"},{"id":"q-1207","question":"Design a CGO bridge for a C EventLib that exposes a function: void register_event_source(int stream_id, void (*cb)(int, const char*)); void start_event_loop(); Build a Go binding that lets two independent streams subscribe and receive events via a single exported Go callback, using a C shim to bridge into Go. Describe memory management and thread-safety; provide header, Go binding, and a small Go program demonstrating two streams; include build steps?","answer":"Use a single C callback bridged to Go via an exported function; maintain per-stream state in a mutex-protected map keyed by stream_id, storing a Go callback. Register a C shim that calls the Go bridge","explanation":"## Why This Is Asked\nExplores cross-language callbacks, CGO lifecycle, and thread-safety. The candidate must design a robust bridge rather than a naive callback.\n\n## Key Concepts\n- CGO cross-language callbacks\n- cgo.Handle for GC control\n- Thread-safety with mutex maps\n- Exported Go callbacks and C shims\n\n## Code Example\n```go\npackage main\n/*\n#include \"eventlib.h\"\n\n// Go callback exported\nextern void goEventBridge(int stream_id, const char* msg);\n\nstatic void shim_cb(int sid, const char* msg){\n    goEventBridge(sid, msg);\n}\n*/\nimport \"C\"\nimport (\n  \"runtime\"\n  \"sync\"\n)\n\ntype Callback func(int, string)\n\nvar (\n  mu sync.RWMutex\n  handlers = make(map[int]Callback)\n)\n\n// RegisterStream registers a Go callback for a stream\nfunc RegisterStream(id int, cb Callback) {\n  mu.Lock()\n  handlers[id] = cb\n  mu.Unlock()\n  C.register_event_source(C.int(id), C.shim_cb)\n  runtime.KeepAlive(cb)\n}\n\n//export goEventBridge\nfunc goEventBridge(s C.int, msg *C.char) {\n  mu.RLock()\n  cb := handlers[int(s)]\n  mu.RUnlock()\n  if cb != nil {\n    cb(int(s), C.GoString(msg))\n  }\n}\n```\n\n## Follow-up Questions\n- How would you stop a stream and clean up without races?\n- How would you propagate C-side errors back to Go?","diagram":"flowchart TD\n  A[Subscriber registers streams] --> B[Shim cb in EventLib]\n  B --> C[C thread emits event]\n  C --> D[goEventBridge is called]\n  D --> E[Go callback invoked]","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Twitter","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T04:56:17.642Z","createdAt":"2026-01-13T04:56:17.642Z"},{"id":"q-1235","question":"Implement a CGOA binding for an opaque C Counter handle. API: typedef struct Counter Counter; Counter* CounterNew(int); void CounterInc(Counter*, int); int CounterValue(Counter*); void CounterFree(Counter*); In Go wrap as type Counter with NewCounter, Inc, Value, Close. Show two goroutines each creating its own Counter, incrementing independently, and printing values to verify isolation and no data races. Include header, binding, and a minimal program with build steps?","answer":"Implement a CGOA binding for an opaque C Counter handle. API: typedef struct Counter Counter; Counter* CounterNew(int); void CounterInc(Counter*, int); int CounterValue(Counter*); void CounterFree(Cou","explanation":"## Why This Is Asked\n\nProbes CGO bindings to an opaque C type, per-instance memory management, and basic concurrency isolation.\n\n## Key Concepts\n\n- CGO binding for opaque C types\n- Manual memory management (CounterNew/CounterFree)\n- Concurrency: per-instance state and data-race awareness\n\n## Code Example\n\n```c\n// C header\ntypedef struct Counter Counter;\nCounter* CounterNew(int initial);\nvoid CounterInc(Counter*, int delta);\nint CounterValue(Counter*);\nvoid CounterFree(Counter*);\n```\n\n```go\n// Go binding snippet\n// #include \\\"counter.h\\\"\nimport \"C\"\n\ntype Counter struct{ c *C.Counter }\n\nfunc NewCounter(init int) *Counter {\n  c := C.CounterNew(C.int(init))\n  return &Counter{c: c}\n}\n\nfunc (ctr *Counter) Inc(delta int) {\n  C.CounterInc(ctr.c, C.int(delta))\n}\n\nfunc (ctr *Counter) Value() int {\n  return int(C.CounterValue(ctr.c))\n}\n\nfunc (ctr *Counter) Close() {\n  C.CounterFree(ctr.c)\n}\n```\n\n## Follow-up Questions\n\n- How would you ensure thread-safety when multiple goroutines manipulate distinct Counter instances?\n- What changes if Counter access becomes shared across goroutines?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Instacart","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T06:33:00.575Z","createdAt":"2026-01-13T06:33:00.575Z"},{"id":"q-1294","question":"Implement a CGOA bridge that lets C trigger a Go callback asynchronously when an external sensor fires events. Provide a C header and stub, a CGO binding in Go that registers a Go callback and routes events through an exported Go function, and a safe cleanup mechanism to release resources when producers stop?","answer":"Design approach: Go registers a callback, wraps it with runtime/cgo.NewHandle(cb) and passes the handle’s uintptr to C. An exported bridge function (//export goCallbackBridge) is invoked by C with the","explanation":"## Why This Is Asked\nCGOA bridges are common in practice when external C libraries need Go callbacks. This tests safe lifetimes, non-Go-pointer transfer, and cross-language threading.\n\n## Key Concepts\n- runtime/cgo.Handle\n- //exported Go functions\n- passing uintptr_t to C\n- proper cleanup and synchronization\n\n## Code Example\n```c\n/* header */\nvoid register_callback(void (*cb)(int, void*), void* ctx);\n```\n\n## Follow-up Questions\n- How to avoid deadlocks when callbacks re-enter?\n- How to handle panics in the Go callback across threads?","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Lyft","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T08:40:37.001Z","createdAt":"2026-01-13T08:40:37.001Z"},{"id":"q-1371","question":"Implement a CGO binding for a C function that computes sum and mean of an int array. Provide header and C source with int compute_stats(const int* values, size_t n, long long* sum, double* mean); 0 on success, -1 if n==0. In Go, implement ComputeStats(values []int) (int64, float64, error) calling the C function via CGO, converting types. Add a small main.go that runs two goroutines, each calling ComputeStats on its own slice. Include build steps?","answer":"Provide a header and C source implementing compute_stats, returning 0 on success and -1 on error (n==0). In Go, implement ComputeStats(values []int) (int64, float64, error) calling the C function via ","explanation":"## Why This Is Asked\nTests bridging Go and C boundaries, including memory handling, error propagation, and concurrency.\n\n## Key Concepts\n- CGO bindings and headers\n- Go to C array conversions\n- Translating C errors to Go errors\n- Concurrency across CGO calls\n- Build considerations (CGO enabled)\n\n## Code Example\n```c\n// stats.h\nint compute_stats(const int* values, size_t n, long long* sum, double* mean);\n```\n```c\n// stats.c\n#include \"stats.h\"\n#include <stddef.h>\nint compute_stats(const int* values, size_t n, long long* sum, double* mean) {\n    if (n == 0) return -1;\n    long long s = 0;\n    for (size_t i = 0; i < n; ++i) s += values[i];\n    *sum = s;\n    *mean = (double)s / (double)n;\n    return 0;\n}\n```\n```go\n// stats.go\npackage main\n/*\n#cgo CFLAGS: -O2\n#include \"stats.h\"\n*/\nimport \"C\"\nimport (\n  \"fmt\"\n)\n\nfunc ComputeStats(values []int) (int64, float64, error) {\n  if len(values) == 0 { return 0, 0, fmt.Errorf(\"empty input\") }\n  cvals := make([]C.int, len(values))\n  for i, v := range values { cvals[i] = C.int(v) }\n  var sum C.longlong\n  var mean C.double\n  if res := C.compute_stats((*C.int)(&cvals[0]), C.size_t(len(cvals)), &sum, &mean); res != 0 {\n    return 0, 0, fmt.Errorf(\"C error\")\n  }\n  return int64(sum), float64(mean), nil\n}\n```\n\n## Follow-up Questions\n- How would you handle larger inputs or streaming data?\n- How would you extend to support multiple concurrent calls safely?\n","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T14:35:20.730Z","createdAt":"2026-01-13T14:35:20.730Z"},{"id":"q-1396","question":"Implement a CGO bridge for a C event source that runs callbacks on its own threads and delivers events to Go via a callback of the form void cb(int code, const char* msg, void* ctx). Expose StartEventSource(cb, ctx) -> handle and StopEventSource(handle). Provide a C header, the Go binding using CGO (with a Go-exported callback and pointer-ownership strategy), and a small Go program that starts two sources and validates receipt of events through a single Go channel. Include build steps?","answer":"Design a CGO bridge where C emits events on its own threads and calls back into Go with a signature void cb(int code, const char* msg, void* ctx). Expose StartEventSource(cb, ctx) -> handle and StopEv","explanation":"## Why This Is Asked\nTests ability to model cross-language ownership, thread safety, and lifecycle across CGO.\n\n## Key Concepts\n- CGO callback exports and Go pointer lifetimes\n- cgo.Handle and runtime.KeepAlive\n- Cross-thread callback safety and event serialization\n- Lifecycle management of C resources across Go\n\n## Code Example\n\n```c\n// header: event_source.h\ntypedef void (*cb_t)(int code, const char* msg, void* ctx);\nint StartEventSource(cb_t cb, void* ctx);\nvoid StopEventSource(int handle);\n```\n\n```go\n// binding.go\npackage main\n// CGO binding sketch showing an exported callback and lifecycle wiring\n```\n\n## Follow-up Questions\n- How would you ensure ctx isn't garbage-collected while C holds it?\n- How would you handle errors from C that should propagate to Go?\n- How would you test for deadlocks or callback reentrancy across the boundary?\n","diagram":"flowchart TD\nA[Go Start] --> B[C: register callback]\nB --> C[Events on C threads]\nC --> D[Go: enqueue to channel]\nD --> E[Go consumer reads]","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","PayPal","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T15:37:15.257Z","createdAt":"2026-01-13T15:37:15.257Z"},{"id":"q-1548","question":"Implement a CGO wrapper for a C library that registers a Go callback and invokes it from a C event loop. Provide a C header and implementation for: - void register_callback(void (*cb)(int)); - void trigger(int value); Write Go bindings using CGO to pass a Go function as the callback, ensuring safe cross-language invocation, correct Go runtime considerations, and demonstrate with two goroutines each registering and triggering events. Include build steps?","answer":"A robust solution defines a C wrapper that stores a callback function pointer, a register_callback function to install it, and a trigger function that invokes it. In Go, export goCallback and pass it to C using CGO, ensuring proper cross-language invocation with runtime safety considerations.","explanation":"## Why This Is Asked\nThis question tests CGO cross-language callback design, memory management, and thread-safety in a beginner-friendly but realistic setup that mirrors real-world integration scenarios.\n\n## Key Concepts\n- CGO interoperability and function pointer management\n- Go exported callbacks with //export directive\n- Go runtime and thread-safety compliance\n- Lifetime management using KeepAlive and avoiding premature GC\n\n## Code Example\n```c\n// header\nvoid register_callback(void (*cb)(int));\nvoid trigger(int value);\n```\n\n```go\n//go:export goCallback\nfunc goCallback(v C.int) {\n  // handle","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Meta","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T06:30:39.820Z","createdAt":"2026-01-13T21:37:30.342Z"},{"id":"q-1659","question":"Design a CGOA wrapper to let a Go function be registered as a callback for a C API that emits events asynchronously on external threads. The C API exposes: typedef void (*cb_t)(int eventCode, void* context); void register_cb(cb_t cb, void* ctx); void emit_event(int code); Implement header, CGO binding, and a minimal program that registers a Go callback, triggers an event, and exits safely. Include build steps?","answer":"Use a trampoline with a CGO handle. Store the Go callback in a map, obtain a CGO handle, and pass the handle as ctx to register_cb. Export a Go function with //export that C calls; it looks up the han","explanation":"## Why This Is Asked\nTests ability to bridge Go and C with callbacks across threads, a common real-world CGO pitfall. It probes lifetime management, thread-safety, and CGO pointer rules.\n\n## Key Concepts\n- CGO callback lifetimes and //export limitations\n- cg oHandle usage to store Go values for C callbacks\n- Thread-safety: mutexes and safe dispatch of callbacks\n- Proper cleanup to avoid leaks when unregistering\n\n## Code Example\n```javascript\n// C header (capi.h)\ntypedef void (*cb_t)(int eventCode, void* context);\nvoid register_cb(cb_t cb, void* ctx);\nvoid emit_event(int code);\n```\n\n```javascript\n// Go binding (cgowa/cgo) - simplified\npackage main\n/*\n#include \"capi.h\"\n*/\nimport \"C\"\nimport (\n  \"sync\"\n  \"unsafe\"\n)\n\nvar (\n  mu       sync.Mutex\n  cbStore  = map[uintptr]func(int){}\n  nextKey  uintptr = 1\n)\n\n//export goCallback\nfunc goCallback(event C.int, ctx unsafe.Pointer) {\n  mu.Lock()\n  if f, ok := cbStore[uintptr(ctx)]; ok {\n    f(int(event))\n  }\n  mu.Unlock()\n}\n\nfunc registerCallback(f func(int)) unsafe.Pointer {\n  mu.Lock()\n  key := nextKey\n  nextKey++\n  cbStore[key] = f\n  mu.Unlock()\n  // pass key as ctx to C\n  return unsafe.Pointer(uintptr(key))\n}\n```\n\n```javascript\n// Minimal usage (main.go)\npackage main\nimport (\n  \"C\"\n  \"fmt\"\n)\nfunc main(){\n  cb := func(e int){ fmt.Println(\"event:\", e) }\n  ctx := registerCallback(cb)\n  C.emit_event(42) // would trigger goCallback with ctx\n  _ = ctx\n}\n```\n\n## Follow-up Questions\n- How would you extend this to support multiple concurrent Go callbacks safely?\n- How do you handle panics in Go callbacks so they don’t crash the C caller or CGO bridge?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Scale Ai","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T05:42:28.056Z","createdAt":"2026-01-14T05:42:28.056Z"},{"id":"q-1758","question":"You have a C library exposing void start_event_loop(void (*cb)(int event, void* ctx), void* ctx) and void stop_event_loop(). Implement a CGO bridge in Go that safely delivers events to per-stream Go handlers without passing Go pointers to C, supports multiple concurrent streams, and clean teardown. Provide C header, a thin C wrapper to register a per-stream callback, and a Go binding plus a small program that starts two streams and stops them?","answer":"Design a CGO bridge for a C event loop that calls a callback from a dedicated thread into Go. Do not pass Go pointers to C; implement a per-stream registry keyed by an opaque handle, use a thread-safe","explanation":"## Why This Is Asked\nTests deep CGO understanding: cross-language callbacks, Go pointer rules, and per-stream lifecycle.\n\n## Key Concepts\n- CGO pointer safety and Go memory management\n- Cross-thread callbacks and event dispatch\n- Per-stream registries and lifecycle management\n\n## Code Example\n```javascript\n// C header and Go binding would be provided here in a real task to illustrate wrappers and registration\n```\n\n## Follow-up Questions\n- How would you handle backpressure when the Go side lags behind C callbacks?\n- How would you extend to support cancellation contexts for individual streams?","diagram":"flowchart TD\n  A[Start] --> B[Bridge Created]\n  B --> C[Streams Registered]\n  C --> D[Events Enqueued]\n  D --> E[Go Handlers Dispatch]\n  E --> F[Teardown]\n  F --> G[Stop Loop]","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Netflix","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T09:45:25.745Z","createdAt":"2026-01-14T09:45:25.745Z"},{"id":"q-1815","question":"Design and implement a CGOA bridge for a C streaming library that emits integers via a callback. Expose a Go API StartStream() (<-chan int, func Stop()) using cgo.Handle to pass the Go-side context. Ensure thread-safe delivery of values to Go, proper cleanup with finalizers, and robust error reporting across the boundary. Provide C header, Go binding, and a minimal caller?","answer":"Propose a CGO wrapper that uses a C function to register a stream callback, with a Go channel wrapped by a cgo.Handle as the ctx. A single C callback pushes values into the Go channel via an exported ","explanation":"## Why This Is Asked\nTests ability to bridge Go and C safely in a streaming, callback-driven API, including memory ownership, callbacks from C into Go, and lifecycle handling.\n\n## Key Concepts\n- CGO and cgo.Handle usage\n- Cross-language callbacks and goroutine scheduling\n- Memory ownership and finalizers\n- Error handling across language boundaries\n\n## Code Example\n```c\ntypedef void (*cb_t)(int value, void* ctx);\nvoid register_stream(cb_t cb, void* ctx);\nvoid start_stream();\nvoid stop_stream();\n```\n```go\n// CGO binding sketch\npackage main\n/*\n#include <stdint.h>\n#include \"stream.h\"\nstatic void go_cb(int v, void* ctx);\n*/\nimport \"C\"\nimport (\n  \"runtime\"\n  \"runtime/cgo\"\n)\n\n//export go_cb\nfunc go_cb(v C.int, ctx unsafe.Pointer) {\n  // forward to Go channel via stored handle\n}\n\nfunc StartStream() (<-chan int, func()) {\n  // wrap ctx in a handle and start streaming; return stop function\n  ch := make(chan int)\n  h := cgo.NewHandle(ch)\n  // pass h.ptr to C as ctx; set up finalizer to ensure cleanup\n  runtime.SetFinalizer(&ch, func(*chan int) { /* cleanup */ })\n  // start_stream and callback wiring...\n  return ch, func() { /* stop and release handle */ }\n}\n```","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Google","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T11:49:06.568Z","createdAt":"2026-01-14T11:49:06.568Z"},{"id":"q-1845","question":"Implement a CGOA wrapper around a C function that returns a heap-allocated string: char* greet(const char* name). Provide a header with greet and void free_string(char*). Write a Go binding using CGO to call greet from multiple goroutines and free the result with free_string to avoid leaks. Include the header, a Go binding file, and a small Go program that calls greet(\"Alice\"), greet(\"Bob\"), greet(\"Carol\") concurrently and prints results. Include build steps?","answer":"Provide the C header greet.h with: char* greet(const char* name); void free_string(char* s); Then implement a C source that allocates via malloc and returns the string. In Go, use // #include \\\"greet.","explanation":"## Why This Is Asked\nTests memory ownership across Go and C, and CGO interaction with heap-allocated strings.\n\n## Key Concepts\n- CGO string handling and C memory management\n- Ownership transfer and explicit frees\n- Concurrency safety when crossing language boundaries\n\n## Code Example\n```c\n// greet.h\nchar* greet(const char* name);\nvoid free_string(char* s);\n```\n```c\n// greet.c\n#include <stdlib.h>\n#include <string.h>\n#include \"greet.h\"\nchar* greet(const char* name){ const char* prefix = \"Hello, \"; size_t len = strlen(prefix) + strlen(name) + 2; char* out = (char*)malloc(len); if(!out) return NULL; strcpy(out, prefix); strcat(out, name); return out; }\n```\n```go\n// greet.go\npackage main\nimport \"C\"\nimport (\n  \"fmt\" \n  \"unsafe\"\n)\nfunc greetGo(name string) string {\n  cstr := C.CString(name)\n  defer C.free(unsafe.Pointer(cstr))\n  r := C.greet(cstr)\n  s := C.GoString(r)\n  C.free_string(r)\n  return s\n}\nfunc main() {\n  // spawn 3 goroutines and print\n  // simplified in actual implementation\n  _ = greetGo\n  fmt.Println(greetGo(\"Alice\"))\n  fmt.Println(greetGo(\"Bob\"))\n  fmt.Println(greetGo(\"Carol\"))\n}\n```\n\n## Follow-up Questions\n- How would you extend to support batch processing with a single allocation?\n- How to verify no memory leaks with Go's tests?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","NVIDIA","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T13:29:41.015Z","createdAt":"2026-01-14T13:29:41.015Z"},{"id":"q-1910","question":"Design a CGOA exercise: Create a C header exposing void scale_and_offset(const float* input, int n, float* output, float scale, float offset); Implement a Go binding using CGO that wraps ScaleAndOffset and returns a slice of float results. Provide a minimal C implementation, a Go binding, and a short Go program that launches two goroutines, each feeding distinct input arrays to scale_and_offset concurrently? Include build steps?","answer":"Implementation approach: C header declares void scale_and_offset(const float* input, int n, float* output, float scale, float offset); Go binds via import \"C\" and a wrapper function ScaleAndOffset(in ","explanation":"## Why This Is Asked\nTests CGO memory handling, cross-language data transfer, and concurrency safety in a realistic wrapper.\n\n## Key Concepts\n- CGO data marshaling between Go and C\n- Avoiding Go pointers in C calls\n- Memory management with malloc/free across boundaries\n- Concurrency safety in native calls via goroutines\n\n## Code Example\n```javascript\n// Example glue code in Go to start CGO wrapper (conceptual)\n```\n\n## Follow-up Questions\n- How would you extend to error reporting from C to Go?\n- How to handle different numeric types and alignment across architectures?\n","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Instacart","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T16:54:29.264Z","createdAt":"2026-01-14T16:54:29.264Z"},{"id":"q-1993","question":"Design a CGO bridge for a C API that uses a progress callback and supports cancelable work. The C API exposes: typedef void (*progress_cb)(int percent, void* user); void register_progress(progress_cb cb, void* user); int do_work(int steps); The callback may be invoked on worker threads. Implement: (1) a C header that defines the callback type and registration; (2) a Go binding using CGO that exposes a Go channel-based Progress stream; (3) a small Go program that starts do_work in a goroutine and prints progress, with a context-based cancellation. Ensure memory and lifecycle safety across boundaries?","answer":"Bridge the C progress callback to Go with per-work handles and a Go channel; export a trampoline in C that forwards (percent, user) to a Go receiver using a stable Go-side map keyed by an opaque handl","explanation":"## Why This Is Asked\nTests cross-language callback lifecycles, CGO invocation rules, and cancellation semantics by streaming progress from C to Go with lifecycle management.\n\n## Key Concepts\n- CGO callback lifetimes and trampolines\n- Safe passing of user data without Go pointers into C\n- Per-work handles and cleanup\n- Streaming events via Go channels\n- Context-based cancellation and unregistering\n\n## Code Example\n```c\n// header: progress.h\ntypedef void (*progress_cb)(int percent, void* user);\nvoid register_progress(progress_cb cb, void* user);\nint do_work(int steps);\n```\n\n```go\n// binding.go\npackage progress\n/*\n#include \"progress.h\"\n*/\nimport \"C\"\n\n// Binding scaffolding to illustrate approach\n```\n\n```go\n// usage.go\npackage main\nimport (\n  \"context\"\n  \"fmt\"\n  \"time\"\n  p \"your/module/path/progress\"\n)\nfunc main() {\n  ctx, cancel := context.WithCancel(context.Background())\n  defer cancel()\n  ch := make(chan int)\n  // Bind a CGO callback to push progress into ch; ensure cleanup on cancel\n  go func(){ C.do_work(C.int(100)) }()\n  for {\n    select {\n    case v := <-ch:\n      fmt.Println(\"progress\", v)\n    case <-ctx.Done():\n      return\n    }\n  }\n}\n```\n\n## Follow-up Questions\n- How would you multiplex progress from multiple concurrent tasks?\n- How would you test cancellation and error propagation in this wrapper?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Google","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T19:49:17.801Z","createdAt":"2026-01-14T19:49:17.801Z"},{"id":"q-2011","question":"Implement a beginner CGO binding that exposes a C API void compute_stats(const double* data, size_t n, double* mean, double* stddev) to Go. Provide a C header, a Go binding using CGO, and a small Go program that launches 4 goroutines, each calling ComputeStats on its own data slice concurrently. Ensure memory safety, zero-copy access where possible, and that data races are avoided. Include explicit build steps?","answer":"Bind a C API void compute_stats(const double* data, size_t n, double* mean, double* stddev) to Go via CGO. Use a header and a Go wrapper ComputeStats(data []float64) (mean, stddev float64) that checks","explanation":"## Why This Is Asked\nTests ability to design safe CGO bindings that move data between Go and C, ensure memory safety, and reason about concurrency.\n\n## Key Concepts\n- CGO bindings and header inclusion\n- Memory ownership and avoiding copies\n- Passing slices to C safely with unsafe\n- Concurrency: goroutines calling C functions without races\n- Error handling for empty inputs and C errors\n\n## Code Example\n```c\n#ifndef STATS_H\n#define STATS_H\nvoid compute_stats(const double* data, size_t n, double* mean, double* stddev);\n#endif\n```\n\n```go\npackage cgobind\n\n/*\n#include \"stats.h\"\n*/\nimport \"C\"\nimport (\n  \"unsafe\"\n)\n\nfunc ComputeStats(data []float64) (mean, stddev float64) {\n  if len(data) == 0 {\n    return 0, 0\n  }\n  var cMean, cStddev C.double\n  ptr := (*C.double)(unsafe.Pointer(&data[0]))\n  C.compute_stats(ptr, C.size_t(len(data)), &cMean, &cStddev)\n  return float64(cMean), float64(cStddev)\n}\n```\n\n## Follow-up Questions\n- How would you adapt for non-contiguous data or different memory layouts?\n- What about error propagation if the C function encounters NaN values?","diagram":"flowchart TD\n  Go --> CGO_Wrapper\n  CGO_Wrapper --> C_Function\n  C_Function --> Go_Return\n  Go_Return --> Goroutines","difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Meta","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T20:49:43.279Z","createdAt":"2026-01-14T20:49:43.279Z"},{"id":"q-2036","question":"Your C library exposes a function int start_task(int task_id, void (*progress_cb)(int, const char*)); void stop_task(int task_id); The callback is invoked from worker threads and passes a progress value and a C string message. Design a CGO-based Go binding that allows registering a Go callback per task, safely translates C strings to Go strings, guarantees thread-safe delivery of progress events to Go, and supports cancellation via stop_task while ensuring resources are freed. Include a header, the Go binding, and a minimal Go program launching two concurrent tasks with per-task callbacks. Provide build steps?","answer":"Register per-task Go callbacks in a mutex-protected map[int]func(int,string). Create a Go–C bridge: assign a unique id, store a closure, pass the id to C as an int and a static C progress_cb. Export progress events through CGO, ensuring thread-safe delivery and proper cleanup when tasks are cancelled.","explanation":"Why This Is Asked\n- Tests CGO callback patterns, memory safety, and concurrency\n- Exercises safe crossing of Go/C without pointer sharing\n- Validates resource management and cancellation in real workloads\n\nKey Concepts\n- CGO callbacks across threads\n- Go closure lifetimes with C handles\n- Safe string conversion and memory management\n\nCode Example\n```c\n// C header\nint start_task(int task_id, void (*progress_cb)(int, const char*));\nvoid stop_task(int task_id);\n```\n\nFollow-up Questions\n- How would you handle panics in the Go callback across CGO?\n- How to extend for multiple C libraries with varying callback signatures?","diagram":"flowchart TD\nA(Task Start) --> B(Register Callback)\nB --> C(C Bridge Invokes Go Callback)\nC --> D(Go Handler Executes)\nD --> E(Stop Task)\n","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","NVIDIA","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T04:49:16.827Z","createdAt":"2026-01-14T21:41:08.651Z"},{"id":"q-842","question":"You have a Go service using cgo to wrap a C API. A C function 'char* fetch_data(int id)' returns a malloc-allocated string or NULL on error. Design a safe Go wrapper that converts the result to a Go string, ensures the C allocation is freed, handles NULL with a meaningful error, and notes CGO thread-safety considerations. What implementation would you write?","answer":"Check for NULL, copy with GoString, then free with C.free(unsafe.Pointer(ptr)). Return (string, error). Include <stdlib.h> and declare the C function. Avoid using the original pointer after free; ensu","explanation":"## Why This Is Asked\nAssess memory management, error handling, and CGO pitfalls in real-world bindings.\n\n## Key Concepts\n- CGO memory ownership\n- NULL handling and errors\n- Safe string conversion\n- Thread-safety and allocation\n\n## Code Example\n```javascript\n// Implementation code here\n```\n\n## Follow-up Questions\n- How would you handle multi-string results and encoding issues?\n- How would you test this wrapper for leaks and concurrency?\n","diagram":"flowchart TD\n  A[Wrapper] --> B[Call C.fetch_data]\n  B --> C{ptr != NULL}\n  C -->|Yes| D[GoString & free]\n  C -->|No| E[Return error]","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","PayPal","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T13:26:43.632Z","createdAt":"2026-01-12T13:26:43.632Z"},{"id":"q-870","question":"Design a Go wrapper for a C API with malloc’d results that must be freed, exploring a new angle: ensure thread-safe, single-point ownership transfer for each call and robust error handling when the C call returns a non-zero code or NULL. API: typedef struct { int code; const char* msg; } ScanResult; ScanResult* perform_scan(const char* query); void free_scan_result(ScanResult*); Implement function: func Scan(query string) (string, error)?","answer":"Serialize CGO calls with a mutex, copy the C message to Go, free the C result, and return meaningful errors when nil or code != 0. Pass query as C string and free it. Ensure no Go pointers escape into","explanation":"## Why This Is Asked\nTests memory ownership, error propagation, and CGO threading. It verifies that the candidate safely consumes C-allocated data, prevents leaks, and handles non-thread-safe C APIs in Go.\n\n## Key Concepts\n- CGO memory management and ownership transfer\n- Error handling from C to Go\n- Thread-safety and mutex usage for non-thread-safe C calls\n- Avoiding Go pointers in C and ensuring proper lifetimes\n- Resource finalization patterns\n\n## Code Example\n```go\npackage main\n\n/*\ntypedef struct { int code; const char* msg; } ScanResult;\nScanResult* perform_scan(const char* query);\nvoid free_scan_result(ScanResult*);\n*/\nimport \"C\"\nimport (\n  \"errors\"\n  \"sync\"\n  \"unsafe\"\n)\n\nvar scanMu sync.Mutex\n\nfunc Scan(query string) (string, error) {\n  cQuery := C.CString(query)\n  defer C.free(unsafe.Pointer(cQuery))\n\n  scanMu.Lock()\n  defer scanMu.Unlock()\n\n  res := C.perform_scan(cQuery)\n  if res == nil {\n    return \"\", errors.New(\"nil ScanResult from C\")\n  }\n  defer C.free_scan_result(res)\n\n  if res.code != 0 {\n    msg := C.GoString(res.msg)\n    return \"\", fmt.Errorf(\"scan failed code=%d: %s\", res.code, msg)\n  }\n  out := C.GoString(res.msg)\n  return out, nil\n}\n```\n\n## Follow-up Questions\n- How would you adapt this for a streaming callback API from C?\n- How would you test with race detector and verify memory safety across CGO calls?","diagram":"flowchart TD\n  A[Go calls Scan] --> B[Convert query to C string]\n  B --> C[Call perform_scan]\n  C --> D{Res != NULL}\n  D -->|no| E[Return error]\n  D -->|yes| F{Res.code == 0}\n  F -->|yes| G[Copy Msg, Free res, Return string]\n  F -->|no| H[Copy error, Free res, Return error]\n","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T13:52:40.902Z","createdAt":"2026-01-12T13:52:40.902Z"},{"id":"q-914","question":"Using cgo, how would you wrap a C function that allocates a string (char*) and returns it, ensuring memory is freed by Go code without leaks, and provide a minimal working example?","answer":"Declare the C function in a preamble, call it from Go, convert the returned char* with C.GoString, and defer C.free(ptr) to avoid leaks. Prefer a small wrapper that owns the allocation and exposes a d","explanation":"## Why This Is Asked\nTests understanding of memory ownership across language boundaries and safe interop.\n\n## Key Concepts\n- cgo memory management\n- Go-C interop patterns\n- Safe wrapper design\n\n## Code Example\n\n```go\n/*\n#include <stdlib.h>\nchar* alloc_str(size_t n) {\n  char* p = (char*)malloc(n+1);\n  if (p) p[n] = '\\0';\n  return p;\n}\n*/\nimport \"C\"\n\nfunc example() {\n  p := C.alloc_str(10)\n  s := C.GoString(p)\n  C.free(p)\n  _ = s\n}\n```\n\n## Follow-up Questions\n- How would you handle allocation failures?\n- How can you avoid GC cross-issue with large strings?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Snap","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T15:27:13.812Z","createdAt":"2026-01-12T15:27:13.812Z"},{"id":"q-950","question":"Implement a minimal CGOA wrapper that exposes a C function int add(int a, int b) to Go. Provide the C header, the Go binding using CGO, and a small Go program that concurrently calls Add from two goroutines to demonstrate thread safety. Include build steps?","answer":"Bridge by CGOA: expose C int add(int a, int b) to Go. In bridge.h declare int add(int a, int b); In Go: include the header, import \\\"C\\\", and implement Add(a,b int) int { return int(C.add(C.int(a), C.","explanation":"## Why This Is Asked\nTo verify practical understanding of bridging C to Go using CGOA, including type conversions and concurrency safety.\n\n## Key Concepts\n- CGOA basics: cgo import and header inclusion\n- Type conversions between C and Go\n- Build/link steps for mixed languages\n- Concurrency: safe calls from multiple goroutines\n\n## Code Example\nExplain how Add wraps C.add as a Go function and how to organize bridge.c/bridge.h and main.go.\n\n## Follow-up Questions\n- How would you handle error returns or errno from C?\n- How to extend to multiple C functions or error propagation?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Snap","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T16:38:23.204Z","createdAt":"2026-01-12T16:38:23.204Z"},{"id":"q-978","question":"Design a CGO bridge for a C streaming API that delivers chunks via a callback: void stream_data(int id, void (*chunk_cb)(const char* data, size_t len, void*), void* ctx). Implement a Go wrapper StreamFromC(id int) (io.Reader, error) that buffers chunks into an io.Pipe and exposes a safe reader, supporting concurrent streams and proper backpressure. Include a C header, a Go CGO binding, and a simple consumer showing two goroutines reading from the reader?","answer":"Leverage a per-stream context and a C callback exported to Go. Use a Go channel to forward chunks, copy data into Go memory, feed an io.Pipe writer, and return an io.Reader to the caller. Ensure clean","explanation":"## Why This Is Asked\nTests ability to bridge callbacks, memory ownership, and streaming backpressure across language boundaries.\n\n## Key Concepts\n- CGO callback bridge and per-stream context\n- Memory ownership and copying from C to Go\n- Streaming via io.Pipe and concurrent reads\n\n## Code Example\n```c\n// stream.h\nvoid stream_data(int id, void (*chunk_cb)(const char*, size_t, void*), void* ctx);\n```\n```go\n// stream_bind.go (skeleton)\n/*\n#cgo CFLAGS: -I./include\n#include \"stream.h\"\n*/\nimport \"C\"\nimport (\n  \"io\"\n)\n\nfunc StreamFromC(id int) (io.Reader, error) {\n  // binding implementation here\n  return nil, nil\n}\n```\n```go\n// consumer.go (usage)\npackage main\nimport (\n  \"io\"\n  \"fmt\"\n)\nfunc main() {\n  r, _ := StreamFromC(42)\n  buf := make([]byte, 1024)\n  for {\n    n, err := r.Read(buf)\n    if err == io.EOF { break }\n    fmt.Printf(\"read %d bytes\\n\", n)\n  }\n}\n```\n\n## Follow-up Questions\n- How would you handle backpressure if C emits chunks faster than Go consumes them?\n- How would you adapt this to multiple ids concurrently without cross-talk?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Microsoft","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T17:41:57.902Z","createdAt":"2026-01-12T17:41:57.902Z"},{"id":"q-987","question":"Implement a CGO binding for a C function char* greet(const char* name) that returns a newly allocated string. Provide the C header and implementation, a Go binding using CGO that wraps greet in a safe Go function returning (string, error), and a small Go program that concurrently calls the binding from multiple goroutines and frees the allocated memory. How would you handle NULL returns and memory deallocation robustly?","answer":"Use CGO to wrap greet: convert input to a C string, call the C function, check for NULL, convert the result back to a Go string, and free both allocations. Return a Go string and an error. Ensure both","explanation":"## Why This Is Asked\nTests practical CGO understanding: safe memory ownership, error translation, and concurrency.\n\n## Key Concepts\n- CGO boundaries and memory ownership\n- Translating errors from C to Go\n- Safe deallocation of C-allocated strings\n- Concurrency: calling CGO from multiple goroutines\n\n## Code Example\n```go\n// Go binding sketch (not full code)\npackage cgowrap\nimport \"C\"\n// Greet wraps C.greet and converts result to Go string with error handling\nfunc Greet(name string) (string, error) { /* omitted for brevity in answer */ }\n```\n\n## Follow-up Questions\n- How would you model ownership if C returns allocated memory for reuse?\n- How can you detect and prevent use-after-free in long-lived Go values?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","MongoDB","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T18:32:47.654Z","createdAt":"2026-01-12T18:32:47.654Z"}],"subChannels":["general"],"companies":["Adobe","Airbnb","Anthropic","Bloomberg","Cloudflare","Coinbase","Databricks","Goldman Sachs","Google","Hashicorp","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Netflix","Oracle","PayPal","Plaid","Robinhood","Scale Ai","Slack","Snap","Snowflake","Square","Stripe","Tesla","Twitter","Two Sigma"],"stats":{"total":22,"beginner":10,"intermediate":7,"advanced":5,"newThisWeek":22}}