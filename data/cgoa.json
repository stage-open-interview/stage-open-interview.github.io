{"questions":[{"id":"q-1026","question":"Design a CGOA wrapper for a C library that provides two symbols: int* generate_seq(int n) which allocates an int array of length n via malloc filled with 0..n-1, and void free_seq(int* p) to free it. Provide the C header, the Go binding using CGO, and a small Go program that concurrently requests arrays of sizes 4 and 8, validates contents, and frees them. Include exact build steps?","answer":"Use C to own the allocated memory and expose two symbols: generate_seq and free_seq. Go binds via CGO, calling into C to obtain a raw *C.int and later frees it with free_seq. Two goroutines race-safe ","explanation":"## Why This Is Asked\nTests memory ownership and boundary safety when mixing Go and C. Candidates must implement correct allocation/free on the C side and valid binding in Go, ensuring no Go pointers cross into C and that allocations are freed.\n\n## Key Concepts\n- CGO memory ownership across boundaries\n- CGO pointer rules: avoid passing Go pointers to C\n- Concurrency safety with CGO calls\n- Leak prevention via paired malloc/free\n\n## Code Example\n```c\n// cg_seq.h\nint* generate_seq(int n);\nvoid free_seq(int* p);\n```\n\n```go\n// go_bind.go\n/*\n#cgo CFLAGS: -I.\n#include \"cg_seq.h\"\n*/\nimport \"C\"\n\nfunc GenerateSeq(n int) *C.int { return C.generate_seq(C.int(n)) }\nfunc FreeSeq(p *C.int) { C.free_seq(p) }\n```\n\n## Follow-up Questions\n- How would you return the length safely alongside the pointer?\n- How to detect leaks in tests with tools like valgrind or Go race detector?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Coinbase","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T19:37:48.180Z","createdAt":"2026-01-12T19:37:48.180Z"},{"id":"q-1099","question":"Given a C library with an asynchronous API: \n\n- void run_async(const char* input, void (*cb)(int status, const char* data, void* user), void* user);\n\nwhere the callback runs on a worker thread and data is malloc-allocated or NULL on error. Design a CGO-based Go wrapper that exposes RunAsync(input string, cb func(status int, data string, err error)). The wrapper must: manage the Go callback safely across C boundaries, free C data, map non-zero status to errors, and handle thread attachment; provide header + binding + minimal test harness to demonstrate safety?","answer":"Design a CGO bridge that stores per-call state with a Go callback and uses a cgo.Handle to pass a Go function across the boundary. Implement RunAsync(input string, cb func(int, string, error)) which c","explanation":"## Why This Is Asked\n\nTests ability to bridge asynchronous C callbacks to Go safely, including memory ownership, cross-thread invocation, and error mapping. It also checks how well the candidate uses cgo.Handle, runtime.LockOSThread, and memory management to avoid leaks or panics crossing boundaries.\n\n## Key Concepts\n\n- CGO callback bridging across threads\n- Memory ownership of malloc'd C strings\n- cgo.Handle lifetime management\n- runtime.LockOSThread and thread-affinity considerations\n- Error translation from C to Go\n\n## Code Example\n\n```javascript\n// Header (C)\n#include <stdlib.h>\nvoid run_async(const char* input, void (*cb)(int status, const char* data, void* user), void* user);\n```\n\n```javascript\n// Go binding sketch (CGO)\n// This is a conceptual outline; actual code would be Go with //export callbacks.\n```\n\n## Follow-up Questions\n\n- How would you implement cancellation and timeouts?\n- How would you test for memory leaks and callback ordering under contention?","diagram":"flowchart TD\n  A[Go API calls RunAsync] --> B[C wrapper calls run_async]\n  B --> C[Worker thread executes callback]\n  C --> D[Callback passes status/data to Go via handle]\n  D --> E[Go callback invoked]\n  E --> F[Data freed and handle cleared]","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","LinkedIn","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T22:31:14.811Z","createdAt":"2026-01-12T22:31:14.811Z"},{"id":"q-1207","question":"Design a CGO bridge for a C EventLib that exposes a function: void register_event_source(int stream_id, void (*cb)(int, const char*)); void start_event_loop(); Build a Go binding that lets two independent streams subscribe and receive events via a single exported Go callback, using a C shim to bridge into Go. Describe memory management and thread-safety; provide header, Go binding, and a small Go program demonstrating two streams; include build steps?","answer":"Use a single C callback bridged to Go via an exported function; maintain per-stream state in a mutex-protected map keyed by stream_id, storing a Go callback. Register a C shim that calls the Go bridge","explanation":"## Why This Is Asked\nExplores cross-language callbacks, CGO lifecycle, and thread-safety. The candidate must design a robust bridge rather than a naive callback.\n\n## Key Concepts\n- CGO cross-language callbacks\n- cgo.Handle for GC control\n- Thread-safety with mutex maps\n- Exported Go callbacks and C shims\n\n## Code Example\n```go\npackage main\n/*\n#include \"eventlib.h\"\n\n// Go callback exported\nextern void goEventBridge(int stream_id, const char* msg);\n\nstatic void shim_cb(int sid, const char* msg){\n    goEventBridge(sid, msg);\n}\n*/\nimport \"C\"\nimport (\n  \"runtime\"\n  \"sync\"\n)\n\ntype Callback func(int, string)\n\nvar (\n  mu sync.RWMutex\n  handlers = make(map[int]Callback)\n)\n\n// RegisterStream registers a Go callback for a stream\nfunc RegisterStream(id int, cb Callback) {\n  mu.Lock()\n  handlers[id] = cb\n  mu.Unlock()\n  C.register_event_source(C.int(id), C.shim_cb)\n  runtime.KeepAlive(cb)\n}\n\n//export goEventBridge\nfunc goEventBridge(s C.int, msg *C.char) {\n  mu.RLock()\n  cb := handlers[int(s)]\n  mu.RUnlock()\n  if cb != nil {\n    cb(int(s), C.GoString(msg))\n  }\n}\n```\n\n## Follow-up Questions\n- How would you stop a stream and clean up without races?\n- How would you propagate C-side errors back to Go?","diagram":"flowchart TD\n  A[Subscriber registers streams] --> B[Shim cb in EventLib]\n  B --> C[C thread emits event]\n  C --> D[goEventBridge is called]\n  D --> E[Go callback invoked]","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Twitter","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T04:56:17.642Z","createdAt":"2026-01-13T04:56:17.642Z"},{"id":"q-1235","question":"Implement a CGOA binding for an opaque C Counter handle. API: typedef struct Counter Counter; Counter* CounterNew(int); void CounterInc(Counter*, int); int CounterValue(Counter*); void CounterFree(Counter*); In Go wrap as type Counter with NewCounter, Inc, Value, Close. Show two goroutines each creating its own Counter, incrementing independently, and printing values to verify isolation and no data races. Include header, binding, and a minimal program with build steps?","answer":"Implement a CGOA binding for an opaque C Counter handle. API: typedef struct Counter Counter; Counter* CounterNew(int); void CounterInc(Counter*, int); int CounterValue(Counter*); void CounterFree(Cou","explanation":"## Why This Is Asked\n\nProbes CGO bindings to an opaque C type, per-instance memory management, and basic concurrency isolation.\n\n## Key Concepts\n\n- CGO binding for opaque C types\n- Manual memory management (CounterNew/CounterFree)\n- Concurrency: per-instance state and data-race awareness\n\n## Code Example\n\n```c\n// C header\ntypedef struct Counter Counter;\nCounter* CounterNew(int initial);\nvoid CounterInc(Counter*, int delta);\nint CounterValue(Counter*);\nvoid CounterFree(Counter*);\n```\n\n```go\n// Go binding snippet\n// #include \\\"counter.h\\\"\nimport \"C\"\n\ntype Counter struct{ c *C.Counter }\n\nfunc NewCounter(init int) *Counter {\n  c := C.CounterNew(C.int(init))\n  return &Counter{c: c}\n}\n\nfunc (ctr *Counter) Inc(delta int) {\n  C.CounterInc(ctr.c, C.int(delta))\n}\n\nfunc (ctr *Counter) Value() int {\n  return int(C.CounterValue(ctr.c))\n}\n\nfunc (ctr *Counter) Close() {\n  C.CounterFree(ctr.c)\n}\n```\n\n## Follow-up Questions\n\n- How would you ensure thread-safety when multiple goroutines manipulate distinct Counter instances?\n- What changes if Counter access becomes shared across goroutines?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Instacart","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T06:33:00.575Z","createdAt":"2026-01-13T06:33:00.575Z"},{"id":"q-1294","question":"Implement a CGOA bridge that lets C trigger a Go callback asynchronously when an external sensor fires events. Provide a C header and stub, a CGO binding in Go that registers a Go callback and routes events through an exported Go function, and a safe cleanup mechanism to release resources when producers stop?","answer":"Design approach: Go registers a callback, wraps it with runtime/cgo.NewHandle(cb) and passes the handle’s uintptr to C. An exported bridge function (//export goCallbackBridge) is invoked by C with the","explanation":"## Why This Is Asked\nCGOA bridges are common in practice when external C libraries need Go callbacks. This tests safe lifetimes, non-Go-pointer transfer, and cross-language threading.\n\n## Key Concepts\n- runtime/cgo.Handle\n- //exported Go functions\n- passing uintptr_t to C\n- proper cleanup and synchronization\n\n## Code Example\n```c\n/* header */\nvoid register_callback(void (*cb)(int, void*), void* ctx);\n```\n\n## Follow-up Questions\n- How to avoid deadlocks when callbacks re-enter?\n- How to handle panics in the Go callback across threads?","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Lyft","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T08:40:37.001Z","createdAt":"2026-01-13T08:40:37.001Z"},{"id":"q-1371","question":"Implement a CGO binding for a C function that computes sum and mean of an int array. Provide header and C source with int compute_stats(const int* values, size_t n, long long* sum, double* mean); 0 on success, -1 if n==0. In Go, implement ComputeStats(values []int) (int64, float64, error) calling the C function via CGO, converting types. Add a small main.go that runs two goroutines, each calling ComputeStats on its own slice. Include build steps?","answer":"Provide a header and C source implementing compute_stats, returning 0 on success and -1 on error (n==0). In Go, implement ComputeStats(values []int) (int64, float64, error) calling the C function via ","explanation":"## Why This Is Asked\nTests bridging Go and C boundaries, including memory handling, error propagation, and concurrency.\n\n## Key Concepts\n- CGO bindings and headers\n- Go to C array conversions\n- Translating C errors to Go errors\n- Concurrency across CGO calls\n- Build considerations (CGO enabled)\n\n## Code Example\n```c\n// stats.h\nint compute_stats(const int* values, size_t n, long long* sum, double* mean);\n```\n```c\n// stats.c\n#include \"stats.h\"\n#include <stddef.h>\nint compute_stats(const int* values, size_t n, long long* sum, double* mean) {\n    if (n == 0) return -1;\n    long long s = 0;\n    for (size_t i = 0; i < n; ++i) s += values[i];\n    *sum = s;\n    *mean = (double)s / (double)n;\n    return 0;\n}\n```\n```go\n// stats.go\npackage main\n/*\n#cgo CFLAGS: -O2\n#include \"stats.h\"\n*/\nimport \"C\"\nimport (\n  \"fmt\"\n)\n\nfunc ComputeStats(values []int) (int64, float64, error) {\n  if len(values) == 0 { return 0, 0, fmt.Errorf(\"empty input\") }\n  cvals := make([]C.int, len(values))\n  for i, v := range values { cvals[i] = C.int(v) }\n  var sum C.longlong\n  var mean C.double\n  if res := C.compute_stats((*C.int)(&cvals[0]), C.size_t(len(cvals)), &sum, &mean); res != 0 {\n    return 0, 0, fmt.Errorf(\"C error\")\n  }\n  return int64(sum), float64(mean), nil\n}\n```\n\n## Follow-up Questions\n- How would you handle larger inputs or streaming data?\n- How would you extend to support multiple concurrent calls safely?\n","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T14:35:20.730Z","createdAt":"2026-01-13T14:35:20.730Z"},{"id":"q-1396","question":"Implement a CGO bridge for a C event source that runs callbacks on its own threads and delivers events to Go via a callback of the form void cb(int code, const char* msg, void* ctx). Expose StartEventSource(cb, ctx) -> handle and StopEventSource(handle). Provide a C header, the Go binding using CGO (with a Go-exported callback and pointer-ownership strategy), and a small Go program that starts two sources and validates receipt of events through a single Go channel. Include build steps?","answer":"Design a CGO bridge where C emits events on its own threads and calls back into Go with a signature void cb(int code, const char* msg, void* ctx). Expose StartEventSource(cb, ctx) -> handle and StopEv","explanation":"## Why This Is Asked\nTests ability to model cross-language ownership, thread safety, and lifecycle across CGO.\n\n## Key Concepts\n- CGO callback exports and Go pointer lifetimes\n- cgo.Handle and runtime.KeepAlive\n- Cross-thread callback safety and event serialization\n- Lifecycle management of C resources across Go\n\n## Code Example\n\n```c\n// header: event_source.h\ntypedef void (*cb_t)(int code, const char* msg, void* ctx);\nint StartEventSource(cb_t cb, void* ctx);\nvoid StopEventSource(int handle);\n```\n\n```go\n// binding.go\npackage main\n// CGO binding sketch showing an exported callback and lifecycle wiring\n```\n\n## Follow-up Questions\n- How would you ensure ctx isn't garbage-collected while C holds it?\n- How would you handle errors from C that should propagate to Go?\n- How would you test for deadlocks or callback reentrancy across the boundary?\n","diagram":"flowchart TD\nA[Go Start] --> B[C: register callback]\nB --> C[Events on C threads]\nC --> D[Go: enqueue to channel]\nD --> E[Go consumer reads]","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","PayPal","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T15:37:15.257Z","createdAt":"2026-01-13T15:37:15.257Z"},{"id":"q-1548","question":"Implement a CGO wrapper for a C library that registers a Go callback and invokes it from a C event loop. Provide a C header and implementation for: - void register_callback(void (*cb)(int)); - void trigger(int value); Write Go bindings using CGO to pass a Go function as the callback, ensuring safe cross-language invocation, correct Go runtime considerations, and demonstrate with two goroutines each registering and triggering events. Include build steps?","answer":"A robust solution defines a C wrapper that stores a callback function pointer, a register_callback function to install it, and a trigger function that invokes it. In Go, export goCallback and pass it to C using CGO, ensuring proper cross-language invocation with runtime safety considerations.","explanation":"## Why This Is Asked\nThis question tests CGO cross-language callback design, memory management, and thread-safety in a beginner-friendly but realistic setup that mirrors real-world integration scenarios.\n\n## Key Concepts\n- CGO interoperability and function pointer management\n- Go exported callbacks with //export directive\n- Go runtime and thread-safety compliance\n- Lifetime management using KeepAlive and avoiding premature GC\n\n## Code Example\n```c\n// header\nvoid register_callback(void (*cb)(int));\nvoid trigger(int value);\n```\n\n```go\n//go:export goCallback\nfunc goCallback(v C.int) {\n  // handle","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Meta","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T06:30:39.820Z","createdAt":"2026-01-13T21:37:30.342Z"},{"id":"q-1659","question":"Design a CGOA wrapper to let a Go function be registered as a callback for a C API that emits events asynchronously on external threads. The C API exposes: typedef void (*cb_t)(int eventCode, void* context); void register_cb(cb_t cb, void* ctx); void emit_event(int code); Implement header, CGO binding, and a minimal program that registers a Go callback, triggers an event, and exits safely. Include build steps?","answer":"Use a trampoline with a CGO handle. Store the Go callback in a map, obtain a CGO handle, and pass the handle as ctx to register_cb. Export a Go function with //export that C calls; it looks up the han","explanation":"## Why This Is Asked\nTests ability to bridge Go and C with callbacks across threads, a common real-world CGO pitfall. It probes lifetime management, thread-safety, and CGO pointer rules.\n\n## Key Concepts\n- CGO callback lifetimes and //export limitations\n- cg oHandle usage to store Go values for C callbacks\n- Thread-safety: mutexes and safe dispatch of callbacks\n- Proper cleanup to avoid leaks when unregistering\n\n## Code Example\n```javascript\n// C header (capi.h)\ntypedef void (*cb_t)(int eventCode, void* context);\nvoid register_cb(cb_t cb, void* ctx);\nvoid emit_event(int code);\n```\n\n```javascript\n// Go binding (cgowa/cgo) - simplified\npackage main\n/*\n#include \"capi.h\"\n*/\nimport \"C\"\nimport (\n  \"sync\"\n  \"unsafe\"\n)\n\nvar (\n  mu       sync.Mutex\n  cbStore  = map[uintptr]func(int){}\n  nextKey  uintptr = 1\n)\n\n//export goCallback\nfunc goCallback(event C.int, ctx unsafe.Pointer) {\n  mu.Lock()\n  if f, ok := cbStore[uintptr(ctx)]; ok {\n    f(int(event))\n  }\n  mu.Unlock()\n}\n\nfunc registerCallback(f func(int)) unsafe.Pointer {\n  mu.Lock()\n  key := nextKey\n  nextKey++\n  cbStore[key] = f\n  mu.Unlock()\n  // pass key as ctx to C\n  return unsafe.Pointer(uintptr(key))\n}\n```\n\n```javascript\n// Minimal usage (main.go)\npackage main\nimport (\n  \"C\"\n  \"fmt\"\n)\nfunc main(){\n  cb := func(e int){ fmt.Println(\"event:\", e) }\n  ctx := registerCallback(cb)\n  C.emit_event(42) // would trigger goCallback with ctx\n  _ = ctx\n}\n```\n\n## Follow-up Questions\n- How would you extend this to support multiple concurrent Go callbacks safely?\n- How do you handle panics in Go callbacks so they don’t crash the C caller or CGO bridge?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Scale Ai","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T05:42:28.056Z","createdAt":"2026-01-14T05:42:28.056Z"},{"id":"q-1758","question":"You have a C library exposing void start_event_loop(void (*cb)(int event, void* ctx), void* ctx) and void stop_event_loop(). Implement a CGO bridge in Go that safely delivers events to per-stream Go handlers without passing Go pointers to C, supports multiple concurrent streams, and clean teardown. Provide C header, a thin C wrapper to register a per-stream callback, and a Go binding plus a small program that starts two streams and stops them?","answer":"Design a CGO bridge for a C event loop that calls a callback from a dedicated thread into Go. Do not pass Go pointers to C; implement a per-stream registry keyed by an opaque handle, use a thread-safe","explanation":"## Why This Is Asked\nTests deep CGO understanding: cross-language callbacks, Go pointer rules, and per-stream lifecycle.\n\n## Key Concepts\n- CGO pointer safety and Go memory management\n- Cross-thread callbacks and event dispatch\n- Per-stream registries and lifecycle management\n\n## Code Example\n```javascript\n// C header and Go binding would be provided here in a real task to illustrate wrappers and registration\n```\n\n## Follow-up Questions\n- How would you handle backpressure when the Go side lags behind C callbacks?\n- How would you extend to support cancellation contexts for individual streams?","diagram":"flowchart TD\n  A[Start] --> B[Bridge Created]\n  B --> C[Streams Registered]\n  C --> D[Events Enqueued]\n  D --> E[Go Handlers Dispatch]\n  E --> F[Teardown]\n  F --> G[Stop Loop]","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Netflix","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T09:45:25.745Z","createdAt":"2026-01-14T09:45:25.745Z"},{"id":"q-1815","question":"Design and implement a CGOA bridge for a C streaming library that emits integers via a callback. Expose a Go API StartStream() (<-chan int, func Stop()) using cgo.Handle to pass the Go-side context. Ensure thread-safe delivery of values to Go, proper cleanup with finalizers, and robust error reporting across the boundary. Provide C header, Go binding, and a minimal caller?","answer":"Propose a CGO wrapper that uses a C function to register a stream callback, with a Go channel wrapped by a cgo.Handle as the ctx. A single C callback pushes values into the Go channel via an exported ","explanation":"## Why This Is Asked\nTests ability to bridge Go and C safely in a streaming, callback-driven API, including memory ownership, callbacks from C into Go, and lifecycle handling.\n\n## Key Concepts\n- CGO and cgo.Handle usage\n- Cross-language callbacks and goroutine scheduling\n- Memory ownership and finalizers\n- Error handling across language boundaries\n\n## Code Example\n```c\ntypedef void (*cb_t)(int value, void* ctx);\nvoid register_stream(cb_t cb, void* ctx);\nvoid start_stream();\nvoid stop_stream();\n```\n```go\n// CGO binding sketch\npackage main\n/*\n#include <stdint.h>\n#include \"stream.h\"\nstatic void go_cb(int v, void* ctx);\n*/\nimport \"C\"\nimport (\n  \"runtime\"\n  \"runtime/cgo\"\n)\n\n//export go_cb\nfunc go_cb(v C.int, ctx unsafe.Pointer) {\n  // forward to Go channel via stored handle\n}\n\nfunc StartStream() (<-chan int, func()) {\n  // wrap ctx in a handle and start streaming; return stop function\n  ch := make(chan int)\n  h := cgo.NewHandle(ch)\n  // pass h.ptr to C as ctx; set up finalizer to ensure cleanup\n  runtime.SetFinalizer(&ch, func(*chan int) { /* cleanup */ })\n  // start_stream and callback wiring...\n  return ch, func() { /* stop and release handle */ }\n}\n```","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Google","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T11:49:06.568Z","createdAt":"2026-01-14T11:49:06.568Z"},{"id":"q-1845","question":"Implement a CGOA wrapper around a C function that returns a heap-allocated string: char* greet(const char* name). Provide a header with greet and void free_string(char*). Write a Go binding using CGO to call greet from multiple goroutines and free the result with free_string to avoid leaks. Include the header, a Go binding file, and a small Go program that calls greet(\"Alice\"), greet(\"Bob\"), greet(\"Carol\") concurrently and prints results. Include build steps?","answer":"Provide the C header greet.h with: char* greet(const char* name); void free_string(char* s); Then implement a C source that allocates via malloc and returns the string. In Go, use // #include \\\"greet.","explanation":"## Why This Is Asked\nTests memory ownership across Go and C, and CGO interaction with heap-allocated strings.\n\n## Key Concepts\n- CGO string handling and C memory management\n- Ownership transfer and explicit frees\n- Concurrency safety when crossing language boundaries\n\n## Code Example\n```c\n// greet.h\nchar* greet(const char* name);\nvoid free_string(char* s);\n```\n```c\n// greet.c\n#include <stdlib.h>\n#include <string.h>\n#include \"greet.h\"\nchar* greet(const char* name){ const char* prefix = \"Hello, \"; size_t len = strlen(prefix) + strlen(name) + 2; char* out = (char*)malloc(len); if(!out) return NULL; strcpy(out, prefix); strcat(out, name); return out; }\n```\n```go\n// greet.go\npackage main\nimport \"C\"\nimport (\n  \"fmt\" \n  \"unsafe\"\n)\nfunc greetGo(name string) string {\n  cstr := C.CString(name)\n  defer C.free(unsafe.Pointer(cstr))\n  r := C.greet(cstr)\n  s := C.GoString(r)\n  C.free_string(r)\n  return s\n}\nfunc main() {\n  // spawn 3 goroutines and print\n  // simplified in actual implementation\n  _ = greetGo\n  fmt.Println(greetGo(\"Alice\"))\n  fmt.Println(greetGo(\"Bob\"))\n  fmt.Println(greetGo(\"Carol\"))\n}\n```\n\n## Follow-up Questions\n- How would you extend to support batch processing with a single allocation?\n- How to verify no memory leaks with Go's tests?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","NVIDIA","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T13:29:41.015Z","createdAt":"2026-01-14T13:29:41.015Z"},{"id":"q-1910","question":"Design a CGOA exercise: Create a C header exposing void scale_and_offset(const float* input, int n, float* output, float scale, float offset); Implement a Go binding using CGO that wraps ScaleAndOffset and returns a slice of float results. Provide a minimal C implementation, a Go binding, and a short Go program that launches two goroutines, each feeding distinct input arrays to scale_and_offset concurrently? Include build steps?","answer":"Implementation approach: C header declares void scale_and_offset(const float* input, int n, float* output, float scale, float offset); Go binds via import \"C\" and a wrapper function ScaleAndOffset(in ","explanation":"## Why This Is Asked\nTests CGO memory handling, cross-language data transfer, and concurrency safety in a realistic wrapper.\n\n## Key Concepts\n- CGO data marshaling between Go and C\n- Avoiding Go pointers in C calls\n- Memory management with malloc/free across boundaries\n- Concurrency safety in native calls via goroutines\n\n## Code Example\n```javascript\n// Example glue code in Go to start CGO wrapper (conceptual)\n```\n\n## Follow-up Questions\n- How would you extend to error reporting from C to Go?\n- How to handle different numeric types and alignment across architectures?\n","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Instacart","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T16:54:29.264Z","createdAt":"2026-01-14T16:54:29.264Z"},{"id":"q-1993","question":"Design a CGO bridge for a C API that uses a progress callback and supports cancelable work. The C API exposes: typedef void (*progress_cb)(int percent, void* user); void register_progress(progress_cb cb, void* user); int do_work(int steps); The callback may be invoked on worker threads. Implement: (1) a C header that defines the callback type and registration; (2) a Go binding using CGO that exposes a Go channel-based Progress stream; (3) a small Go program that starts do_work in a goroutine and prints progress, with a context-based cancellation. Ensure memory and lifecycle safety across boundaries?","answer":"Bridge the C progress callback to Go with per-work handles and a Go channel; export a trampoline in C that forwards (percent, user) to a Go receiver using a stable Go-side map keyed by an opaque handl","explanation":"## Why This Is Asked\nTests cross-language callback lifecycles, CGO invocation rules, and cancellation semantics by streaming progress from C to Go with lifecycle management.\n\n## Key Concepts\n- CGO callback lifetimes and trampolines\n- Safe passing of user data without Go pointers into C\n- Per-work handles and cleanup\n- Streaming events via Go channels\n- Context-based cancellation and unregistering\n\n## Code Example\n```c\n// header: progress.h\ntypedef void (*progress_cb)(int percent, void* user);\nvoid register_progress(progress_cb cb, void* user);\nint do_work(int steps);\n```\n\n```go\n// binding.go\npackage progress\n/*\n#include \"progress.h\"\n*/\nimport \"C\"\n\n// Binding scaffolding to illustrate approach\n```\n\n```go\n// usage.go\npackage main\nimport (\n  \"context\"\n  \"fmt\"\n  \"time\"\n  p \"your/module/path/progress\"\n)\nfunc main() {\n  ctx, cancel := context.WithCancel(context.Background())\n  defer cancel()\n  ch := make(chan int)\n  // Bind a CGO callback to push progress into ch; ensure cleanup on cancel\n  go func(){ C.do_work(C.int(100)) }()\n  for {\n    select {\n    case v := <-ch:\n      fmt.Println(\"progress\", v)\n    case <-ctx.Done():\n      return\n    }\n  }\n}\n```\n\n## Follow-up Questions\n- How would you multiplex progress from multiple concurrent tasks?\n- How would you test cancellation and error propagation in this wrapper?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Google","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T19:49:17.801Z","createdAt":"2026-01-14T19:49:17.801Z"},{"id":"q-2011","question":"Implement a beginner CGO binding that exposes a C API void compute_stats(const double* data, size_t n, double* mean, double* stddev) to Go. Provide a C header, a Go binding using CGO, and a small Go program that launches 4 goroutines, each calling ComputeStats on its own data slice concurrently. Ensure memory safety, zero-copy access where possible, and that data races are avoided. Include explicit build steps?","answer":"Bind a C API void compute_stats(const double* data, size_t n, double* mean, double* stddev) to Go via CGO. Use a header and a Go wrapper ComputeStats(data []float64) (mean, stddev float64) that checks","explanation":"## Why This Is Asked\nTests ability to design safe CGO bindings that move data between Go and C, ensure memory safety, and reason about concurrency.\n\n## Key Concepts\n- CGO bindings and header inclusion\n- Memory ownership and avoiding copies\n- Passing slices to C safely with unsafe\n- Concurrency: goroutines calling C functions without races\n- Error handling for empty inputs and C errors\n\n## Code Example\n```c\n#ifndef STATS_H\n#define STATS_H\nvoid compute_stats(const double* data, size_t n, double* mean, double* stddev);\n#endif\n```\n\n```go\npackage cgobind\n\n/*\n#include \"stats.h\"\n*/\nimport \"C\"\nimport (\n  \"unsafe\"\n)\n\nfunc ComputeStats(data []float64) (mean, stddev float64) {\n  if len(data) == 0 {\n    return 0, 0\n  }\n  var cMean, cStddev C.double\n  ptr := (*C.double)(unsafe.Pointer(&data[0]))\n  C.compute_stats(ptr, C.size_t(len(data)), &cMean, &cStddev)\n  return float64(cMean), float64(cStddev)\n}\n```\n\n## Follow-up Questions\n- How would you adapt for non-contiguous data or different memory layouts?\n- What about error propagation if the C function encounters NaN values?","diagram":"flowchart TD\n  Go --> CGO_Wrapper\n  CGO_Wrapper --> C_Function\n  C_Function --> Go_Return\n  Go_Return --> Goroutines","difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Meta","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T20:49:43.279Z","createdAt":"2026-01-14T20:49:43.279Z"},{"id":"q-2036","question":"Your C library exposes a function int start_task(int task_id, void (*progress_cb)(int, const char*)); void stop_task(int task_id); The callback is invoked from worker threads and passes a progress value and a C string message. Design a CGO-based Go binding that allows registering a Go callback per task, safely translates C strings to Go strings, guarantees thread-safe delivery of progress events to Go, and supports cancellation via stop_task while ensuring resources are freed. Include a header, the Go binding, and a minimal Go program launching two concurrent tasks with per-task callbacks. Provide build steps?","answer":"Register per-task Go callbacks in a mutex-protected map[int]func(int,string). Create a Go–C bridge: assign a unique task handle, store the Go closure, pass the handle to C as an int with a static C progress callback. Export progress events through CGO using C.CString/C.GoString translation with thread-safe delivery via channels or sync primitives, ensuring proper cleanup of allocated C strings and removal of callbacks when tasks are cancelled or completed.","explanation":"Why This Is Asked\n- Tests CGO callback patterns, memory safety, and concurrency\n- Exercises safe crossing of Go/C without pointer sharing\n- Validates resource management and cancellation in real workloads\n\nKey Concepts\n- CGO callbacks across threads\n- Go closure lifetimes with C handles\n- Safe string conversion and memory management\n- Thread-safe event delivery and resource cleanup\n\nCode Example\n```c\n// C header\nint start_task(int task_id, void (*progress_cb)(int, const char*));\nvoid stop_task(int task_id);\n```\n\nFollow-up Questions\n- How would you handle panics in the Go callback across CGO?\n- What strategies would you use to prevent memory leaks in long-running tasks?\n- How would you implement timeout handling for stuck tasks?","diagram":"flowchart TD\nA(Task Start) --> B(Register Callback)\nB --> C(C Bridge Invokes Go Callback)\nC --> D(Go Handler Executes)\nD --> E(Stop Task)\n","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","NVIDIA","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T06:15:11.070Z","createdAt":"2026-01-14T21:41:08.651Z"},{"id":"q-2185","question":"Design a CGOA binding for a C library exposing a thread-safe ring buffer with multiple producers and a single consumer. Provide a C header with:\n- typedef struct ring_buffer ring_buffer;\n- ring_buffer* rb_new(size_t capacity);\n- void rb_free(ring_buffer*);\n- int rb_push(ring_buffer*, int value);\n- int rb_pop(ring_buffer*, int* value); // 0 on success, -1 if empty\nImplement a Go binding using CGO that wraps rb_push/rb_pop, exposing a Go type RingBuffer with New, Push, Pop. Include a small demo with 4 producers and 2 consumers and build steps?","answer":"An ideal answer shows: an opaque C ring_buffer with an internal mutex; rb_push/rb_pop lock, modify, unlock. Go wraps *ring_buffer via CGO, exposing New/Push/Pop with ownership via rb_new/rb_free. Demo","explanation":"## Why This Is Asked\nTests CGO boundary design, memory ownership, and real-world thread-safety across language fences.\n\n## Key Concepts\n- CGO calls and opaque pointers\n- Thread-safety via internal mutexes in C\n- Ownership lifecycle across Go/C\n- Avoiding data races when sharing data across CGO\n\n## Code Example\n```c\n// header-like sketch\ntypedef struct ring_buffer ring_buffer;\nring_buffer* rb_new(size_t capacity);\nvoid rb_free(ring_buffer* rb);\nint rb_push(ring_buffer* rb, int v);\nint rb_pop(ring_buffer* rb, int* v);\n```\n```\n\n## Follow-up Questions\n- How would you adapt to multiple consumers? How to handle blocking pops? \n- How would you test memory ownership and leak scenarios across CGO boundaries?","diagram":"flowchart TD\n  GoApp --> CGOWrapper\n  CGOWrapper --> CLayer\n  CLayer --> RingBufferState\n  RingBufferState --> GoApp","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Apple","Discord"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T06:51:54.148Z","createdAt":"2026-01-15T06:51:54.148Z"},{"id":"q-2263","question":"Design a CGOA binding for a C library function that registers a callback and a context pointer. Create a Go binding using CGO that lets Go pass a Go function as the callback, supports multiple concurrent subscriptions, and is memory-safe with proper cleanup. Provide the C API, the Go binding, and a short Go snippet showing two subscriptions and callbacks concurrently?","answer":"Use a trampoline approach: export a Go function goEventCb that the C code calls, and a per-subscription registry mapping a void* ctx to a Go func(int). On Subscribe, allocate a stable ctx handle for t","explanation":"## Why This Is Asked\nTests understanding of cross-language callbacks, memory management, and lifecycle handling in CGO bindings, including safety around Go pointers from C.\n\n## Key Concepts\n- CGO callback lifecycles and trampolines\n- Managing Go function pointers from C via a registry\n- Per-subscription context lifetimes and cleanup\n- Thread-safety and avoiding GC hazards during C callbacks\n\n## Code Example\n```javascript\n/* C Header (wrapper.h) */\ntypedef void (*cb_t)(int, void*);\ntypedef struct { cb_t cb; void* ctx; } reg_t;\nvoid subscribe(reg_t* r, void* ctx);\n\n/* Go Binding (wrapper.go) */\npackage main\n/*\n#include \"wrapper.h\"\n*/\nimport \"C\"\nimport (\n  \"runtime\"\n  \"sync\"\n  \"unsafe\"\n)\nvar reg sync.Map // ctx -> func(int)\n//export goEventCb\nfunc goEventCb(event C.int, ctx unsafe.Pointer) {\n  if v, ok := reg.Load(ctx); ok {\n    if f, ok := v.(func(int)); ok {\n      f(int(event))\n    }\n  }\n}\nfunc Subscribe(f func(int)) unsafe.Pointer {\n  ctx := C.malloc(C.size_t(8))\n  reg.Store(ctx, f)\n  C.subscribe((*C.reg_t)(unsafe.Pointer(&C.reg_t{cb: (*C.cb_t)(C.goEventCb), ctx: ctx})), ctx)\n  runtime.KeepAlive(f)\n  return ctx\n}\n```\n\n## Follow-up Questions\n- How would you handle panics in Go callbacks invoked from C?\n- How would you support cancellation and resource reuse for subscriptions?","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Lyft","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T09:47:27.284Z","createdAt":"2026-01-15T09:47:27.284Z"},{"id":"q-2305","question":"## Question\n\n**CGO Binding: In-Place String Reversal with Concurrency**\n\nYou have a C function:\n```c\nvoid reverse_inplace(char* s);\n```\nProvide:\n- A C header exposing the signature\n- A Go binding using CGO implementing ReverseGo(s string) string\n- A short Go program that launches two goroutines calling ReverseGo on different inputs\n- Build steps\n\nEnd with a question mark?","answer":"Use CGO to wrap reverse_inplace with a Go helper that copies s to a C buffer (C.CString), defers C.free, calls C.reverse_inplace, and returns C.GoString. In main, spawn two goroutines with distinct st","explanation":"## Why This Is Asked\n\nTests memory management and safe interop between Go and C via CGO, focusing on in-place mutation and per-call buffers to avoid data races.\n\n## Key Concepts\n\n- CGO memory management and C string interop\n- Converting between Go string and C string\n- Concurrency with goroutines and CGO\n\n## Code Example\n\n```c\n// reverse.h\nvoid reverse_inplace(char* s);\n```\n\n```go\n// binding.go\n// #cgo CFLAGS: -O2\n// #include \"reverse.h\"\nimport \"C\"\nimport \"unsafe\"\n\nfunc ReverseGo(s string) string {\n    c := C.CString(s)\n    defer C.free(unsafe.Pointer(c))\n    C.reverse_inplace(c)\n    return C.GoString(c)\n}\n```\n\n## Follow-up Questions\n\n- How would you handle errors if reverse_inplace had error codes?\n- How would you validate thread-safety across different CGO configurations?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Netflix","Snowflake","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T11:33:39.782Z","createdAt":"2026-01-15T11:33:39.782Z"},{"id":"q-2373","question":"Implement a CGO binding for a C API that processes an int array and reports results via a callback. The C API: typedef void (*cb_t)(int result, void* ctx); void sum_with_callback(const int* data, size_t n, cb_t cb, void* ctx); Provide a C header exposing the signature, a Go binding using CGO that offers func SumWithCallback(data []int, cb func(int)) error, and a short Go program that concurrently calls SumWithCallback from multiple goroutines. Include build steps and CGO thread-safety and memory-management considerations. End with a question mark?","answer":"Design a CGO wrapper for a C API that processes an array and reports the result via a callback. Expose the C types and function in a header, implement a Go binding using //export to expose a Go callba","explanation":"## Why This Is Asked\nTests CGO callback bridges, memory ownership, and thread-safety when Go calls into C and C calls back into Go.\n\n## Key Concepts\n- CGO callback export and cgo rules\n- Memory ownership and avoiding GC lifetimes crossing boundaries\n- Thread-safety with concurrent Go calls into C\n- Safe passing of Go pointers via context handles\n\n## Code Example\n```c\n// header\ntypedef void (*cb_t)(int result, void* ctx);\nvoid sum_with_callback(const int* data, size_t n, cb_t cb, void* ctx);\n```\n\n```go\n// binding sketch\n//export go_cb\nfunc go_cb(res C.int, ctx unsafe.Pointer) { /* translate to Go */ }\n```\n\n## Follow-up Questions\n- How would you handle panics in the Go callback?\n- How do you ensure callbacks are not invoked after the Go GC moves data?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Hugging Face","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T15:40:05.063Z","createdAt":"2026-01-15T15:40:05.063Z"},{"id":"q-2478","question":"Implement a CGOA binding for a C matrix-vector multiply. Provide matvec.h and a minimal matvec.c implementing void matvec(const double* A, const double* x, double* y, int rows, int cols) that computes y[i] = sum_j A[i*cols + j] * x[j]. Write a CGO Go binding exposing MatVec(A []float64, x []float64, rows, cols int) ([]float64, error). Include a small Go program that runs two goroutines, each calling MatVec with different inputs to prove concurrency safety, and build steps to compile and run?","answer":"Validate input dims, allocate an output slice, pass pointers to C.matvec via CGO, and convert results back to Go safely. The two goroutines should operate on distinct A/x inputs with a sync.WaitGroup ","explanation":"## Why This Is Asked\nTests CGO bindings, memory ownership across Go/C, and concurrency safety in a realistic, minimal setup.\n\n## Key Concepts\n- Go slices to C pointers, CGO bindings\n- Memory ownership across language boundaries\n- Row-major data layout and bounds checks\n- Safe concurrent calls without races\n\n## Code Example\n```c\n// matvec.h\n#ifndef MATVEC_H\n#define MATVEC_H\nvoid matvec(const double* A, const double* x, double* y, int rows, int cols);\n#endif\n```\n```c\n// matvec.c\n#include \"matvec.h\"\nvoid matvec(const double* A, const double* x, double* y, int rows, int cols) {\n  for (int i = 0; i < rows; ++i) {\n    double s = 0.0;\n    for (int j = 0; j < cols; ++j) s += A[i*cols + j] * x[j];\n    y[i] = s;\n  }\n}\n```\n```go\n// matvec.go\npackage matvec\n// CGO bindings to be implemented here\n```\n\n## Follow-up Questions\n- How would you handle C crashes and propagate errors to Go?\n- How would you extend to batched matvec for multiple rows efficiently?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","NVIDIA","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T19:40:23.509Z","createdAt":"2026-01-15T19:40:23.509Z"},{"id":"q-2757","question":"Design a CGOA wrapper for a C streaming function that reports encrypted chunks via a callback: void stream_xor(const uint8_t* input, size_t n, void (*chunk_cb)(const uint8_t* chunk, size_t len, void* user), void* user); Implement a Go binding (CGO) that exposes a function StreamXor(src []byte) (<-chan []byte, func()) which starts the stream in a goroutine, pipes chunks to a channel, and returns a cancel function to terminate and free resources. Provide a header, a minimal C implementation, the Go binding, and a small program that runs two streams concurrently?","answer":"To solve this, implement a CGOA bridge where Go passes a cgo.Handle to C as the user token, C calls the registered chunk_cb with chunks, and Go converts chunks to Go slices sent on a channel. Maintain","explanation":"## Why This Is Asked\nTests bridging asynchronous C callbacks with Go, memory lifetime, cancellation semantics, and safe channeling; validates CGO constraints (no Go pointers in C, use cgo.Handle).\n\n## Key Concepts\n- CGO callback bridging and cgo.Handle usage\n- Management of C resources from Go\n- Concurrency through channels and cancellation\n- Memory safety across language boundaries\n\n## Code Example\n```javascript\n// Implementation code would be provided in the task\n```\n\n## Follow-up Questions\n- How would you handle backpressure if Go consumes chunks slowly?\n- What are the edge cases for end-of-stream and errors?","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Hugging Face","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T10:44:35.031Z","createdAt":"2026-01-16T10:44:35.031Z"},{"id":"q-2830","question":"Design a CGOA wrapper around a C asynchronous task API: C header exposes Task* start_task(const uint8_t* input, size_t n, void (*cb)(const char* status, void* user), void* user); void cancel_task(Task*); void free_task(Task*); Implement a Go binding that exposes RunTask(input []byte) (<-chan string, func()) which starts the task, streams status updates to the channel, and returns a cancellation function that frees resources. Include header, minimal C impl, Go binding, and a small Go program that runs two tasks concurrently and prints progress. Include build steps?","answer":"To solve, define an opaque Task in C and provide start_task, cancel_task, and free_task. In Go, wrap start_task with a CGO binding that registers a Go callback, converts status to a string channel, an","explanation":"## Why This Is Asked\nTests expertise bridging C callbacks and Go channels, memory ownership, and cancellation semantics in CGO.\n\n## Key Concepts\n- CGO memory management and ownership\n- Bridging C callbacks to Go channels\n- Finalizers and resource cleanup\n- Concurrency: independent tasks and cancellation\n\n## Code Example\n```c\n// header\ntypedef struct Task Task;\nTask* start_task(const uint8_t* input, size_t n, void (*cb)(const char* status, void* user), void* user);\nvoid cancel_task(Task* t);\nvoid free_task(Task* t);\n```\n\n```go\n// binding sketches CGO wrapper around start_task and channel\n```\n\n## Follow-up Questions\n- How would you handle backpressure if status updates are too fast?\n- How would you propagate errors from C to Go?","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Netflix","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T14:04:17.852Z","createdAt":"2026-01-16T14:04:17.853Z"},{"id":"q-2839","question":"CGO callback bridging: Given a C library that invokes a callback of the form void (*event)(int id, const char* payload) from internal threads, design a CGO wrapper so Go can safely register a Go callback and receive events. Provide a C header exposing the registration, a Go binding using CGO that registers and forwards events to Go, and a minimal Go program that demonstrates two concurrent event streams. Include build steps?","answer":"Use a per-library context with a Go callback stored via a handle (cgo.Handle). Export a Go function for C to call, enqueue events on a Go channel, and dispatch in a dedicated worker to preserve Go run","explanation":"## Why This Is Asked\nTests ability to implement cross-language callbacks with CGO, manage Go runtime constraints, and ensure safe memory management across language boundaries.\n\n## Key Concepts\n- CGO callbacks and //export mechanics\n- Managing Go closures across C via cg o.Handle\n- Thread-safety when C invokes Go on non-Go threads\n- Memory ownership for payloads across boundaries\n- Event dispatch pattern using channels and a worker\n\n## Code Example\n```javascript\n// C header (example.h)\ntypedef void (*event_cb)(int id, const char* payload);\nvoid register_event_source(event_cb cb, void* ctx);\nvoid unregister_event_source(void* ctx);\n```\n```javascript\n// Go binding skeleton (binding.go)\npackage main\n/*\n#include \"example.h\"\n*/\nimport \"C\"\nimport (\n  \"runtime/cgo\"\n)\nvar _ = cgo.Register\n// ... store handlers with a map[handle] and export a Go callback\n```\n\n## Follow-up Questions\n- How do you ensure payload lifetime is safe if C reuses buffers?\n- How would you clean up handles when callbacks unregister?\n- How would you test callback delivery under heavy concurrency?","diagram":"flowchart TD\n  A[Go Program] --> B[CGO Bridge]\n  B --> C[C Library]\n  C --> D[Go Callback Invoked]\n  D --> E[Channel Processor]","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Netflix","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T14:34:16.110Z","createdAt":"2026-01-16T14:34:16.110Z"},{"id":"q-3000","question":"Implement a CGO wrapper for a C library function that performs a one-shot transform: void transform(const uint8_t* data, size_t n, uint8_t* out, size_t* out_n, int* err); The wrapper should expose a Go function Transform(src []byte) ([]byte, error). Provide a header, a minimal C implementation (e.g., XOR each byte with 0x5A, allocate out via malloc, fill out_n, set err), and a Go program that concurrently calls Transform from two goroutines and prints results. Ensure memory is freed?","answer":"Design and implement a CGO binding where Go passes a []byte to C; C allocates an output buffer with malloc, XORs every input byte with 0x5A, writes the length to out_n, and signals errors via err. The","explanation":"## Why This Is Asked\nTests memory ownership across CGO, error propagation, and concurrent usage of a C function defended by a Go wrapper.\n\n## Key Concepts\n- CGO memory management\n- C-to-Go data transfer\n- Error handling across language boundaries\n- Concurrency safety with shared C resources\n\n## Code Example\n```javascript\n// Implementation code here\n```\n\n## Follow-up Questions\n- How would you handle large outputs or streaming data?\n- What changes are needed to support non-blocking calls?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Square","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T20:40:22.698Z","createdAt":"2026-01-16T20:40:22.698Z"},{"id":"q-3046","question":"CGO Callback Bridge: Implement an async C API that schedules a job and reports results via a callback. Provide a C header and a Go binding using CGO so that Go passes a Go function as a callback by using an opaque handle and a C bridge wrapper; ensure thread-safety, lifecycle, and memory cleanup. How would you design and implement this?","answer":"Use a CGO bridge: assign a unique Go callback handle for each job; pass an opaque handle to C; export a Go function (//export) that C calls back with id, result, and the handle; a small C wrapper signature converts between C and Go calling conventions while maintaining thread-safety.","explanation":"## Why This Is Asked\n\nThis question probes how well a candidate bridges Go and C for asynchronous work, including memory management, lifecycle, and thread-safety.\n\n## Key Concepts\n\n- CGO cross-language callbacks and exported Go functions\n- Opaque handles and lifecycle management\n- Synchronized callback registry (maps, synchronization)\n- Avoiding Go pointer leaks to C and ensuring GC safety\n\n## Code Example\n\n```c\n// cgobridge.h\ntypedef void (*cb_t)(int id, const char* result, void* opaque);\nvoid schedule_job(int id, cb_t cb, void* opaque);\nvoid cancel_job(int id);\n```\n\n```c\n// cgobridge_wrapper.c\n#include \"cgobridge.h\"\n#include <stdlib.h>\n\n// Forward declaration of exported Go function\nextern void go_callback_bridge(int id, const char* result, void* opaque);\n\nvoid schedule_job(int id, cb_t cb, void* opaque) {\n    // C implementation that eventually calls back\n    // ...\n    cb(id, \"result\", opaque);\n}\n```\n\n```go\n// cgobridge.go\npackage main\n\n/*\n#include \"cgobridge.h\"\n*/\nimport \"C\"\nimport (\n    \"sync\"\n    \"unsafe\"\n)\n\ntype goCallback func(int, string)\n\nvar (\n    callbacks sync.Map\n    nextHandle uint64\n    handleMu   sync.Mutex\n)\n\n//export go_callback_bridge\nfunc go_callback_bridge(id C.int, result *C.char, opaque unsafe.Pointer) {\n    if handle, ok := callbacks.Load(opaque); ok {\n        cb := handle.(goCallback)\n        cb(int(id), C.GoString(result))\n    }\n}\n\nfunc ScheduleJob(id int, cb goCallback) {\n    handleMu.Lock()\n    nextHandle++\n    handle := unsafe.Pointer(uintptr(nextHandle))\n    handleMu.Unlock()\n    \n    callbacks.Store(handle, cb)\n    C.schedule_job(C.int(id), (*[0]byte)(C.go_callback_bridge), handle)\n}\n```\n\n## Design Considerations\n\n- **Handle Management**: Use atomic counters or sync.Map for thread-safe handle generation\n- **Memory Safety**: Store Go callbacks in a registry, never pass Go pointers directly to C\n- **Cleanup**: Remove handles from registry after callback or job cancellation\n- **Error Handling**: Convert C error codes to Go errors and handle edge cases","diagram":"flowchart TD\n  A[Go schedules job] --> B[C bridge wrapper calls C function]\n  B --> C[C invokes callback bridge]\n  C --> D[go_bridge called in Go]\n  D --> E[Go user callback executes]\n  E --> F[Cleanup/Finalize]","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Instacart","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T05:28:01.574Z","createdAt":"2026-01-16T22:40:38.261Z"},{"id":"q-3152","question":"CGO Callback Bridge: Given a C API that streams integers via a callback 'void cb(int value, void* user)' registered with 'void register_stream(cb_t cb, void* user);', implement a Go binding that lets Go supply a Go function to handle values. Provide a C header and a minimal C trampoline, and a Go API StartStream(process func(int)) (<-chan int). Show two goroutines consuming from distinct streams. How will you manage the Go callback lifetime and memory across CGO boundaries?","answer":"Use a trampoline and cgo.Handle. In C, typedef void (*cb_t)(int, void*); register_stream(cb_t, void*). In Go, wrap by converting the Go callback to a uintptr via cgo.Handle, pass the handle to C, expo","explanation":"## Why This Is Asked\nTests ability to bridge Go and C with callbacks, manage lifetimes, and avoid unsafe pointer passes.\n\n## Key Concepts\n- CGO callbacks and trampolines\n- cgo.Handle for Go values across C boundaries\n- Memory ownership and handle release\n- Thread-safety when called from C across Go threads\n\n## Code Example\n```javascript\n// sketch: header exposure and trampoline glue\n```\n\n## Follow-up Questions\n- How would you handle panics in the Go callback invoked from C?\n- What are performance implications of per-call handles vs static wrappers?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Databricks","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T04:48:22.369Z","createdAt":"2026-01-17T04:48:22.370Z"},{"id":"q-3244","question":"Design a CGOA wrapper for a C library that returns a heap-allocated greeting string: const char* greet(const char* name, int* err); The function allocates memory for the greeting and returns NULL on error; The Go binding should expose a function GetGreeting(name string) (string, error) which calls greet, converts the C string to Go, and frees the C buffer. Demonstrate concurrency by launching two goroutines requesting greetings concurrently. Include a C header, a minimal C implementation, the Go binding, and a small program that runs in parallel?","answer":"Proposed answer approach: implement greet in C to allocate with malloc, set err nonzero on failure, return NULL. In Go, call C.greet, check err, convert to Go string with C.GoString, free with C.free,","explanation":"## Why This Is Asked\nTests memory ownership, cgo boundaries, and concurrency safety by wrapping a C-allocated string.\n\n## Key Concepts\n- CGO memory management\n- C->Go string conversion\n- Error propagation across FFI\n- Concurrent Go calls without shared mutable state\n\n## Code Example\n```c\n/* header: cgoc_hello.h */\n#ifndef CGOA_HELLO_H\n#define CGOA_HELLO_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nunsigned char* greet(const char* name, int* err); // returns malloc'ed buffer or NULL\n#ifdef __cplusplus\n}\n#endif\n#endif\n```\n\n```c\n/* minimal implementation: cg_hello.c */\n#include <stdlib.h>\n#include <string.h>\n#include \"cgoc_hello.h\"\nunsigned char* greet(const char* name, int* err){\n  if(!name){ *err = 1; return NULL; }\n  const char* base = \"Hello, \";\n  size_t len = strlen(base) + strlen(name) + 2;\n  char* out = (char*)malloc(len);\n  if(!out){ *err = 2; return NULL; }\n  strcpy(out, base);\n  strcat(out, name);\n  *err = 0; return (unsigned char*)out;\n}\n```\n\n```go\n// go binding: cg_hello.go\npackage cgHello\n/*\n#include \"cgoc_hello.h\"\n#include <stdlib.h>\n*/\nimport \"C\"\nimport (\n  \"errors\"\n  \"unsafe\"\n)\n\nfunc GetGreeting(name string) (string, error) {\n  cname := C.CString(name)\n  defer C.free(unsafe.Pointer(cname))\n  var err C.int\n  buf := C.greet(cname, &err)\n  if buf == nil {\n    switch err {\n    default:\n      return \"\", errors.New(\"greet failed\")\n    }\n  }\n  defer C.free(unsafe.Pointer(buf))\n  goStr := C.GoString((*C.char)(unsafe.Pointer(buf)))\n  return goStr, nil\n}\n```\n\n```go\n// main.go\npackage main\nimport (\n  \"fmt\"\n  cg \"path/to/cgHello\"\n  \"sync\"\n)\nfunc main(){\n  var wg sync.WaitGroup\n  names := []string{\"Alice\",\"Bob\"}\n  for _, n := range names {\n    wg.Add(1)\n    go func(name string){\n      defer wg.Done()\n      s, err := cg.GetGreeting(name)\n      if err != nil { fmt.Println(\"err\", err); return }\n      fmt.Println(s)\n    }(n)\n  }\n  wg.Wait()\n}\n```\n\n## Follow-up Questions\n- How would you adapt this to a streaming callback (callback into Go) safely?\n- How would you handle error codes with richer semantics and avoid leaking memory if multiple errors occur?","diagram":"flowchart TD\n  A[Go calls C greet] --> B[Receive C pointer or NULL]\n  B --> C{Is NULL?}\n  C -- Yes --> D[Return error to Go]\n  C -- No --> E[Convert to Go string]\n  E --> F[Free C buffer]\n  F --> G[Return string to Go]\n  G --> H[Return to caller]","difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","NVIDIA","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T08:41:04.171Z","createdAt":"2026-01-17T08:41:04.172Z"},{"id":"q-3266","question":"Design a CGOA wrapper for a C library function that formats a message into a pre-allocated buffer: int format_message(const char* name, char* out, size_t out_size); It should return the number of bytes written or -1 on error with errno set to ERANGE when the buffer is too small. Expose a Go binding: func FormatMessage(name string) (string, error) that starts with 128 bytes and auto-resizes to 256, 512, then 1024 on ERANGE. Ensure concurrent calls are safe. Include header, C impl, Go binding, and a small multi-goroutine test?","answer":"Implement FormatMessage using a resize loop. For size in [128,256,512,1024]: allocate buf, cname := C.CString(name); defer C.free(unsafe.Pointer(cname)); n := C.format_message(cname, (*C.char)(unsafe.","explanation":"## Why This Is Asked\nTests safe CGO buffer management, error propagation via errno, and concurrent invocation patterns.\n\n## Key Concepts\n- CGO memory lifetimes across Go/C boundaries\n- Preallocated buffers and safe Go->C data transfer\n- Handling errno and ERANGE for dynamic resizing\n- Concurrency safety with per-call allocations\n\n## Code Example\n```javascript\n// C header\nint format_message(const char* name, char* out, size_t out_size);\n\n// Minimal C impl (header + body)\n#include <string.h>\n#include <errno.h>\nint format_message(const char* name, char* out, size_t out_size){\n  const char* greet = \"Hello, \";\n  size_t needed = strlen(greet) + strlen(name) + 2; // including '!'\n  if (out_size <= needed) { errno = ERANGE; return -1; }\n  strcpy(out, greet);\n  strcat(out, name);\n  strcat(out, \"!\");\n  return (int)strlen(out);\n}\n```\n\n```javascript\n// Go binding sketch (conceptual)\npackage main\n/*\n#include <stdlib.h>\n#include \"format.h\"\n*/\nimport \"C\"\nimport (\n  \"errors\"\n  \"unsafe\"\n)\n\nfunc FormatMessage(name string) (string, error) {\n  sizes := []int{128, 256, 512, 1024}\n  for _, s := range sizes {\n    buf := make([]byte, s)\n    cname := C.CString(name)\n    defer C.free(unsafe.Pointer(cname))\n    n := C.format_message(cname, (*C.char)(unsafe.Pointer(&buf[0])), C.size_t(s))\n    if n >= 0 {\n      return string(buf[:n]), nil\n    }\n    if C.errno != C.ERANGE {\n      return \"\", errors.New(\"format failed\")\n    }\n  }\n  return \"\", errors.New(\"buffer too small\")\n}\n```\n\n## Follow-up Questions\n- How would you handle C errors without errno propagation?  \n- How would you test cancellation and timeouts for concurrent calls?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Lyft","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T09:31:47.249Z","createdAt":"2026-01-17T09:31:47.249Z"},{"id":"q-3347","question":"Interfacing asynchronous C callbacks with Go via CGOA. Given a C API:\n\ntypedef void (*ev_cb)(const char* event, void* user);\nvoid register_evt_source(ev_cb cb, void* user);\nvoid stop_evt_source(void);\n\nDesign a CGOA wrapper that exposes in Go:\n\nfunc RegisterEvents(h EventHandler) error\n\n- Header and minimal C that starts a thread emitting events every 100ms and stops on stop_evt_source.\n- Safe callback from C to Go (exported function), with string lifetime and memory cleanup.\n- Demonstrate two independent handlers concurrently and discuss CGO threading rules?","answer":"Maintain a map[uintptr]EventHandler with a mutex; generate a unique handle per RegisterEvents call and pass it as 'user' to C. Export a Go callback (//export) that converts the C string via C.GoString","explanation":"## Why This Is Asked\nTests ability to bridge async C callbacks into Go safely, including lifetime management and cross-thread CGO rules.\n\n## Key Concepts\n- CGO callback export and thread-safety\n- Go memory management across C boundaries\n- Runtime.KeepAlive and preventing GC of callbacks\n- Handling multiple independent callbacks concurrently\n\n## Code Example\n```c\n// header and minimal C impl\n```\n\n## Follow-up Questions\n- How would you handle backpressure if events overwhelm Go?\n- How would you extend to support per-event metadata and cancellation?\n","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Oracle","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T13:04:15.703Z","createdAt":"2026-01-17T13:04:15.703Z"},{"id":"q-3378","question":"Implement a CGOA wrapper for a C thread-safe queue API. The C API (queue.h) exposes: queue_t* queue_create(); void queue_destroy(queue_t*); int queue_push(queue_t* q, item* it); int queue_pop(queue_t* q, item** out, int timeout_ms); void queue_free_item(item*); typedef struct item { int id; const char* data; } item; Design a Go binding that provides:\n- type Item struct { ID int; Data string }\n- type Queue struct { p *C.queue_t }\n- func NewQueue() *Queue\n- func (q *Queue) Push(it Item) error\n- func (q *Queue) Pop(timeout time.Duration) (Item, error)\n\nRequirements: convert Go string to C string for pushes; allocate item for C, copy data, free data after push; on Pop, convert C item to Go Item and call queue_free_item. Ensure thread-safety across goroutines, zero memory leaks, and proper error semantics. Include a minimal C glue (wrapper header and c go glue), a Go binding file, and a small Go program that runs 4 producers and 2 consumers for 2 seconds?","answer":"Implement a CGOA wrapper around a C thread-safe queue. Expose Go API NewQueue() *Queue, (q *Queue) Push(it Item) error, (q *Queue) Pop(timeout time.Duration) (Item, error). Use queue.h with queue_crea","explanation":"## Why This Is Asked\nTests practical CGO ownership, memory management, and cross-language error handling with real concurrency. It reveals ability to design safe resource lifetimes and translation between Go and C types.\n\n## Key Concepts\n- CGO memory management and ownership transfer\n- Converting strings between Go and C safely\n- Managing C-allocated items from Go with precise frees\n- Concurrency safety across goroutines and correct error mapping\n\n## Code Example\n```javascript\n// queue.h (C header) and simple glue would be provided\n```\n\n```javascript\n// go_binding.go: minimal bindings showing NewQueue, Push, and Pop wrappers\n```\n\n## Follow-up Questions\n- How would you detect and prevent use-after-free or double-free scenarios in this wrapper?\n- How would you adapt the wrapper for multiple independent queues across modules with per-queue lifetime management?","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Google","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T13:52:02.120Z","createdAt":"2026-01-17T13:52:02.120Z"},{"id":"q-3494","question":"Design a CGOA wrapper for a C library that streams partial results via a callback: a process_start function takes data and a callback with signature chunk_cb(chunk, len, user, is_final), and is_final signals completion. The Go binding should expose: func ProcessData(input []byte) ([]byte, error) that aggregates all chunks into a single result. Provide a C header, a minimal C implementation, the Go binding, and a small Go program that calls ProcessData on two inputs concurrently to prove thread-safety and correct aggregation?","answer":"Implement a CGOA wrapper for a C streaming API that calls back with chunks and an is_final flag. The Go binding should collect chunks into a per-call buffer and return the combined result in ProcessDa","explanation":"## Why This Is Asked\nTests CGO callback bridging, memory ownership, and concurrent safety when wrapping streaming C APIs.\n\n## Key Concepts\n- CGO callback translation\n- Per-call ownership and cleanup\n- Safe concurrent CGO usage with isolated handles\n- Memory management across CGo boundaries\n\n## Code Example\n```go\n// binding usage example (pseudo)\nfunc ProcessData(input []byte) ([]byte, error) { /* ... */ }\n```\n\n## Follow-up Questions\n- How would you extend to multi-stream aggregation? \n- How would you enforce timeouts or backpressure between C and Go?\n","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Scale Ai","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T18:50:37.066Z","createdAt":"2026-01-17T18:50:37.066Z"},{"id":"q-3514","question":"Design a CGOA binding for a C API that creates and frees a Book object and returns its title. Given C:\\ntypedef struct Book Book;\\nBook* create_book(const char* title);\\nconst char* book_title(Book*);\\nvoid free_book(Book*);\\nImplement a CGO Go wrapper exposing:\\n\\n type BookHandle struct { ptr *C.Book }\\n\\nfunc NewBook(title string) (*BookHandle, error)\\nfunc (b *BookHandle) Title() (string, error)\\nfunc (b *BookHandle) Close() error\\n\\nEnsure ownership is explicit (Close frees) or a finalizer, no leaks, and demonstrate two concurrent book creations and title fetches?","answer":"Create a Go type that holds the C pointer, call create_book, convert the C string with C.GoString, and free via free_book in Close or a runtime.SetFinalizer. Title uses book_title. Demonstrate two gor","explanation":"## Why This Is Asked\nTests memory ownership across CGO, error handling, and lifecycle management.\n\n## Key Concepts\n- CGO memory ownership and finalizers\n- Go-C string conversion and error propagation\n- Concurrency safety and resource cleanup\n\n## Code Example\n```c\n// header\ntypedef struct Book Book;\nBook* create_book(const char* title);\nconst char* book_title(Book*);\nvoid free_book(Book*);\n```\n```go\n// binding sketch\ntype BookHandle struct { p *C.Book }\nfunc NewBook(title string) (*BookHandle, error) { ... }\nfunc (b *BookHandle) Title() (string, error) { ... }\nfunc (b *BookHandle) Close() error { ... }\n```\n\n## Follow-up Questions\n- How would you handle errors from book_title?  \n- How would you adapt if C returns NULL and sets errno?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T19:30:13.387Z","createdAt":"2026-01-17T19:30:13.387Z"},{"id":"q-3544","question":"Design a CGOA wrapper for a C API that streams a file's bytes via a callback: void stream_file(const char* path, void (*chunk_cb)(const uint8_t*, size_t, void*), void* user). The C function streams 4KB chunks and signals completion with a zero-length chunk. Expose in Go: func ReadFileStream(path string) (<-chan []byte, func()) that streams in a goroutine and returns a cancel function. Provide a header, a minimal C impl, the Go binding, and a small program that runs two streams concurrently?","answer":"Safely bridge C and Go by copying each chunk, exporting a C callback (//export) and running the stream on its own thread; use a Go channel per stream and a cancel function to signal termination. Manag","explanation":"## Why This Is Asked\nTests understanding of CGO callbacks, memory ownership, and concurrency when streaming data from C into Go. It also evaluates how to design a clean Go API around a C streaming pattern and cancellation.\n\n## Key Concepts\n- CGO callbacks and //export\n- Memory ownership across C↔Go boundaries\n- Per-stream isolation and cancellation\n- Lifecycle management of buffers and channels\n\n## Code Example\n```c\n// header.h\n#include <stdint.h>\nvoid stream_file(const char* path, void (*chunk_cb)(const uint8_t*, size_t, void*), void* user);\n```\n```c\n// impl.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"header.h\"\n\nvoid stream_file(const char* path, void (*chunk_cb)(const uint8_t*, size_t, void*), void* user){\n  FILE* f = fopen(path, \"rb\");\n  if (!f) { chunk_cb(NULL, 0, user); return; }\n  uint8_t buf[4096];\n  size_t n;\n  while ((n = fread(buf, 1, sizeof(buf), f)) > 0){\n    chunk_cb(buf, n, user);\n  }\n  fclose(f);\n  // end signal\n  chunk_cb(NULL, 0, user);\n}\n```\n```go\n// bindings.go\npackage main\n// #cinclude \"header.h\"\nimport \"C\"\nimport (\n  \"unsafe\"\n)\n\n//export goChunk\nfunc goChunk(cbuf *C.uint8_t, len C.size_t, user unsafe.Pointer) {\n  // implement copy and send on channel in Go side\n}\n\nfunc ReadFileStream(path string) (<-chan []byte, func()) {\n  ch := make(chan []byte)\n  // produce stream in a goroutine and return cancel func\n  // (Implementation details omitted for brevity in this example)\n  cancel := func() { close(ch) }\n  return ch, cancel\n}\n```\n```go\n// main.go\npackage main\nimport (\n  \"fmt\"\n)\nfunc main(){\n  ch1, cancel1 := ReadFileStream(\"a.dat\")\n  ch2, cancel2 := ReadFileStream(\"b.dat\")\n  go func(){ for b := range ch1 { fmt.Printf(\"a: %d bytes\\n\", len(b)) } }()\n  go func(){ for b := range ch2 { fmt.Printf(\"b: %d bytes\\n\", len(b)) } }()\n  // run briefly, then cancel\n  // ...\n  cancel1(); cancel2()\n}\n```\n","diagram":"flowchart TD\n  A[C: stream_file] --> B[CGO binding ReadFileStream]\n  B --> C[Go channel per stream]\n  A --> D[chunk_cb]\n  D --> E[Go side handler/receiver]\n  E --> F[application consumes data]\n","difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Meta","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T20:42:30.558Z","createdAt":"2026-01-17T20:42:30.559Z"},{"id":"q-3666","question":"Design a CGOA wrapper for a C library exposing a multi-threaded async job API: typedef void (*job_cb)(int job_id, const unsigned char* result, size_t len, void* user); void submit_job(int job_id, const unsigned char* payload, size_t len, job_cb cb, void* user); void shutdown_jobs(void); Expose in Go a function: func SubmitJob(payload []byte) (<-chan []byte, func()) - Each call assigns a unique job_id internally; the C side calls back with the result asynchronously. The Go binding should convert the C callback into Go via a //export wrapper, dispatch into a channel, and provide a cancel function that shuts down all pending jobs safely. Ensure there are no Go pointers passed through CGO into C, handle lifetimes, and explain how to avoid data races across goroutines. Provide a minimal header and C implementation, Go binding, and a test program that submits 2-3 jobs concurrently and reads results from the channel. Include build steps?","answer":"Map each C job_id to a Go channel using a thread-safe registry (atomic ID, sync.Map). Provide a //export callback that copies the C result into a Go byte slice, sends it on the channel, and frees C me","explanation":"## Why This Is Asked\n\nTests design of a robust CGO bridge for asynchronous C APIs, memory management, and cancellation handling.\n\n## Key Concepts\n\n- CGO callback bridging\n- Avoid passing Go pointers to C\n- Async job lifecycle and cancellation\n- Memory management across languages (alloc/free)\n- Concurrency safety: per-job channels, atomic IDs, sync.Map\n\n## Code Example\n\n```c\n// header\ntypedef void (*job_cb)(int job_id, const unsigned char* result, size_t len, void* user);\nvoid submit_job(int job_id, const unsigned char* payload, size_t len, job_cb cb, void* user);\nvoid shutdown_jobs(void);\n```\n\n```go\n// binding skeleton\npackage binding\n\n//export goCallback\nfunc goCallback(C.int, *C.uchar, C.size_t, unsafe.Pointer) {\n    // map to Go channel\n}\n```\n\n## Follow-up Questions\n\n- How would you add per-job timeouts and backpressure?\n- How would you test cross-language memory safety and leak detection?","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T04:18:31.266Z","createdAt":"2026-01-18T04:18:31.267Z"},{"id":"q-3751","question":"CGOA Binding: Safe Go callback bridge for a C API with user context?\n\nDesign a CGOA binding for a C API that registers a callback and emits events from multiple threads. Provide a C header and minimal C implementation, plus a Go binding using CGO that exposes BindEventHandler(handler EventHandler) (unbind func(), error). The wrapper must deliver events to Go safely (via a channel), support multiple concurrent handlers, and clean up on unbind. Include a small Go program that registers two handlers and triggers events concurrently. End with a question mark?","answer":"Use a single C callback, export a Go function, map opaque handles to channels, and deliver events via channel to the correct handler. Manage lifecycle with unbind, ensure thread-safety with locks, and","explanation":"## Why This Is Asked\n\nTests practical CGOA callback patterns, cross-thread safety, and resource lifecycles in a realistic binding.\n\n## Key Concepts\n\n- CGO callbacks and //export semantics\n- Cross-language context/pointer safety\n- Synchronization between C threads and Go schedulers\n- Lifecycle: registration, unbinding, and resource cleanup\n\n## Code Example\n\n```c\n// header: cgobind.h\ntypedef void (*event_cb)(int event, void* ctx);\nvoid register_event_source(event_cb cb, void* ctx);\nvoid emit_event(int event);\n```\n\n```c\n// minimal cgobind.c\n#include \"cgobind.h\"\nstatic event_cb g_cb = NULL;\nstatic void* g_ctx = NULL;\n\nvoid register_event_source(event_cb cb, void* ctx) {\n  g_cb = cb;\n  g_ctx = ctx;\n}\n\nvoid emit_event(int event) {\n  if (g_cb) g_cb(event, g_ctx);\n}\n```\n\n```go\n// binding.go (sketch)\npackage cgobind\n\n// #cgo CFLAGS: -I.\n// #include \"cgobind.h\"\nimport \"C\"\nimport (\n  \"sync\"\n  \"unsafe\"\n)\n\ntype EventHandler func(int)\n\nvar (\n  mu       sync.Mutex\n  handles  = make(map[uintptr]EventHandler)\n  nextID   uintptr = 1\n)\n\n//export goEventCallback\nfunc goEventCallback(ctx unsafe.Pointer, event C.int) {\n  id := uintptr(uintptr(ctx))\n  mu.Lock()\n  h, ok := handles[id]\n  mu.Unlock()\n  if ok {\n    h(int(event))\n  }\n}\n\nfunc BindEventHandler(handler EventHandler) (func(), error) {\n  mu.Lock()\n  id := nextID\n  nextID++\n  handles[id] = handler\n  mu.Unlock()\n\n  // register C callback with context as id\n  C.register_event_source((C.event_cb)(C.goEventCallback), unsafe.Pointer(uintptr(id)))\n\n  unbind := func() {\n    mu.Lock()\n    delete(handles, id)\n    mu.Unlock()\n  }\n  return unbind, nil\n}\n```\n\n```go\n// main.go\npackage main\n\nimport (\n  \"fmt\"\n  cgobind \"path/to/cgobind\"\n)\n\nfunc main() {\n  h1 := func(e int) { fmt.Println(\"handler1 got\", e) }\n  h2 := func(e int) { fmt.Println(\"handler2 got\", e) }\n  if unbind1, _ := cgobind.BindEventHandler(h1); unbind1 != nil {\n    // simulate\n  }\n  if unbind2, _ := cgobind.BindEventHandler(h2); unbind2 != nil {\n    // simulate\n  }\n  // trigger events from C side through emit_event\n}\n```\n\n## Follow-up Questions\n\n- How would you safely shut down all callbacks and avoid goroutine leaks when the Go program exits?\n- How would you handle backpressure if events arrive faster than Go can process them?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","DoorDash"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T08:36:40.561Z","createdAt":"2026-01-18T08:36:40.561Z"},{"id":"q-4013","question":"CGOA Binding: Implement a Go binding for a C streaming transform API that reports progress via a callback. C API: typedef void (*progress_cb)(int percent, void* user); int stream_transform(const uint8_t* in, size_t in_n, uint8_t** out, size_t* out_n, progress_cb cb, void* user); Expose StreamTransform(src []byte) ([]byte, error) and stream progress to a Go channel via a callback, using a stable handle to pass Go data to C. Provide header, minimal C impl (reverse bytes, call cb 0..100, malloc), the Go binding, and a short program spawning two concurrent transforms. Build steps?","answer":"Use a cgo.Handle to store Go channels and export a C callback that routes progress updates back to Go. Pass the handle as user to stream_transform; in C call cb(percent, user) as progress. Allocate ou","explanation":"## Why This Is Asked\n\nTests ability to bridge CGO with callbacks, memory ownership, and concurrency; addresses streaming transforms, progress reporting, and safe cross language callbacks.\n\n## Key Concepts\n\n- CGO callbacks and Go pointers handling\n- cgo.Handle use for passing Go values to C\n- Memory management across CGo boundaries\n- Concurrency safety\n\n## Code Example\n\n```c\ntypedef void (*progress_cb)(int percent, void* user);\nint stream_transform(const uint8_t* in, size_t in_n, uint8_t** out, size_t* out_n, progress_cb cb, void* user);\n```\n\n```c\n// minimal impl: reverse input, report progress linearly, allocate with malloc\n```\n\n```go\n// binding skeleton showing StreamTransform signature\npackage cgobinding\n```\n\n## Follow-up Questions\n- How would you handle errors in the C callback vs Go error values?\n- How does this pattern scale with multiple concurrent streams?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Bloomberg","Cloudflare"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T19:32:22.158Z","createdAt":"2026-01-18T19:32:22.158Z"},{"id":"q-4067","question":"Design a CGOA wrapper for a stateful C library exposing ip_init, ip_process, ip_destroy. Build Go bindings providing NewImageProcessor(config string) (*ImageProcessor, error), (p *ImageProcessor) Process(data []byte) ([]byte, error), and (p *ImageProcessor) Close(). Demonstrate two instances in parallel with different inputs to prove per-instance isolation. Include header and minimal C, Go binding, and a small program that runs two goroutines in parallel; how would you implement and verify this binding?","answer":"Create a Go struct ImageProcessor that stores a C pointer. NewImageProcessor calls ip_init and stores the handle; Process calls ip_process, copies the C output into a Go slice, then frees the C buffer","explanation":"## Why This Is Asked\nTests memory ownership across language boundaries and per-instance isolation when CGO is used with stateful C libraries. It also checks basic error mapping and concurrent usage.\n\n## Key Concepts\n- CGO memory management between C and Go\n- Opaque per-instance handles\n- Error translation from C to Go\n- Safe concurrent usage of CGO-bound objects\n\n## Code Example\n```c\n// header\ntypedef struct ImageProcessor ImageProcessor;\nImageProcessor* ip_init(const char* config, int* err);\nint ip_process(ImageProcessor* ip, const uint8_t* src, size_t len, uint8_t** out, size_t* out_len);\nvoid ip_destroy(ImageProcessor* ip);\n```\n```go\n// binding sketch (Go)\n// type ImageProcessor struct{ p *C.ImageProcessor }\n// func NewImageProcessor(config string) (*ImageProcessor, error) { ... }\n// func (ip *ImageProcessor) Process(data []byte) ([]byte, error) { ... }\n// func (ip *ImageProcessor) Close() { ... }\n```\n\n## Follow-up Questions\n- How would you add timeout handling for Process calls?\n- How would you prevent leaks if ip_process frequently fails mid-copy?\n","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Apple","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T22:34:48.062Z","createdAt":"2026-01-18T22:34:48.062Z"},{"id":"q-4149","question":"CGO Callback Bridge: Implement a C library that exposes subscribe(void (*cb)(int event, const char* payload, void* user), void* user) and emit events asynchronously. Build a Go binding that lets Go register a Go callback via //export and exposes StartStream() (<-chan Event) that yields parsed events. Show header, minimal C wrapper, and a Go program with two goroutines consuming events concurrently. End with a question mark?","answer":"Use runtime/cgo.Handle to store Go callbacks for each subscription, pass the handle to C, export a Go callback that retrieves the handle, converts payload to Go string, and sends it to a channel. Ensu","explanation":"## Why This Is Asked\nTests bridging C callbacks into Go, memory ownership, and concurrency under CGO constraints. It reveals how a candidate handles lifetime management, thread-safety, and safe Go→C↔C→Go transitions.\n\n## Key Concepts\n- CGO callback patterns with exported Go functions\n- Runtime/cgo.Handle for passing Go values across boundaries\n- Memory ownership: C allocations vs Go frees\n- Thread-safety: callback delivery and OS thread considerations\n\n## Code Example\n```c\n// header: cgoback.h\n#ifndef CGOBACK_H\n#define CGOBACK_H\n\ntypedef void (*cb_t)(int event, const char* payload, void* user);\n\nvoid subscribe(cb_t cb, void* user);\nvoid unsubscribe(cb_t cb, void* user);\n\n#endif\n```\n\n```c\n// implementation: cgoback.c (minimal, illustrative)\n#include <stdlib.h>\n#include <string.h>\n#include \"cgoback.h\"\n\nstatic cb_t global_cb = NULL;\nstatic void* global_user = NULL;\n\nvoid emit(int event, const char* payload){\n  if(global_cb) global_cb(event, payload, global_user);\n}\n\nvoid subscribe(cb_t cb, void* user){\n  global_cb = cb; global_user = user;\n  // simulate events\n  for(int i=0;i<3;i++){\n    char buf[16]; snprintf(buf, sizeof(buf), \"payload-%d\", i);\n    emit(i, buf);\n  }\n}\n\nvoid unsubscribe(cb_t cb, void* user){ global_cb = NULL; global_user = NULL; }\n```\n\n```go\n// binding: cgoback.go (illustrative, not full production code)\npackage main\n\n/*\n#include \"cgoback.h\"\n*/\nimport \"C\"\nimport (\n  \"runtime/cgo\"\n)\n\ntype Event struct { Code int; Data string }\n\n//export goCallback\nfunc goCallback(event C.int, payload *C.char, user unsafe.Pointer) {\n  // retrieve and dispatch to channel associated with 'user'\n}\n\nfunc StartStream() <-chan Event {\n  ch := make(chan Event)\n  // register callback with C, pass a handle to Go side\n  // C.subscribe(C.cb, nil)\n  return ch\n}\n\nfunc main() { /* start stream and print events */ }\n```\n\n```bash\n# build steps (illustrative)\n# 1) compile C library\n# 2) run `go build` with CGO_ENABLED=1\n```\n\n## Follow-up Questions\n- How to support multiple independent subscriptions efficiently?\n- How would you cleanly cancel a stream and free resources across CGO boundaries?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T05:40:02.411Z","createdAt":"2026-01-19T05:40:02.411Z"},{"id":"q-4262","question":"Design a CGOA wrapper for a C event system that streams events on a background thread: \n\nC API:\ntypedef void (*event_cb)(int id, const char* payload, void* user);\nvoid start_events(void);\nvoid stop_events(void);\nvoid register_event_cb(event_cb cb, void* user);\n\nRequirements:\n- In Go, expose func RegisterHandlers(hs []Handler) (cleanup func(), err error) where Handler has id int and Callback func(string)\n- Use cgo.Handle to pass Go callbacks to C safely; ensure callbacks from C invoke the correct Go handler and do not poison GC\n- Support registering multiple independent handlers concurrently; events must route to the right callback; stop_events cleans resources and prevents further callbacks\n- Provide a minimal header and a C implementation that emits events every 50ms on a worker thread\n- Provide a Go binding and a small program that registers three handlers, prints received payloads, then calls the cleanup when done\n- Discuss lifecycle and CGO threading caveats?","answer":"Use a CGOA wrapper that stores Go callbacks in a sync.Map and passes a cgo.Handle integer as the user pointer to the C callback. The C side emits events on a thread and calls back through an exported ","explanation":"## Why This Is Asked\nTests ability to bridge Go and C via CGO under concurrency, including safe callback invocation from C threads, memory management, and lifecycle cleanup. Emphasizes correct use of cgo.Handle and avoiding Go GC pitfalls.\n\n## Key Concepts\n- CGO thread safety and Go callback lifetimes\n- cgo.Handle usage to pass Go values to C\n- Concurrency: multiple independent handlers, event routing\n- Cleanup: unregister, stop C thread, prevent use-after-free\n\n## Code Example\n```c\n// header: event_api.h\ntypedef void (*event_cb)(int id, const char* payload, void* user);\nvoid start_events(void);\nvoid stop_events(void);\nvoid register_event_cb(event_cb cb, void* user);\n```\n```go\n// binding.go (simplified)\npackage eventapi\n\nimport \"C\"\n\n//export goEventHandler\nfunc goEventHandler(id C.int, payload *C.char, user unsafe.Pointer) {\n    // dispatch using the handle stored in user\n}\n```\n\n## Follow-up Questions\n- How would you handle backpressure if event rate overwhelms Go side?\n- What are potential deadlocks with stop_events and in-flight callbacks, and how to mitigate them?","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Bloomberg","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T10:51:21.172Z","createdAt":"2026-01-19T10:51:21.172Z"},{"id":"q-4336","question":"Design a CGOA wrapper for a C library that provides an asynchronous API using a completion callback. Expose a Go function AsyncCompute(src []byte) ([]byte, error) that can run concurrently from multiple goroutines. Provide a C header and minimal C implementation that schedules a callback on a new thread; show a Go binding using CGO and a short program launching two concurrent calls. Include build steps?","answer":"I'd implement a per-call waiter keyed by id. In Go, generate a unique id, register a chan for the result, and invoke the C async_compute with that id and a trampoline to the Go callback (exported). Th","explanation":"## Why This Is Asked\n\nTests ability to design CGO boundaries for async callbacks, memory ownership, and concurrency.\n\n## Key Concepts\n\n- CGO thread-safety and PTHREAD usage\n- Exported Go callbacks from C trampolines\n- Memory management across C and Go (malloc/free)\n- Synchronization of multiple in-flight calls using a map and channels\n\n## Code Example\n\n```c\n// header and trampoline example\n```\n\n```go\n// binding idea\n```\n\n## Follow-up Questions\n\n- How would you handle timeouts or callback errors?\n- How would you extend to streaming results or cancelation?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T14:46:46.911Z","createdAt":"2026-01-19T14:46:46.911Z"},{"id":"q-4445","question":"Design a CGOA wrapper for a C streaming JSON tokenizer: void json_stream_parse(const char* data, size_t len, void (*tok_cb)(int type, const char* value, size_t value_len, void* user), void* user); Tokens types: STRING, NUMBER, TRUE, FALSE, NULL, BEGIN_OBJECT, END_OBJECT, BEGIN_ARRAY, END_ARRAY. Expose Go API: type JsonToken struct { Type TokenType; Value string }; func JsonStreamParse(src []byte) (<-chan JsonToken, func()) . Provide header, minimal C implementation, Go binding, and a test program that feeds two streams concurrently and cancels one stream mid-flight?","answer":"I would implement a thread‑safe CGOA bridge that uses a per‑stream Go manager and a buffered channel to deliver tokens. In the C callback, copy value via C.GoStringN, then send JsonToken{Type, Value} ","explanation":"## Why This Is Asked\nTests understanding of CGO cross‑language callbacks, memory ownership, and cancellation semantics for streaming data.\n\n## Key Concepts\n- CGOA callback lifecycle and thread confinement\n- Safe string marshaling across boundaries\n- Per‑stream lifecycle management with cancellation\n- Resource lifetimes and Go GC interaction\n\n## Code Example\n```c\n// header: json_token.h\ntypedef enum { STRING, NUMBER, TRUE, FALSE, NULL_T, BEGIN_OBJECT, END_OBJECT, BEGIN_ARRAY, END_ARRAY } TokenType;\ntypedef void (*tok_cb)(int type, const char* value, size_t value_len, void* user);\nvoid json_stream_parse(const char* data, size_t len, tok_cb cb, void* user);\n```\n\n```go\n// binding.go (conceptual)\ntype TokenType int\nconst (\n  STRING TokenType = iota\n  // ... other types\n)\ntype JsonToken struct{ Type TokenType; Value string }\nfunc JsonStreamParse(src []byte) (<-chan JsonToken, func()) { /* binding logic */ }\n```\n\n## Follow-up Questions\n- How would you prevent deadlocks if C calls back while Go blocks on a channel?\n- How would you extend to backpressure handling when token production outpaces consumption?","diagram":"flowchart TD\n  A[Caller provides src] --> B[json_stream_parse in C]\n  B --> C{tok_cb invoked}\n  C --> D[Go channel receives JsonToken]\n  D --> E[Go side processes token]\n  E --> F{cancelled?}\n  F -->|yes| G[stop streaming]\n  F -->|no| H[continue streaming]","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Instacart","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T19:27:01.292Z","createdAt":"2026-01-19T19:27:01.294Z"},{"id":"q-4487","question":"CGOA Binding: Implement a C API with an asynchronous progress callback, and provide a Go binding that allows Go code to supply a callback function to receive progress updates. The C API should be: typedef void (*progress_cb)(int progress, void* user); int start_task_async(progress_cb cb, void* user); The C implementation should call cb with progress every 25% and then return 0 on success. Expose a Go wrapper StartTaskWithCallback(cb func(int) error) error and demonstrate concurrent usage by starting two tasks in parallel with distinct callbacks. Provide header, C implementation, Go binding, and a minimal Go program that runs two tasks concurrently. End with a question?","answer":"Approach: bind a C callback into Go by registering a per-task handler in a map keyed by a unique token, and pass that token as user to C. The wrapper should avoid passing Go pointers to C, use //expor","explanation":"## Why This Is Asked\n\nCGO callback integration is a classic pitfall: Go does not allow passing Go pointers to C; you must register callbacks via a C function and store Go callbacks in a per-task context. This tests memory safety, concurrency, and proper cleanup.\n\n## Key Concepts\n\n- CGO callbacks and //export\n- Passing Go values vs pointers across FFI\n- Per-task context and lifecycle\n- Concurrency and thread-safety\n\n## Code Example\n\n```c\n// task.h\ntypedef void (*progress_cb)(int progress, void* user);\nint start_task_async(progress_cb cb, void* user);\n```\n\n```c\n// task.c\n#include \"task.h\"\n#include <unistd.h>\nstatic progress_cb g_cb;\nstatic void* g_user;\nint start_task_async(progress_cb cb, void* user){\n    g_cb = cb; g_user = user;\n    for (int i = 1; i <= 4; ++i){\n        if (g_cb) g_cb(i * 25, g_user);\n        sleep(1);\n    }\n    return 0;\n}\n```\n\n```go\n// task.go\npackage task\n/*\n#include \"task.h\"\n*/\nimport \"C\"\nimport (\n    \"errors\"\n    \"sync\"\n)\nvar callbacks sync.Map // token -> func(int) error\n\n// StartTaskWithCallback starts a C task with a Go callback gateway\nfunc StartTaskWithCallback(f func(int) error) error {\n    // simplified placeholder for gateway logic\n    // would register f and pass a C callback that looks up the Go function\n    return errors.New(\"not implemented in this snippet\")\n}\n```\n\n```go\n// main.go\npackage main\nimport (\n  \"fmt\"\n  \"sync\"\n  \"time\"\n  \"your/module/task\"\n)\nfunc main(){\n  var wg sync.WaitGroup\n  wg.Add(2)\n  go func(){\n    defer wg.Done()\n    task.StartTaskWithCallback(func(p int) error { fmt.Println(\"A progress:\", p); return nil })\n  }()\n  go func(){\n    defer wg.Done()\n    task.StartTaskWithCallback(func(p int) error { fmt.Println(\"B progress:\", p); return nil })\n  }()\n  time.Sleep(3 * time.Second)\n  wg.Wait()\n  fmt.Println(\"done\")\n}\n```\n\n## Follow-up Questions\n\n- How would you ensure the Go callback does not get GC'd while C holds a pointer to it?\n- How would you manage multiple concurrent tasks with distinct contexts and error propagation?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Cloudflare"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T20:48:56.621Z","createdAt":"2026-01-19T20:48:56.621Z"},{"id":"q-4500","question":"CGO Callback Bridge: Design a CGOA wrapper so C can invoke a Go closure on a background thread. Provide: a C header with typedef void (*cb_t)(int, const char*); void register_cb(cb_t, void*); and a Go binding exposing RegisterCallback(fn func(int, string)) (handle, error) and Unregister(handle). Implement a registry mapping handles to Go closures, export a Go callback entry, dispatch via a channel, and demonstrate with a concurrent test?","answer":"I'd implement a Go-side registry that maps opaque handles to Go closures, exposed through RegisterCallback(fn func(int, string)) (handle, error) and Unregister(handle). The C side stores the handle and invokes a single exported Go callback entry point. The Go callback dispatches through a channel to execute the appropriate closure on a background thread, ensuring thread safety and proper lifecycle management.","explanation":"## Why This Is Asked\nTests CGO callback implementation with cross-language lifecycles and concurrent execution.\n\n## Key Concepts\n- CGO export mechanisms\n- Go closures mapped to C handles\n- Thread-safe dispatch from C to Go\n- Memory ownership and Unregister semantics\n\n## Code Example\n```c\n// header sketch\ntypedef void (*cb_t)(int, const char*);\nvoid register_cb(cb_t cb, void* user);\n```\n\n```go\n// export go_cb(...) // signature as used by C\n```\n\n## Follow-up Questions\n- How to avoid deadlocks when C calls back synchronously?\n- How to ensure correctness with multiple registrants?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T07:49:48.358Z","createdAt":"2026-01-19T21:39:12.344Z"},{"id":"q-4531","question":"CGOA Binding: Given a C library API:\n\nvoid register_listener(void* ctx, void (*cb)(int event, const char* data));\nvoid unregister_listener(void* ctx);\n\nDesign a CGOA wrapper that lets Go code subscribe to events via a Go channel. Implement:\n- A C header exposing the callback type and registration functions\n- Go binding using //export to route C callbacks to Go; use cgo.Handle to map Go channels\n- A small Go program that starts two independent listeners and prints incoming events\n- Build steps?","answer":"Use a CGO bridge with a Go channel per listener, store channels via a cgo.Handle, pass the handle as ctx to C, export a Go callback GoCb(int, const char*) and forward to the respective channel. Provide build instructions using `go build` with appropriate CGO flags.","explanation":"## Why This Is Asked\nInterfacing C callbacks with Go via CGO is common in high-performance systems. This tests understanding of memory ownership, callback lifetimes, and safe cross-language synchronization.\n\n## Key Concepts\n- CGO callbacks and //export directives\n- cgo.Handle for bridging Go values to C\n- Memory ownership and cross-language resource management\n- Concurrency patterns with multiple listeners and per-listener channels\n\n## Code Example\n```c\n// cgo_listener.h\ntypedef void (*cb_t)(int event, const char* data);\nvoid register_listener(void* ctx, cb_t cb);\nvoid unregister_listener(void* ctx);\n```\n\n```go\n// binding.go\npackage main\n// #include \"cgo_listener.h\"\n// extern void GoCb(int event, const char* data);\nimport \"C\"\nimport \"unsafe\"\n\nfunc main() {\n    ch1 := make(chan Event, 10)\n    ch2 := make(chan Event, 10)\n    \n    handle1 := C.malloc(C.size_t(unsafe.Sizeof(C.uintptr_t(0))))\n    handle2 := C.malloc(C.size_t(unsafe.Sizeof(C.uintptr_t(0))))\n    \n    // Register listeners and handle events...\n}\n```","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Microsoft","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T04:57:04.885Z","createdAt":"2026-01-19T22:42:20.450Z"},{"id":"q-4653","question":"Design a CGOA wrapper for a C library that provides asynchronous computation via a callback: void compute_async(const uint8_t* data, size_t n, void (*cb)(const uint8_t* result, size_t m, void* user), void* user); Expose a Go API ComputeAsync(src []byte) (<-chan []byte, <-chan error) that streams results back via channel; implement memory safety, cancellation, and cross-GO thread-safety; include a header, minimal C wrapper, Go binding, and a small program that runs ComputeAsync in two goroutines concurrently?","answer":"Use a CGO-exported trampoline callback and a Go channel per call. Allocate a cgo.Handle for a Go channel, pass a C function that sends chunks back via the channel, and free on completion. Use runtime.","explanation":"## Why This Is Asked\nTests understanding of cross-language async callbacks, CGO safety, and memory management. It also probes how to map C callbacks to Go channels and how to cancel/cleanup.\n\n## Key Concepts\n- CGO callback handling and cgo.Handle\n- Memory ownership across C-Go boundary\n- Concurrency isolation and cancellation\n- Runtime considerations (GOMAXPROCS, CGO thread affinity)\n\n## Code Example\n```c\n// header\nvoid compute_async(const uint8_t* data, size_t n, void (*cb)(const uint8_t* result, size_t m, void* user), void* user);\n```\n```go\n// binding sketch\nfunc ComputeAsync(src []byte) (<-chan []byte, <-chan error) { /* ... */ }\n```\n\n## Follow-up Questions\n- How would you implement cancellation? \n- How do you test memory safety across calls?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T06:59:54.896Z","createdAt":"2026-01-20T06:59:54.896Z"},{"id":"q-4716","question":"Wrap a C API that manages a configuration as an opaque handle. The C API provides:\n\ntypedef struct Config Config;\nConfig* config_new(const char* json);\nconst char* config_to_json(const Config* cfg);\nvoid config_free(Config* cfg);\n\nThe string returned by config_to_json is allocated with malloc and must be freed with free. Build a CGO wrapper in Go exposing:\n\ntype ConfigHandle struct { ptr *C.Config }\nfunc CreateConfig(json string) (*ConfigHandle, error)\nfunc ConfigToJSON(h *ConfigHandle) (string, error)\nfunc (h *ConfigHandle) Close() error\n\nRequirements:\n- Allocate and free memory correctly, translate C strings to Go strings, and free buffers.\n- Ensure safe usage across two goroutines by calling CreateConfig in two goroutines, then pass to ConfigToJSON in parallel, and free the handles?","answer":"Use a CGO wrapper that creates a new Config with C.config_new(C.CString(json)) and returns an error if NULL. For ConfigToJSON, call C.config_to_json(h.ptr), convert with C.GoString, then C.free on the","explanation":"## Why This Is Asked\nTests ability to bridge C memory life cycles, error handling, and CGO threading basics with opaque handles.\n\n## Key Concepts\n- CGO memory ownership and C.GoString\n- Freeing C-allocated buffers with C.free\n- Opaque C handles in Go wrappers\n- Concurrent calls safety without shared state\n\n## Code Example\n```c\n// config.h\ntypedef struct Config Config;\n Config* config_new(const char* json);\n const char* config_to_json(const Config* cfg);\n void config_free(Config* cfg);\n```\n```c\n// config.c (minimal)\n#include <stdlib.h>\n#include <string.h>\n#include \"config.h\"\n\nstruct Config { char* data; };\nConfig* config_new(const char* json){ if(!json) return NULL; Config* c=malloc(sizeof(Config)); c->data=strdup(json); return c; }\nconst char* config_to_json(const Config* cfg){ return cfg? cfg->data: NULL; }\nvoid config_free(Config* cfg){ free(cfg->data); free(cfg); }\n```\n```go\n// binding.go\npackage main\n\n// #include \"config.h\"\n// #cgo CFLAGS: -I.\nimport \"C\"\nimport (\n  \"errors\"\n  \"unsafe\"\n)\n\ntype ConfigHandle struct{ ptr *C.Config }\n\nfunc CreateConfig(json string) (*ConfigHandle, error){ cstr := C.CString(json); defer C.free(unsafe.Pointer(cstr)); cfg := C.config_new(cstr); if cfg == nil { return nil, errors.New(\"config creation failed\") }; return &ConfigHandle{ptr: cfg}, nil }\n\nfunc ConfigToJSON(h *ConfigHandle) (string, error){ if h==nil || h.ptr==nil { return \"\", errors.New(\"nil handle\") }\n  cstr := C.config_to_json(h.ptr); if cstr == nil { return \"\", nil }\n  s := C.GoString(cstr); C.free(unsafe.Pointer((*C.char)(unsafe.Pointer(cstr))))\n  return s, nil\n}\n\nfunc (h *ConfigHandle) Close() { if h!=nil && h.ptr!=nil { C.config_free(h.ptr); h.ptr = nil }\n}\n```\n\n## Follow-up Questions\n- How would you adapt this to streaming JSON results?\n- What if config_to_json returns a static string; how would you adjust memory management?","diagram":"flowchart TD\n  A[Go code] --> B[C API: config_new]\n  B --> C[ConfigHandle]\n  C --> D[C API: config_to_json]\n  D --> E[Go string]\n  E --> F[Go Close frees resources]","difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Google","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T09:45:03.358Z","createdAt":"2026-01-20T09:45:03.358Z"},{"id":"q-4737","question":"Design a CGOA wrapper for a C API: void get_message(char* buf, size_t* len); if buf is NULL, return required len in *len; otherwise copy up to *len-1 bytes, NUL-terminate, and set *len to actual length. Expose in Go a function GetMessage() (string, error) that performs the two-step call, converts the result to a Go string, and frees any allocated memory if needed. Provide header, minimal C, the Go binding, and a small program that launches two goroutines calling GetMessage concurrently to validate thread-safety?","answer":"Describe a two-step CGO pattern: first call with buf NULL to obtain len, allocate buffer in Go, call again, convert with GoStringN, and return. Include error checks for truncation and NULLs, and ensur","explanation":"## Why This Is Asked\nTests understanding of two-pass C APIs, memory ownership across CGO, and safe string conversion, plus basic concurrency.\n\n## Key Concepts\n- Two-pass C API usage\n- Memory management across Go/C boundaries\n- CGO string conversion and error handling\n- Concurrency safety with CGO calls\n\n## Code Example\n```javascript\n// Go binding sketch (conceptual)\n#include <stdlib.h>\n#include <string.h>\n\nint get_message(char* buf, size_t* len);\n\n// Go usage: GetMessage() (string, error) implemented in Go\n```\n\n```javascript\n// Go binding outline (pseudo)\nimport \"C\"\nimport (\n  \"fmt\"\n  \"unsafe\"\n)\n\nfunc GetMessage() (string, error) {\n  var n C.size_t\n  if C.get_message(nil, &n) != 0 { return \"\", fmt.Errorf(\"error\") }\n  buf := make([]byte, int(n))\n  if C.get_message((*C.char)(unsafe.Pointer(&buf[0])), &n) != 0 { return \"\", fmt.Errorf(\"error\") }\n  return string(buf[:int(n)-1]), nil\n}\n```\n\n## Follow-up Questions\n- How would you handle larger data exceeding Go's contiguous allocations?\n- How would you adapt for cancellation or timeouts in long-running C operations?\n- How would you test concurrency safety and memory leaks in this wrapper?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T10:37:07.551Z","createdAt":"2026-01-20T10:37:07.554Z"},{"id":"q-842","question":"You have a Go service using cgo to wrap a C API. A C function 'char* fetch_data(int id)' returns a malloc-allocated string or NULL on error. Design a safe Go wrapper that converts the result to a Go string, ensures the C allocation is freed, handles NULL with a meaningful error, and notes CGO thread-safety considerations. What implementation would you write?","answer":"Check for NULL, copy with GoString, then free with C.free(unsafe.Pointer(ptr)). Return (string, error). Include <stdlib.h> and declare the C function. Avoid using the original pointer after free; ensu","explanation":"## Why This Is Asked\nAssess memory management, error handling, and CGO pitfalls in real-world bindings.\n\n## Key Concepts\n- CGO memory ownership\n- NULL handling and errors\n- Safe string conversion\n- Thread-safety and allocation\n\n## Code Example\n```javascript\n// Implementation code here\n```\n\n## Follow-up Questions\n- How would you handle multi-string results and encoding issues?\n- How would you test this wrapper for leaks and concurrency?\n","diagram":"flowchart TD\n  A[Wrapper] --> B[Call C.fetch_data]\n  B --> C{ptr != NULL}\n  C -->|Yes| D[GoString & free]\n  C -->|No| E[Return error]","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","PayPal","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T13:26:43.632Z","createdAt":"2026-01-12T13:26:43.632Z"},{"id":"q-870","question":"Design a Go wrapper for a C API with malloc’d results that must be freed, exploring a new angle: ensure thread-safe, single-point ownership transfer for each call and robust error handling when the C call returns a non-zero code or NULL. API: typedef struct { int code; const char* msg; } ScanResult; ScanResult* perform_scan(const char* query); void free_scan_result(ScanResult*); Implement function: func Scan(query string) (string, error)?","answer":"Serialize CGO calls with a mutex, copy the C message to Go, free the C result, and return meaningful errors when nil or code != 0. Pass query as C string and free it. Ensure no Go pointers escape into","explanation":"## Why This Is Asked\nTests memory ownership, error propagation, and CGO threading. It verifies that the candidate safely consumes C-allocated data, prevents leaks, and handles non-thread-safe C APIs in Go.\n\n## Key Concepts\n- CGO memory management and ownership transfer\n- Error handling from C to Go\n- Thread-safety and mutex usage for non-thread-safe C calls\n- Avoiding Go pointers in C and ensuring proper lifetimes\n- Resource finalization patterns\n\n## Code Example\n```go\npackage main\n\n/*\ntypedef struct { int code; const char* msg; } ScanResult;\nScanResult* perform_scan(const char* query);\nvoid free_scan_result(ScanResult*);\n*/\nimport \"C\"\nimport (\n  \"errors\"\n  \"sync\"\n  \"unsafe\"\n)\n\nvar scanMu sync.Mutex\n\nfunc Scan(query string) (string, error) {\n  cQuery := C.CString(query)\n  defer C.free(unsafe.Pointer(cQuery))\n\n  scanMu.Lock()\n  defer scanMu.Unlock()\n\n  res := C.perform_scan(cQuery)\n  if res == nil {\n    return \"\", errors.New(\"nil ScanResult from C\")\n  }\n  defer C.free_scan_result(res)\n\n  if res.code != 0 {\n    msg := C.GoString(res.msg)\n    return \"\", fmt.Errorf(\"scan failed code=%d: %s\", res.code, msg)\n  }\n  out := C.GoString(res.msg)\n  return out, nil\n}\n```\n\n## Follow-up Questions\n- How would you adapt this for a streaming callback API from C?\n- How would you test with race detector and verify memory safety across CGO calls?","diagram":"flowchart TD\n  A[Go calls Scan] --> B[Convert query to C string]\n  B --> C[Call perform_scan]\n  C --> D{Res != NULL}\n  D -->|no| E[Return error]\n  D -->|yes| F{Res.code == 0}\n  F -->|yes| G[Copy Msg, Free res, Return string]\n  F -->|no| H[Copy error, Free res, Return error]\n","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T13:52:40.902Z","createdAt":"2026-01-12T13:52:40.902Z"},{"id":"q-914","question":"Using cgo, how would you wrap a C function that allocates a string (char*) and returns it, ensuring memory is freed by Go code without leaks, and provide a minimal working example?","answer":"Declare the C function in a preamble, call it from Go, convert the returned char* with C.GoString, and defer C.free(ptr) to avoid leaks. Prefer a small wrapper that owns the allocation and exposes a d","explanation":"## Why This Is Asked\nTests understanding of memory ownership across language boundaries and safe interop.\n\n## Key Concepts\n- cgo memory management\n- Go-C interop patterns\n- Safe wrapper design\n\n## Code Example\n\n```go\n/*\n#include <stdlib.h>\nchar* alloc_str(size_t n) {\n  char* p = (char*)malloc(n+1);\n  if (p) p[n] = '\\0';\n  return p;\n}\n*/\nimport \"C\"\n\nfunc example() {\n  p := C.alloc_str(10)\n  s := C.GoString(p)\n  C.free(p)\n  _ = s\n}\n```\n\n## Follow-up Questions\n- How would you handle allocation failures?\n- How can you avoid GC cross-issue with large strings?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Snap","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T15:27:13.812Z","createdAt":"2026-01-12T15:27:13.812Z"},{"id":"q-950","question":"Implement a minimal CGOA wrapper that exposes a C function int add(int a, int b) to Go. Provide the C header, the Go binding using CGO, and a small Go program that concurrently calls Add from two goroutines to demonstrate thread safety. Include build steps?","answer":"Bridge by CGOA: expose C int add(int a, int b) to Go. In bridge.h declare int add(int a, int b); In Go: include the header, import \\\"C\\\", and implement Add(a,b int) int { return int(C.add(C.int(a), C.","explanation":"## Why This Is Asked\nTo verify practical understanding of bridging C to Go using CGOA, including type conversions and concurrency safety.\n\n## Key Concepts\n- CGOA basics: cgo import and header inclusion\n- Type conversions between C and Go\n- Build/link steps for mixed languages\n- Concurrency: safe calls from multiple goroutines\n\n## Code Example\nExplain how Add wraps C.add as a Go function and how to organize bridge.c/bridge.h and main.go.\n\n## Follow-up Questions\n- How would you handle error returns or errno from C?\n- How to extend to multiple C functions or error propagation?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Snap","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T16:38:23.204Z","createdAt":"2026-01-12T16:38:23.204Z"},{"id":"q-978","question":"Design a CGO bridge for a C streaming API that delivers chunks via a callback: void stream_data(int id, void (*chunk_cb)(const char* data, size_t len, void*), void* ctx). Implement a Go wrapper StreamFromC(id int) (io.Reader, error) that buffers chunks into an io.Pipe and exposes a safe reader, supporting concurrent streams and proper backpressure. Include a C header, a Go CGO binding, and a simple consumer showing two goroutines reading from the reader?","answer":"Leverage a per-stream context and a C callback exported to Go. Use a Go channel to forward chunks, copy data into Go memory, feed an io.Pipe writer, and return an io.Reader to the caller. Ensure clean","explanation":"## Why This Is Asked\nTests ability to bridge callbacks, memory ownership, and streaming backpressure across language boundaries.\n\n## Key Concepts\n- CGO callback bridge and per-stream context\n- Memory ownership and copying from C to Go\n- Streaming via io.Pipe and concurrent reads\n\n## Code Example\n```c\n// stream.h\nvoid stream_data(int id, void (*chunk_cb)(const char*, size_t, void*), void* ctx);\n```\n```go\n// stream_bind.go (skeleton)\n/*\n#cgo CFLAGS: -I./include\n#include \"stream.h\"\n*/\nimport \"C\"\nimport (\n  \"io\"\n)\n\nfunc StreamFromC(id int) (io.Reader, error) {\n  // binding implementation here\n  return nil, nil\n}\n```\n```go\n// consumer.go (usage)\npackage main\nimport (\n  \"io\"\n  \"fmt\"\n)\nfunc main() {\n  r, _ := StreamFromC(42)\n  buf := make([]byte, 1024)\n  for {\n    n, err := r.Read(buf)\n    if err == io.EOF { break }\n    fmt.Printf(\"read %d bytes\\n\", n)\n  }\n}\n```\n\n## Follow-up Questions\n- How would you handle backpressure if C emits chunks faster than Go consumes them?\n- How would you adapt this to multiple ids concurrently without cross-talk?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Microsoft","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T17:41:57.902Z","createdAt":"2026-01-12T17:41:57.902Z"},{"id":"q-987","question":"Implement a CGO binding for a C function char* greet(const char* name) that returns a newly allocated string. Provide the C header and implementation, a Go binding using CGO that wraps greet in a safe Go function returning (string, error), and a small Go program that concurrently calls the binding from multiple goroutines and frees the allocated memory. How would you handle NULL returns and memory deallocation robustly?","answer":"Use CGO to wrap greet: convert input to a C string, call the C function, check for NULL, convert the result back to a Go string, and free both allocations. Return a Go string and an error. Ensure both","explanation":"## Why This Is Asked\nTests practical CGO understanding: safe memory ownership, error translation, and concurrency.\n\n## Key Concepts\n- CGO boundaries and memory ownership\n- Translating errors from C to Go\n- Safe deallocation of C-allocated strings\n- Concurrency: calling CGO from multiple goroutines\n\n## Code Example\n```go\n// Go binding sketch (not full code)\npackage cgowrap\nimport \"C\"\n// Greet wraps C.greet and converts result to Go string with error handling\nfunc Greet(name string) (string, error) { /* omitted for brevity in answer */ }\n```\n\n## Follow-up Questions\n- How would you model ownership if C returns allocated memory for reuse?\n- How can you detect and prevent use-after-free in long-lived Go values?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","MongoDB","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T18:32:47.654Z","createdAt":"2026-01-12T18:32:47.654Z"}],"subChannels":["general"],"companies":["Adobe","Airbnb","Amazon","Anthropic","Apple","Bloomberg","Citadel","Cloudflare","Coinbase","Databricks","Discord","DoorDash","Goldman Sachs","Google","Hashicorp","Hugging Face","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Netflix","OpenAI","Oracle","PayPal","Plaid","Robinhood","Scale Ai","Slack","Snap","Snowflake","Square","Stripe","Tesla","Twitter","Two Sigma","Uber"],"stats":{"total":54,"beginner":21,"intermediate":20,"advanced":13,"newThisWeek":41}}