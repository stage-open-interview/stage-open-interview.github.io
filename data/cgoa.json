{"questions":[{"id":"q-1026","question":"Design a CGOA wrapper for a C library that provides two symbols: int* generate_seq(int n) which allocates an int array of length n via malloc filled with 0..n-1, and void free_seq(int* p) to free it. Provide the C header, the Go binding using CGO, and a small Go program that concurrently requests arrays of sizes 4 and 8, validates contents, and frees them. Include exact build steps?","answer":"Use C to own the allocated memory and expose two symbols: generate_seq and free_seq. Go binds via CGO, calling into C to obtain a raw *C.int and later frees it with free_seq. Two goroutines race-safe ","explanation":"## Why This Is Asked\nTests memory ownership and boundary safety when mixing Go and C. Candidates must implement correct allocation/free on the C side and valid binding in Go, ensuring no Go pointers cross into C and that allocations are freed.\n\n## Key Concepts\n- CGO memory ownership across boundaries\n- CGO pointer rules: avoid passing Go pointers to C\n- Concurrency safety with CGO calls\n- Leak prevention via paired malloc/free\n\n## Code Example\n```c\n// cg_seq.h\nint* generate_seq(int n);\nvoid free_seq(int* p);\n```\n\n```go\n// go_bind.go\n/*\n#cgo CFLAGS: -I.\n#include \"cg_seq.h\"\n*/\nimport \"C\"\n\nfunc GenerateSeq(n int) *C.int { return C.generate_seq(C.int(n)) }\nfunc FreeSeq(p *C.int) { C.free_seq(p) }\n```\n\n## Follow-up Questions\n- How would you return the length safely alongside the pointer?\n- How to detect leaks in tests with tools like valgrind or Go race detector?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Coinbase","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T19:37:48.180Z","createdAt":"2026-01-12T19:37:48.180Z"},{"id":"q-1099","question":"Given a C library with an asynchronous API: \n\n- void run_async(const char* input, void (*cb)(int status, const char* data, void* user), void* user);\n\nwhere the callback runs on a worker thread and data is malloc-allocated or NULL on error. Design a CGO-based Go wrapper that exposes RunAsync(input string, cb func(status int, data string, err error)). The wrapper must: manage the Go callback safely across C boundaries, free C data, map non-zero status to errors, and handle thread attachment; provide header + binding + minimal test harness to demonstrate safety?","answer":"Design a CGO bridge that stores per-call state with a Go callback and uses a cgo.Handle to pass a Go function across the boundary. Implement RunAsync(input string, cb func(int, string, error)) which c","explanation":"## Why This Is Asked\n\nTests ability to bridge asynchronous C callbacks to Go safely, including memory ownership, cross-thread invocation, and error mapping. It also checks how well the candidate uses cgo.Handle, runtime.LockOSThread, and memory management to avoid leaks or panics crossing boundaries.\n\n## Key Concepts\n\n- CGO callback bridging across threads\n- Memory ownership of malloc'd C strings\n- cgo.Handle lifetime management\n- runtime.LockOSThread and thread-affinity considerations\n- Error translation from C to Go\n\n## Code Example\n\n```javascript\n// Header (C)\n#include <stdlib.h>\nvoid run_async(const char* input, void (*cb)(int status, const char* data, void* user), void* user);\n```\n\n```javascript\n// Go binding sketch (CGO)\n// This is a conceptual outline; actual code would be Go with //export callbacks.\n```\n\n## Follow-up Questions\n\n- How would you implement cancellation and timeouts?\n- How would you test for memory leaks and callback ordering under contention?","diagram":"flowchart TD\n  A[Go API calls RunAsync] --> B[C wrapper calls run_async]\n  B --> C[Worker thread executes callback]\n  C --> D[Callback passes status/data to Go via handle]\n  D --> E[Go callback invoked]\n  E --> F[Data freed and handle cleared]","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","LinkedIn","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T22:31:14.811Z","createdAt":"2026-01-12T22:31:14.811Z"},{"id":"q-1207","question":"Design a CGO bridge for a C EventLib that exposes a function: void register_event_source(int stream_id, void (*cb)(int, const char*)); void start_event_loop(); Build a Go binding that lets two independent streams subscribe and receive events via a single exported Go callback, using a C shim to bridge into Go. Describe memory management and thread-safety; provide header, Go binding, and a small Go program demonstrating two streams; include build steps?","answer":"Use a single C callback bridged to Go via an exported function; maintain per-stream state in a mutex-protected map keyed by stream_id, storing a Go callback. Register a C shim that calls the Go bridge","explanation":"## Why This Is Asked\nExplores cross-language callbacks, CGO lifecycle, and thread-safety. The candidate must design a robust bridge rather than a naive callback.\n\n## Key Concepts\n- CGO cross-language callbacks\n- cgo.Handle for GC control\n- Thread-safety with mutex maps\n- Exported Go callbacks and C shims\n\n## Code Example\n```go\npackage main\n/*\n#include \"eventlib.h\"\n\n// Go callback exported\nextern void goEventBridge(int stream_id, const char* msg);\n\nstatic void shim_cb(int sid, const char* msg){\n    goEventBridge(sid, msg);\n}\n*/\nimport \"C\"\nimport (\n  \"runtime\"\n  \"sync\"\n)\n\ntype Callback func(int, string)\n\nvar (\n  mu sync.RWMutex\n  handlers = make(map[int]Callback)\n)\n\n// RegisterStream registers a Go callback for a stream\nfunc RegisterStream(id int, cb Callback) {\n  mu.Lock()\n  handlers[id] = cb\n  mu.Unlock()\n  C.register_event_source(C.int(id), C.shim_cb)\n  runtime.KeepAlive(cb)\n}\n\n//export goEventBridge\nfunc goEventBridge(s C.int, msg *C.char) {\n  mu.RLock()\n  cb := handlers[int(s)]\n  mu.RUnlock()\n  if cb != nil {\n    cb(int(s), C.GoString(msg))\n  }\n}\n```\n\n## Follow-up Questions\n- How would you stop a stream and clean up without races?\n- How would you propagate C-side errors back to Go?","diagram":"flowchart TD\n  A[Subscriber registers streams] --> B[Shim cb in EventLib]\n  B --> C[C thread emits event]\n  C --> D[goEventBridge is called]\n  D --> E[Go callback invoked]","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Twitter","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T04:56:17.642Z","createdAt":"2026-01-13T04:56:17.642Z"},{"id":"q-1235","question":"Implement a CGOA binding for an opaque C Counter handle. API: typedef struct Counter Counter; Counter* CounterNew(int); void CounterInc(Counter*, int); int CounterValue(Counter*); void CounterFree(Counter*); In Go wrap as type Counter with NewCounter, Inc, Value, Close. Show two goroutines each creating its own Counter, incrementing independently, and printing values to verify isolation and no data races. Include header, binding, and a minimal program with build steps?","answer":"Implement a CGOA binding for an opaque C Counter handle. API: typedef struct Counter Counter; Counter* CounterNew(int); void CounterInc(Counter*, int); int CounterValue(Counter*); void CounterFree(Cou","explanation":"## Why This Is Asked\n\nProbes CGO bindings to an opaque C type, per-instance memory management, and basic concurrency isolation.\n\n## Key Concepts\n\n- CGO binding for opaque C types\n- Manual memory management (CounterNew/CounterFree)\n- Concurrency: per-instance state and data-race awareness\n\n## Code Example\n\n```c\n// C header\ntypedef struct Counter Counter;\nCounter* CounterNew(int initial);\nvoid CounterInc(Counter*, int delta);\nint CounterValue(Counter*);\nvoid CounterFree(Counter*);\n```\n\n```go\n// Go binding snippet\n// #include \\\"counter.h\\\"\nimport \"C\"\n\ntype Counter struct{ c *C.Counter }\n\nfunc NewCounter(init int) *Counter {\n  c := C.CounterNew(C.int(init))\n  return &Counter{c: c}\n}\n\nfunc (ctr *Counter) Inc(delta int) {\n  C.CounterInc(ctr.c, C.int(delta))\n}\n\nfunc (ctr *Counter) Value() int {\n  return int(C.CounterValue(ctr.c))\n}\n\nfunc (ctr *Counter) Close() {\n  C.CounterFree(ctr.c)\n}\n```\n\n## Follow-up Questions\n\n- How would you ensure thread-safety when multiple goroutines manipulate distinct Counter instances?\n- What changes if Counter access becomes shared across goroutines?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Instacart","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T06:33:00.575Z","createdAt":"2026-01-13T06:33:00.575Z"},{"id":"q-1294","question":"Implement a CGOA bridge that lets C trigger a Go callback asynchronously when an external sensor fires events. Provide a C header and stub, a CGO binding in Go that registers a Go callback and routes events through an exported Go function, and a safe cleanup mechanism to release resources when producers stop?","answer":"Design approach: Go registers a callback, wraps it with runtime/cgo.NewHandle(cb) and passes the handle’s uintptr to C. An exported bridge function (//export goCallbackBridge) is invoked by C with the","explanation":"## Why This Is Asked\nCGOA bridges are common in practice when external C libraries need Go callbacks. This tests safe lifetimes, non-Go-pointer transfer, and cross-language threading.\n\n## Key Concepts\n- runtime/cgo.Handle\n- //exported Go functions\n- passing uintptr_t to C\n- proper cleanup and synchronization\n\n## Code Example\n```c\n/* header */\nvoid register_callback(void (*cb)(int, void*), void* ctx);\n```\n\n## Follow-up Questions\n- How to avoid deadlocks when callbacks re-enter?\n- How to handle panics in the Go callback across threads?","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Lyft","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T08:40:37.001Z","createdAt":"2026-01-13T08:40:37.001Z"},{"id":"q-842","question":"You have a Go service using cgo to wrap a C API. A C function 'char* fetch_data(int id)' returns a malloc-allocated string or NULL on error. Design a safe Go wrapper that converts the result to a Go string, ensures the C allocation is freed, handles NULL with a meaningful error, and notes CGO thread-safety considerations. What implementation would you write?","answer":"Check for NULL, copy with GoString, then free with C.free(unsafe.Pointer(ptr)). Return (string, error). Include <stdlib.h> and declare the C function. Avoid using the original pointer after free; ensu","explanation":"## Why This Is Asked\nAssess memory management, error handling, and CGO pitfalls in real-world bindings.\n\n## Key Concepts\n- CGO memory ownership\n- NULL handling and errors\n- Safe string conversion\n- Thread-safety and allocation\n\n## Code Example\n```javascript\n// Implementation code here\n```\n\n## Follow-up Questions\n- How would you handle multi-string results and encoding issues?\n- How would you test this wrapper for leaks and concurrency?\n","diagram":"flowchart TD\n  A[Wrapper] --> B[Call C.fetch_data]\n  B --> C{ptr != NULL}\n  C -->|Yes| D[GoString & free]\n  C -->|No| E[Return error]","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","PayPal","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T13:26:43.632Z","createdAt":"2026-01-12T13:26:43.632Z"},{"id":"q-870","question":"Design a Go wrapper for a C API with malloc’d results that must be freed, exploring a new angle: ensure thread-safe, single-point ownership transfer for each call and robust error handling when the C call returns a non-zero code or NULL. API: typedef struct { int code; const char* msg; } ScanResult; ScanResult* perform_scan(const char* query); void free_scan_result(ScanResult*); Implement function: func Scan(query string) (string, error)?","answer":"Serialize CGO calls with a mutex, copy the C message to Go, free the C result, and return meaningful errors when nil or code != 0. Pass query as C string and free it. Ensure no Go pointers escape into","explanation":"## Why This Is Asked\nTests memory ownership, error propagation, and CGO threading. It verifies that the candidate safely consumes C-allocated data, prevents leaks, and handles non-thread-safe C APIs in Go.\n\n## Key Concepts\n- CGO memory management and ownership transfer\n- Error handling from C to Go\n- Thread-safety and mutex usage for non-thread-safe C calls\n- Avoiding Go pointers in C and ensuring proper lifetimes\n- Resource finalization patterns\n\n## Code Example\n```go\npackage main\n\n/*\ntypedef struct { int code; const char* msg; } ScanResult;\nScanResult* perform_scan(const char* query);\nvoid free_scan_result(ScanResult*);\n*/\nimport \"C\"\nimport (\n  \"errors\"\n  \"sync\"\n  \"unsafe\"\n)\n\nvar scanMu sync.Mutex\n\nfunc Scan(query string) (string, error) {\n  cQuery := C.CString(query)\n  defer C.free(unsafe.Pointer(cQuery))\n\n  scanMu.Lock()\n  defer scanMu.Unlock()\n\n  res := C.perform_scan(cQuery)\n  if res == nil {\n    return \"\", errors.New(\"nil ScanResult from C\")\n  }\n  defer C.free_scan_result(res)\n\n  if res.code != 0 {\n    msg := C.GoString(res.msg)\n    return \"\", fmt.Errorf(\"scan failed code=%d: %s\", res.code, msg)\n  }\n  out := C.GoString(res.msg)\n  return out, nil\n}\n```\n\n## Follow-up Questions\n- How would you adapt this for a streaming callback API from C?\n- How would you test with race detector and verify memory safety across CGO calls?","diagram":"flowchart TD\n  A[Go calls Scan] --> B[Convert query to C string]\n  B --> C[Call perform_scan]\n  C --> D{Res != NULL}\n  D -->|no| E[Return error]\n  D -->|yes| F{Res.code == 0}\n  F -->|yes| G[Copy Msg, Free res, Return string]\n  F -->|no| H[Copy error, Free res, Return error]\n","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T13:52:40.902Z","createdAt":"2026-01-12T13:52:40.902Z"},{"id":"q-914","question":"Using cgo, how would you wrap a C function that allocates a string (char*) and returns it, ensuring memory is freed by Go code without leaks, and provide a minimal working example?","answer":"Declare the C function in a preamble, call it from Go, convert the returned char* with C.GoString, and defer C.free(ptr) to avoid leaks. Prefer a small wrapper that owns the allocation and exposes a d","explanation":"## Why This Is Asked\nTests understanding of memory ownership across language boundaries and safe interop.\n\n## Key Concepts\n- cgo memory management\n- Go-C interop patterns\n- Safe wrapper design\n\n## Code Example\n\n```go\n/*\n#include <stdlib.h>\nchar* alloc_str(size_t n) {\n  char* p = (char*)malloc(n+1);\n  if (p) p[n] = '\\0';\n  return p;\n}\n*/\nimport \"C\"\n\nfunc example() {\n  p := C.alloc_str(10)\n  s := C.GoString(p)\n  C.free(p)\n  _ = s\n}\n```\n\n## Follow-up Questions\n- How would you handle allocation failures?\n- How can you avoid GC cross-issue with large strings?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Snap","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T15:27:13.812Z","createdAt":"2026-01-12T15:27:13.812Z"},{"id":"q-950","question":"Implement a minimal CGOA wrapper that exposes a C function int add(int a, int b) to Go. Provide the C header, the Go binding using CGO, and a small Go program that concurrently calls Add from two goroutines to demonstrate thread safety. Include build steps?","answer":"Bridge by CGOA: expose C int add(int a, int b) to Go. In bridge.h declare int add(int a, int b); In Go: include the header, import \\\"C\\\", and implement Add(a,b int) int { return int(C.add(C.int(a), C.","explanation":"## Why This Is Asked\nTo verify practical understanding of bridging C to Go using CGOA, including type conversions and concurrency safety.\n\n## Key Concepts\n- CGOA basics: cgo import and header inclusion\n- Type conversions between C and Go\n- Build/link steps for mixed languages\n- Concurrency: safe calls from multiple goroutines\n\n## Code Example\nExplain how Add wraps C.add as a Go function and how to organize bridge.c/bridge.h and main.go.\n\n## Follow-up Questions\n- How would you handle error returns or errno from C?\n- How to extend to multiple C functions or error propagation?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Snap","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T16:38:23.204Z","createdAt":"2026-01-12T16:38:23.204Z"},{"id":"q-978","question":"Design a CGO bridge for a C streaming API that delivers chunks via a callback: void stream_data(int id, void (*chunk_cb)(const char* data, size_t len, void*), void* ctx). Implement a Go wrapper StreamFromC(id int) (io.Reader, error) that buffers chunks into an io.Pipe and exposes a safe reader, supporting concurrent streams and proper backpressure. Include a C header, a Go CGO binding, and a simple consumer showing two goroutines reading from the reader?","answer":"Leverage a per-stream context and a C callback exported to Go. Use a Go channel to forward chunks, copy data into Go memory, feed an io.Pipe writer, and return an io.Reader to the caller. Ensure clean","explanation":"## Why This Is Asked\nTests ability to bridge callbacks, memory ownership, and streaming backpressure across language boundaries.\n\n## Key Concepts\n- CGO callback bridge and per-stream context\n- Memory ownership and copying from C to Go\n- Streaming via io.Pipe and concurrent reads\n\n## Code Example\n```c\n// stream.h\nvoid stream_data(int id, void (*chunk_cb)(const char*, size_t, void*), void* ctx);\n```\n```go\n// stream_bind.go (skeleton)\n/*\n#cgo CFLAGS: -I./include\n#include \"stream.h\"\n*/\nimport \"C\"\nimport (\n  \"io\"\n)\n\nfunc StreamFromC(id int) (io.Reader, error) {\n  // binding implementation here\n  return nil, nil\n}\n```\n```go\n// consumer.go (usage)\npackage main\nimport (\n  \"io\"\n  \"fmt\"\n)\nfunc main() {\n  r, _ := StreamFromC(42)\n  buf := make([]byte, 1024)\n  for {\n    n, err := r.Read(buf)\n    if err == io.EOF { break }\n    fmt.Printf(\"read %d bytes\\n\", n)\n  }\n}\n```\n\n## Follow-up Questions\n- How would you handle backpressure if C emits chunks faster than Go consumes them?\n- How would you adapt this to multiple ids concurrently without cross-talk?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Microsoft","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T17:41:57.902Z","createdAt":"2026-01-12T17:41:57.902Z"},{"id":"q-987","question":"Implement a CGO binding for a C function char* greet(const char* name) that returns a newly allocated string. Provide the C header and implementation, a Go binding using CGO that wraps greet in a safe Go function returning (string, error), and a small Go program that concurrently calls the binding from multiple goroutines and frees the allocated memory. How would you handle NULL returns and memory deallocation robustly?","answer":"Use CGO to wrap greet: convert input to a C string, call the C function, check for NULL, convert the result back to a Go string, and free both allocations. Return a Go string and an error. Ensure both","explanation":"## Why This Is Asked\nTests practical CGO understanding: safe memory ownership, error translation, and concurrency.\n\n## Key Concepts\n- CGO boundaries and memory ownership\n- Translating errors from C to Go\n- Safe deallocation of C-allocated strings\n- Concurrency: calling CGO from multiple goroutines\n\n## Code Example\n```go\n// Go binding sketch (not full code)\npackage cgowrap\nimport \"C\"\n// Greet wraps C.greet and converts result to Go string with error handling\nfunc Greet(name string) (string, error) { /* omitted for brevity in answer */ }\n```\n\n## Follow-up Questions\n- How would you model ownership if C returns allocated memory for reuse?\n- How can you detect and prevent use-after-free in long-lived Go values?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","MongoDB","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T18:32:47.654Z","createdAt":"2026-01-12T18:32:47.654Z"}],"subChannels":["general"],"companies":["Adobe","Anthropic","Bloomberg","Coinbase","Goldman Sachs","Google","Hashicorp","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Netflix","Oracle","PayPal","Snap","Snowflake","Tesla","Twitter","Two Sigma"],"stats":{"total":11,"beginner":5,"intermediate":4,"advanced":2,"newThisWeek":11}}