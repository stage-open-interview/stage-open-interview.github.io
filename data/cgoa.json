{"questions":[{"id":"q-1026","question":"Design a CGOA wrapper for a C library that provides two symbols: int* generate_seq(int n) which allocates an int array of length n via malloc filled with 0..n-1, and void free_seq(int* p) to free it. Provide the C header, the Go binding using CGO, and a small Go program that concurrently requests arrays of sizes 4 and 8, validates contents, and frees them. Include exact build steps?","answer":"Use C to own the allocated memory and expose two symbols: generate_seq and free_seq. Go binds via CGO, calling into C to obtain a raw *C.int and later frees it with free_seq. Two goroutines race-safe ","explanation":"## Why This Is Asked\nTests memory ownership and boundary safety when mixing Go and C. Candidates must implement correct allocation/free on the C side and valid binding in Go, ensuring no Go pointers cross into C and that allocations are freed.\n\n## Key Concepts\n- CGO memory ownership across boundaries\n- CGO pointer rules: avoid passing Go pointers to C\n- Concurrency safety with CGO calls\n- Leak prevention via paired malloc/free\n\n## Code Example\n```c\n// cg_seq.h\nint* generate_seq(int n);\nvoid free_seq(int* p);\n```\n\n```go\n// go_bind.go\n/*\n#cgo CFLAGS: -I.\n#include \"cg_seq.h\"\n*/\nimport \"C\"\n\nfunc GenerateSeq(n int) *C.int { return C.generate_seq(C.int(n)) }\nfunc FreeSeq(p *C.int) { C.free_seq(p) }\n```\n\n## Follow-up Questions\n- How would you return the length safely alongside the pointer?\n- How to detect leaks in tests with tools like valgrind or Go race detector?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Coinbase","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T19:37:48.180Z","createdAt":"2026-01-12T19:37:48.180Z"},{"id":"q-1099","question":"Given a C library with an asynchronous API: \n\n- void run_async(const char* input, void (*cb)(int status, const char* data, void* user), void* user);\n\nwhere the callback runs on a worker thread and data is malloc-allocated or NULL on error. Design a CGO-based Go wrapper that exposes RunAsync(input string, cb func(status int, data string, err error)). The wrapper must: manage the Go callback safely across C boundaries, free C data, map non-zero status to errors, and handle thread attachment; provide header + binding + minimal test harness to demonstrate safety?","answer":"Design a CGO bridge that stores per-call state with a Go callback and uses a cgo.Handle to pass a Go function across the boundary. Implement RunAsync(input string, cb func(int, string, error)) which c","explanation":"## Why This Is Asked\n\nTests ability to bridge asynchronous C callbacks to Go safely, including memory ownership, cross-thread invocation, and error mapping. It also checks how well the candidate uses cgo.Handle, runtime.LockOSThread, and memory management to avoid leaks or panics crossing boundaries.\n\n## Key Concepts\n\n- CGO callback bridging across threads\n- Memory ownership of malloc'd C strings\n- cgo.Handle lifetime management\n- runtime.LockOSThread and thread-affinity considerations\n- Error translation from C to Go\n\n## Code Example\n\n```javascript\n// Header (C)\n#include <stdlib.h>\nvoid run_async(const char* input, void (*cb)(int status, const char* data, void* user), void* user);\n```\n\n```javascript\n// Go binding sketch (CGO)\n// This is a conceptual outline; actual code would be Go with //export callbacks.\n```\n\n## Follow-up Questions\n\n- How would you implement cancellation and timeouts?\n- How would you test for memory leaks and callback ordering under contention?","diagram":"flowchart TD\n  A[Go API calls RunAsync] --> B[C wrapper calls run_async]\n  B --> C[Worker thread executes callback]\n  C --> D[Callback passes status/data to Go via handle]\n  D --> E[Go callback invoked]\n  E --> F[Data freed and handle cleared]","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","LinkedIn","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T22:31:14.811Z","createdAt":"2026-01-12T22:31:14.811Z"},{"id":"q-1207","question":"Design a CGO bridge for a C EventLib that exposes a function: void register_event_source(int stream_id, void (*cb)(int, const char*)); void start_event_loop(); Build a Go binding that lets two independent streams subscribe and receive events via a single exported Go callback, using a C shim to bridge into Go. Describe memory management and thread-safety; provide header, Go binding, and a small Go program demonstrating two streams; include build steps?","answer":"Use a single C callback bridged to Go via an exported function; maintain per-stream state in a mutex-protected map keyed by stream_id, storing a Go callback. Register a C shim that calls the Go bridge","explanation":"## Why This Is Asked\nExplores cross-language callbacks, CGO lifecycle, and thread-safety. The candidate must design a robust bridge rather than a naive callback.\n\n## Key Concepts\n- CGO cross-language callbacks\n- cgo.Handle for GC control\n- Thread-safety with mutex maps\n- Exported Go callbacks and C shims\n\n## Code Example\n```go\npackage main\n/*\n#include \"eventlib.h\"\n\n// Go callback exported\nextern void goEventBridge(int stream_id, const char* msg);\n\nstatic void shim_cb(int sid, const char* msg){\n    goEventBridge(sid, msg);\n}\n*/\nimport \"C\"\nimport (\n  \"runtime\"\n  \"sync\"\n)\n\ntype Callback func(int, string)\n\nvar (\n  mu sync.RWMutex\n  handlers = make(map[int]Callback)\n)\n\n// RegisterStream registers a Go callback for a stream\nfunc RegisterStream(id int, cb Callback) {\n  mu.Lock()\n  handlers[id] = cb\n  mu.Unlock()\n  C.register_event_source(C.int(id), C.shim_cb)\n  runtime.KeepAlive(cb)\n}\n\n//export goEventBridge\nfunc goEventBridge(s C.int, msg *C.char) {\n  mu.RLock()\n  cb := handlers[int(s)]\n  mu.RUnlock()\n  if cb != nil {\n    cb(int(s), C.GoString(msg))\n  }\n}\n```\n\n## Follow-up Questions\n- How would you stop a stream and clean up without races?\n- How would you propagate C-side errors back to Go?","diagram":"flowchart TD\n  A[Subscriber registers streams] --> B[Shim cb in EventLib]\n  B --> C[C thread emits event]\n  C --> D[goEventBridge is called]\n  D --> E[Go callback invoked]","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Twitter","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T04:56:17.642Z","createdAt":"2026-01-13T04:56:17.642Z"},{"id":"q-1235","question":"Implement a CGOA binding for an opaque C Counter handle. API: typedef struct Counter Counter; Counter* CounterNew(int); void CounterInc(Counter*, int); int CounterValue(Counter*); void CounterFree(Counter*); In Go wrap as type Counter with NewCounter, Inc, Value, Close. Show two goroutines each creating its own Counter, incrementing independently, and printing values to verify isolation and no data races. Include header, binding, and a minimal program with build steps?","answer":"Implement a CGOA binding for an opaque C Counter handle. API: typedef struct Counter Counter; Counter* CounterNew(int); void CounterInc(Counter*, int); int CounterValue(Counter*); void CounterFree(Cou","explanation":"## Why This Is Asked\n\nProbes CGO bindings to an opaque C type, per-instance memory management, and basic concurrency isolation.\n\n## Key Concepts\n\n- CGO binding for opaque C types\n- Manual memory management (CounterNew/CounterFree)\n- Concurrency: per-instance state and data-race awareness\n\n## Code Example\n\n```c\n// C header\ntypedef struct Counter Counter;\nCounter* CounterNew(int initial);\nvoid CounterInc(Counter*, int delta);\nint CounterValue(Counter*);\nvoid CounterFree(Counter*);\n```\n\n```go\n// Go binding snippet\n// #include \\\"counter.h\\\"\nimport \"C\"\n\ntype Counter struct{ c *C.Counter }\n\nfunc NewCounter(init int) *Counter {\n  c := C.CounterNew(C.int(init))\n  return &Counter{c: c}\n}\n\nfunc (ctr *Counter) Inc(delta int) {\n  C.CounterInc(ctr.c, C.int(delta))\n}\n\nfunc (ctr *Counter) Value() int {\n  return int(C.CounterValue(ctr.c))\n}\n\nfunc (ctr *Counter) Close() {\n  C.CounterFree(ctr.c)\n}\n```\n\n## Follow-up Questions\n\n- How would you ensure thread-safety when multiple goroutines manipulate distinct Counter instances?\n- What changes if Counter access becomes shared across goroutines?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Instacart","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T06:33:00.575Z","createdAt":"2026-01-13T06:33:00.575Z"},{"id":"q-1294","question":"Implement a CGOA bridge that lets C trigger a Go callback asynchronously when an external sensor fires events. Provide a C header and stub, a CGO binding in Go that registers a Go callback and routes events through an exported Go function, and a safe cleanup mechanism to release resources when producers stop?","answer":"Design approach: Go registers a callback, wraps it with runtime/cgo.NewHandle(cb) and passes the handle’s uintptr to C. An exported bridge function (//export goCallbackBridge) is invoked by C with the","explanation":"## Why This Is Asked\nCGOA bridges are common in practice when external C libraries need Go callbacks. This tests safe lifetimes, non-Go-pointer transfer, and cross-language threading.\n\n## Key Concepts\n- runtime/cgo.Handle\n- //exported Go functions\n- passing uintptr_t to C\n- proper cleanup and synchronization\n\n## Code Example\n```c\n/* header */\nvoid register_callback(void (*cb)(int, void*), void* ctx);\n```\n\n## Follow-up Questions\n- How to avoid deadlocks when callbacks re-enter?\n- How to handle panics in the Go callback across threads?","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Lyft","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T08:40:37.001Z","createdAt":"2026-01-13T08:40:37.001Z"},{"id":"q-1371","question":"Implement a CGO binding for a C function that computes sum and mean of an int array. Provide header and C source with int compute_stats(const int* values, size_t n, long long* sum, double* mean); 0 on success, -1 if n==0. In Go, implement ComputeStats(values []int) (int64, float64, error) calling the C function via CGO, converting types. Add a small main.go that runs two goroutines, each calling ComputeStats on its own slice. Include build steps?","answer":"Provide a header and C source implementing compute_stats, returning 0 on success and -1 on error (n==0). In Go, implement ComputeStats(values []int) (int64, float64, error) calling the C function via ","explanation":"## Why This Is Asked\nTests bridging Go and C boundaries, including memory handling, error propagation, and concurrency.\n\n## Key Concepts\n- CGO bindings and headers\n- Go to C array conversions\n- Translating C errors to Go errors\n- Concurrency across CGO calls\n- Build considerations (CGO enabled)\n\n## Code Example\n```c\n// stats.h\nint compute_stats(const int* values, size_t n, long long* sum, double* mean);\n```\n```c\n// stats.c\n#include \"stats.h\"\n#include <stddef.h>\nint compute_stats(const int* values, size_t n, long long* sum, double* mean) {\n    if (n == 0) return -1;\n    long long s = 0;\n    for (size_t i = 0; i < n; ++i) s += values[i];\n    *sum = s;\n    *mean = (double)s / (double)n;\n    return 0;\n}\n```\n```go\n// stats.go\npackage main\n/*\n#cgo CFLAGS: -O2\n#include \"stats.h\"\n*/\nimport \"C\"\nimport (\n  \"fmt\"\n)\n\nfunc ComputeStats(values []int) (int64, float64, error) {\n  if len(values) == 0 { return 0, 0, fmt.Errorf(\"empty input\") }\n  cvals := make([]C.int, len(values))\n  for i, v := range values { cvals[i] = C.int(v) }\n  var sum C.longlong\n  var mean C.double\n  if res := C.compute_stats((*C.int)(&cvals[0]), C.size_t(len(cvals)), &sum, &mean); res != 0 {\n    return 0, 0, fmt.Errorf(\"C error\")\n  }\n  return int64(sum), float64(mean), nil\n}\n```\n\n## Follow-up Questions\n- How would you handle larger inputs or streaming data?\n- How would you extend to support multiple concurrent calls safely?\n","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T14:35:20.730Z","createdAt":"2026-01-13T14:35:20.730Z"},{"id":"q-1396","question":"Implement a CGO bridge for a C event source that runs callbacks on its own threads and delivers events to Go via a callback of the form void cb(int code, const char* msg, void* ctx). Expose StartEventSource(cb, ctx) -> handle and StopEventSource(handle). Provide a C header, the Go binding using CGO (with a Go-exported callback and pointer-ownership strategy), and a small Go program that starts two sources and validates receipt of events through a single Go channel. Include build steps?","answer":"Design a CGO bridge where C emits events on its own threads and calls back into Go with a signature void cb(int code, const char* msg, void* ctx). Expose StartEventSource(cb, ctx) -> handle and StopEv","explanation":"## Why This Is Asked\nTests ability to model cross-language ownership, thread safety, and lifecycle across CGO.\n\n## Key Concepts\n- CGO callback exports and Go pointer lifetimes\n- cgo.Handle and runtime.KeepAlive\n- Cross-thread callback safety and event serialization\n- Lifecycle management of C resources across Go\n\n## Code Example\n\n```c\n// header: event_source.h\ntypedef void (*cb_t)(int code, const char* msg, void* ctx);\nint StartEventSource(cb_t cb, void* ctx);\nvoid StopEventSource(int handle);\n```\n\n```go\n// binding.go\npackage main\n// CGO binding sketch showing an exported callback and lifecycle wiring\n```\n\n## Follow-up Questions\n- How would you ensure ctx isn't garbage-collected while C holds it?\n- How would you handle errors from C that should propagate to Go?\n- How would you test for deadlocks or callback reentrancy across the boundary?\n","diagram":"flowchart TD\nA[Go Start] --> B[C: register callback]\nB --> C[Events on C threads]\nC --> D[Go: enqueue to channel]\nD --> E[Go consumer reads]","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","PayPal","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T15:37:15.257Z","createdAt":"2026-01-13T15:37:15.257Z"},{"id":"q-1548","question":"Implement a CGO wrapper for a C library that registers a Go callback and invokes it from a C event loop. Provide a C header and implementation for: - void register_callback(void (*cb)(int)); - void trigger(int value); Write Go bindings using CGO to pass a Go function as the callback, ensuring safe cross-language invocation, correct Go runtime considerations, and demonstrate with two goroutines each registering and triggering events. Include build steps?","answer":"A robust solution defines a C wrapper that stores a callback function pointer, a register_callback function to install it, and a trigger function that invokes it. In Go, export goCallback and pass it to C using CGO, ensuring proper cross-language invocation with runtime safety considerations.","explanation":"## Why This Is Asked\nThis question tests CGO cross-language callback design, memory management, and thread-safety in a beginner-friendly but realistic setup that mirrors real-world integration scenarios.\n\n## Key Concepts\n- CGO interoperability and function pointer management\n- Go exported callbacks with //export directive\n- Go runtime and thread-safety compliance\n- Lifetime management using KeepAlive and avoiding premature GC\n\n## Code Example\n```c\n// header\nvoid register_callback(void (*cb)(int));\nvoid trigger(int value);\n```\n\n```go\n//go:export goCallback\nfunc goCallback(v C.int) {\n  // handle","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Meta","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T06:30:39.820Z","createdAt":"2026-01-13T21:37:30.342Z"},{"id":"q-1659","question":"Design a CGOA wrapper to let a Go function be registered as a callback for a C API that emits events asynchronously on external threads. The C API exposes: typedef void (*cb_t)(int eventCode, void* context); void register_cb(cb_t cb, void* ctx); void emit_event(int code); Implement header, CGO binding, and a minimal program that registers a Go callback, triggers an event, and exits safely. Include build steps?","answer":"Use a trampoline with a CGO handle. Store the Go callback in a map, obtain a CGO handle, and pass the handle as ctx to register_cb. Export a Go function with //export that C calls; it looks up the han","explanation":"## Why This Is Asked\nTests ability to bridge Go and C with callbacks across threads, a common real-world CGO pitfall. It probes lifetime management, thread-safety, and CGO pointer rules.\n\n## Key Concepts\n- CGO callback lifetimes and //export limitations\n- cg oHandle usage to store Go values for C callbacks\n- Thread-safety: mutexes and safe dispatch of callbacks\n- Proper cleanup to avoid leaks when unregistering\n\n## Code Example\n```javascript\n// C header (capi.h)\ntypedef void (*cb_t)(int eventCode, void* context);\nvoid register_cb(cb_t cb, void* ctx);\nvoid emit_event(int code);\n```\n\n```javascript\n// Go binding (cgowa/cgo) - simplified\npackage main\n/*\n#include \"capi.h\"\n*/\nimport \"C\"\nimport (\n  \"sync\"\n  \"unsafe\"\n)\n\nvar (\n  mu       sync.Mutex\n  cbStore  = map[uintptr]func(int){}\n  nextKey  uintptr = 1\n)\n\n//export goCallback\nfunc goCallback(event C.int, ctx unsafe.Pointer) {\n  mu.Lock()\n  if f, ok := cbStore[uintptr(ctx)]; ok {\n    f(int(event))\n  }\n  mu.Unlock()\n}\n\nfunc registerCallback(f func(int)) unsafe.Pointer {\n  mu.Lock()\n  key := nextKey\n  nextKey++\n  cbStore[key] = f\n  mu.Unlock()\n  // pass key as ctx to C\n  return unsafe.Pointer(uintptr(key))\n}\n```\n\n```javascript\n// Minimal usage (main.go)\npackage main\nimport (\n  \"C\"\n  \"fmt\"\n)\nfunc main(){\n  cb := func(e int){ fmt.Println(\"event:\", e) }\n  ctx := registerCallback(cb)\n  C.emit_event(42) // would trigger goCallback with ctx\n  _ = ctx\n}\n```\n\n## Follow-up Questions\n- How would you extend this to support multiple concurrent Go callbacks safely?\n- How do you handle panics in Go callbacks so they don’t crash the C caller or CGO bridge?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Scale Ai","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T05:42:28.056Z","createdAt":"2026-01-14T05:42:28.056Z"},{"id":"q-1758","question":"You have a C library exposing void start_event_loop(void (*cb)(int event, void* ctx), void* ctx) and void stop_event_loop(). Implement a CGO bridge in Go that safely delivers events to per-stream Go handlers without passing Go pointers to C, supports multiple concurrent streams, and clean teardown. Provide C header, a thin C wrapper to register a per-stream callback, and a Go binding plus a small program that starts two streams and stops them?","answer":"Design a CGO bridge for a C event loop that calls a callback from a dedicated thread into Go. Do not pass Go pointers to C; implement a per-stream registry keyed by an opaque handle, use a thread-safe","explanation":"## Why This Is Asked\nTests deep CGO understanding: cross-language callbacks, Go pointer rules, and per-stream lifecycle.\n\n## Key Concepts\n- CGO pointer safety and Go memory management\n- Cross-thread callbacks and event dispatch\n- Per-stream registries and lifecycle management\n\n## Code Example\n```javascript\n// C header and Go binding would be provided here in a real task to illustrate wrappers and registration\n```\n\n## Follow-up Questions\n- How would you handle backpressure when the Go side lags behind C callbacks?\n- How would you extend to support cancellation contexts for individual streams?","diagram":"flowchart TD\n  A[Start] --> B[Bridge Created]\n  B --> C[Streams Registered]\n  C --> D[Events Enqueued]\n  D --> E[Go Handlers Dispatch]\n  E --> F[Teardown]\n  F --> G[Stop Loop]","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Netflix","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T09:45:25.745Z","createdAt":"2026-01-14T09:45:25.745Z"},{"id":"q-1815","question":"Design and implement a CGOA bridge for a C streaming library that emits integers via a callback. Expose a Go API StartStream() (<-chan int, func Stop()) using cgo.Handle to pass the Go-side context. Ensure thread-safe delivery of values to Go, proper cleanup with finalizers, and robust error reporting across the boundary. Provide C header, Go binding, and a minimal caller?","answer":"Propose a CGO wrapper that uses a C function to register a stream callback, with a Go channel wrapped by a cgo.Handle as the ctx. A single C callback pushes values into the Go channel via an exported ","explanation":"## Why This Is Asked\nTests ability to bridge Go and C safely in a streaming, callback-driven API, including memory ownership, callbacks from C into Go, and lifecycle handling.\n\n## Key Concepts\n- CGO and cgo.Handle usage\n- Cross-language callbacks and goroutine scheduling\n- Memory ownership and finalizers\n- Error handling across language boundaries\n\n## Code Example\n```c\ntypedef void (*cb_t)(int value, void* ctx);\nvoid register_stream(cb_t cb, void* ctx);\nvoid start_stream();\nvoid stop_stream();\n```\n```go\n// CGO binding sketch\npackage main\n/*\n#include <stdint.h>\n#include \"stream.h\"\nstatic void go_cb(int v, void* ctx);\n*/\nimport \"C\"\nimport (\n  \"runtime\"\n  \"runtime/cgo\"\n)\n\n//export go_cb\nfunc go_cb(v C.int, ctx unsafe.Pointer) {\n  // forward to Go channel via stored handle\n}\n\nfunc StartStream() (<-chan int, func()) {\n  // wrap ctx in a handle and start streaming; return stop function\n  ch := make(chan int)\n  h := cgo.NewHandle(ch)\n  // pass h.ptr to C as ctx; set up finalizer to ensure cleanup\n  runtime.SetFinalizer(&ch, func(*chan int) { /* cleanup */ })\n  // start_stream and callback wiring...\n  return ch, func() { /* stop and release handle */ }\n}\n```","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Google","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T11:49:06.568Z","createdAt":"2026-01-14T11:49:06.568Z"},{"id":"q-1845","question":"Implement a CGOA wrapper around a C function that returns a heap-allocated string: char* greet(const char* name). Provide a header with greet and void free_string(char*). Write a Go binding using CGO to call greet from multiple goroutines and free the result with free_string to avoid leaks. Include the header, a Go binding file, and a small Go program that calls greet(\"Alice\"), greet(\"Bob\"), greet(\"Carol\") concurrently and prints results. Include build steps?","answer":"Provide the C header greet.h with: char* greet(const char* name); void free_string(char* s); Then implement a C source that allocates via malloc and returns the string. In Go, use // #include \\\"greet.","explanation":"## Why This Is Asked\nTests memory ownership across Go and C, and CGO interaction with heap-allocated strings.\n\n## Key Concepts\n- CGO string handling and C memory management\n- Ownership transfer and explicit frees\n- Concurrency safety when crossing language boundaries\n\n## Code Example\n```c\n// greet.h\nchar* greet(const char* name);\nvoid free_string(char* s);\n```\n```c\n// greet.c\n#include <stdlib.h>\n#include <string.h>\n#include \"greet.h\"\nchar* greet(const char* name){ const char* prefix = \"Hello, \"; size_t len = strlen(prefix) + strlen(name) + 2; char* out = (char*)malloc(len); if(!out) return NULL; strcpy(out, prefix); strcat(out, name); return out; }\n```\n```go\n// greet.go\npackage main\nimport \"C\"\nimport (\n  \"fmt\" \n  \"unsafe\"\n)\nfunc greetGo(name string) string {\n  cstr := C.CString(name)\n  defer C.free(unsafe.Pointer(cstr))\n  r := C.greet(cstr)\n  s := C.GoString(r)\n  C.free_string(r)\n  return s\n}\nfunc main() {\n  // spawn 3 goroutines and print\n  // simplified in actual implementation\n  _ = greetGo\n  fmt.Println(greetGo(\"Alice\"))\n  fmt.Println(greetGo(\"Bob\"))\n  fmt.Println(greetGo(\"Carol\"))\n}\n```\n\n## Follow-up Questions\n- How would you extend to support batch processing with a single allocation?\n- How to verify no memory leaks with Go's tests?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","NVIDIA","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T13:29:41.015Z","createdAt":"2026-01-14T13:29:41.015Z"},{"id":"q-1910","question":"Design a CGOA exercise: Create a C header exposing void scale_and_offset(const float* input, int n, float* output, float scale, float offset); Implement a Go binding using CGO that wraps ScaleAndOffset and returns a slice of float results. Provide a minimal C implementation, a Go binding, and a short Go program that launches two goroutines, each feeding distinct input arrays to scale_and_offset concurrently? Include build steps?","answer":"Implementation approach: C header declares void scale_and_offset(const float* input, int n, float* output, float scale, float offset); Go binds via import \"C\" and a wrapper function ScaleAndOffset(in ","explanation":"## Why This Is Asked\nTests CGO memory handling, cross-language data transfer, and concurrency safety in a realistic wrapper.\n\n## Key Concepts\n- CGO data marshaling between Go and C\n- Avoiding Go pointers in C calls\n- Memory management with malloc/free across boundaries\n- Concurrency safety in native calls via goroutines\n\n## Code Example\n```javascript\n// Example glue code in Go to start CGO wrapper (conceptual)\n```\n\n## Follow-up Questions\n- How would you extend to error reporting from C to Go?\n- How to handle different numeric types and alignment across architectures?\n","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Instacart","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T16:54:29.264Z","createdAt":"2026-01-14T16:54:29.264Z"},{"id":"q-1993","question":"Design a CGO bridge for a C API that uses a progress callback and supports cancelable work. The C API exposes: typedef void (*progress_cb)(int percent, void* user); void register_progress(progress_cb cb, void* user); int do_work(int steps); The callback may be invoked on worker threads. Implement: (1) a C header that defines the callback type and registration; (2) a Go binding using CGO that exposes a Go channel-based Progress stream; (3) a small Go program that starts do_work in a goroutine and prints progress, with a context-based cancellation. Ensure memory and lifecycle safety across boundaries?","answer":"Bridge the C progress callback to Go with per-work handles and a Go channel; export a trampoline in C that forwards (percent, user) to a Go receiver using a stable Go-side map keyed by an opaque handl","explanation":"## Why This Is Asked\nTests cross-language callback lifecycles, CGO invocation rules, and cancellation semantics by streaming progress from C to Go with lifecycle management.\n\n## Key Concepts\n- CGO callback lifetimes and trampolines\n- Safe passing of user data without Go pointers into C\n- Per-work handles and cleanup\n- Streaming events via Go channels\n- Context-based cancellation and unregistering\n\n## Code Example\n```c\n// header: progress.h\ntypedef void (*progress_cb)(int percent, void* user);\nvoid register_progress(progress_cb cb, void* user);\nint do_work(int steps);\n```\n\n```go\n// binding.go\npackage progress\n/*\n#include \"progress.h\"\n*/\nimport \"C\"\n\n// Binding scaffolding to illustrate approach\n```\n\n```go\n// usage.go\npackage main\nimport (\n  \"context\"\n  \"fmt\"\n  \"time\"\n  p \"your/module/path/progress\"\n)\nfunc main() {\n  ctx, cancel := context.WithCancel(context.Background())\n  defer cancel()\n  ch := make(chan int)\n  // Bind a CGO callback to push progress into ch; ensure cleanup on cancel\n  go func(){ C.do_work(C.int(100)) }()\n  for {\n    select {\n    case v := <-ch:\n      fmt.Println(\"progress\", v)\n    case <-ctx.Done():\n      return\n    }\n  }\n}\n```\n\n## Follow-up Questions\n- How would you multiplex progress from multiple concurrent tasks?\n- How would you test cancellation and error propagation in this wrapper?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Google","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T19:49:17.801Z","createdAt":"2026-01-14T19:49:17.801Z"},{"id":"q-2011","question":"Implement a beginner CGO binding that exposes a C API void compute_stats(const double* data, size_t n, double* mean, double* stddev) to Go. Provide a C header, a Go binding using CGO, and a small Go program that launches 4 goroutines, each calling ComputeStats on its own data slice concurrently. Ensure memory safety, zero-copy access where possible, and that data races are avoided. Include explicit build steps?","answer":"Bind a C API void compute_stats(const double* data, size_t n, double* mean, double* stddev) to Go via CGO. Use a header and a Go wrapper ComputeStats(data []float64) (mean, stddev float64) that checks","explanation":"## Why This Is Asked\nTests ability to design safe CGO bindings that move data between Go and C, ensure memory safety, and reason about concurrency.\n\n## Key Concepts\n- CGO bindings and header inclusion\n- Memory ownership and avoiding copies\n- Passing slices to C safely with unsafe\n- Concurrency: goroutines calling C functions without races\n- Error handling for empty inputs and C errors\n\n## Code Example\n```c\n#ifndef STATS_H\n#define STATS_H\nvoid compute_stats(const double* data, size_t n, double* mean, double* stddev);\n#endif\n```\n\n```go\npackage cgobind\n\n/*\n#include \"stats.h\"\n*/\nimport \"C\"\nimport (\n  \"unsafe\"\n)\n\nfunc ComputeStats(data []float64) (mean, stddev float64) {\n  if len(data) == 0 {\n    return 0, 0\n  }\n  var cMean, cStddev C.double\n  ptr := (*C.double)(unsafe.Pointer(&data[0]))\n  C.compute_stats(ptr, C.size_t(len(data)), &cMean, &cStddev)\n  return float64(cMean), float64(cStddev)\n}\n```\n\n## Follow-up Questions\n- How would you adapt for non-contiguous data or different memory layouts?\n- What about error propagation if the C function encounters NaN values?","diagram":"flowchart TD\n  Go --> CGO_Wrapper\n  CGO_Wrapper --> C_Function\n  C_Function --> Go_Return\n  Go_Return --> Goroutines","difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Meta","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T20:49:43.279Z","createdAt":"2026-01-14T20:49:43.279Z"},{"id":"q-2036","question":"Your C library exposes a function int start_task(int task_id, void (*progress_cb)(int, const char*)); void stop_task(int task_id); The callback is invoked from worker threads and passes a progress value and a C string message. Design a CGO-based Go binding that allows registering a Go callback per task, safely translates C strings to Go strings, guarantees thread-safe delivery of progress events to Go, and supports cancellation via stop_task while ensuring resources are freed. Include a header, the Go binding, and a minimal Go program launching two concurrent tasks with per-task callbacks. Provide build steps?","answer":"Register per-task Go callbacks in a mutex-protected map[int]func(int,string). Create a Go–C bridge: assign a unique task handle, store the Go closure, pass the handle to C as an int with a static C progress callback. Export progress events through CGO using C.CString/C.GoString translation with thread-safe delivery via channels or sync primitives, ensuring proper cleanup of allocated C strings and removal of callbacks when tasks are cancelled or completed.","explanation":"Why This Is Asked\n- Tests CGO callback patterns, memory safety, and concurrency\n- Exercises safe crossing of Go/C without pointer sharing\n- Validates resource management and cancellation in real workloads\n\nKey Concepts\n- CGO callbacks across threads\n- Go closure lifetimes with C handles\n- Safe string conversion and memory management\n- Thread-safe event delivery and resource cleanup\n\nCode Example\n```c\n// C header\nint start_task(int task_id, void (*progress_cb)(int, const char*));\nvoid stop_task(int task_id);\n```\n\nFollow-up Questions\n- How would you handle panics in the Go callback across CGO?\n- What strategies would you use to prevent memory leaks in long-running tasks?\n- How would you implement timeout handling for stuck tasks?","diagram":"flowchart TD\nA(Task Start) --> B(Register Callback)\nB --> C(C Bridge Invokes Go Callback)\nC --> D(Go Handler Executes)\nD --> E(Stop Task)\n","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","NVIDIA","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T06:15:11.070Z","createdAt":"2026-01-14T21:41:08.651Z"},{"id":"q-2185","question":"Design a CGOA binding for a C library exposing a thread-safe ring buffer with multiple producers and a single consumer. Provide a C header with:\n- typedef struct ring_buffer ring_buffer;\n- ring_buffer* rb_new(size_t capacity);\n- void rb_free(ring_buffer*);\n- int rb_push(ring_buffer*, int value);\n- int rb_pop(ring_buffer*, int* value); // 0 on success, -1 if empty\nImplement a Go binding using CGO that wraps rb_push/rb_pop, exposing a Go type RingBuffer with New, Push, Pop. Include a small demo with 4 producers and 2 consumers and build steps?","answer":"An ideal answer shows: an opaque C ring_buffer with an internal mutex; rb_push/rb_pop lock, modify, unlock. Go wraps *ring_buffer via CGO, exposing New/Push/Pop with ownership via rb_new/rb_free. Demo","explanation":"## Why This Is Asked\nTests CGO boundary design, memory ownership, and real-world thread-safety across language fences.\n\n## Key Concepts\n- CGO calls and opaque pointers\n- Thread-safety via internal mutexes in C\n- Ownership lifecycle across Go/C\n- Avoiding data races when sharing data across CGO\n\n## Code Example\n```c\n// header-like sketch\ntypedef struct ring_buffer ring_buffer;\nring_buffer* rb_new(size_t capacity);\nvoid rb_free(ring_buffer* rb);\nint rb_push(ring_buffer* rb, int v);\nint rb_pop(ring_buffer* rb, int* v);\n```\n```\n\n## Follow-up Questions\n- How would you adapt to multiple consumers? How to handle blocking pops? \n- How would you test memory ownership and leak scenarios across CGO boundaries?","diagram":"flowchart TD\n  GoApp --> CGOWrapper\n  CGOWrapper --> CLayer\n  CLayer --> RingBufferState\n  RingBufferState --> GoApp","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Apple","Discord"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T06:51:54.148Z","createdAt":"2026-01-15T06:51:54.148Z"},{"id":"q-2263","question":"Design a CGOA binding for a C library function that registers a callback and a context pointer. Create a Go binding using CGO that lets Go pass a Go function as the callback, supports multiple concurrent subscriptions, and is memory-safe with proper cleanup. Provide the C API, the Go binding, and a short Go snippet showing two subscriptions and callbacks concurrently?","answer":"Use a trampoline approach: export a Go function goEventCb that the C code calls, and a per-subscription registry mapping a void* ctx to a Go func(int). On Subscribe, allocate a stable ctx handle for t","explanation":"## Why This Is Asked\nTests understanding of cross-language callbacks, memory management, and lifecycle handling in CGO bindings, including safety around Go pointers from C.\n\n## Key Concepts\n- CGO callback lifecycles and trampolines\n- Managing Go function pointers from C via a registry\n- Per-subscription context lifetimes and cleanup\n- Thread-safety and avoiding GC hazards during C callbacks\n\n## Code Example\n```javascript\n/* C Header (wrapper.h) */\ntypedef void (*cb_t)(int, void*);\ntypedef struct { cb_t cb; void* ctx; } reg_t;\nvoid subscribe(reg_t* r, void* ctx);\n\n/* Go Binding (wrapper.go) */\npackage main\n/*\n#include \"wrapper.h\"\n*/\nimport \"C\"\nimport (\n  \"runtime\"\n  \"sync\"\n  \"unsafe\"\n)\nvar reg sync.Map // ctx -> func(int)\n//export goEventCb\nfunc goEventCb(event C.int, ctx unsafe.Pointer) {\n  if v, ok := reg.Load(ctx); ok {\n    if f, ok := v.(func(int)); ok {\n      f(int(event))\n    }\n  }\n}\nfunc Subscribe(f func(int)) unsafe.Pointer {\n  ctx := C.malloc(C.size_t(8))\n  reg.Store(ctx, f)\n  C.subscribe((*C.reg_t)(unsafe.Pointer(&C.reg_t{cb: (*C.cb_t)(C.goEventCb), ctx: ctx})), ctx)\n  runtime.KeepAlive(f)\n  return ctx\n}\n```\n\n## Follow-up Questions\n- How would you handle panics in Go callbacks invoked from C?\n- How would you support cancellation and resource reuse for subscriptions?","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Lyft","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T09:47:27.284Z","createdAt":"2026-01-15T09:47:27.284Z"},{"id":"q-2305","question":"## Question\n\n**CGO Binding: In-Place String Reversal with Concurrency**\n\nYou have a C function:\n```c\nvoid reverse_inplace(char* s);\n```\nProvide:\n- A C header exposing the signature\n- A Go binding using CGO implementing ReverseGo(s string) string\n- A short Go program that launches two goroutines calling ReverseGo on different inputs\n- Build steps\n\nEnd with a question mark?","answer":"Use CGO to wrap reverse_inplace with a Go helper that copies s to a C buffer (C.CString), defers C.free, calls C.reverse_inplace, and returns C.GoString. In main, spawn two goroutines with distinct st","explanation":"## Why This Is Asked\n\nTests memory management and safe interop between Go and C via CGO, focusing on in-place mutation and per-call buffers to avoid data races.\n\n## Key Concepts\n\n- CGO memory management and C string interop\n- Converting between Go string and C string\n- Concurrency with goroutines and CGO\n\n## Code Example\n\n```c\n// reverse.h\nvoid reverse_inplace(char* s);\n```\n\n```go\n// binding.go\n// #cgo CFLAGS: -O2\n// #include \"reverse.h\"\nimport \"C\"\nimport \"unsafe\"\n\nfunc ReverseGo(s string) string {\n    c := C.CString(s)\n    defer C.free(unsafe.Pointer(c))\n    C.reverse_inplace(c)\n    return C.GoString(c)\n}\n```\n\n## Follow-up Questions\n\n- How would you handle errors if reverse_inplace had error codes?\n- How would you validate thread-safety across different CGO configurations?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Netflix","Snowflake","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T11:33:39.782Z","createdAt":"2026-01-15T11:33:39.782Z"},{"id":"q-2373","question":"Implement a CGO binding for a C API that processes an int array and reports results via a callback. The C API: typedef void (*cb_t)(int result, void* ctx); void sum_with_callback(const int* data, size_t n, cb_t cb, void* ctx); Provide a C header exposing the signature, a Go binding using CGO that offers func SumWithCallback(data []int, cb func(int)) error, and a short Go program that concurrently calls SumWithCallback from multiple goroutines. Include build steps and CGO thread-safety and memory-management considerations. End with a question mark?","answer":"Design a CGO wrapper for a C API that processes an array and reports the result via a callback. Expose the C types and function in a header, implement a Go binding using //export to expose a Go callba","explanation":"## Why This Is Asked\nTests CGO callback bridges, memory ownership, and thread-safety when Go calls into C and C calls back into Go.\n\n## Key Concepts\n- CGO callback export and cgo rules\n- Memory ownership and avoiding GC lifetimes crossing boundaries\n- Thread-safety with concurrent Go calls into C\n- Safe passing of Go pointers via context handles\n\n## Code Example\n```c\n// header\ntypedef void (*cb_t)(int result, void* ctx);\nvoid sum_with_callback(const int* data, size_t n, cb_t cb, void* ctx);\n```\n\n```go\n// binding sketch\n//export go_cb\nfunc go_cb(res C.int, ctx unsafe.Pointer) { /* translate to Go */ }\n```\n\n## Follow-up Questions\n- How would you handle panics in the Go callback?\n- How do you ensure callbacks are not invoked after the Go GC moves data?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Hugging Face","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T15:40:05.063Z","createdAt":"2026-01-15T15:40:05.063Z"},{"id":"q-2478","question":"Implement a CGOA binding for a C matrix-vector multiply. Provide matvec.h and a minimal matvec.c implementing void matvec(const double* A, const double* x, double* y, int rows, int cols) that computes y[i] = sum_j A[i*cols + j] * x[j]. Write a CGO Go binding exposing MatVec(A []float64, x []float64, rows, cols int) ([]float64, error). Include a small Go program that runs two goroutines, each calling MatVec with different inputs to prove concurrency safety, and build steps to compile and run?","answer":"Validate input dims, allocate an output slice, pass pointers to C.matvec via CGO, and convert results back to Go safely. The two goroutines should operate on distinct A/x inputs with a sync.WaitGroup ","explanation":"## Why This Is Asked\nTests CGO bindings, memory ownership across Go/C, and concurrency safety in a realistic, minimal setup.\n\n## Key Concepts\n- Go slices to C pointers, CGO bindings\n- Memory ownership across language boundaries\n- Row-major data layout and bounds checks\n- Safe concurrent calls without races\n\n## Code Example\n```c\n// matvec.h\n#ifndef MATVEC_H\n#define MATVEC_H\nvoid matvec(const double* A, const double* x, double* y, int rows, int cols);\n#endif\n```\n```c\n// matvec.c\n#include \"matvec.h\"\nvoid matvec(const double* A, const double* x, double* y, int rows, int cols) {\n  for (int i = 0; i < rows; ++i) {\n    double s = 0.0;\n    for (int j = 0; j < cols; ++j) s += A[i*cols + j] * x[j];\n    y[i] = s;\n  }\n}\n```\n```go\n// matvec.go\npackage matvec\n// CGO bindings to be implemented here\n```\n\n## Follow-up Questions\n- How would you handle C crashes and propagate errors to Go?\n- How would you extend to batched matvec for multiple rows efficiently?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","NVIDIA","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T19:40:23.509Z","createdAt":"2026-01-15T19:40:23.509Z"},{"id":"q-2757","question":"Design a CGOA wrapper for a C streaming function that reports encrypted chunks via a callback: void stream_xor(const uint8_t* input, size_t n, void (*chunk_cb)(const uint8_t* chunk, size_t len, void* user), void* user); Implement a Go binding (CGO) that exposes a function StreamXor(src []byte) (<-chan []byte, func()) which starts the stream in a goroutine, pipes chunks to a channel, and returns a cancel function to terminate and free resources. Provide a header, a minimal C implementation, the Go binding, and a small program that runs two streams concurrently?","answer":"To solve this, implement a CGOA bridge where Go passes a cgo.Handle to C as the user token, C calls the registered chunk_cb with chunks, and Go converts chunks to Go slices sent on a channel. Maintain","explanation":"## Why This Is Asked\nTests bridging asynchronous C callbacks with Go, memory lifetime, cancellation semantics, and safe channeling; validates CGO constraints (no Go pointers in C, use cgo.Handle).\n\n## Key Concepts\n- CGO callback bridging and cgo.Handle usage\n- Management of C resources from Go\n- Concurrency through channels and cancellation\n- Memory safety across language boundaries\n\n## Code Example\n```javascript\n// Implementation code would be provided in the task\n```\n\n## Follow-up Questions\n- How would you handle backpressure if Go consumes chunks slowly?\n- What are the edge cases for end-of-stream and errors?","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Hugging Face","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T10:44:35.031Z","createdAt":"2026-01-16T10:44:35.031Z"},{"id":"q-2830","question":"Design a CGOA wrapper around a C asynchronous task API: C header exposes Task* start_task(const uint8_t* input, size_t n, void (*cb)(const char* status, void* user), void* user); void cancel_task(Task*); void free_task(Task*); Implement a Go binding that exposes RunTask(input []byte) (<-chan string, func()) which starts the task, streams status updates to the channel, and returns a cancellation function that frees resources. Include header, minimal C impl, Go binding, and a small Go program that runs two tasks concurrently and prints progress. Include build steps?","answer":"To solve, define an opaque Task in C and provide start_task, cancel_task, and free_task. In Go, wrap start_task with a CGO binding that registers a Go callback, converts status to a string channel, an","explanation":"## Why This Is Asked\nTests expertise bridging C callbacks and Go channels, memory ownership, and cancellation semantics in CGO.\n\n## Key Concepts\n- CGO memory management and ownership\n- Bridging C callbacks to Go channels\n- Finalizers and resource cleanup\n- Concurrency: independent tasks and cancellation\n\n## Code Example\n```c\n// header\ntypedef struct Task Task;\nTask* start_task(const uint8_t* input, size_t n, void (*cb)(const char* status, void* user), void* user);\nvoid cancel_task(Task* t);\nvoid free_task(Task* t);\n```\n\n```go\n// binding sketches CGO wrapper around start_task and channel\n```\n\n## Follow-up Questions\n- How would you handle backpressure if status updates are too fast?\n- How would you propagate errors from C to Go?","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Netflix","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T14:04:17.852Z","createdAt":"2026-01-16T14:04:17.853Z"},{"id":"q-2839","question":"CGO callback bridging: Given a C library that invokes a callback of the form void (*event)(int id, const char* payload) from internal threads, design a CGO wrapper so Go can safely register a Go callback and receive events. Provide a C header exposing the registration, a Go binding using CGO that registers and forwards events to Go, and a minimal Go program that demonstrates two concurrent event streams. Include build steps?","answer":"Use a per-library context with a Go callback stored via a handle (cgo.Handle). Export a Go function for C to call, enqueue events on a Go channel, and dispatch in a dedicated worker to preserve Go run","explanation":"## Why This Is Asked\nTests ability to implement cross-language callbacks with CGO, manage Go runtime constraints, and ensure safe memory management across language boundaries.\n\n## Key Concepts\n- CGO callbacks and //export mechanics\n- Managing Go closures across C via cg o.Handle\n- Thread-safety when C invokes Go on non-Go threads\n- Memory ownership for payloads across boundaries\n- Event dispatch pattern using channels and a worker\n\n## Code Example\n```javascript\n// C header (example.h)\ntypedef void (*event_cb)(int id, const char* payload);\nvoid register_event_source(event_cb cb, void* ctx);\nvoid unregister_event_source(void* ctx);\n```\n```javascript\n// Go binding skeleton (binding.go)\npackage main\n/*\n#include \"example.h\"\n*/\nimport \"C\"\nimport (\n  \"runtime/cgo\"\n)\nvar _ = cgo.Register\n// ... store handlers with a map[handle] and export a Go callback\n```\n\n## Follow-up Questions\n- How do you ensure payload lifetime is safe if C reuses buffers?\n- How would you clean up handles when callbacks unregister?\n- How would you test callback delivery under heavy concurrency?","diagram":"flowchart TD\n  A[Go Program] --> B[CGO Bridge]\n  B --> C[C Library]\n  C --> D[Go Callback Invoked]\n  D --> E[Channel Processor]","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Netflix","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T14:34:16.110Z","createdAt":"2026-01-16T14:34:16.110Z"},{"id":"q-3000","question":"Implement a CGO wrapper for a C library function that performs a one-shot transform: void transform(const uint8_t* data, size_t n, uint8_t* out, size_t* out_n, int* err); The wrapper should expose a Go function Transform(src []byte) ([]byte, error). Provide a header, a minimal C implementation (e.g., XOR each byte with 0x5A, allocate out via malloc, fill out_n, set err), and a Go program that concurrently calls Transform from two goroutines and prints results. Ensure memory is freed?","answer":"Design and implement a CGO binding where Go passes a []byte to C; C allocates an output buffer with malloc, XORs every input byte with 0x5A, writes the length to out_n, and signals errors via err. The","explanation":"## Why This Is Asked\nTests memory ownership across CGO, error propagation, and concurrent usage of a C function defended by a Go wrapper.\n\n## Key Concepts\n- CGO memory management\n- C-to-Go data transfer\n- Error handling across language boundaries\n- Concurrency safety with shared C resources\n\n## Code Example\n```javascript\n// Implementation code here\n```\n\n## Follow-up Questions\n- How would you handle large outputs or streaming data?\n- What changes are needed to support non-blocking calls?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Square","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T20:40:22.698Z","createdAt":"2026-01-16T20:40:22.698Z"},{"id":"q-3046","question":"CGO Callback Bridge: Implement an async C API that schedules a job and reports results via a callback. Provide a C header and a Go binding using CGO so that Go passes a Go function as a callback by using an opaque handle and a C bridge wrapper; ensure thread-safety, lifecycle, and memory cleanup. How would you design and implement this?","answer":"Use a CGO bridge: assign a unique Go callback handle for each job; pass an opaque handle to C; export a Go function (//export) that C calls back with id, result, and the handle; a small C wrapper signature converts between C and Go calling conventions while maintaining thread-safety.","explanation":"## Why This Is Asked\n\nThis question probes how well a candidate bridges Go and C for asynchronous work, including memory management, lifecycle, and thread-safety.\n\n## Key Concepts\n\n- CGO cross-language callbacks and exported Go functions\n- Opaque handles and lifecycle management\n- Synchronized callback registry (maps, synchronization)\n- Avoiding Go pointer leaks to C and ensuring GC safety\n\n## Code Example\n\n```c\n// cgobridge.h\ntypedef void (*cb_t)(int id, const char* result, void* opaque);\nvoid schedule_job(int id, cb_t cb, void* opaque);\nvoid cancel_job(int id);\n```\n\n```c\n// cgobridge_wrapper.c\n#include \"cgobridge.h\"\n#include <stdlib.h>\n\n// Forward declaration of exported Go function\nextern void go_callback_bridge(int id, const char* result, void* opaque);\n\nvoid schedule_job(int id, cb_t cb, void* opaque) {\n    // C implementation that eventually calls back\n    // ...\n    cb(id, \"result\", opaque);\n}\n```\n\n```go\n// cgobridge.go\npackage main\n\n/*\n#include \"cgobridge.h\"\n*/\nimport \"C\"\nimport (\n    \"sync\"\n    \"unsafe\"\n)\n\ntype goCallback func(int, string)\n\nvar (\n    callbacks sync.Map\n    nextHandle uint64\n    handleMu   sync.Mutex\n)\n\n//export go_callback_bridge\nfunc go_callback_bridge(id C.int, result *C.char, opaque unsafe.Pointer) {\n    if handle, ok := callbacks.Load(opaque); ok {\n        cb := handle.(goCallback)\n        cb(int(id), C.GoString(result))\n    }\n}\n\nfunc ScheduleJob(id int, cb goCallback) {\n    handleMu.Lock()\n    nextHandle++\n    handle := unsafe.Pointer(uintptr(nextHandle))\n    handleMu.Unlock()\n    \n    callbacks.Store(handle, cb)\n    C.schedule_job(C.int(id), (*[0]byte)(C.go_callback_bridge), handle)\n}\n```\n\n## Design Considerations\n\n- **Handle Management**: Use atomic counters or sync.Map for thread-safe handle generation\n- **Memory Safety**: Store Go callbacks in a registry, never pass Go pointers directly to C\n- **Cleanup**: Remove handles from registry after callback or job cancellation\n- **Error Handling**: Convert C error codes to Go errors and handle edge cases","diagram":"flowchart TD\n  A[Go schedules job] --> B[C bridge wrapper calls C function]\n  B --> C[C invokes callback bridge]\n  C --> D[go_bridge called in Go]\n  D --> E[Go user callback executes]\n  E --> F[Cleanup/Finalize]","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Instacart","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T05:28:01.574Z","createdAt":"2026-01-16T22:40:38.261Z"},{"id":"q-3152","question":"CGO Callback Bridge: Given a C API that streams integers via a callback 'void cb(int value, void* user)' registered with 'void register_stream(cb_t cb, void* user);', implement a Go binding that lets Go supply a Go function to handle values. Provide a C header and a minimal C trampoline, and a Go API StartStream(process func(int)) (<-chan int). Show two goroutines consuming from distinct streams. How will you manage the Go callback lifetime and memory across CGO boundaries?","answer":"Use a trampoline and cgo.Handle. In C: `typedef void (*cb_t)(int, void*); void register_stream(cb_t cb, void* user); void trampoline(int value, void* handle_ptr);`. In Go, create a channel and goroutine that converts the Go callback to a cgo.Handle, passes the handle pointer to C, and forwards values to the channel. The StartStream function returns the channel and manages handle cleanup when the stream stops.","explanation":"## Why This Is Asked\nTests ability to bridge Go and C with callbacks, manage lifetimes, and avoid unsafe pointer passes.\n\n## Key Concepts\n- CGO callbacks and trampolines\n- cgo.Handle for Go values across C boundaries\n- Memory ownership and handle release\n- Thread-safety when called from C across Go threads\n\n## Complete Implementation\n\n**C Header (stream.h):**\n```c\ntypedef void (*cb_t)(int, void*);\nvoid register_stream(cb_t cb, void* user);\nvoid trampoline(int value, void* handle_ptr);\nvoid unregister_stream(void);\n```\n\n**C Trampoline (stream.c):**\n```c\n#include \"stream.h\"\n#include <stdint.h>\n\nvoid trampoline(int value, void* handle_ptr) {\n    uintptr_t handle = (uintptr_t)handle_ptr;\n    // This calls back into Go via cgo.Handle\n    extern void go_callback(int value, uintptr_t handle);\n    go_callback(value, handle);\n}\n```\n\n**Go Binding:**\n```go\n/*\n#cgo LDFLAGS: -L. -lstream\n#include \"stream.h\"\n*/\nimport \"C\"\nimport \"unsafe\"\n\nvar activeStreams = make(map[uintptr]chan int)\nvar streamsMutex sync.RWMutex\n\n//export go_callback\nfunc go_callback(value C.int, handlePtr C.uintptr_t) {\n    handle := uintptr(handlePtr)\n    streamsMutex.RLock()\n    if ch, exists := activeStreams[handle]; exists {\n        select {\n        case ch <- int(value):\n        default:\n            // Channel full, drop value\n        }\n    }\n    streamsMutex.RUnlock()\n}\n\nfunc StartStream() (<-chan int, func()) {\n    ch := make(chan int, 100)\n    \n    // Create wrapper function and handle\n    done := make(chan struct{})\n    handle := C.uintptr_t(C.NewHandle(done))\n    \n    streamsMutex.Lock()\n    activeStreams[uintptr(handle)] = ch\n    streamsMutex.Unlock()\n    \n    // Register with C trampoline\n    C.register_stream((*[0]byte)(C.trampoline), unsafe.Pointer(handle))\n    \n    // Cleanup function\n    cleanup := func() {\n        C.unregister_stream()\n        C.Delete(C.Handle(handle))\n        \n        streamsMutex.Lock()\n        delete(activeStreams, uintptr(handle))\n        streamsMutex.Unlock()\n        \n        close(ch)\n    }\n    \n    return ch, cleanup\n}\n\n// Usage example:\nfunc consumeStreams() {\n    stream1, stop1 := StartStream()\n    stream2, stop2 := StartStream()\n    \n    go func() {\n        for val := range stream1 {\n            fmt.Printf(\"Stream 1: %d\\n\", val)\n        }\n    }()\n    \n    go func() {\n        for val := range stream2 {\n            fmt.Printf(\"Stream 2: %d\\n\", val)\n        }\n    }()\n    \n    // Stop after some time\n    time.Sleep(5 * time.Second)\n    stop1()\n    stop2()\n}\n```\n\n## Follow-up Questions\n- How would you handle panics in the Go callback invoked from C?\n- What are performance implications of per-call handles vs static wrappers?\n- How can you prevent memory leaks if the C side never calls unregister?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Databricks","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":["cgo callback bridge","cgo.handle","c trampoline function","go callback lifetime","memory management","thread safety","register stream","unregister stream","goroutine streams","channel consumption","handle cleanup","unsafe pointer"],"voiceSuitable":true,"isNew":false,"lastUpdated":"2026-01-26T05:21:41.465Z","createdAt":"2026-01-17T04:48:22.370Z"},{"id":"q-3244","question":"Design a CGOA wrapper for a C library that returns a heap-allocated greeting string: const char* greet(const char* name, int* err); The function allocates memory for the greeting and returns NULL on error; The Go binding should expose a function GetGreeting(name string) (string, error) which calls greet, converts the C string to Go, and frees the C buffer. Demonstrate concurrency by launching two goroutines requesting greetings concurrently. Include a C header, a minimal C implementation, the Go binding, and a small program that runs in parallel?","answer":"Proposed answer approach: implement greet in C to allocate with malloc, set err nonzero on failure, return NULL. In Go, call C.greet, check err, convert to Go string with C.GoString, free with C.free,","explanation":"## Why This Is Asked\nTests memory ownership, cgo boundaries, and concurrency safety by wrapping a C-allocated string.\n\n## Key Concepts\n- CGO memory management\n- C->Go string conversion\n- Error propagation across FFI\n- Concurrent Go calls without shared mutable state\n\n## Code Example\n```c\n/* header: cgoc_hello.h */\n#ifndef CGOA_HELLO_H\n#define CGOA_HELLO_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nunsigned char* greet(const char* name, int* err); // returns malloc'ed buffer or NULL\n#ifdef __cplusplus\n}\n#endif\n#endif\n```\n\n```c\n/* minimal implementation: cg_hello.c */\n#include <stdlib.h>\n#include <string.h>\n#include \"cgoc_hello.h\"\nunsigned char* greet(const char* name, int* err){\n  if(!name){ *err = 1; return NULL; }\n  const char* base = \"Hello, \";\n  size_t len = strlen(base) + strlen(name) + 2;\n  char* out = (char*)malloc(len);\n  if(!out){ *err = 2; return NULL; }\n  strcpy(out, base);\n  strcat(out, name);\n  *err = 0; return (unsigned char*)out;\n}\n```\n\n```go\n// go binding: cg_hello.go\npackage cgHello\n/*\n#include \"cgoc_hello.h\"\n#include <stdlib.h>\n*/\nimport \"C\"\nimport (\n  \"errors\"\n  \"unsafe\"\n)\n\nfunc GetGreeting(name string) (string, error) {\n  cname := C.CString(name)\n  defer C.free(unsafe.Pointer(cname))\n  var err C.int\n  buf := C.greet(cname, &err)\n  if buf == nil {\n    switch err {\n    default:\n      return \"\", errors.New(\"greet failed\")\n    }\n  }\n  defer C.free(unsafe.Pointer(buf))\n  goStr := C.GoString((*C.char)(unsafe.Pointer(buf)))\n  return goStr, nil\n}\n```\n\n```go\n// main.go\npackage main\nimport (\n  \"fmt\"\n  cg \"path/to/cgHello\"\n  \"sync\"\n)\nfunc main(){\n  var wg sync.WaitGroup\n  names := []string{\"Alice\",\"Bob\"}\n  for _, n := range names {\n    wg.Add(1)\n    go func(name string){\n      defer wg.Done()\n      s, err := cg.GetGreeting(name)\n      if err != nil { fmt.Println(\"err\", err); return }\n      fmt.Println(s)\n    }(n)\n  }\n  wg.Wait()\n}\n```\n\n## Follow-up Questions\n- How would you adapt this to a streaming callback (callback into Go) safely?\n- How would you handle error codes with richer semantics and avoid leaking memory if multiple errors occur?","diagram":"flowchart TD\n  A[Go calls C greet] --> B[Receive C pointer or NULL]\n  B --> C{Is NULL?}\n  C -- Yes --> D[Return error to Go]\n  C -- No --> E[Convert to Go string]\n  E --> F[Free C buffer]\n  F --> G[Return string to Go]\n  G --> H[Return to caller]","difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","NVIDIA","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T08:41:04.171Z","createdAt":"2026-01-17T08:41:04.172Z"},{"id":"q-3266","question":"Design a CGOA wrapper for a C library function that formats a message into a pre-allocated buffer: int format_message(const char* name, char* out, size_t out_size); It should return the number of bytes written or -1 on error with errno set to ERANGE when the buffer is too small. Expose a Go binding: func FormatMessage(name string) (string, error) that starts with 128 bytes and auto-resizes to 256, 512, then 1024 on ERANGE. Ensure concurrent calls are safe. Include header, C impl, Go binding, and a small multi-goroutine test?","answer":"Implement FormatMessage using a resize loop. For size in [128,256,512,1024]: allocate buf, cname := C.CString(name); defer C.free(unsafe.Pointer(cname)); n := C.format_message(cname, (*C.char)(unsafe.","explanation":"## Why This Is Asked\nTests safe CGO buffer management, error propagation via errno, and concurrent invocation patterns.\n\n## Key Concepts\n- CGO memory lifetimes across Go/C boundaries\n- Preallocated buffers and safe Go->C data transfer\n- Handling errno and ERANGE for dynamic resizing\n- Concurrency safety with per-call allocations\n\n## Code Example\n```javascript\n// C header\nint format_message(const char* name, char* out, size_t out_size);\n\n// Minimal C impl (header + body)\n#include <string.h>\n#include <errno.h>\nint format_message(const char* name, char* out, size_t out_size){\n  const char* greet = \"Hello, \";\n  size_t needed = strlen(greet) + strlen(name) + 2; // including '!'\n  if (out_size <= needed) { errno = ERANGE; return -1; }\n  strcpy(out, greet);\n  strcat(out, name);\n  strcat(out, \"!\");\n  return (int)strlen(out);\n}\n```\n\n```javascript\n// Go binding sketch (conceptual)\npackage main\n/*\n#include <stdlib.h>\n#include \"format.h\"\n*/\nimport \"C\"\nimport (\n  \"errors\"\n  \"unsafe\"\n)\n\nfunc FormatMessage(name string) (string, error) {\n  sizes := []int{128, 256, 512, 1024}\n  for _, s := range sizes {\n    buf := make([]byte, s)\n    cname := C.CString(name)\n    defer C.free(unsafe.Pointer(cname))\n    n := C.format_message(cname, (*C.char)(unsafe.Pointer(&buf[0])), C.size_t(s))\n    if n >= 0 {\n      return string(buf[:n]), nil\n    }\n    if C.errno != C.ERANGE {\n      return \"\", errors.New(\"format failed\")\n    }\n  }\n  return \"\", errors.New(\"buffer too small\")\n}\n```\n\n## Follow-up Questions\n- How would you handle C errors without errno propagation?  \n- How would you test cancellation and timeouts for concurrent calls?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Lyft","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T09:31:47.249Z","createdAt":"2026-01-17T09:31:47.249Z"},{"id":"q-3347","question":"Interfacing asynchronous C callbacks with Go via CGOA. Given a C API:\n\ntypedef void (*ev_cb)(const char* event, void* user);\nvoid register_evt_source(ev_cb cb, void* user);\nvoid stop_evt_source(void);\n\nDesign a CGOA wrapper that exposes in Go:\n\nfunc RegisterEvents(h EventHandler) error\n\n- Header and minimal C that starts a thread emitting events every 100ms and stops on stop_evt_source.\n- Safe callback from C to Go (exported function), with string lifetime and memory cleanup.\n- Demonstrate two independent handlers concurrently and discuss CGO threading rules?","answer":"Maintain a map[uintptr]EventHandler with a mutex; generate a unique handle per RegisterEvents call and pass it as 'user' to C. Export a Go callback (//export) that converts the C string via C.GoString","explanation":"## Why This Is Asked\nTests ability to bridge async C callbacks into Go safely, including lifetime management and cross-thread CGO rules.\n\n## Key Concepts\n- CGO callback export and thread-safety\n- Go memory management across C boundaries\n- Runtime.KeepAlive and preventing GC of callbacks\n- Handling multiple independent callbacks concurrently\n\n## Code Example\n```c\n// header and minimal C impl\n```\n\n## Follow-up Questions\n- How would you handle backpressure if events overwhelm Go?\n- How would you extend to support per-event metadata and cancellation?\n","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Oracle","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T13:04:15.703Z","createdAt":"2026-01-17T13:04:15.703Z"},{"id":"q-3378","question":"Implement a CGOA wrapper for a C thread-safe queue API. The C API (queue.h) exposes: queue_t* queue_create(); void queue_destroy(queue_t*); int queue_push(queue_t* q, item* it); int queue_pop(queue_t* q, item** out, int timeout_ms); void queue_free_item(item*); typedef struct item { int id; const char* data; } item; Design a Go binding that provides:\n- type Item struct { ID int; Data string }\n- type Queue struct { p *C.queue_t }\n- func NewQueue() *Queue\n- func (q *Queue) Push(it Item) error\n- func (q *Queue) Pop(timeout time.Duration) (Item, error)\n\nRequirements: convert Go string to C string for pushes; allocate item for C, copy data, free data after push; on Pop, convert C item to Go Item and call queue_free_item. Ensure thread-safety across goroutines, zero memory leaks, and proper error semantics. Include a minimal C glue (wrapper header and c go glue), a Go binding file, and a small Go program that runs 4 producers and 2 consumers for 2 seconds?","answer":"Implement a CGOA wrapper around a C thread-safe queue. Expose Go API NewQueue() *Queue, (q *Queue) Push(it Item) error, (q *Queue) Pop(timeout time.Duration) (Item, error). Use queue.h with queue_crea","explanation":"## Why This Is Asked\nTests practical CGO ownership, memory management, and cross-language error handling with real concurrency. It reveals ability to design safe resource lifetimes and translation between Go and C types.\n\n## Key Concepts\n- CGO memory management and ownership transfer\n- Converting strings between Go and C safely\n- Managing C-allocated items from Go with precise frees\n- Concurrency safety across goroutines and correct error mapping\n\n## Code Example\n```javascript\n// queue.h (C header) and simple glue would be provided\n```\n\n```javascript\n// go_binding.go: minimal bindings showing NewQueue, Push, and Pop wrappers\n```\n\n## Follow-up Questions\n- How would you detect and prevent use-after-free or double-free scenarios in this wrapper?\n- How would you adapt the wrapper for multiple independent queues across modules with per-queue lifetime management?","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Google","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T13:52:02.120Z","createdAt":"2026-01-17T13:52:02.120Z"},{"id":"q-3494","question":"Design a CGOA wrapper for a C library that streams partial results via a callback: a process_start function takes data and a callback with signature chunk_cb(chunk, len, user, is_final), and is_final signals completion. The Go binding should expose: func ProcessData(input []byte) ([]byte, error) that aggregates all chunks into a single result. Provide a C header, a minimal C implementation, the Go binding, and a small Go program that calls ProcessData on two inputs concurrently to prove thread-safety and correct aggregation?","answer":"Implement a CGOA wrapper for a C streaming API that calls back with chunks and an is_final flag. The Go binding should collect chunks into a per-call buffer and return the combined result in ProcessDa","explanation":"## Why This Is Asked\nTests CGO callback bridging, memory ownership, and concurrent safety when wrapping streaming C APIs.\n\n## Key Concepts\n- CGO callback translation\n- Per-call ownership and cleanup\n- Safe concurrent CGO usage with isolated handles\n- Memory management across CGo boundaries\n\n## Code Example\n```go\n// binding usage example (pseudo)\nfunc ProcessData(input []byte) ([]byte, error) { /* ... */ }\n```\n\n## Follow-up Questions\n- How would you extend to multi-stream aggregation? \n- How would you enforce timeouts or backpressure between C and Go?\n","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Scale Ai","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T18:50:37.066Z","createdAt":"2026-01-17T18:50:37.066Z"},{"id":"q-3514","question":"Design a CGOA binding for a C API that creates and frees a Book object and returns its title. Given C:\\ntypedef struct Book Book;\\nBook* create_book(const char* title);\\nconst char* book_title(Book*);\\nvoid free_book(Book*);\\nImplement a CGO Go wrapper exposing:\\n\\n type BookHandle struct { ptr *C.Book }\\n\\nfunc NewBook(title string) (*BookHandle, error)\\nfunc (b *BookHandle) Title() (string, error)\\nfunc (b *BookHandle) Close() error\\n\\nEnsure ownership is explicit (Close frees) or a finalizer, no leaks, and demonstrate two concurrent book creations and title fetches?","answer":"Create a Go type that holds the C pointer, call create_book, convert the C string with C.GoString, and free via free_book in Close or a runtime.SetFinalizer. Title uses book_title. Demonstrate two gor","explanation":"## Why This Is Asked\nTests memory ownership across CGO, error handling, and lifecycle management.\n\n## Key Concepts\n- CGO memory ownership and finalizers\n- Go-C string conversion and error propagation\n- Concurrency safety and resource cleanup\n\n## Code Example\n```c\n// header\ntypedef struct Book Book;\nBook* create_book(const char* title);\nconst char* book_title(Book*);\nvoid free_book(Book*);\n```\n```go\n// binding sketch\ntype BookHandle struct { p *C.Book }\nfunc NewBook(title string) (*BookHandle, error) { ... }\nfunc (b *BookHandle) Title() (string, error) { ... }\nfunc (b *BookHandle) Close() error { ... }\n```\n\n## Follow-up Questions\n- How would you handle errors from book_title?  \n- How would you adapt if C returns NULL and sets errno?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T19:30:13.387Z","createdAt":"2026-01-17T19:30:13.387Z"},{"id":"q-3544","question":"Design a CGOA wrapper for a C API that streams a file's bytes via a callback: void stream_file(const char* path, void (*chunk_cb)(const uint8_t*, size_t, void*), void* user). The C function streams 4KB chunks and signals completion with a zero-length chunk. Expose in Go: func ReadFileStream(path string) (<-chan []byte, func()) that streams in a goroutine and returns a cancel function. Provide a header, a minimal C impl, the Go binding, and a small program that runs two streams concurrently?","answer":"Safely bridge C and Go by copying each chunk, exporting a C callback (//export) and running the stream on its own thread; use a Go channel per stream and a cancel function to signal termination. Manag","explanation":"## Why This Is Asked\nTests understanding of CGO callbacks, memory ownership, and concurrency when streaming data from C into Go. It also evaluates how to design a clean Go API around a C streaming pattern and cancellation.\n\n## Key Concepts\n- CGO callbacks and //export\n- Memory ownership across C↔Go boundaries\n- Per-stream isolation and cancellation\n- Lifecycle management of buffers and channels\n\n## Code Example\n```c\n// header.h\n#include <stdint.h>\nvoid stream_file(const char* path, void (*chunk_cb)(const uint8_t*, size_t, void*), void* user);\n```\n```c\n// impl.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"header.h\"\n\nvoid stream_file(const char* path, void (*chunk_cb)(const uint8_t*, size_t, void*), void* user){\n  FILE* f = fopen(path, \"rb\");\n  if (!f) { chunk_cb(NULL, 0, user); return; }\n  uint8_t buf[4096];\n  size_t n;\n  while ((n = fread(buf, 1, sizeof(buf), f)) > 0){\n    chunk_cb(buf, n, user);\n  }\n  fclose(f);\n  // end signal\n  chunk_cb(NULL, 0, user);\n}\n```\n```go\n// bindings.go\npackage main\n// #cinclude \"header.h\"\nimport \"C\"\nimport (\n  \"unsafe\"\n)\n\n//export goChunk\nfunc goChunk(cbuf *C.uint8_t, len C.size_t, user unsafe.Pointer) {\n  // implement copy and send on channel in Go side\n}\n\nfunc ReadFileStream(path string) (<-chan []byte, func()) {\n  ch := make(chan []byte)\n  // produce stream in a goroutine and return cancel func\n  // (Implementation details omitted for brevity in this example)\n  cancel := func() { close(ch) }\n  return ch, cancel\n}\n```\n```go\n// main.go\npackage main\nimport (\n  \"fmt\"\n)\nfunc main(){\n  ch1, cancel1 := ReadFileStream(\"a.dat\")\n  ch2, cancel2 := ReadFileStream(\"b.dat\")\n  go func(){ for b := range ch1 { fmt.Printf(\"a: %d bytes\\n\", len(b)) } }()\n  go func(){ for b := range ch2 { fmt.Printf(\"b: %d bytes\\n\", len(b)) } }()\n  // run briefly, then cancel\n  // ...\n  cancel1(); cancel2()\n}\n```\n","diagram":"flowchart TD\n  A[C: stream_file] --> B[CGO binding ReadFileStream]\n  B --> C[Go channel per stream]\n  A --> D[chunk_cb]\n  D --> E[Go side handler/receiver]\n  E --> F[application consumes data]\n","difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Meta","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T20:42:30.558Z","createdAt":"2026-01-17T20:42:30.559Z"},{"id":"q-3666","question":"Design a CGOA wrapper for a C library exposing a multi-threaded async job API: typedef void (*job_cb)(int job_id, const unsigned char* result, size_t len, void* user); void submit_job(int job_id, const unsigned char* payload, size_t len, job_cb cb, void* user); void shutdown_jobs(void); Expose in Go a function: func SubmitJob(payload []byte) (<-chan []byte, func()) - Each call assigns a unique job_id internally; the C side calls back with the result asynchronously. The Go binding should convert the C callback into Go via a //export wrapper, dispatch into a channel, and provide a cancel function that shuts down all pending jobs safely. Ensure there are no Go pointers passed through CGO into C, handle lifetimes, and explain how to avoid data races across goroutines. Provide a minimal header and C implementation, Go binding, and a test program that submits 2-3 jobs concurrently and reads results from the channel. Include build steps?","answer":"Map each C job_id to a Go channel using a thread-safe registry (atomic ID, sync.Map). Provide a //export callback that copies the C result into a Go byte slice, sends it on the channel, and frees C me","explanation":"## Why This Is Asked\n\nTests design of a robust CGO bridge for asynchronous C APIs, memory management, and cancellation handling.\n\n## Key Concepts\n\n- CGO callback bridging\n- Avoid passing Go pointers to C\n- Async job lifecycle and cancellation\n- Memory management across languages (alloc/free)\n- Concurrency safety: per-job channels, atomic IDs, sync.Map\n\n## Code Example\n\n```c\n// header\ntypedef void (*job_cb)(int job_id, const unsigned char* result, size_t len, void* user);\nvoid submit_job(int job_id, const unsigned char* payload, size_t len, job_cb cb, void* user);\nvoid shutdown_jobs(void);\n```\n\n```go\n// binding skeleton\npackage binding\n\n//export goCallback\nfunc goCallback(C.int, *C.uchar, C.size_t, unsafe.Pointer) {\n    // map to Go channel\n}\n```\n\n## Follow-up Questions\n\n- How would you add per-job timeouts and backpressure?\n- How would you test cross-language memory safety and leak detection?","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T04:18:31.266Z","createdAt":"2026-01-18T04:18:31.267Z"},{"id":"q-3751","question":"CGOA Binding: Safe Go callback bridge for a C API with user context?\n\nDesign a CGOA binding for a C API that registers a callback and emits events from multiple threads. Provide a C header and minimal C implementation, plus a Go binding using CGO that exposes BindEventHandler(handler EventHandler) (unbind func(), error). The wrapper must deliver events to Go safely (via a channel), support multiple concurrent handlers, and clean up on unbind. Include a small Go program that registers two handlers and triggers events concurrently. End with a question mark?","answer":"Use a single C callback, export a Go function, map opaque handles to channels, and deliver events via channel to the correct handler. Manage lifecycle with unbind, ensure thread-safety with locks, and","explanation":"## Why This Is Asked\n\nTests practical CGOA callback patterns, cross-thread safety, and resource lifecycles in a realistic binding.\n\n## Key Concepts\n\n- CGO callbacks and //export semantics\n- Cross-language context/pointer safety\n- Synchronization between C threads and Go schedulers\n- Lifecycle: registration, unbinding, and resource cleanup\n\n## Code Example\n\n```c\n// header: cgobind.h\ntypedef void (*event_cb)(int event, void* ctx);\nvoid register_event_source(event_cb cb, void* ctx);\nvoid emit_event(int event);\n```\n\n```c\n// minimal cgobind.c\n#include \"cgobind.h\"\nstatic event_cb g_cb = NULL;\nstatic void* g_ctx = NULL;\n\nvoid register_event_source(event_cb cb, void* ctx) {\n  g_cb = cb;\n  g_ctx = ctx;\n}\n\nvoid emit_event(int event) {\n  if (g_cb) g_cb(event, g_ctx);\n}\n```\n\n```go\n// binding.go (sketch)\npackage cgobind\n\n// #cgo CFLAGS: -I.\n// #include \"cgobind.h\"\nimport \"C\"\nimport (\n  \"sync\"\n  \"unsafe\"\n)\n\ntype EventHandler func(int)\n\nvar (\n  mu       sync.Mutex\n  handles  = make(map[uintptr]EventHandler)\n  nextID   uintptr = 1\n)\n\n//export goEventCallback\nfunc goEventCallback(ctx unsafe.Pointer, event C.int) {\n  id := uintptr(uintptr(ctx))\n  mu.Lock()\n  h, ok := handles[id]\n  mu.Unlock()\n  if ok {\n    h(int(event))\n  }\n}\n\nfunc BindEventHandler(handler EventHandler) (func(), error) {\n  mu.Lock()\n  id := nextID\n  nextID++\n  handles[id] = handler\n  mu.Unlock()\n\n  // register C callback with context as id\n  C.register_event_source((C.event_cb)(C.goEventCallback), unsafe.Pointer(uintptr(id)))\n\n  unbind := func() {\n    mu.Lock()\n    delete(handles, id)\n    mu.Unlock()\n  }\n  return unbind, nil\n}\n```\n\n```go\n// main.go\npackage main\n\nimport (\n  \"fmt\"\n  cgobind \"path/to/cgobind\"\n)\n\nfunc main() {\n  h1 := func(e int) { fmt.Println(\"handler1 got\", e) }\n  h2 := func(e int) { fmt.Println(\"handler2 got\", e) }\n  if unbind1, _ := cgobind.BindEventHandler(h1); unbind1 != nil {\n    // simulate\n  }\n  if unbind2, _ := cgobind.BindEventHandler(h2); unbind2 != nil {\n    // simulate\n  }\n  // trigger events from C side through emit_event\n}\n```\n\n## Follow-up Questions\n\n- How would you safely shut down all callbacks and avoid goroutine leaks when the Go program exits?\n- How would you handle backpressure if events arrive faster than Go can process them?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","DoorDash"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T08:36:40.561Z","createdAt":"2026-01-18T08:36:40.561Z"},{"id":"q-4013","question":"CGOA Binding: Implement a Go binding for a C streaming transform API that reports progress via a callback. C API: typedef void (*progress_cb)(int percent, void* user); int stream_transform(const uint8_t* in, size_t in_n, uint8_t** out, size_t* out_n, progress_cb cb, void* user); Expose StreamTransform(src []byte) ([]byte, error) and stream progress to a Go channel via a callback, using a stable handle to pass Go data to C. Provide header, minimal C impl (reverse bytes, call cb 0..100, malloc), the Go binding, and a short program spawning two concurrent transforms. Build steps?","answer":"Use a cgo.Handle to store Go channels and export a C callback that routes progress updates back to Go. Pass the handle as user to stream_transform; in C call cb(percent, user) as progress. Allocate ou","explanation":"## Why This Is Asked\n\nTests ability to bridge CGO with callbacks, memory ownership, and concurrency; addresses streaming transforms, progress reporting, and safe cross language callbacks.\n\n## Key Concepts\n\n- CGO callbacks and Go pointers handling\n- cgo.Handle use for passing Go values to C\n- Memory management across CGo boundaries\n- Concurrency safety\n\n## Code Example\n\n```c\ntypedef void (*progress_cb)(int percent, void* user);\nint stream_transform(const uint8_t* in, size_t in_n, uint8_t** out, size_t* out_n, progress_cb cb, void* user);\n```\n\n```c\n// minimal impl: reverse input, report progress linearly, allocate with malloc\n```\n\n```go\n// binding skeleton showing StreamTransform signature\npackage cgobinding\n```\n\n## Follow-up Questions\n- How would you handle errors in the C callback vs Go error values?\n- How does this pattern scale with multiple concurrent streams?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Bloomberg","Cloudflare"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T19:32:22.158Z","createdAt":"2026-01-18T19:32:22.158Z"},{"id":"q-4067","question":"Design a CGOA wrapper for a stateful C library exposing ip_init, ip_process, ip_destroy. Build Go bindings providing NewImageProcessor(config string) (*ImageProcessor, error), (p *ImageProcessor) Process(data []byte) ([]byte, error), and (p *ImageProcessor) Close(). Demonstrate two instances in parallel with different inputs to prove per-instance isolation. Include header and minimal C, Go binding, and a small program that runs two goroutines in parallel; how would you implement and verify this binding?","answer":"Create a Go struct ImageProcessor that stores a C pointer. NewImageProcessor calls ip_init and stores the handle; Process calls ip_process, copies the C output into a Go slice, then frees the C buffer","explanation":"## Why This Is Asked\nTests memory ownership across language boundaries and per-instance isolation when CGO is used with stateful C libraries. It also checks basic error mapping and concurrent usage.\n\n## Key Concepts\n- CGO memory management between C and Go\n- Opaque per-instance handles\n- Error translation from C to Go\n- Safe concurrent usage of CGO-bound objects\n\n## Code Example\n```c\n// header\ntypedef struct ImageProcessor ImageProcessor;\nImageProcessor* ip_init(const char* config, int* err);\nint ip_process(ImageProcessor* ip, const uint8_t* src, size_t len, uint8_t** out, size_t* out_len);\nvoid ip_destroy(ImageProcessor* ip);\n```\n```go\n// binding sketch (Go)\n// type ImageProcessor struct{ p *C.ImageProcessor }\n// func NewImageProcessor(config string) (*ImageProcessor, error) { ... }\n// func (ip *ImageProcessor) Process(data []byte) ([]byte, error) { ... }\n// func (ip *ImageProcessor) Close() { ... }\n```\n\n## Follow-up Questions\n- How would you add timeout handling for Process calls?\n- How would you prevent leaks if ip_process frequently fails mid-copy?\n","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Apple","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T22:34:48.062Z","createdAt":"2026-01-18T22:34:48.062Z"},{"id":"q-4149","question":"CGO Callback Bridge: Implement a C library that exposes subscribe(void (*cb)(int event, const char* payload, void* user), void* user) and emit events asynchronously. Build a Go binding that lets Go register a Go callback via //export and exposes StartStream() (<-chan Event) that yields parsed events. Show header, minimal C wrapper, and a Go program with two goroutines consuming events concurrently. End with a question mark?","answer":"Use runtime/cgo.Handle to store Go callbacks for each subscription, pass the handle to C, export a Go callback that retrieves the handle, converts payload to Go string, and sends it to a channel. Ensu","explanation":"## Why This Is Asked\nTests bridging C callbacks into Go, memory ownership, and concurrency under CGO constraints. It reveals how a candidate handles lifetime management, thread-safety, and safe Go→C↔C→Go transitions.\n\n## Key Concepts\n- CGO callback patterns with exported Go functions\n- Runtime/cgo.Handle for passing Go values across boundaries\n- Memory ownership: C allocations vs Go frees\n- Thread-safety: callback delivery and OS thread considerations\n\n## Code Example\n```c\n// header: cgoback.h\n#ifndef CGOBACK_H\n#define CGOBACK_H\n\ntypedef void (*cb_t)(int event, const char* payload, void* user);\n\nvoid subscribe(cb_t cb, void* user);\nvoid unsubscribe(cb_t cb, void* user);\n\n#endif\n```\n\n```c\n// implementation: cgoback.c (minimal, illustrative)\n#include <stdlib.h>\n#include <string.h>\n#include \"cgoback.h\"\n\nstatic cb_t global_cb = NULL;\nstatic void* global_user = NULL;\n\nvoid emit(int event, const char* payload){\n  if(global_cb) global_cb(event, payload, global_user);\n}\n\nvoid subscribe(cb_t cb, void* user){\n  global_cb = cb; global_user = user;\n  // simulate events\n  for(int i=0;i<3;i++){\n    char buf[16]; snprintf(buf, sizeof(buf), \"payload-%d\", i);\n    emit(i, buf);\n  }\n}\n\nvoid unsubscribe(cb_t cb, void* user){ global_cb = NULL; global_user = NULL; }\n```\n\n```go\n// binding: cgoback.go (illustrative, not full production code)\npackage main\n\n/*\n#include \"cgoback.h\"\n*/\nimport \"C\"\nimport (\n  \"runtime/cgo\"\n)\n\ntype Event struct { Code int; Data string }\n\n//export goCallback\nfunc goCallback(event C.int, payload *C.char, user unsafe.Pointer) {\n  // retrieve and dispatch to channel associated with 'user'\n}\n\nfunc StartStream() <-chan Event {\n  ch := make(chan Event)\n  // register callback with C, pass a handle to Go side\n  // C.subscribe(C.cb, nil)\n  return ch\n}\n\nfunc main() { /* start stream and print events */ }\n```\n\n```bash\n# build steps (illustrative)\n# 1) compile C library\n# 2) run `go build` with CGO_ENABLED=1\n```\n\n## Follow-up Questions\n- How to support multiple independent subscriptions efficiently?\n- How would you cleanly cancel a stream and free resources across CGO boundaries?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T05:40:02.411Z","createdAt":"2026-01-19T05:40:02.411Z"},{"id":"q-4262","question":"Design a CGOA wrapper for a C event system that streams events on a background thread: \n\nC API:\ntypedef void (*event_cb)(int id, const char* payload, void* user);\nvoid start_events(void);\nvoid stop_events(void);\nvoid register_event_cb(event_cb cb, void* user);\n\nRequirements:\n- In Go, expose func RegisterHandlers(hs []Handler) (cleanup func(), err error) where Handler has id int and Callback func(string)\n- Use cgo.Handle to pass Go callbacks to C safely; ensure callbacks from C invoke the correct Go handler and do not poison GC\n- Support registering multiple independent handlers concurrently; events must route to the right callback; stop_events cleans resources and prevents further callbacks\n- Provide a minimal header and a C implementation that emits events every 50ms on a worker thread\n- Provide a Go binding and a small program that registers three handlers, prints received payloads, then calls the cleanup when done\n- Discuss lifecycle and CGO threading caveats?","answer":"Use a CGOA wrapper that stores Go callbacks in a sync.Map and passes a cgo.Handle integer as the user pointer to the C callback. The C side emits events on a thread and calls back through an exported ","explanation":"## Why This Is Asked\nTests ability to bridge Go and C via CGO under concurrency, including safe callback invocation from C threads, memory management, and lifecycle cleanup. Emphasizes correct use of cgo.Handle and avoiding Go GC pitfalls.\n\n## Key Concepts\n- CGO thread safety and Go callback lifetimes\n- cgo.Handle usage to pass Go values to C\n- Concurrency: multiple independent handlers, event routing\n- Cleanup: unregister, stop C thread, prevent use-after-free\n\n## Code Example\n```c\n// header: event_api.h\ntypedef void (*event_cb)(int id, const char* payload, void* user);\nvoid start_events(void);\nvoid stop_events(void);\nvoid register_event_cb(event_cb cb, void* user);\n```\n```go\n// binding.go (simplified)\npackage eventapi\n\nimport \"C\"\n\n//export goEventHandler\nfunc goEventHandler(id C.int, payload *C.char, user unsafe.Pointer) {\n    // dispatch using the handle stored in user\n}\n```\n\n## Follow-up Questions\n- How would you handle backpressure if event rate overwhelms Go side?\n- What are potential deadlocks with stop_events and in-flight callbacks, and how to mitigate them?","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Bloomberg","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T10:51:21.172Z","createdAt":"2026-01-19T10:51:21.172Z"},{"id":"q-4336","question":"Design a CGOA wrapper for a C library that provides an asynchronous API using a completion callback. Expose a Go function AsyncCompute(src []byte) ([]byte, error) that can run concurrently from multiple goroutines. Provide a C header and minimal C implementation that schedules a callback on a new thread; show a Go binding using CGO and a short program launching two concurrent calls. Include build steps?","answer":"I'd implement a per-call waiter keyed by id. In Go, generate a unique id, register a chan for the result, and invoke the C async_compute with that id and a trampoline to the Go callback (exported). Th","explanation":"## Why This Is Asked\n\nTests ability to design CGO boundaries for async callbacks, memory ownership, and concurrency.\n\n## Key Concepts\n\n- CGO thread-safety and PTHREAD usage\n- Exported Go callbacks from C trampolines\n- Memory management across C and Go (malloc/free)\n- Synchronization of multiple in-flight calls using a map and channels\n\n## Code Example\n\n```c\n// header and trampoline example\n```\n\n```go\n// binding idea\n```\n\n## Follow-up Questions\n\n- How would you handle timeouts or callback errors?\n- How would you extend to streaming results or cancelation?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T14:46:46.911Z","createdAt":"2026-01-19T14:46:46.911Z"},{"id":"q-4445","question":"Design a CGOA wrapper for a C streaming JSON tokenizer: void json_stream_parse(const char* data, size_t len, void (*tok_cb)(int type, const char* value, size_t value_len, void* user), void* user); Tokens types: STRING, NUMBER, TRUE, FALSE, NULL, BEGIN_OBJECT, END_OBJECT, BEGIN_ARRAY, END_ARRAY. Expose Go API: type JsonToken struct { Type TokenType; Value string }; func JsonStreamParse(src []byte) (<-chan JsonToken, func()) . Provide header, minimal C implementation, Go binding, and a test program that feeds two streams concurrently and cancels one stream mid-flight?","answer":"I would implement a thread‑safe CGOA bridge that uses a per‑stream Go manager and a buffered channel to deliver tokens. In the C callback, copy value via C.GoStringN, then send JsonToken{Type, Value} ","explanation":"## Why This Is Asked\nTests understanding of CGO cross‑language callbacks, memory ownership, and cancellation semantics for streaming data.\n\n## Key Concepts\n- CGOA callback lifecycle and thread confinement\n- Safe string marshaling across boundaries\n- Per‑stream lifecycle management with cancellation\n- Resource lifetimes and Go GC interaction\n\n## Code Example\n```c\n// header: json_token.h\ntypedef enum { STRING, NUMBER, TRUE, FALSE, NULL_T, BEGIN_OBJECT, END_OBJECT, BEGIN_ARRAY, END_ARRAY } TokenType;\ntypedef void (*tok_cb)(int type, const char* value, size_t value_len, void* user);\nvoid json_stream_parse(const char* data, size_t len, tok_cb cb, void* user);\n```\n\n```go\n// binding.go (conceptual)\ntype TokenType int\nconst (\n  STRING TokenType = iota\n  // ... other types\n)\ntype JsonToken struct{ Type TokenType; Value string }\nfunc JsonStreamParse(src []byte) (<-chan JsonToken, func()) { /* binding logic */ }\n```\n\n## Follow-up Questions\n- How would you prevent deadlocks if C calls back while Go blocks on a channel?\n- How would you extend to backpressure handling when token production outpaces consumption?","diagram":"flowchart TD\n  A[Caller provides src] --> B[json_stream_parse in C]\n  B --> C{tok_cb invoked}\n  C --> D[Go channel receives JsonToken]\n  D --> E[Go side processes token]\n  E --> F{cancelled?}\n  F -->|yes| G[stop streaming]\n  F -->|no| H[continue streaming]","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Instacart","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T19:27:01.292Z","createdAt":"2026-01-19T19:27:01.294Z"},{"id":"q-4487","question":"CGOA Binding: Implement a C API with an asynchronous progress callback, and provide a Go binding that allows Go code to supply a callback function to receive progress updates. The C API should be: typedef void (*progress_cb)(int progress, void* user); int start_task_async(progress_cb cb, void* user); The C implementation should call cb with progress every 25% and then return 0 on success. Expose a Go wrapper StartTaskWithCallback(cb func(int) error) error and demonstrate concurrent usage by starting two tasks in parallel with distinct callbacks. Provide header, C implementation, Go binding, and a minimal Go program that runs two tasks concurrently. End with a question?","answer":"Approach: bind a C callback into Go by registering a per-task handler in a map keyed by a unique token, and pass that token as user to C. The wrapper should avoid passing Go pointers to C, use //expor","explanation":"## Why This Is Asked\n\nCGO callback integration is a classic pitfall: Go does not allow passing Go pointers to C; you must register callbacks via a C function and store Go callbacks in a per-task context. This tests memory safety, concurrency, and proper cleanup.\n\n## Key Concepts\n\n- CGO callbacks and //export\n- Passing Go values vs pointers across FFI\n- Per-task context and lifecycle\n- Concurrency and thread-safety\n\n## Code Example\n\n```c\n// task.h\ntypedef void (*progress_cb)(int progress, void* user);\nint start_task_async(progress_cb cb, void* user);\n```\n\n```c\n// task.c\n#include \"task.h\"\n#include <unistd.h>\nstatic progress_cb g_cb;\nstatic void* g_user;\nint start_task_async(progress_cb cb, void* user){\n    g_cb = cb; g_user = user;\n    for (int i = 1; i <= 4; ++i){\n        if (g_cb) g_cb(i * 25, g_user);\n        sleep(1);\n    }\n    return 0;\n}\n```\n\n```go\n// task.go\npackage task\n/*\n#include \"task.h\"\n*/\nimport \"C\"\nimport (\n    \"errors\"\n    \"sync\"\n)\nvar callbacks sync.Map // token -> func(int) error\n\n// StartTaskWithCallback starts a C task with a Go callback gateway\nfunc StartTaskWithCallback(f func(int) error) error {\n    // simplified placeholder for gateway logic\n    // would register f and pass a C callback that looks up the Go function\n    return errors.New(\"not implemented in this snippet\")\n}\n```\n\n```go\n// main.go\npackage main\nimport (\n  \"fmt\"\n  \"sync\"\n  \"time\"\n  \"your/module/task\"\n)\nfunc main(){\n  var wg sync.WaitGroup\n  wg.Add(2)\n  go func(){\n    defer wg.Done()\n    task.StartTaskWithCallback(func(p int) error { fmt.Println(\"A progress:\", p); return nil })\n  }()\n  go func(){\n    defer wg.Done()\n    task.StartTaskWithCallback(func(p int) error { fmt.Println(\"B progress:\", p); return nil })\n  }()\n  time.Sleep(3 * time.Second)\n  wg.Wait()\n  fmt.Println(\"done\")\n}\n```\n\n## Follow-up Questions\n\n- How would you ensure the Go callback does not get GC'd while C holds a pointer to it?\n- How would you manage multiple concurrent tasks with distinct contexts and error propagation?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Cloudflare"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T20:48:56.621Z","createdAt":"2026-01-19T20:48:56.621Z"},{"id":"q-4500","question":"CGO Callback Bridge: Design a CGOA wrapper so C can invoke a Go closure on a background thread. Provide: a C header with typedef void (*cb_t)(int, const char*); void register_cb(cb_t, void*); and a Go binding exposing RegisterCallback(fn func(int, string)) (handle, error) and Unregister(handle). Implement a registry mapping handles to Go closures, export a Go callback entry, dispatch via a channel, and demonstrate with a concurrent test?","answer":"I'd implement a Go-side registry that maps opaque handles to Go closures, exposed through RegisterCallback(fn func(int, string)) (handle, error) and Unregister(handle). The C side stores the handle and invokes a single exported Go callback entry point. The Go callback dispatches through a channel to execute the appropriate closure on a background thread, ensuring thread safety and proper lifecycle management.","explanation":"## Why This Is Asked\nTests CGO callback implementation with cross-language lifecycles and concurrent execution.\n\n## Key Concepts\n- CGO export mechanisms\n- Go closures mapped to C handles\n- Thread-safe dispatch from C to Go\n- Memory ownership and Unregister semantics\n\n## Code Example\n```c\n// header sketch\ntypedef void (*cb_t)(int, const char*);\nvoid register_cb(cb_t cb, void* user);\n```\n\n```go\n// export go_cb(...) // signature as used by C\n```\n\n## Follow-up Questions\n- How to avoid deadlocks when C calls back synchronously?\n- How to ensure correctness with multiple registrants?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T07:49:48.358Z","createdAt":"2026-01-19T21:39:12.344Z"},{"id":"q-4531","question":"CGOA Binding: Given a C library API:\n\nvoid register_listener(void* ctx, void (*cb)(int event, const char* data));\nvoid unregister_listener(void* ctx);\n\nDesign a CGOA wrapper that lets Go code subscribe to events via a Go channel. Implement:\n- A C header exposing the callback type and registration functions\n- Go binding using //export to route C callbacks to Go; use cgo.Handle to map Go channels\n- A small Go program that starts two independent listeners and prints incoming events\n- Build steps?","answer":"Use a CGO bridge with a Go channel per listener, store channels via a cgo.Handle, pass the handle as ctx to C, export a Go callback GoCb(int, const char*) and forward to the respective channel. Provide build instructions using `go build` with appropriate CGO flags.","explanation":"## Why This Is Asked\nInterfacing C callbacks with Go via CGO is common in high-performance systems. This tests understanding of memory ownership, callback lifetimes, and safe cross-language synchronization.\n\n## Key Concepts\n- CGO callbacks and //export directives\n- cgo.Handle for bridging Go values to C\n- Memory ownership and cross-language resource management\n- Concurrency patterns with multiple listeners and per-listener channels\n\n## Code Example\n```c\n// cgo_listener.h\ntypedef void (*cb_t)(int event, const char* data);\nvoid register_listener(void* ctx, cb_t cb);\nvoid unregister_listener(void* ctx);\n```\n\n```go\n// binding.go\npackage main\n// #include \"cgo_listener.h\"\n// extern void GoCb(int event, const char* data);\nimport \"C\"\nimport \"unsafe\"\n\nfunc main() {\n    ch1 := make(chan Event, 10)\n    ch2 := make(chan Event, 10)\n    \n    handle1 := C.malloc(C.size_t(unsafe.Sizeof(C.uintptr_t(0))))\n    handle2 := C.malloc(C.size_t(unsafe.Sizeof(C.uintptr_t(0))))\n    \n    // Register listeners and handle events...\n}\n```","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Microsoft","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T04:57:04.885Z","createdAt":"2026-01-19T22:42:20.450Z"},{"id":"q-4653","question":"Design a CGOA wrapper for a C library that provides asynchronous computation via a callback: void compute_async(const uint8_t* data, size_t n, void (*cb)(const uint8_t* result, size_t m, void* user), void* user); Expose a Go API ComputeAsync(src []byte) (<-chan []byte, <-chan error) that streams results back via channel; implement memory safety, cancellation, and cross-GO thread-safety; include a header, minimal C wrapper, Go binding, and a small program that runs ComputeAsync in two goroutines concurrently?","answer":"Use a CGO-exported trampoline callback and a Go channel per call. Allocate a cgo.Handle for a Go channel, pass a C function that sends chunks back via the channel, and free on completion. Use runtime.","explanation":"## Why This Is Asked\nTests understanding of cross-language async callbacks, CGO safety, and memory management. It also probes how to map C callbacks to Go channels and how to cancel/cleanup.\n\n## Key Concepts\n- CGO callback handling and cgo.Handle\n- Memory ownership across C-Go boundary\n- Concurrency isolation and cancellation\n- Runtime considerations (GOMAXPROCS, CGO thread affinity)\n\n## Code Example\n```c\n// header\nvoid compute_async(const uint8_t* data, size_t n, void (*cb)(const uint8_t* result, size_t m, void* user), void* user);\n```\n```go\n// binding sketch\nfunc ComputeAsync(src []byte) (<-chan []byte, <-chan error) { /* ... */ }\n```\n\n## Follow-up Questions\n- How would you implement cancellation? \n- How do you test memory safety across calls?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T06:59:54.896Z","createdAt":"2026-01-20T06:59:54.896Z"},{"id":"q-4716","question":"Wrap a C API that manages a configuration as an opaque handle. The C API provides:\n\ntypedef struct Config Config;\nConfig* config_new(const char* json);\nconst char* config_to_json(const Config* cfg);\nvoid config_free(Config* cfg);\n\nThe string returned by config_to_json is allocated with malloc and must be freed with free. Build a CGO wrapper in Go exposing:\n\ntype ConfigHandle struct { ptr *C.Config }\nfunc CreateConfig(json string) (*ConfigHandle, error)\nfunc ConfigToJSON(h *ConfigHandle) (string, error)\nfunc (h *ConfigHandle) Close() error\n\nRequirements:\n- Allocate and free memory correctly, translate C strings to Go strings, and free buffers.\n- Ensure safe usage across two goroutines by calling CreateConfig in two goroutines, then pass to ConfigToJSON in parallel, and free the handles?","answer":"Use a CGO wrapper that creates a new Config with C.config_new(C.CString(json)) and returns an error if NULL. For ConfigToJSON, call C.config_to_json(h.ptr), convert with C.GoString, then C.free on the","explanation":"## Why This Is Asked\nTests ability to bridge C memory life cycles, error handling, and CGO threading basics with opaque handles.\n\n## Key Concepts\n- CGO memory ownership and C.GoString\n- Freeing C-allocated buffers with C.free\n- Opaque C handles in Go wrappers\n- Concurrent calls safety without shared state\n\n## Code Example\n```c\n// config.h\ntypedef struct Config Config;\n Config* config_new(const char* json);\n const char* config_to_json(const Config* cfg);\n void config_free(Config* cfg);\n```\n```c\n// config.c (minimal)\n#include <stdlib.h>\n#include <string.h>\n#include \"config.h\"\n\nstruct Config { char* data; };\nConfig* config_new(const char* json){ if(!json) return NULL; Config* c=malloc(sizeof(Config)); c->data=strdup(json); return c; }\nconst char* config_to_json(const Config* cfg){ return cfg? cfg->data: NULL; }\nvoid config_free(Config* cfg){ free(cfg->data); free(cfg); }\n```\n```go\n// binding.go\npackage main\n\n// #include \"config.h\"\n// #cgo CFLAGS: -I.\nimport \"C\"\nimport (\n  \"errors\"\n  \"unsafe\"\n)\n\ntype ConfigHandle struct{ ptr *C.Config }\n\nfunc CreateConfig(json string) (*ConfigHandle, error){ cstr := C.CString(json); defer C.free(unsafe.Pointer(cstr)); cfg := C.config_new(cstr); if cfg == nil { return nil, errors.New(\"config creation failed\") }; return &ConfigHandle{ptr: cfg}, nil }\n\nfunc ConfigToJSON(h *ConfigHandle) (string, error){ if h==nil || h.ptr==nil { return \"\", errors.New(\"nil handle\") }\n  cstr := C.config_to_json(h.ptr); if cstr == nil { return \"\", nil }\n  s := C.GoString(cstr); C.free(unsafe.Pointer((*C.char)(unsafe.Pointer(cstr))))\n  return s, nil\n}\n\nfunc (h *ConfigHandle) Close() { if h!=nil && h.ptr!=nil { C.config_free(h.ptr); h.ptr = nil }\n}\n```\n\n## Follow-up Questions\n- How would you adapt this to streaming JSON results?\n- What if config_to_json returns a static string; how would you adjust memory management?","diagram":"flowchart TD\n  A[Go code] --> B[C API: config_new]\n  B --> C[ConfigHandle]\n  C --> D[C API: config_to_json]\n  D --> E[Go string]\n  E --> F[Go Close frees resources]","difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Google","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T09:45:03.358Z","createdAt":"2026-01-20T09:45:03.358Z"},{"id":"q-4737","question":"Design a CGOA wrapper for a C API: void get_message(char* buf, size_t* len); if buf is NULL, return required len in *len; otherwise copy up to *len-1 bytes, NUL-terminate, and set *len to actual length. Expose in Go a function GetMessage() (string, error) that performs the two-step call, converts the result to a Go string, and frees any allocated memory if needed. Provide header, minimal C, the Go binding, and a small program that launches two goroutines calling GetMessage concurrently to validate thread-safety?","answer":"Describe a two-step CGO pattern: first call with buf NULL to obtain len, allocate buffer in Go, call again, convert with GoStringN, and return. Include error checks for truncation and NULLs, and ensur","explanation":"## Why This Is Asked\nTests understanding of two-pass C APIs, memory ownership across CGO, and safe string conversion, plus basic concurrency.\n\n## Key Concepts\n- Two-pass C API usage\n- Memory management across Go/C boundaries\n- CGO string conversion and error handling\n- Concurrency safety with CGO calls\n\n## Code Example\n```javascript\n// Go binding sketch (conceptual)\n#include <stdlib.h>\n#include <string.h>\n\nint get_message(char* buf, size_t* len);\n\n// Go usage: GetMessage() (string, error) implemented in Go\n```\n\n```javascript\n// Go binding outline (pseudo)\nimport \"C\"\nimport (\n  \"fmt\"\n  \"unsafe\"\n)\n\nfunc GetMessage() (string, error) {\n  var n C.size_t\n  if C.get_message(nil, &n) != 0 { return \"\", fmt.Errorf(\"error\") }\n  buf := make([]byte, int(n))\n  if C.get_message((*C.char)(unsafe.Pointer(&buf[0])), &n) != 0 { return \"\", fmt.Errorf(\"error\") }\n  return string(buf[:int(n)-1]), nil\n}\n```\n\n## Follow-up Questions\n- How would you handle larger data exceeding Go's contiguous allocations?\n- How would you adapt for cancellation or timeouts in long-running C operations?\n- How would you test concurrency safety and memory leaks in this wrapper?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T10:37:07.551Z","createdAt":"2026-01-20T10:37:07.554Z"},{"id":"q-4860","question":"CGOA wrapper: given a C API\n\nvoid process_buffer(const uint8_t* in, size_t in_len, void (*chunk_cb)(const uint8_t* chunk, size_t len, void* user), void* user);\n\nThe function processes the input buffer and emits encrypted chunks via chunk_cb. Implement a CGOA wrapper in Go that exposes:\n\nfunc ProcessBuffer(in []byte) (<-chan []byte, func())\n\n- The function starts processing synchronously in a goroutine; chunks are copied into Go slices and sent on the channel; a cancel function terminates processing and frees resources.\n\nProvide a C header, a minimal C implementation, the Go binding, and a small Go program that runs two concurrent ProcessBuffer calls on different inputs?","answer":"To implement this, use CGO with //export to route chunk_cb into Go, copy each C chunk into a Go slice, and send on a channel. Store the Go channel in a cgo.Handle to keep it alive, and provide a cance","explanation":"## Why This Is Asked\nTests CGOA callback lifecycle, memory ownership, and safe cross-language concurrency without leaks.\n\n## Key Concepts\n- CGO callbacks from C to Go using //export\n- Managing Go values across C with cgo.Handle\n- Channel-based streaming and cancellation safety\n\n## Code Example\n```go\n// Skeleton: start, receive chunks, cancel\n```\n\n## Follow-up Questions\n- How would you handle errors reported via the C callback and propagate them on the Go side?\n- What cleanup guarantees would you add for repeated ProcessBuffer calls in a long-running process?","diagram":"flowchart TD\n  A[ProcessBuffer in Go] --> B[Passs through CGO to C]\n  B --> C[C emits chunk_cb calls]\n  C --> D[Go copies to []byte and sends on channel]\n  D --> E[Caller reads from channel; on cancel, stop and free]","difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Meta","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T16:49:24.090Z","createdAt":"2026-01-20T16:49:24.090Z"},{"id":"q-4914","question":"CGOA Binding: Implement a C event emitter and a Go binding that supports multiple listeners. The C library emits events on a background thread and must callback into Go through a CGO-exported function. Expose in C: typedef void (*event_cb)(int event, const char* message, void* ctx); void register_event_listener(event_cb cb, void* ctx); void unregister_event_listener(void* ctx); The Go binding should expose StartListener() (returns a receive-only channel of events: type Event struct { Event int; Message string }) and StopListener() to unregister. Demonstrate two listeners started concurrently and printing events. Provide a header, a minimal C implementation, the Go binding, and a small program?","answer":"Use a per-listener context handle stored in a Go-backed map, pass the handle as ctx from Go to C, implement a CGO-exported Go callback, and call it with event and message. C side runs a background thr","explanation":"## Why This Is Asked\nTests practical CGOA wiring with callbacks, thread safety, and per-listener lifetimes, not just simple wrappers.\n\n## Key Concepts\n- CGO callbacks and //export usage\n- Passing a Go-visible context to C without raw Go pointers\n- Thread safety and runtime constraints when C calls Go\n- Cleanup/unregister patterns and backpressure considerations\n\n## Code Example\n```c\n// evt.h\ntypedef void (*event_cb)(int event, const char* message, void* ctx);\nvoid register_event_listener(event_cb cb, void* ctx);\nvoid unregister_event_listener(void* ctx);\n```\n```c\n// evt.c (minimal emitter)\n#include <pthread.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"evt.h\"\n\nstatic struct { event_cb cb; void* ctx; } listeners[16];\nstatic int n=0; static pthread_t t;\nstatic int run=1;\nvoid* emitter(void*){ int i=0; while(run){ sleep(1); for(int k=0;k<n;k++) listeners[k].cb(i, \"msg\", listeners[k].ctx); i++; } return NULL; }\nvoid register_event_listener(event_cb cb, void* ctx){ if(n<16){ listeners[n++]={cb,ctx}; if(n==1) pthread_create(&t, NULL, emitter, NULL); }}\nvoid unregister_event_listener(void* ctx){ for(int i=0;i<n;i++) if(listeners[i].ctx==ctx){ for(int j=i;j<n-1;j++) listeners[j]=listeners[j+1]; n--; break;} if(n==0) run=0; }\n```\n```go\n// evt.go\npackage main\n/*\n#include \"evt.h\"\n*/\nimport \"C\"\nimport (\n  \"sync\"\n  \"unsafe\"\n)\n\ntype Event struct{ Event int; Message string }\n\nvar listeners sync.Map // ctx -> chan Event\n\n//export goEventCallback\nfunc goEventCallback(event C.int, msg *C.char, ctx unsafe.Pointer) {\n  if v,ok := listeners.Load(ctx); ok {\n    ch := v.(chan Event)\n    ch <- Event{int(event), C.GoString(msg)}\n  }\n}\n\nfunc StartListener() chan Event {\n  ch := make(chan Event, 8)\n  // In a real implementation, generate a unique ctx per listener and pass it to C\n  ctx := unsafe.Pointer(uintptr(new(int)))\n  listeners.Store(ctx, ch)\n  C.register_event_listener((C.event_cb)(C.goEventCallback), ctx)\n  return ch\n}\n\nfunc StopListener(ctx unsafe.Pointer) { C.unregister_event_listener(ctx) }\n```\n\n## Follow-up Questions\n- How would you scale listener counts and ensure cleanup when goroutines terminate?\n- How would you handle events that produce backpressure or long-running messages?","diagram":"flowchart TD\n  GoListener1[Go Listener] --> Emitter\n  GoListener2[Go Listener] --> Emitter\n  Emitter -->|callback| GoListener1\n  Emitter -->|callback| GoListener2","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Bloomberg","Instacart"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T19:04:26.500Z","createdAt":"2026-01-20T19:04:26.500Z"},{"id":"q-5018","question":"Design a CGOA wrapper for a C thread pool library that queues tasks and returns results via a callback. The C API is: typedef void (*task_cb)(int result, void* user); void pool_init(int nthreads); void pool_submit(task_cb cb, void* user); void pool_shutdown(); Provide a Go binding that offers SubmitTask(data int) (<-chan int, func()) which enqueues a task that computes data+1 in C and sends the result back through a Go channel. Include a header, minimal C, the CGO binding, and a small Go program that runs two tasks concurrently?","answer":"Create a CGO wrapper that maps each Go task submission to a unique channel handle, using a CGO-exported callback function that retrieves the channel from a map and sends the result back through Go's channel system.","explanation":"## Why This Is Asked\n\nTests ability to bridge Go closures to C callbacks, manage memory and lifecycle across CGO boundaries, and expose idiomatic Go concurrency patterns through channel-based APIs.\n\n## Key Concepts\n\n- CGO with //export directives and cgo.Handle for Go-to-C communication\n- Passing Go values through C using opaque user pointers\n- Memory ownership and cleanup across language boundaries\n- Channel-based Go APIs wrapping callback-based C code\n- Thread-safe coordination between Go runtime and C threads\n\n## Code Example\n\n```c\n// pool.h\ntypedef void (*task_cb)(int result, void* user);\nvoid pool_init(int nthreads);\nvoid pool_submit(task_cb cb, void* user);\nvoid pool_shutdown();\n```\n\n```c\n// pool.c\n#include \"pool.h\"\n#include <stdlib.h>\n#include <pthread.h>\n\ntypedef struct {\n    task_cb cb;\n    void* user;\n    int data;\n} task_t;\n\nstatic pthread_t* threads;\nstatic task_t* queue;\nstatic int queue_size, head, tail, count;\nstatic pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nstatic int running = 1;\n\nvoid* worker(void* arg) {\n    while (running) {\n        pthread_mutex_lock(&mutex);\n        while (count == 0 && running) {\n            pthread_cond_wait(&cond, &mutex);\n        }\n        if (!running) break;\n        \n        task_t task = queue[head];\n        head = (head + 1) % queue_size;\n        count--;\n        pthread_mutex_unlock(&mutex);\n        \n        task.cb(task.data + 1, task.user);\n    }\n    return NULL;\n}\n\nvoid pool_init(int nthreads) {\n    queue_size = 100;\n    queue = malloc(queue_size * sizeof(task_t));\n    threads = malloc(nthreads * sizeof(pthread_t));\n    \n    for (int i = 0; i < nthreads; i++) {\n        pthread_create(&threads[i], NULL, worker, NULL);\n    }\n}\n\nvoid pool_submit(task_cb cb, void* user) {\n    pthread_mutex_lock(&mutex);\n    queue[tail].cb = cb;\n    queue[tail].user = user;\n    tail = (tail + 1) % queue_size;\n    count++;\n    pthread_cond_signal(&cond);\n    pthread_mutex_unlock(&mutex);\n}\n\nvoid pool_shutdown() {\n    running = 0;\n    pthread_cond_broadcast(&cond);\n    for (int i = 0; i < 4; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    free(threads);\n    free(queue);\n}\n```\n\n```go\n// pool.go\npackage main\n\n/*\n#cgo CFLAGS: -Wall\n#include \"pool.h\"\n*/\nimport \"C\"\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar (\n\tmu      sync.Mutex\n\ttasks   = make(map[C.uintptr_t]chan int)\n\tnextID  C.uintptr_t = 1\n)\n\n//export taskCallback\nfunc taskCallback(result C.int, user C.uintptr_t) {\n\tmu.Lock()\n\tch, ok := tasks[user]\n\tdelete(tasks, user)\n\tmu.Unlock()\n\t\n\tif ok {\n\t\tch <- int(result)\n\t\tclose(ch)\n\t}\n}\n\nfunc init() {\n\tC.pool_init(4)\n}\n\nfunc SubmitTask(data int) (<-chan int, func()) {\n\tch := make(chan int, 1)\n\t\n\tmu.Lock()\n\tid := nextID\n\tnextID++\n\ttasks[id] = ch\n\tmu.Unlock()\n\t\n\tC.pool_submit((*[0]byte)(C.taskCallback), C.uintptr_t(id))\n\t\n\tcancel := func() {\n\t\tmu.Lock()\n\t\tif ch, exists := tasks[id]; exists {\n\t\t\tdelete(tasks, id)\n\t\t\tclose(ch)\n\t\t}\n\t\tmu.Unlock()\n\t}\n\t\n\treturn ch, cancel\n}\n\nfunc main() {\n\tdefer C.pool_shutdown()\n\t\n\tch1, cancel1 := SubmitTask(5)\n\tch2, cancel2 := SubmitTask(10)\n\t\n\tgo func() {\n\t\tselect {\n\t\tcase result := <-ch1:\n\t\t\tfmt.Printf(\"Task 1 result: %d\\n\", result)\n\t\tcase <-time.After(time.Second):\n\t\t\tfmt.Println(\"Task 1 timeout\")\n\t\t}\n\t\tcancel1()\n\t}()\n\t\n\tgo func() {\n\t\tselect {\n\t\tcase result := <-ch2:\n\t\t\tfmt.Printf(\"Task 2 result: %d\\n\", result)\n\t\tcase <-time.After(time.Second):\n\t\t\tfmt.Println(\"Task 2 timeout\")\n\t\t}\n\t\tcancel2()\n\t}()\n\t\n\ttime.Sleep(500 * time.Millisecond)\n}\n```","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Hashicorp","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T04:06:25.660Z","createdAt":"2026-01-20T23:57:30.874Z"},{"id":"q-5089","question":"CGOA wrapper: Given a C library exposing an opaque session type with thread-safe event callbacks across multiple threads: typedef struct session session_t; session_t* session_create(const char* cfg, int* err); void session_ref(session_t* s); void session_unref(session_t* s); void session_set_callback(session_t* s, void (*cb)(int event, const char* data, void* user), void* user); Design a CGOA wrapper that exposes: type Session struct { ptr *C.session_t; evt <-chan Event; } type Event struct { Event int; Data string } Requirements: - Correct lifetime management via ref/unref and Go finalizers - Safe cross-thread callbacks from C to Go using a per-session channel - No blocking Go calls inside the C callback - Two concurrent sessions are handled without interleaving events Provide a C header, minimal C implementation, the Go binding, and a small Go program that creates two sessions and prints events?","answer":"Wrap a C session with ref counting; NewSession creates and increments, finalizer calls session_unref. Use a per-session Go channel stored via a map guarded by a mutex; pass a cgo.Handle to C as user d","explanation":"Why This Is Asked\n\nTests ability to bridge C and Go lifecycles, cross-thread callbacks, and memory management. It enforces ref counting, finalizers, and non-blocking callbacks across threads. It also evaluates structuring per-session state and safe shutdown with multiple concurrent sessions.\n\n## Key Concepts\n\n- CGO lifetimes and ref counting\n- cgo.Handle and cross-thread callbacks\n- runtime.SetFinalizer and runtime.KeepAlive\n- Non-blocking channel communication across threads\n\n## Code Example\n\n```c\n// C header sketch\ntypedef struct session session_t;\nsession_t* session_create(const char* cfg, int* err);\nvoid session_ref(session_t* s);\nvoid session_unref(session_t* s);\nvoid session_set_callback(session_t* s, void (*cb)(int event, const char* data, void* user), void* user);\n```\n\n```go\n// Go binding sketch (high level)\n// package main\n// type Session struct { ptr *C.session_t; evt chan Event }\n// type Event struct { Event int; Data string }\n```\n\n## Follow-up Questions\n\n- How would you extend to multiple callback types?\n- How to diagnose stalls in event delivery?","diagram":"flowchart TD\n  A[Start] --> B[Create two Sessions]\n  B --> C{C callbacks arrive}\n  C --> D[Send events to per-session channels]\n  D --> E[Go handlers process]\n  E --> F[Shutdown triggers session_unref]\n  F --> G[Exit]","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T05:50:42.019Z","createdAt":"2026-01-21T05:50:42.020Z"},{"id":"q-5296","question":"CGOA Binding: Wrap a C library that offers an asynchronous API using a callback: void read_async(int fd, void (*cb)(int status, const char* data, size_t len)); Expose a Go binding that provides ReadAsync(fd int) ([]byte, error) using CGO callbacks, implement a minimal C shim that spawns a thread and invokes cb with sample data, and a short Go program that issues two concurrent reads and prints results. Include headers and build steps?","answer":"Bridge CGO to a C async API by storing a Go value with a cgo.Handle and passing its uintptr to C. The C shim launches a thread, invokes the callback with status and data, then copies data into a Go sl","explanation":"## Why This Is Asked\nTests ability to bridge asynchronous C callbacks into Go, memory lifecycle across CGO, and concurrency semantics in a realistic API surface.\n\n## Key Concepts\n- CGO callback bridge via cgo.Handle\n- Memory management across C/Go (malloc/free, data copying)\n- Threading and lifecycle guarantees with CGO\n\n## Code Example\n\n```c\n// header\nvoid read_async(int fd, void (*cb)(int status, const char* data, size_t len));\n```\n\n```c\n// Example shim (conceptual; actual binding in Go with CGO)\n#include <stdlib.h>\n#include <string.h>\n\nstatic void cb_wrapper(int status, const char* data, size_t len);\n\nvoid read_async(int fd, void (*cb)(int, const char*, size_t)) {\n  // spawn thread and invoke cb with sample data\n}\n```\n\n## Follow-up Questions\n- How would you handle cancellation or timeouts?\n- How to minimize data copying for large payloads?\n- How would you extend to multiple concurrent fds with per-op state?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","NVIDIA","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T15:42:57.364Z","createdAt":"2026-01-21T15:42:57.364Z"},{"id":"q-5344","question":"Design a CGOA wrapper for an opaque C data source API: typedef struct ds_t ds_t; ds_t* ds_create(); void ds_config(ds_t*, const char* key, const char* value); void ds_subscribe(ds_t*, void (*chunk_cb)(const uint8_t* chunk, size_t len, void* user), void* user); void ds_destroy(ds_t*); The Go binding should expose: func SubscribeSource(cfg map[string]string) (<-chan []byte, func()) which initializes with cfg, streams chunks via a channel, and returns a cancel function to stop and free. Include header, minimal C sim, Go binding, and a sample main with two streams?","answer":"Implement a CGOA wrapper for an opaque C data source. The Go API should be SubscribeSource(cfg map[string]string) (<-chan []byte, func()) which creates a ds with ds_create, applies cfg via ds_config f","explanation":"## Why This Is Asked\n\nThis question tests ability to design a CGO boundary around an opaque C handle, manage memory correctly, and map a C callback into a Go channel without leaks or races. It adds configuration data passing and explicit cancellation semantics.\n\n## Key Concepts\n\n- CGO with opaque C types and lifecycle management\n- go:export callbacks and channel-based communication\n- Resource ownership transfer and explicit cancellation\n\n## Code Example\n\n```c\n/* Minimal C header/impl: opaque handle, config, subscribe, destroy */\n#include <stdint.h>\n#include <stddef.h>\n\ntypedef struct ds_t ds_t;\nds_t* ds_create();\nvoid ds_config(ds_t* h, const char* key, const char* value);\nvoid ds_subscribe(ds_t* h, void (*chunk_cb)(const uint8_t* chunk, size_t len, void* user), void* user);\nvoid ds_destroy(ds_t* h);\n```\n\n```go\n// Go binding scaffold: export callback, manage handle, provide SubscribeSource\npackage main\nimport \"C\"\n//export chunkCallback\nfunc chunkCallback(c *C.uint8_t, len C.size_t, user unsafe.Pointer) {\n    // push to channel associated with user\n}\nfunc SubscribeSource(cfg map[string]string) (<-chan []byte, func()) {\n    // create ds, apply cfg, subscribe, and return channel + cancel func\n    return nil, func(){}\n}\n```\n\n## Follow-up Questions\n\n- How would you propagate C-level errors back to Go when a callback encounters an error?\n- How would you extend to multiple independent sources and ensure no cross-talk between channels?\n","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Discord","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T18:59:21.625Z","createdAt":"2026-01-21T18:59:21.625Z"},{"id":"q-5489","question":"Design a CGOA wrapper for a C function:\n\nint compute_stats(const double* samples, size_t n, char** out_summary, double* out_mean, double* out_std);\n\nThe C function allocates a heap-allocated summary string in out_summary and returns 0 on success, non-zero on error. Create a Go binding exposing:\n\nfunc ComputeStats(data []float64) (summary string, mean, std float64, err error)\n\n- Ownership: convert the C string with C.GoString and free it with C.free, after verifying inputs (n>0, data != nil).\n- Concurrency: call ComputeStats from two goroutines on two different data slices to prove thread-safety.\n\nInclude: a header, a minimal C implementation, the Go binding, and a small Go program showing two concurrent calls?","answer":"Use a CGO wrapper that passes a C array of doubles to compute_stats, capturing a malloc-allocated summary string and the mean/std. Convert the summary with C.GoString, then free the C string via C.fre","explanation":"## Why This Is Asked\nTests memory ownership across CGO boundaries, error propagation, and safe concurrent usage of a C API that allocates memory. It also covers input validation and proper cleanup without leaks.\n\n## Key Concepts\n- CGO memory ownership between C and Go\n- Passing Go slices to C as C arrays\n- Handling malloc/free across languages\n- Concurrency safety with per-call state\n\n## Code Example\n```javascript\n// Skeleton usage sketch (not functional) illustrating the binding call\npackage main\n// #include \"stats.h\"\nimport \"C\"\nimport \"fmt\"\n\nfunc main() {\n    data := []float64{1.0, 2.5, 3.2}\n    summary, mean, std, err := ComputeStats(data)\n    if err != nil { fmt.Println(\"err:\", err); return }\n    fmt.Println(summary, mean, std)\n}\n```\n\n## Follow-up Questions\n- How would you handle very large inputs or streaming data?\n- What if compute_stats sometimes returns partial results before free; how to guard?\n","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","NVIDIA","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T02:29:46.174Z","createdAt":"2026-01-22T02:29:46.174Z"},{"id":"q-5515","question":"CGOA Binding: Given a C library with an asynchronous streaming API:\\n\\ntypedef void (*chunk_cb_t)(const uint8_t* chunk, size_t len, void* user);\\nvoid start_stream(void* ctx, chunk_cb_t cb, void* user);\\nvoid stop_stream(void* ctx);\\nunsigned int stream_id(const char* name);\\n\\nDesign a CGOA wrapper that exposes:\\n\\n- A Go function StartStream(name string) (<-chan []byte, func()) which starts the C stream under the hood and sends chunks on the Go channel. Provide a cancel function to stop and free resources.\\n\\n- Ensure safe pointer handling: use a cgo.Handle to store the Go channel reference and pass a pointer to C; ensure each chunk is copied before sending to Go to avoid aliasing after C releases the memory.\\n\\n- Provide a C header and a minimal C implementation; Go binding using //export to route callbacks back to Go; a small Go program that starts two independent streams concurrently and prints the first 4 chunk lengths from each channel.\\n\\nInclude build steps?","answer":"Design a CGOA wrapper for a C library that streams data asynchronously: start_stream(ctx, chunk_cb, user); stop_stream(ctx). Expose Go API: StartStream(name string) (<-chan []byte, func()). Key: use a","explanation":"## Why This Is Asked\\nTests bridging C callbacks to Go channels, memory ownership, and cancellation lifecycles in CGO with concurrency.\\n\\n## Key Concepts\\n- cgo callback bridging and handle management\\n- memory safety across Go/C boundaries\\n- resource lifecycle and cancellation semantics\\n- thread safety between Go and C\\n\\n## Code Example\\n```go\\n// Sample scaffold showing the callback bridge (illustrative)\\npackage main\\nimport \\\"C\\\"\\nimport (\\n  \\\"unsafe\\\"\\n)\\n//export chunkCallback\\nfunc chunkCallback(user unsafe.Pointer, chunk *C.uint8_t, len C.size_t) {\\n  // retrieve channel, copy data, push to Go channel\\n}\\n```\\n\\n## Follow-up Questions\\n- How would you prevent GC from collecting the channel while streams run?\\n- How would you handle backpressure if the channel is slow?","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T04:14:33.453Z","createdAt":"2026-01-22T04:14:33.454Z"},{"id":"q-5768","question":"CGOA Wrapper: Wrap a C key-value store with an opaque handle. The C API is:\ntypedef struct KVStore KVStore;\nKVStore* kv_open(const char* path);\nint kv_put(KVStore*, const char* key, const char* value);\nint kv_get(KVStore*, const char* key, char** out_value);\nvoid kv_free_string(char*);\nvoid kv_close(KVStore*);\n\nExpose a Go binding:\n\ntype KVStore struct{ p *C.KVStore }\nfunc Open(path string) (*KVStore, error)\nfunc (s *KVStore) Put(key, value string) error\nfunc (s *KVStore) Get(key string) (string, error)\n\nUse a finalizer to Close; manage the C-allocated out_value with kv_free_string; allow two goroutines to concurrently Put/Get on the same store. Include a C header, a minimal C impl, the Go binding, and a small Go program that exercises two goroutines?","answer":"Design a CGOA binding for a C key-value store API with an opaque handle. The C API: kv_open, kv_put, kv_get (allocates out_value), kv_free_string, kv_close. Go binding: type KVStore struct{ p *C.KVSto","explanation":"## Why This Is Asked\nTests CGOA memory ownership, opaque handles, and lifetime via finalizers; ensures Go wraps C resources safely under concurrency.\n\n## Key Concepts\n- CGO memory ownership and C string lifetimes\n- opaque C handles in Go wrappers\n- runtime.SetFinalizer for resource cleanup\n- concurrency with shared C resources\n- error translation across languages\n\n## Code Example\n```c\n// kv_store.h\ntypedef struct KVStore KVStore;\nKVStore* kv_open(const char* path);\nint kv_put(KVStore*, const char* key, const char* value);\nint kv_get(KVStore*, const char* key, char** out_value);\nvoid kv_free_string(char*);\nvoid kv_close(KVStore*);\n```\n```c\n#include <stdlib.h>\n#include <string.h>\n#include \"kv_store.h\"\nstruct KVStore { /* simple in-memory placeholder */ };\nKVStore* kv_open(const char* path){ return (KVStore*)malloc(sizeof(KVStore)); }\nint kv_put(KVStore* s, const char* k, const char* v){ return 0; }\nint kv_get(KVStore* s, const char* k, char** out){ *out = NULL; return 0; }\nvoid kv_free_string(char* s){ free(s); }\nvoid kv_close(KVStore* s){ free(s); }\n```\n```go\npackage main\n/*\n#include \"kv_store.h\"\n*/\nimport \"C\"\nimport (\n  \"errors\"\n  \"runtime\"\n  \"unsafe\"\n)\ntype KVStore struct{ p *C.KVStore }\nfunc Open(path string) (*KVStore, error) { cp := C.CString(path); defer C.free(unsafe.Pointer(cp)); s := C.kv_open(cp); if s == nil { return nil, errors.New(\"open failed\") }; v := &KVStore{p: s}; runtime.SetFinalizer(v, func(v *KVStore){ v.Close() }); return v, nil }\nfunc (s *KVStore) Put(key, value string) error { ck := C.CString(key); cv := C.CString(value); defer C.free(unsafe.Pointer(ck)); defer C.free(unsafe.Pointer(cv)); if C.kv_put(s.p, ck, cv) != 0 { return errors.New(\"put failed\") }; return nil }\nfunc (s *KVStore) Get(key string) (string, error) { ck := C.CString(key); defer C.free(unsafe.Pointer(ck)); var cstr *C.char; if C.kv_get(s.p, ck, &cstr) != 0 { return \"\", errors.New(\"get failed\") }; defer C.kv_free_string(cstr); return C.GoString(cstr), nil }\nfunc (s *KVStore) Close() { if s.p != nil { C.kv_close(s.p); s.p = nil } }\n```\n\n## Follow-up Questions\n- How would you ensure thread-safety for concurrent Put/Get on same store?\n- How would you detect and prevent leaks or double-free in production usage?","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Citadel","Cloudflare"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T15:53:02.267Z","createdAt":"2026-01-22T15:53:02.267Z"},{"id":"q-5863","question":"CGOA Design: wrap a C API that uses thread-local context. The C library exposes:\n\ntypedef struct tls_ctx tls_ctx;\ntls_ctx* tls_ctx_create(void);\nvoid tls_ctx_destroy(tls_ctx*);\nconst char* tls_eval(tls_ctx*, const char* input, int* out_len);\n\nDesign a CGOA wrapper that guarantees each Go goroutine binds to its own TLS context without cross-thread leakage. Expose:\n\n- a Go function Eval(input string) (string, error)\n- per-thread TLS binding in C with thread-local storage\n- lifecycle: explicit Close per context and automatic cleanup on thread exit\n\nProvide a minimal C header, a minimal C impl, the Go binding, and a small Go program that runs 8 concurrent Eval calls with distinct inputs?","answer":"Use C thread-local storage to bind a tls_ctx to every OS thread. TLS is created on first tls_eval call for that thread and destroyed on program exit. In Go, wrap tls_eval via CGO; pin the goroutine to","explanation":"## Why This Is Asked\nTests depth in CGOA: thread affinity, TLS lifecycles, and cross-language safety. Highlights per-thread context handling when Go schedulers move goroutines between threads.\n\n## Key Concepts\n- CGO and runtime.LockOSThread\n- C thread-local storage (TLS) and per-thread ctx\n- Resource lifecycle and explicit cleanup\n- Error propagation across language boundaries\n\n## Code Example\n```c\n// tls.h\ntypedef struct tls_ctx tls_ctx;\ntls_ctx* tls_ctx_create(void);\nvoid tls_ctx_destroy(tls_ctx*);\nconst char* tls_eval(tls_ctx*, const char* input, int* out_len);\n```\n```go\n// binding.go (conceptual)\n// #include \"tls.h\"\n// import \"C\"\nimport \"runtime\"\nimport \"unsafe\"\nfunc Eval(input string) (string, error) {\n  runtime.LockOSThread()\n  defer runtime.UnlockOSThread()\n  cstr := C.CString(input)\n  defer C.free(unsafe.Pointer(cstr))\n  var out C.int\n  res := C.tls_eval(nil, cstr, &out)\n  if res == nil {\n    return \"\", fmt.Errorf(\"eval error\")\n  }\n  return C.GoString(res), nil\n}\n```\n\n## Follow-up Questions\n- How would you test for thread leakage or context reuse under high contention?\n- How would you extend to support timeouts or cancellation per Eval call?","diagram":"flowchart TD\n  GoGoroutine --> CGOBridge[CGO Bridge]\n  CGOBridge --> CLibrary[C Library TLS]\n  CLibrary --> GoGoroutine\n  GoGoroutine -->|Eval Result| CGOBridge","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Goldman Sachs","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T19:44:00.451Z","createdAt":"2026-01-22T19:44:00.451Z"},{"id":"q-5896","question":"CGOA Binding: Wrap a C API that reports progress via a callback and returns a malloc'ed string?\n\nC API (example):\ntypedef void (*progress_cb)(int percent, void* ctx);\nvoid start_work(progress_cb cb, void* ctx);\nchar* get_result(); // malloc'ed string or NULL on error\n\nTask: implement a CGOA wrapper that exposes:\n- StartWork(param int) (string, error) which runs start_work and then get_result\n- ProgressStream(param int) (<-chan int, error) returning a Go channel of progress updates while the work runs in background\n- Ensure the C callback safely relays progress to Go without CGO rules violations, manage memory (free the result), and allow cancellation.\n\nProvide a C header, a minimal C wrapper, the Go binding, and a small Go program that consumes the progress channel and prints updates; include build steps?","answer":"Strategy: implement a trampoline for C→Go callbacks and a per-task registry. Expose CGO bindings that keep a Go channel for progress; pass a uintptr ctx to C to map to the Go channel. Use //export to ","explanation":"## Why This Is Asked\nTests CGO callback wiring, memory ownership, and cross-thread safety; ensures proper Go<->C interaction across goroutines.\n\n## Key Concepts\n- CGO callbacks and //export\n- Avoid passing Go pointers to C across threads\n- Managing malloc'd C strings in Go\n- Concurrency: progress channel + cancellation\n\n## Code Example\n```go\n//go:generate\nimport \"C\"\nimport (\n  \"runtime\"\n  \"unsafe\"\n)\n\n//export goProgressCallback\nfunc goProgressCallback(ctx unsafe.Pointer, progress C.int) {\n  // push progress to channel retrieved via ctx\n  // ...\n  runtime.KeepAlive(ctx)\n}\n```\n\n## Follow-up Questions\n- How would you handle multiple concurrent tasks and ensure callback isolation?\n- What are the risks if the C thread continues after Go side cancels the task?","diagram":"flowchart TD\n  A[Start] --> B[Register callback in C]\n  B --> C[Go receives progress via channel]\n  C --> D[Get final result and free C memory]\n  D --> E[Return to caller]","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Microsoft","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T21:10:17.172Z","createdAt":"2026-01-22T21:10:17.172Z"},{"id":"q-5923","question":"CGOA Binding: Async C Callback to Go? You have a C API: typedef void (*cb_t)(int status, const char* message, void* user); void start_job(int payload, cb_t cb, void* user); Design a CGOA wrapper that exposes RunJob(payload int) (string, error) which starts a job and returns the final status message when the C callback fires. Provide a minimal C header and glue that simulates asynchrony, and explain how to map each Go call to a unique ID, bridge the callback to Go without passing Go pointers to C, and manage memory for C strings?","answer":"Use a per-call opaque handle with a Go callback bridged via //export. RunJob generates a unique ID, stores a channel in a sync.Map, and passes the ID as user data to C.start_job. The C callback retrieves the ID, looks up the corresponding Go channel, and delivers the status and message. The Go function blocks on the channel, receives the result, and returns it as (string, error). C strings are copied to Go and freed to prevent memory leaks.","explanation":"## Why This Is Asked\nThis tests the ability to bridge a C asynchronous API into Go, focusing on safe callback routing, memory ownership, and CGO compliance.\n\n## Key Concepts\n- CGO callbacks with //export directives\n- Memory management: proper freeing of C strings\n- Thread safety: per-call handles and sync.Map\n- Go pointer passing restrictions in CGO\n- Preventing garbage collection and pointer escapes\n\n## Code Example\n```c\n// header\ntypedef void (*cb_t)(int status, const char* message, void *user);\nvoid start_job(int payload, cb_t cb, void *user);\n```\n\n```go\n// A minimal bridge would include a unique ID system, channel mapping,\n// and proper memory management for C-to-Go string conversion.\n```","diagram":"flowchart TD\n  A[Go RunJob] --> B[generate id]\n  B --> C[store chan/map]\n  C --> D[call C.start_job with id]\n  D --> E[callback bridge via //export]\n  E --> F[deliver to channel]\n  F --> G[Go RunJob returns string]","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","DoorDash"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T05:46:34.492Z","createdAt":"2026-01-22T22:32:28.681Z"},{"id":"q-5948","question":"CGOA Binding Challenge: A C library exposes ErrorInfo* get_errors(int* count) returning an malloc'ed array of ErrorInfo (struct { int code; char* msg; }), with count entries. Design a CGOA wrapper that exposes in Go:\n\ntype CGError struct { Code int; Message string }\n\nfunc Errors() ([]CGError, error)\n\nInclude a C header with the struct and declaration, a minimal C implementation, and a Go binding that copies messages with C.GoString, frees memory via free, and a short Go program to print errors?","answer":"To implement this safely, call get_errors to retrieve the malloc'ed array and count, allocate a Go slice of CGError sized by count, then iterate through each entry converting the C.msg to a Go string using C.GoString and copying the Code. After processing, free both the ErrorInfo array and each individual message to prevent memory leaks.","explanation":"## Why This Is Asked\nTests memory ownership across CGO: who frees what, and how to convert C strings safely.\n\n## Key Concepts\n- CGO memory ownership and free responsibilities\n- Converting C strings to Go with C.GoString\n- Handling arrays allocated in C and freeing them\n- Error mapping from C to Go errors\n\n## Code Example\n```c\n// error.h\n#ifndef ERROR_H\n#define ERROR_H\n\ntypedef struct {\n    int code;\n    char* msg;\n} ErrorInfo;\n\nErrorInfo* get_errors(int* count);\n\n#endif\n```\n\n```c\n// error.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"error.h\"\n\nErrorInfo* get_errors(int* count) {\n    *count = 2;\n    ErrorInfo* errors = malloc(sizeof(ErrorInfo) * (*count));\n    \n    errors[0].code = 404;\n    errors[0].msg = strdup(\"Not Found\");\n    \n    errors[1].code = 500;\n    errors[1].msg = strdup(\"Internal Server Error\");\n    \n    return errors;\n}\n```\n\n```go\n// error.go\npackage main\n\n/*\n#cgo CFLAGS: -I.\n#cgo LDFLAGS: -L. -lerror\n#include \"error.h\"\n#include <stdlib.h>\n*/\nimport \"C\"\n\nimport (\n\t\"fmt\"\n\t\"unsafe\"\n)\n\ntype CGError struct {\n\tCode    int\n\tMessage string\n}\n\nfunc Errors() ([]CGError, error) {\n\tvar count C.int\n\terrorPtr := C.get_errors(&count)\n\tif errorPtr == nil {\n\t\treturn nil, fmt.Errorf(\"failed to get errors\")\n\t}\n\n\tdefer C.free(unsafe.Pointer(errorPtr))\n\n\tresult := make([]CGError, int(count))\n\tslice := (*[1 << 28]C.ErrorInfo)(unsafe.Pointer(errorPtr))[:count:count]\n\n\tfor i := 0; i < int(count); i++ {\n\t\tresult[i].Code = int(slice[i].code)\n\t\tresult[i].Message = C.GoString(slice[i].msg)\n\t\tC.free(unsafe.Pointer(slice[i].msg))\n\t}\n\n\treturn result, nil\n}\n\nfunc main() {\n\terrors, err := Errors()\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t\treturn\n\t}\n\n\tfor _, err := range errors {\n\t\tfmt.Printf(\"Code: %d, Message: %s\\n\", err.Code, err.Message)\n\t}\n}\n```\n\n## Follow-up Questions\n- How would you handle error messages that are not UTF-8?\n- What changes if get_errors returns NULL on error vs empty list?","diagram":"flowchart TD\n  A[Start] --> B[Call get_errors]\n  B --> C{count>0?}\n  C -->|Yes| D[Copy to Go slice]\n  D --> E[Free memory]\n  E --> F[Return CGError slice]\n  C -->|No| F","difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Snap","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T05:30:22.904Z","createdAt":"2026-01-22T23:33:53.755Z"},{"id":"q-6059","question":"CGOA wrapper: design a Go binding for a C streaming API that calls a chunk callback from any thread. Expose StartStream(input []byte) (<-chan []byte, func()) and support multiple concurrent streams with safe cancellation and memory management. Include C header, a minimal C shim, the Go binding using //export and go:linkname or cgo.Handle, and a short Go program demonstrating two streams in parallel?","answer":"Use a per-stream state, tracked by a cgoh.Handle, with a Go dispatcher receiving C on_chunk calls. Bind with //export to route into a Go channel, copy chunks into new slices, and expose Stop to cancel","explanation":"## Why This Is Asked\nTests knowledge of CGO interop, cross-thread callbacks, and memory ownership with non-Go libraries. It probes lifecycle, cancellation, and avoiding pointer escapes.\n\n## Key Concepts\n- CGO callbacks across threads\n- go:export and cgoh.Handle mappings\n- Memory ownership and finalizers\n- Concurrency with multiple streams\n\n## Code Example\n```c\n// header\nvoid start_stream(const uint8_t* data, size_t len, void (*cb)(const uint8_t*, size_t, void*), void* user);\n```\n\n```javascript\n// Placeholder illustrating bindings approach\n```\n\n## Follow-up Questions\n- How would you handle panics across the boundary?\n- How to measure overhead and ensure no GC stalls during streaming?\n","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","Microsoft","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T07:07:19.351Z","createdAt":"2026-01-23T07:07:19.351Z"},{"id":"q-6117","question":"Design a CGOA wrapper for a C API that processes a batch of images and reports progress via a callback: typedef void (*progress_cb)(int step, const char* message, void* user); void process_batch(const char** image_paths, int count, progress_cb cb, void* user); Expose in Go: func ProcessBatch(paths []string) (<-chan ProgressEvent, func()). Ensure per-call state, safe callbacks via //export, and proper memory ownership. Demonstrate two concurrent batches?","answer":"A strong answer outlines: use //export to route progress_cb to Go, map per-call state with a cgo.Handle, convert C messages with C.GoString and free C buffers, spawn a Go goroutine to forward events i","explanation":"## Why This Is Asked\nTests ability to design a CGO callback boundary with per-call state, safe memory handling, and concurrent invocations. It probes understanding of Go<->C lifetimes and cancellation patterns.\n\n## Key Concepts\n- CGO callbacks and //export wiring\n- Per-call state management with cgo.Handle\n- Memory ownership and string lifetimes across boundaries\n- Concurrency: multiple concurrent processes, non-blocking callbacks\n- Cleanup: cancel function, avoids leaks\n\n## Code Example\n```javascript\n// Header (C)\ntypedef void (*progress_cb)(int step, const char* message, void* user);\nvoid process_batch(const char** image_paths, int count, progress_cb cb, void* user);\n\n// Go binding sketch\ntype ProgressEvent struct { Step int; Message string }\nfunc ProcessBatch(paths []string) (<-chan ProgressEvent, func()) { /* ... */ }\n\n//export progressCallback\n//export progressCallback\nfunc progressCallback(step C.int, msg *C.char, user unsafe.Pointer) { /* ... */ }\n```\n\n## Follow-up Questions\n- How would you handle very long-running batches to avoid starving the Go scheduler?\n- How would you ensure cleanup when the channel is closed or the operation is canceled?","diagram":"flowchart TD\nA[ProcessBatch] --> B[C callback in C]\nB --> C[Go exported progressCallback]\nC --> D[Go channel emits ProgressEvent]\nE[Cancel] --> F[Cleanup resources]","difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Instacart","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T09:42:51.935Z","createdAt":"2026-01-23T09:42:51.936Z"},{"id":"q-6166","question":"CGOA Callback Bridge: Given a C API with typedef void (*event_cb)(int event_id, const char* payload); void register_event_source(event_cb cb); implement a CGO-based Go binding that lets Go supply a Go function as an event handler invoked by C on each event. Include: a C header exposing the API, a minimal C implementation that periodically emits events from a background thread, a Go binding exposing RegisterEventHandler(fn func(int, string)) error, and a small Go program demonstrating concurrent event handling and clean shutdown. How would you implement?","answer":"Use //export to expose a Go callback, create a C wrapper that calls the exported Go function, and register that wrapper with register_event_source. Store the Go handler in a sync.Map or a single funct","explanation":"## Why This Is Asked\nTests CGO callback patterns, exported Go callbacks, cross-language memory mgmt, and thread-safety.\n\n## Key Concepts\n- CGO callbacks across language boundaries\n- Using //export to bridge Go and C\n- Managing memory and string data between Go and C\n- Thread-safety and lifecycle: registration, dispatch, and shutdown\n\n## Code Example\n```javascript\n// Bridge sketch (not full, shows core idea)\n// In Go: //export eventBridge\n// func eventBridge(id C.int, payload *C.char)\n// In C: void cEventBridge(int id, const char* p) { eventBridge((int)id, p); }\n```\n\n## Follow-up Questions\n- How would you detect and debug callback re-entrancy or panic in Go?\n- How would you test for memory leaks and ensure proper cleanup across shutdowns?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Citadel","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T11:35:36.221Z","createdAt":"2026-01-23T11:35:36.221Z"},{"id":"q-6318","question":"CGOA Binding: Async Event API with Callbacks? You have a C API that delivers events via a callback signature: typedef void (*event_cb_t)(int event_id, const char* payload, void* user); void register_event_source(event_cb_t cb, void* user); void emit_test_events(int count). Implement a CGO Go binding exposing ListenEvents() (<-chan Event, error) with Event struct { ID int; Msg string }. Pass a Go channel via the user pointer, export a Go callback, ensure safe conversion of payload to string, and proper lifecycle (unregister/cleanup). Demonstrate concurrency by starting two listeners and reading events from both channels. Provide C header, shim, and small Go program?","answer":"Implement a CGO bridge that uses an exported Go callback to receive C events and a Go handle to map user data to a Go channel. Use a cgo.Handle to pass the channel pointer through the C API as void*, ","explanation":"## Why This Is Asked\nTests ability to bridge C callbacks to Go, manage lifetimes, and reason about CGO safety and concurrency.\n\n## Key Concepts\n- CGO callback bridging\n- runtime/cgo handles\n- memory management between C and Go\n- avoiding Go pointers in C calls\n\n## Code Example\n\n```c\n// header snippet\ntypedef void (*event_cb_t)(int, const char*, void*);\nvoid register_event_source(event_cb_t cb, void* user);\n```\n\n```go\n// binding sketch (exported callback example)\n//export goEvent\nfunc goEvent(event C.int, payload *C.char, user unsafe.Pointer) {\n    // h := cgo.Handle(user)\n    // ch := h.Value().(chan Event)\n    // ch <- Event{ID:int(event), Msg: C.GoString(payload)}\n}\n```\n\n## Follow-up Questions\n- How would you handle backpressure if events flood faster than Go can process?\n- How to safely cleanup and unregister callbacks on shutdown?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Snowflake","Square","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T19:05:14.594Z","createdAt":"2026-01-23T19:05:14.594Z"},{"id":"q-6422","question":"Design a CGOA wrapper for a C long-running data processor that reports progress via a callback: void process_data_async(const uint8_t* data, size_t len, void (*progress)(int pct, void* user), void* user); Expose in Go: func ProcessData(data []byte) (<-chan int, func()) which starts processing in a separate C thread, forwards progress updates to a Go channel, and returns a cancel function to stop and free resources. Include a header, a minimal C implementation, the Go binding, and a small Go program showing two concurrent processors?","answer":"Create a per-call Go context and pass a go:export callback to C. Use a cgo.Handle to hold a Go channel and send progress integers from the C callback. ProcessData allocates the handle, invokes process_data_async with the exported callback, and returns a channel and cancel function. The cancel function aborts processing and deletes the handle to prevent memory leaks.","explanation":"## Why This Is Asked\nTests knowledge of CGO cross-language callbacks, memory ownership, and safe cancellation in a realistic long-running task.\n\n## Key Concepts\n- CGO callbacks from C to Go\n- go:export integration\n- Per-call context via cgo.Handle\n- Thread lifecycle and cancellation\n- Resource cleanup across language boundaries\n\n## Code Example\n\n```c\n// header: proc.h\n#ifndef PROC_H\n#define PROC_H\n#include <stdint.h>\n#include <stdlib.h>\n\ntypedef void (*progress_cb)(int pct, void* user);\nvoid process_data_async(const uint8_t* data, size_t len, progress_cb cb, void* user);\nvoid abort_processing(void* handle);\n#endif\n```\n\n```c\n// implementation: proc.c\n#include \"proc.h\"\n#include <pthread.h>\n#include <unistd.h>\n\ntypedef struct {\n    const uint8_t* data;\n    size_t len;\n    progress_cb cb;\n    void* user;\n    int cancelled;\n    pthread_t thread;\n} process_context_t;\n\nstatic void* process_thread(void* arg) {\n    process_context_t* ctx = (process_context_t*)arg;\n    for (int i = 0; i <= 100 && !ctx->cancelled; i++) {\n        usleep(10000); // simulate work\n        if (ctx->cb) ctx->cb(i, ctx->user);\n    }\n    return NULL;\n}\n\nvoid process_data_async(const uint8_t* data, size_t len, progress_cb cb, void* user) {\n    process_context_t* ctx = malloc(sizeof(process_context_t));\n    ctx->data = data;\n    ctx->len = len;\n    ctx->cb = cb;\n    ctx->user = user;\n    ctx->cancelled = 0;\n    pthread_create(&ctx->thread, NULL, process_thread, ctx);\n    pthread_detach(ctx->thread);\n}\n\nvoid abort_processing(void* handle) {\n    process_context_t* ctx = (process_context_t*)handle;\n    if (ctx) ctx->cancelled = 1;\n}\n```\n\n```go\n// binding: proc.go\npackage main\n\n/*\n#cgo CFLAGS: -I.\n#cgo LDFLAGS: -L. -lproc\n#include \"proc.h\"\n#include <stdint.h>\n\n//export progressCallback\nvoid progressCallback(int pct, void* user) {\n    // This will be implemented in Go\n}\n*/\nimport \"C\"\nimport (\n    \"runtime\"\n    \"sync\"\n    \"unsafe\"\n)\n\ntype processor struct {\n    ch    chan int\n    ctx   *C.process_context_t\n    mutex sync.Mutex\n}\n\nvar processors = make(map[uintptr]*processor)\nvar processorsMutex sync.Mutex\n\n//export progressCallback\nfunc progressCallback(pct C.int, user unsafe.Pointer) {\n    handle := uintptr(user)\n    processorsMutex.Lock()\n    defer processorsMutex.Unlock()\n    \n    if proc, exists := processors[handle]; exists {\n        select {\n        case proc.ch <- int(pct):\n        default:\n        }\n    }\n}\n\nfunc ProcessData(data []byte) (<-chan int, func()) {\n    ch := make(chan int, 10)\n    proc := &processor{ch: ch}\n    \n    handle := C.malloc(C.size_t(unsafe.Sizeof(uintptr(0))))\n    *(*uintptr)(handle) = uintptr(unsafe.Pointer(proc))\n    \n    processorsMutex.Lock()\n    processors[uintptr(handle)] = proc\n    processorsMutex.Unlock()\n    \n    cdata := (*C.uint8_t)(unsafe.Pointer(&data[0]))\n    C.process_data_async(cdata, C.size_t(len(data)), \n        (C.progress_cb)(C.progressCallback), handle)\n    \n    cancel := func() {\n        proc.mutex.Lock()\n        defer proc.mutex.Unlock()\n        \n        if proc.ctx != nil {\n            C.abort_processing(unsafe.Pointer(proc.ctx))\n        }\n        \n        processorsMutex.Lock()\n        delete(processors, uintptr(handle))\n        processorsMutex.Unlock()\n        \n        C.free(handle)\n        close(ch)\n    }\n    \n    runtime.SetFinalizer(proc, func(*processor) {\n        cancel()\n    })\n    \n    return ch, cancel\n}\n```\n\n```go\n// main.go\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    data1 := make([]byte, 1000)\n    data2 := make([]byte, 2000)\n    \n    ch1, cancel1 := ProcessData(data1)\n    ch2, cancel2 := ProcessData(data2)\n    \n    go func() {\n        for pct := range ch1 {\n            fmt.Printf(\"Processor 1: %d%%\\n\", pct)\n        }\n    }()\n    \n    go func() {\n        for pct := range ch2 {\n            fmt.Printf(\"Processor 2: %d%%\\n\", pct)\n        }\n    }()\n    \n    time.Sleep(2 * time.Second)\n    cancel1()\n    \n    time.Sleep(1 * time.Second)\n    cancel2()\n    \n    fmt.Println(\"All processors stopped\")\n}\n```\n\n## Implementation Notes\n- Use cgo.Handle for safe Go object references\n- Implement proper cancellation and cleanup\n- Handle concurrent access with mutexes\n- Use buffered channels to prevent blocking\n- Set finalizers for resource cleanup","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","Scale Ai","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T05:04:29.426Z","createdAt":"2026-01-23T23:34:45.922Z"},{"id":"q-6495","question":"CGOA Binding: Implement a safe Go wrapper for a C library that returns a heap-allocated binary blob. The C side exposes: typedef struct { size_t len; unsigned char* data; } Blob; Blob* gen_blob(int seed, size_t n); void blob_free(Blob* b); Provide: a header exposing the API, a minimal C implementation, a Go binding using CGO implementing MakeBlob(n int) ([]byte, error) that copies data into a Go slice and frees via blob_free, and a small Go program that concurrently calls MakeBlob(256) from multiple goroutines and prints a checksum to prove independence. End with ?","answer":"Implement a CGO wrapper that calls C.gen_blob(seed,n) producing a Blob{len,data}; copy data into a Go []byte, then call blob_free. Ensure no Go pointers cross into C, validate NULL, and free on error.","explanation":"## Why This Is Asked\nTests memory lifecycle and concurrency safety when crossing the Go/C boundary. Requires safe copying, explicit freeing, and avoidance of Go pointers in C.\n\n## Key Concepts\n- CGO memory management\n- Safe cross-language data transfer\n- Concurrency and race avoidance\n\n## Code Example\n```c\n// blob.h\ntypedef struct { size_t len; unsigned char* data; } Blob;\nBlob* gen_blob(int seed, size_t n);\nvoid blob_free(Blob* b);\n```\n```go\n// blob.go\n/*\n#include \"blob.h\"\n*/\nimport \"C\"\nimport \"unsafe\"\nimport \"fmt\"\nfunc MakeBlob(n int) ([]byte, error) {\n  b := C.gen_blob(0, C.size_t(n))\n  if b == nil { return nil, fmt.Errorf(\"C gen_blob failed\") }\n  data := C.GoBytes(unsafe.Pointer(b.data), C.int(b.len))\n  C.blob_free(b)\n  return data, nil\n}\n```\n\n## Follow-up Questions\n- How would you adapt this to streaming data in chunks?\n- How would you add context cancellation in Go while a C call is in progress?\n","diagram":"flowchart TD\n  A[Go calls MakeBlob] --> B[C.gen_blob allocates Blob]\n  B --> C[Copy to Go slice]\n  C --> D[Call blob_free]\n  D --> E[Return data to Go]","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","DoorDash","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T05:31:54.335Z","createdAt":"2026-01-24T05:31:54.337Z"},{"id":"q-6559","question":"CGOA Wrapping: Given a C API that streams real-time sensor data via a dedicated thread and a callback:\n\ntypedef void (*sensor_cb)(const uint8_t* data, size_t len, void* user);\nvoid sensor_start(sensor_cb cb, void* user);\nvoid sensor_stop();\n\nDesign a CGOA wrapper that exposes:\n\nfunc StartSensorStream() (<-chan []byte, func())\n\n- The wrapper should start the C producer in its own thread, marshal chunks into Go slices on a channel; ensure callbacks do not call Go code from non-Go threads or via cgo restrictions; implement a Go binding that uses cgo.Handle to pass per-stream Go channels; support cancellation and proper resource cleanup; ensure multiple streams can run concurrently with their own channels; include a minimal C header/implementation and a small Go program that demonstrates two concurrent streams. Include build steps?","answer":"To pass data safely, bind per-stream Go channels via a cgo.Handle. The C callback should enqueue data to a Go goroutine (not call Go directly from C threads). Use a unique per-stream handle stored in ","explanation":"## Why This Is Asked\nEdge cases around CGO callbacks, thread context, and memory ownership are critical in real-time streaming. This tests safe data transfer without crossing Go/C boundaries unsafely, and robust cancellation.\n\n## Key Concepts\n- cgo.Handle for passing Go values to C\n- Avoid calling Go from arbitrary C threads\n- Thread-safe per-stream channel mapping\n- Proper cleanup and runtime.KeepAlive\n\n## Code Example\n```c\n// sensor.h\ntypedef void (*sensor_cb)(const uint8_t* data, size_t len, void* user);\nvoid sensor_start(sensor_cb cb, void* user);\nvoid sensor_stop();\n```\n```c\n// sensor.c (minimal sketch)\n#include \"sensor.h\"\n#include <stdlib.h>\nstatic void dummy_cb(const uint8_t* d, size_t l, void* u) {\n    // placeholder for callback from sensor thread\n}\nvoid sensor_start(sensor_cb cb, void* user) { /* start thread and invoke cb(...) */ }\nvoid sensor_stop() { /* stop thread */ }\n```\n\n```go\n// sensor_bind.go\npackage main\n/*\n#include \"sensor.h\"\n*/\nimport \"C\"\nimport (\n  \"runtime\"\n  \"sync\"\n  \"unsafe\"\n)\n\n//export goCallback\nfunc goCallback(data *C.uint8_t, len C.size_t, user unsafe.Pointer) {\n  // map user to Go channel via goHandle and forward data\n  _ = runtime.KeepAlive(user)\n}\n\nfunc StartSensorStream() (<-chan []byte, func()) {\n  ch := make(chan []byte)\n  // store channel in a handle and pass to C as user\n  // return a cancel function that stops and closes channel\n  return ch, func() { /* stop and close */ }\n}\n```\n\n## Follow-up Questions\n- How would you test for deadlocks and data races in this wrapper?\n- How would you adapt if the C API occasionally delivers partial frames across callbacks?","diagram":"flowchart TD\n  Start([Start]) --> CallbackInvoked[Sensor callback invoked]\n  CallbackInvoked --> Enqueue[Enqueue to per-stream channel via Go goroutine]\n  Enqueue --> ChannelOut[Channel delivers []byte to caller]\n  ChannelOut --> Cancel[Cancel cleans up resources]\n","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","Plaid","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T08:02:28.686Z","createdAt":"2026-01-24T08:02:28.686Z"},{"id":"q-6631","question":"CGOA Wrapping: You are given a C API with a background job and a progress callback. Design a CGOA wrapper that exposes StartJobWithProgress(jobID int, onProgress ProgressFunc) error, where ProgressFunc is func(int) bool. The C API: typedef void (*progress_cb)(int, void*); void start_job(int, progress_cb, void*); void cancel_job(int); Implement header, a minimal C stub, the Go binding, and a small Go program that demonstrates progress updates and cancellation?","answer":"Bridge a Go callback through CGO by storing the ProgressFunc in a cgo.Handle and passing its uintptr as the C callback context. The C progress_cb calls back into Go via a //export function, which retr","explanation":"## Why This Is Asked\nTests cross-language callbacks, memory management, and thread-safety in CGO wrappers; also probes lifecycle management of Go values passed to C.\n\n## Key Concepts\n- CGO callback bridging\n- cgo.Handle usage for Go values\n- Avoiding Go pointers in C memory\n- Thread affinity and lifecycle management\n\n## Code Example\n```c\n// header: progress.h\ntypedef void (*progress_cb)(int percent, void* ctx);\nvoid start_job(int job_id, progress_cb cb, void* ctx);\nvoid cancel_job(int job_id);\n```\n```go\n// binding.go (skeleton)\npackage main\n/*\n#include \"progress.h\"\n*/\nimport \"C\"\nimport (\n  \"runtime\"\n  \"sync\"\n  \"unsafe\"\n)\n\ntype ProgressFunc func(int) bool\n\nfunc StartJobWithProgress(jobID int, onProgress ProgressFunc) error {\n  // store handle and call C.start_job with unsafe.Pointer(uintptr(jobID)) as ctx\n  return nil\n}\n\n//export progress_cb\nfunc progress_cb(percent C.int, ctx unsafe.Pointer) {\n  // retrieve Go ProgressFunc and invoke\n}\n```\n\n## Follow-up Questions\n- How would you handle multiple concurrent jobs without leaking handles?\n- How would you test this wrapper under high concurrency and GC pressure?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Instacart","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T10:48:55.297Z","createdAt":"2026-01-24T10:48:55.297Z"},{"id":"q-6751","question":"CGOA Binding: Implement a CGOA wrapper for a C function with signature void compute_chunk(const float* data, size_t n, void (*cb)(const float* chunk, size_t len, void* user), void* user, int terminate); Terminate can be signaled by setting terminate to 1. Expose a Go API:\n\nfunc ComputeChunks(data []float64, chunkSize int) (<-chan []float64, func())\n\n- The binding should launch processing in a goroutine, deliver each chunk as a new slice to the channel, support cancellation, ensure multiple concurrent calls from different goroutines do not race on global state, and clean up the C resources properly. Provide C header, C impl, Go binding, and a sample main that runs two ComputeChunks calls concurrently?","answer":"Use a per-call handle to map C callbacks to a Go channel. Provide a C wrapper that accepts a callback and a void* user; in Go, allocate a channel, wrap it with runtime/cgo.NewHandle, and pass the hand","explanation":"## Why This Is Asked\nTests ability to design safe, concurrent CGO bridges with per-call state and cancellation.\n\n## Key Concepts\n- CGO callback routing using Go handles\n- Memory ownership and avoiding cross-thread Go access\n- Per-call isolation and cleanup\n\n## Code Example\n```go\n// Bridge sketch (not full implementation)\n```\n\n## Follow-up Questions\n- How would you handle backpressure if C outpaces Go consumer?\n- How would you extend to support multiple callback types without recompiling?","diagram":"flowchart TD\n  A[Go calls ComputeChunks] --> B[C passes data and handle to C]\n  B --> C[CGO callback delivers chunks]\n  C --> D[Go channel receives chunks]\n  D --> E[Caller reads chunks]","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","IBM","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T15:43:29.066Z","createdAt":"2026-01-24T15:43:29.066Z"},{"id":"q-6838","question":"CGOA wrapper: Given a C API that streams frames via a callback:\\n\\nvoid start_stream(void (*frame_cb)(const uint8_t* frame, size_t len, void* user), void* user);\\n\\nEach frame is allocated by the C side (malloc) and must be freed after copying to Go. Design a CGOA wrapper that exposes:\\n\\nfunc StartStream() (<-chan []byte, func())\\n\\n- The channel delivers copies of each frame; StartStream returns a cancellation function to stop streaming and free resources. Implement header, a minimal C implementation, the Go binding using //export to route callback to Go with a go.Handle mapping, and a small Go program that starts two streams in parallel and reports frame counts. Include build steps?","answer":"Use CGO with a Go-exported callback to forward each frame to a Go channel mapped by a per-stream handle. The C side allocates frames (malloc); Go copies len bytes into a new Go slice and calls free on","explanation":"## Why This Is Asked\nTests memory ownership across CGO, callback routing, and channel-based streaming under concurrency.\n\n## Key Concepts\n- CGO callbacks via //export\n- go.Handle mapping and thread-safety\n- Memory ownership: malloc vs free across Go boundary\n- Cancellation and resource lifecycle\n\n## Code Example\n```c\n// header: void start_stream(void (*frame_cb)(const uint8_t*, size_t, void*), void* user);\n```\n\n```go\n//go:export frameCallback\nfunc frameCallback(data *C.uint8_t, len C.size_t, user unsafe.Pointer) { /* copy to Go slice and send */ }\n```\n\n## Follow-up Questions\n- How would you handle backpressure if Go consumer lags?\n- How to avoid GC stalls due to large frame copies?\n","diagram":"flowchart TD\n  A[CGOA Question] --> B[StartStream]\n  B --> C[Callback]\n  C --> D[Go Channel]\n  D --> E[Two Streams]\n  E --> F[Cancellation/Cleanup]","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T19:32:01.107Z","createdAt":"2026-01-24T19:32:01.107Z"},{"id":"q-6938","question":"CGOA Binding: Streaming data via C callback into Go?\n\nProvide a header with:\n- typedef void (*chunk_cb_t)(const uint8_t*, size_t, void*);\n- void start_stream(chunk_cb_t cb, void* user);\n- void stop_stream();\n\nExpose in Go a binding exposing StartStreaming() (<-chan []byte, <-chan error) that starts the stream and yields each chunk to the channel. Allow two streams concurrently. Include a minimal C implementation that emits deterministic chunks, and a Go program that runs two streams in parallel. Include build steps?","answer":"Use a Go wrapper that registers a Go callback via //export, creates a unique handle per stream stored in a map, passes the handle as the C user pointer, and in the callback copies data into a Go slice.","explanation":"## Why This Is Asked\nTests understanding of CGO callbacks, memory management, and concurrency. It also probes ability to design safe lifetime handling across Go<->C barriers.\n\n## Key Concepts\n- CGO callbacks and //export\n- cgo.Handle or uintptr context passing\n- Memory safety: copy vs. share\n- Concurrency: per-stream channels and isolation\n\n## Code Example\n```javascript\n// not actual code here; see explanation\n```\n\n## Follow-up Questions\n- How would you handle backpressure if Go processes lagged behind C chunks?\n- How to avoid leaks if a stream errors mid-flight?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Google","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T05:45:37.728Z","createdAt":"2026-01-24T23:38:30.880Z"},{"id":"q-6992","question":"Design a CGOA wrapper for a C library providing a dynamic int vector. Expose: vec_new, vec_push, vec_sum, vec_free. Implement a Go binding with type VecHandle and methods NewVec, Push, Sum, Free. Provide a minimal C header/implementation, CGO bindings, and a Go program that shares a single Vec across 3 goroutines each pushing 0..999; verify the final sum is 1498500. Include build steps?","answer":"Implement a C Vec with malloc/realloc, expose vec_new, vec_push, vec_sum, vec_free. In Go, wrap as type VecHandle { cvec *C.Vec; mu sync.Mutex }; func NewVec() *VecHandle; func (v *VecHandle) Push(x i","explanation":"## Why This Is Asked\nTests CGO memory ownership and safe concurrency when wrapping a C resource.\n\n## Key Concepts\n- CGO ownership and manual Free\n- Go concurrency with shared C state\n- Lightweight C dynamic array implementation\n\n## Code Example\n```c\ntypedef struct Vec Vec;\nVec* vec_new();\nvoid vec_push(Vec*, int);\nint vec_sum(Vec*);\nvoid vec_free(Vec*);\n```\n\n```go\n// binding sketch\nimport \"C\"\ntype VecHandle struct{ cvec *C.Vec; mu sync.Mutex }\nfunc NewVec() *VecHandle { return &VecHandle{cvec: C.vec_new()} }\nfunc (v *VecHandle) Push(x int) { v.mu.Lock(); defer v.mu.Unlock(); C.vec_push(v.cvec, C.int(x)) }\nfunc (v *VecHandle) Sum() int { v.mu.Lock(); defer v.mu.Unlock(); return int(C.vec_sum(v.cvec)) }\nfunc (v *VecHandle) Free() { C.vec_free(v.cvec) }\n```\n\n## Follow-up Questions\n- How would you test for data races in this wrapper?\n- How would you implement auto-release via finalizers and CGO thread safety?","diagram":"flowchart TD\n  GoCode[Go binding] --> CGOBind[CGO Bridge]\n  CGOBind --> VecStruct[Vec in C]\n  GoCode --> Goroutines[Goroutines] \n  Goroutines --> SumCheck[Sum & Verify]","difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Lyft","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T04:28:02.802Z","createdAt":"2026-01-25T04:28:02.802Z"},{"id":"q-7104","question":"CGOA wrapper: A C library exposes a session-based pub/sub API with opaque handles. Design and implement a CGOA wrapper that lets Go code receive messages via Go channels. Each session_open must map to an independent channel; data is delivered through a C-to-Go callback using a stable Go value handle; use //export for the callback and a cgo.Handle to pass the channel. Ensure lifecycle cleanup with session_close and a runtime finalizer. Demonstrate two concurrent sessions sending messages to two channels in parallel. Provide header, minimal C, Go binding, and a small program to run in parallel?","answer":"Map each C session_open to a dedicated Go channel. The C callback signature (session*, const char* topic, const uint8_t* payload, size_t len, void* user) is bridged with a //export function that reads","explanation":"## Why This Is Asked\n\nTests ability to bridge C callbacks into Go without leaking memory and with per-session isolation.\n\n## Key Concepts\n\n- CGO //export callbacks\n- cgo.Handle to pass Go values to C\n- Lifecycle management via runtime.SetFinalizer\n- Concurrent sessions and channel multiplexing\n\n## Code Example\n\n```c\n// header\ntypedef struct session session;\nsession* session_open(const char* cfg, char** err);\nvoid session_close(session*);\ntypedef void (*msg_cb)(session*, const char* topic, const uint8_t* payload, size_t len, void* user);\nint session_subscribe(session*, const char* topic, msg_cb cb, void* user);\n```\n\n```go\n//go binding sketch\n//export goMsgCallback\nfunc goMsgCallback(sess *C.session, topic *C.char, payload *C.uint8_t, len C.size_t, user unsafe.Pointer) {\n  // retrieve channel from handle and push message\n}\n```\n\n```go\n// small program sketch\nfunc main() {\n  // start two sessions and read from their channels concurrently\n}\n```\n\n## Follow-up Questions\n\n- How would you handle backpressure if consumer is slow?\n- How would you test correctness under reentrancy and multi-threaded callbacks?","diagram":"flowchart TD\n  A[Start] --> B[Open two sessions]\n  B --> C[Create channels per session]\n  C --> D[Callbacks push messages]\n  D --> E[Consumers read channels]\n  E --> F[Close sessions]\n  F --> G[End]","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Oracle","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T09:34:43.439Z","createdAt":"2026-01-25T09:34:43.439Z"},{"id":"q-7292","question":"CGOA Wrapper: Wrap a C streaming hash API using per-instance state and safe memory ownership. The C header exposes: typedef struct hash_ctx hash_ctx; hash_ctx* hash_init(int algo); void hash_update(hash_ctx*, const uint8_t* data, size_t len); int hash_finalize(hash_ctx*, uint8_t* out, size_t* out_len); void hash_free(hash_ctx*); Implement a Go binding that exposes: type Hasher interface { Write(p []byte) (n int, err error); Sum() ([]byte, error); Close() error }. Ensure multiple Hasher instances hash concurrently with independent C contexts, deterministic cleanup, and proper error handling. Include header, minimal C impl, Go binding, and a short program hashing two streams in parallel?","answer":"Provide per-hasher C context using hash_init; allocate a unique hash_ctx per Go Hasher; Write calls hash_update; Sum calls hash_finalize and copies the digest; Close frees with hash_free; ensure no sh","explanation":"## Why This Is Asked\n\nThis question probes understanding of cross-language ownership, per-instance state, and safe memory management in CGO, plus concurrent usage patterns.\n\n## Key Concepts\n\n- CGO memory ownership and cross-language errors\n- Per-instance C context management\n- Concurrency: independent contexts vs shared locks\n- Resource cleanup: Close vs finalizers\n- Error propagation across Go/C boundaries\n\n## Code Example\n\n```c\n// header sketch\ntypedef struct hash_ctx hash_ctx;\nhash_ctx* hash_init(int algo);\nvoid hash_update(hash_ctx*, const uint8_t* data, size_t len);\nint hash_finalize(hash_ctx*, unsigned char* out, size_t* out_len);\nvoid hash_free(hash_ctx*);\n```\n\n```go\n// Go binding sketch\ntype Hasher interface {\n  Write(p []byte) (n int, err error)\n  Sum() ([]byte, error)\n  Close() error\n}\n```\n\n## Follow-up Questions\n\n- How would you propagate C errors to Go across multiple goroutines?\n- How would you ensure finalizers run if Close is forgotten?\n","diagram":"flowchart TD\n  A[Go CGO Hasher] --> B[C hash_ctx per instance]\n  B --> C[hash_update]\n  C --> D[hash_finalize]\n  D --> E[Sum results]\n  E --> F[Close frees resources]","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T17:02:46.138Z","createdAt":"2026-01-25T17:02:46.138Z"},{"id":"q-7323","question":"CGOA Binding: wrap a C library that streams events via a callback: void register_cb(void (*cb)(int, const char*, void*)); Expose StartEventStream() error in Go that registers a Go-exported callback, forwards events to a Go channel, and supports two concurrent streams safely. Provide a minimal C header/impl and a Go program printing events in real time?","answer":"Bind a C event-callback to Go safely by exporting a Go function and routing callbacks through a thread-safe queue to a Go channel. The wrapper should register the callback once, avoid storing Go point","explanation":"## Why This Is Asked\nTests understanding of CGO event callbacks, cross-language ownership, and thread-safety.\n\n## Key Concepts\n- CGO callbacks and //export\n- Passing data without Go pointers into C\n- Thread-safety with multiple producers\n- Cleanup and shutdown sequencing\n\n## Code Example\n```go\n// Minimal binding skeleton\npackage main\nimport \"C\"\nimport \"fmt\"\nimport \"unsafe\"\nvar ch = make(chan string)\n//export goEventCallback\nfunc goEventCallback(event C.int, detail *C.char, ctx unsafe.Pointer) {\n    msg := C.GoString(detail)\n    ch <- fmt.Sprintf(\"Event %d: %s\", int(event), msg)\n}\n```\n\n## Follow-up Questions\n- How would you handle backpressure if Go consumer is slow?\n- How to support multiple independent streams beyond two?\n","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Twitter","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T18:45:45.593Z","createdAt":"2026-01-25T18:45:45.593Z"},{"id":"q-7344","question":"Design a CGOA wrapper for a C library that uses reference-counted resource_t handles. API: resource_t* resource_create(); void resource_acquire(resource_t*); void resource_release(resource_t*); int resource_do(resource_t*, const char* cmd). Expose in Go: type Resource struct{ p *C.resource_t; mu sync.Mutex; closed bool }; NewResource() (*Resource, error); Do(cmd string) error; Close() error. Use finalizers and per-handle ref counts to allow safe concurrent Do calls across goroutines. Include header/impl, Go binding, and a small program that runs two Resources in parallel?","answer":"Wrap resource_t with a Go struct { p *C.resource_t; mu sync.Mutex; closed bool }. NewResource calls resource_create(); Do(cmd string) uses a C string and calls resource_do; Close() calls resource_rele","explanation":"## Why This Is Asked\nTests CGO lifetime management, thread safety, and ref counting for shared C resources.\n\n## Key Concepts\n- CGO ownership and memory lifetime\n- Per-handle reference counting\n- Go finalizers and deterministic Close\n- Error translation from C to Go\n\n## Code Example\n```c\ntypedef struct resource_t resource_t;\nresource_t* resource_create();\nvoid resource_acquire(resource_t* r);\nvoid resource_release(resource_t* r);\nint resource_do(resource_t* r, const char* cmd);\n```\n\n```go\ntype Resource struct {\n  p *C.resource_t\n  mu sync.Mutex\n  closed bool\n}\n```\n\n```go\n// additional binding skeleton (pseudo)\n```\n\n## Follow-up Questions\n- How would you propagate errors from resource_do to Go error values?\n- How would you extend to a resource pool with deterministic lifecycle?","diagram":"flowchart TD\n  A[Go: NewResource] --> B[C: resource_create]\n  B --> C{Two paths}\n  C --> D[Go: Do]\n  D --> E[C: resource_release]\n  F[Go: Close] --> E","difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Slack","Twitter","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T19:31:06.427Z","createdAt":"2026-01-25T19:31:06.427Z"},{"id":"q-7538","question":"Design a CGOA wrapper for a C API that enumerates items via a callback. The C API is: typedef struct { int id; const char* name; double value; } item_t; typedef int (*enum_cb)(const item_t* item, void* user); int enumerate_items(enum_cb cb, void* user); The C library allocates item.name; Go binding should expose: type Item struct { ID int; Name string; Value float64 } func EnumerateItems() ([]Item, error) Provide header and minimal C implementation that calls cb for multiple items, a Go binding using CGO, and a test harness that enumerates in parallel, with proper memory ownership and error handling?","answer":"Use a Go handle to pass a Go slice to C via the user pointer, export a Go callback (//export go_item_cb) that converts item_t to Item and appends it under a mutex; call enumerate_items with the C call","explanation":"## Why This Is Asked\nTests bridging of callback-based C APIs with CGO, memory ownership of C strings, and returning a Go slice from C callbacks. It also touches concurrency safety when enumerating in parallel.\n\n## Key Concepts\n- CGO callbacks and //export\n- cgo.Handle for passing Go values to C\n- Go string conversion via C.GoString\n- Memory ownership and lifecycle across language boundaries\n- Synchronization and runtime.KeepAlive during callbacks\n\n## Code Example\n```c\n// header\ntypedef struct { int id; const char* name; double value; } item_t;\ntypedef int (*enum_cb)(const item_t* item, void* user);\nint enumerate_items(enum_cb cb, void* user);\n```\n```c\n// minimal C implementation sketch\nstatic int cb_wrapper(const item_t* item, void* user) { return 0; }\n```\n```go\n//export go_item_cb\nfunc go_item_cb(item *C.item_t, user unsafe.Pointer) C.int { /* convert and append to slice */ return 0 }\n```\n\n## Follow-up Questions\n- How would you handle errors from enumerate_items?\n- How to scale for thousands of items or streaming data?\n- How to cancel enumeration safely from Go side?\n","diagram":"flowchart TD\n  Go EnumerateItems -->|calls| C.enumerate_items(cb, user)\n  C.cb_invocation -->|invokes| Go callback //export go_item_cb\n  Go callback -->|append item| Go slice\n  Go slice -->|return| EnumerateItems\n","difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Lyft","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T07:00:25.996Z","createdAt":"2026-01-26T07:00:25.996Z"},{"id":"q-7573","question":"CGOA Wrapping: A C library offers an opaque Pipeline with asynchronous submit:\n\ntypedef struct Pipeline Pipeline;\nPipeline* pipeline_create(const char* cfg);\nvoid pipeline_submit(Pipeline* p, const uint8_t* in, size_t len, void (*done)(const uint8_t* out, size_t out_len, void* ctx), void* ctx);\nvoid pipeline_destroy(Pipeline* p);\n\nCreate a CGOA wrapper that exposes:\n\nfunc SubmitAndGet(ctx context.Context, cfg string, data []byte) ([]byte, error)\n\n- It should build the pipeline, submit data, wait for a single output via done, copy it to Go, and free C memory. Honor ctx cancellation, allow two concurrent calls, and avoid leaks. Provide header, minimal C, the Go binding with //export, and a small program that runs two parallel submissions?","answer":"Design approach: use a per-call context and a unique handle (via a go Handle) to map the C callback to the correct Go goroutine. Register the C done callback with //export, store the output in a Go sl","explanation":"## Why This Is Asked\nTests deep CGOA bridging: asynchronous C callbacks, per-call lifetimes, and memory ownership across boundaries with context cancellation.\n\n## Key Concepts\n- CGO and //export callbacks\n- go\thandle mapping for multiple in-flight calls\n- memory ownership and freeing across boundaries\n- context-aware cancellation and concurrency safety\n\n## Code Example\n```c\n// header example\ntypedef struct Pipeline Pipeline;\nPipeline* pipeline_create(const char* cfg);\nvoid pipeline_submit(Pipeline* p, const uint8_t* in, size_t len, void (*done)(const uint8_t* out, size_t out_len, void* ctx), void* ctx);\nvoid pipeline_destroy(Pipeline* p);\n```\n```c\n// minimal C impl sketch (no error paths)\n#include <stdlib.h>\n#include \"pipeline.h\"\n\nstruct Pipeline { int dummy; };\nPipeline* pipeline_create(const char* cfg){ (void)cfg; return (Pipeline*)malloc(sizeof(Pipeline)); }\nvoid pipeline_destroy(Pipeline* p){ free(p); }\nvoid pipeline_submit(Pipeline* p, const uint8_t* in, size_t len,\n                     void (*done)(const uint8_t*, size_t, void*), void* ctx){\n  // pretend processing and return a copied output asynchronously via callback\n  uint8_t* out = (uint8_t*)malloc(len);\n  for(size_t i=0;i<len;i++) out[i] = in[i] ^ 0xAA;\n  done(out, len, ctx);\n  free(out);\n}\n```\n```go\n// Go binding sketch (high level)\npackage main\nimport \"C\"\nimport (\n  \"context\"\n  \"unsafe\"\n)\n//export goDone\nfunc goDone(out *C.uint8_t, outLen C.size_t, ctx unsafe.Pointer){\n  // retrieve per-call channel from context and send copied data\n}\nfunc SubmitAndGet(ctx context.Context, cfg string, data []byte) ([]byte, error) {\n  // create Pipeline, submit data, bridge callback to Go, handle cancellation\n  return nil, nil\n}\n```\n\n## Follow-up Questions\n- How would you extend to support multiple simultaneous pipelines with independent configs?\n- How would you detect and prevent callback re-entry across Go threads?\n- What tests would you add to validate memory safety and cancellation behavior?","diagram":"flowchart TD\nA[Go code] --> B[CGOA binding]\nB --> C[C callback bridge]\nC --> D[Go data copy]\nD --> E[Return to caller]","difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Salesforce","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T07:58:07.997Z","createdAt":"2026-01-26T07:58:07.997Z"},{"id":"q-7688","question":"CGOA Challenge: Given a C API that streams data via a callback and uses an opaque Decoder* context, design a CGOA wrapper that exposes:\n- type DecoderHandle struct{}\n- func NewDecoder(config string) (*DecoderHandle, error)\n- func (h *DecoderHandle) Start() (<-chan []byte, func(), error)\n\nThe C API:\n- typedef void (*chunk_cb)(const uint8_t* data, size_t len, void* user);\n- Decoder* decoder_new(const char* config);\n- void decoder_free(Decoder*);\n- void decoder_start(Decoder* d, chunk_cb cb, void* user);\n- void decoder_stop(Decoder* d);\n\nStart should deliver copies of chunks on a Go channel and return a cancellation function to stop and free resources. Ensure multiple decoders run in parallel safely, callbacks route to the correct handle without CGO pointer pitfalls. Include a C header, a minimal C impl, Go binding using //export, and a small Go program that runs two decoders concurrently?","answer":"Design a per-decoder context in C and map each to a Go handle. Go binding exposes NewDecoder(config string) (*DecoderHandle, error) and (h *DecoderHandle) Start() (<-chan []byte, func(), error). Start","explanation":"## Why This Is Asked\nTests ability to bridge C callbacks into Go safely, with per-context lifetimes, memory ownership, and concurrency guarantees. It also probes resource management, cancellation, and race-free routing of callbacks to multiple decoders.\n\n## Key Concepts\n- CGO callbacks and ownership across languages\n- Stable callback routing using per-handle identifiers\n- Resource lifecycle: creation, start, stop, and free\n- Concurrency: multiple decoders in parallel without data races\n\n## Code Example\n```c\n// header concept (minimal)\ntypedef void (*chunk_cb)(const uint8_t* data, size_t len, void* user);\ntypedef struct Decoder Decoder;\nDecoder* decoder_new(const char* config);\nvoid decoder_free(Decoder*);\nvoid decoder_start(Decoder* d, chunk_cb cb, void* user);\nvoid decoder_stop(Decoder* d);\n```\n```go\n// binding sketch (high-level)\n//export goChunkCallback\nfunc goChunkCallback(id C.int, data *C.uint8_t, len C.size_t)\n```\n\n## Follow-up Questions\n- How would you enforce backpressure if consumer slows down?\n- How would you detect and prevent deadlocks between Start calls on multiple decoders?\n- What memory management strategies ensure no leaks when decoders are canceled prematurely?","diagram":null,"difficulty":"advanced","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T13:25:46.636Z","createdAt":"2026-01-26T13:25:46.636Z"},{"id":"q-842","question":"You have a Go service using cgo to wrap a C API. A C function 'char* fetch_data(int id)' returns a malloc-allocated string or NULL on error. Design a safe Go wrapper that converts the result to a Go string, ensures the C allocation is freed, handles NULL with a meaningful error, and notes CGO thread-safety considerations. What implementation would you write?","answer":"Check for NULL, copy with GoString, then free with C.free(unsafe.Pointer(ptr)). Return (string, error). Include <stdlib.h> and declare the C function. Avoid using the original pointer after free; ensu","explanation":"## Why This Is Asked\nAssess memory management, error handling, and CGO pitfalls in real-world bindings.\n\n## Key Concepts\n- CGO memory ownership\n- NULL handling and errors\n- Safe string conversion\n- Thread-safety and allocation\n\n## Code Example\n```javascript\n// Implementation code here\n```\n\n## Follow-up Questions\n- How would you handle multi-string results and encoding issues?\n- How would you test this wrapper for leaks and concurrency?\n","diagram":"flowchart TD\n  A[Wrapper] --> B[Call C.fetch_data]\n  B --> C{ptr != NULL}\n  C -->|Yes| D[GoString & free]\n  C -->|No| E[Return error]","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","PayPal","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T13:26:43.632Z","createdAt":"2026-01-12T13:26:43.632Z"},{"id":"q-870","question":"Design a Go wrapper for a C API with malloc’d results that must be freed, exploring a new angle: ensure thread-safe, single-point ownership transfer for each call and robust error handling when the C call returns a non-zero code or NULL. API: typedef struct { int code; const char* msg; } ScanResult; ScanResult* perform_scan(const char* query); void free_scan_result(ScanResult*); Implement function: func Scan(query string) (string, error)?","answer":"Serialize CGO calls with a mutex, copy the C message to Go, free the C result, and return meaningful errors when nil or code != 0. Pass query as C string and free it. Ensure no Go pointers escape into","explanation":"## Why This Is Asked\nTests memory ownership, error propagation, and CGO threading. It verifies that the candidate safely consumes C-allocated data, prevents leaks, and handles non-thread-safe C APIs in Go.\n\n## Key Concepts\n- CGO memory management and ownership transfer\n- Error handling from C to Go\n- Thread-safety and mutex usage for non-thread-safe C calls\n- Avoiding Go pointers in C and ensuring proper lifetimes\n- Resource finalization patterns\n\n## Code Example\n```go\npackage main\n\n/*\ntypedef struct { int code; const char* msg; } ScanResult;\nScanResult* perform_scan(const char* query);\nvoid free_scan_result(ScanResult*);\n*/\nimport \"C\"\nimport (\n  \"errors\"\n  \"sync\"\n  \"unsafe\"\n)\n\nvar scanMu sync.Mutex\n\nfunc Scan(query string) (string, error) {\n  cQuery := C.CString(query)\n  defer C.free(unsafe.Pointer(cQuery))\n\n  scanMu.Lock()\n  defer scanMu.Unlock()\n\n  res := C.perform_scan(cQuery)\n  if res == nil {\n    return \"\", errors.New(\"nil ScanResult from C\")\n  }\n  defer C.free_scan_result(res)\n\n  if res.code != 0 {\n    msg := C.GoString(res.msg)\n    return \"\", fmt.Errorf(\"scan failed code=%d: %s\", res.code, msg)\n  }\n  out := C.GoString(res.msg)\n  return out, nil\n}\n```\n\n## Follow-up Questions\n- How would you adapt this for a streaming callback API from C?\n- How would you test with race detector and verify memory safety across CGO calls?","diagram":"flowchart TD\n  A[Go calls Scan] --> B[Convert query to C string]\n  B --> C[Call perform_scan]\n  C --> D{Res != NULL}\n  D -->|no| E[Return error]\n  D -->|yes| F{Res.code == 0}\n  F -->|yes| G[Copy Msg, Free res, Return string]\n  F -->|no| H[Copy error, Free res, Return error]\n","difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T13:52:40.902Z","createdAt":"2026-01-12T13:52:40.902Z"},{"id":"q-914","question":"Using cgo, how would you wrap a C function that allocates a string (char*) and returns it, ensuring memory is freed by Go code without leaks, and provide a minimal working example?","answer":"Declare the C function in a preamble, call it from Go, convert the returned char* with C.GoString, and defer C.free(ptr) to avoid leaks. Prefer a small wrapper that owns the allocation and exposes a d","explanation":"## Why This Is Asked\nTests understanding of memory ownership across language boundaries and safe interop.\n\n## Key Concepts\n- cgo memory management\n- Go-C interop patterns\n- Safe wrapper design\n\n## Code Example\n\n```go\n/*\n#include <stdlib.h>\nchar* alloc_str(size_t n) {\n  char* p = (char*)malloc(n+1);\n  if (p) p[n] = '\\0';\n  return p;\n}\n*/\nimport \"C\"\n\nfunc example() {\n  p := C.alloc_str(10)\n  s := C.GoString(p)\n  C.free(p)\n  _ = s\n}\n```\n\n## Follow-up Questions\n- How would you handle allocation failures?\n- How can you avoid GC cross-issue with large strings?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Snap","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T15:27:13.812Z","createdAt":"2026-01-12T15:27:13.812Z"},{"id":"q-950","question":"Implement a minimal CGOA wrapper that exposes a C function int add(int a, int b) to Go. Provide the C header, the Go binding using CGO, and a small Go program that concurrently calls Add from two goroutines to demonstrate thread safety. Include build steps?","answer":"Bridge by CGOA: expose C int add(int a, int b) to Go. In bridge.h declare int add(int a, int b); In Go: include the header, import \\\"C\\\", and implement Add(a,b int) int { return int(C.add(C.int(a), C.","explanation":"## Why This Is Asked\nTo verify practical understanding of bridging C to Go using CGOA, including type conversions and concurrency safety.\n\n## Key Concepts\n- CGOA basics: cgo import and header inclusion\n- Type conversions between C and Go\n- Build/link steps for mixed languages\n- Concurrency: safe calls from multiple goroutines\n\n## Code Example\nExplain how Add wraps C.add as a Go function and how to organize bridge.c/bridge.h and main.go.\n\n## Follow-up Questions\n- How would you handle error returns or errno from C?\n- How to extend to multiple C functions or error propagation?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Snap","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T16:38:23.204Z","createdAt":"2026-01-12T16:38:23.204Z"},{"id":"q-978","question":"Design a CGO bridge for a C streaming API that delivers chunks via a callback: void stream_data(int id, void (*chunk_cb)(const char* data, size_t len, void*), void* ctx). Implement a Go wrapper StreamFromC(id int) (io.Reader, error) that buffers chunks into an io.Pipe and exposes a safe reader, supporting concurrent streams and proper backpressure. Include a C header, a Go CGO binding, and a simple consumer showing two goroutines reading from the reader?","answer":"Leverage a per-stream context and a C callback exported to Go. Use a Go channel to forward chunks, copy data into Go memory, feed an io.Pipe writer, and return an io.Reader to the caller. Ensure clean","explanation":"## Why This Is Asked\nTests ability to bridge callbacks, memory ownership, and streaming backpressure across language boundaries.\n\n## Key Concepts\n- CGO callback bridge and per-stream context\n- Memory ownership and copying from C to Go\n- Streaming via io.Pipe and concurrent reads\n\n## Code Example\n```c\n// stream.h\nvoid stream_data(int id, void (*chunk_cb)(const char*, size_t, void*), void* ctx);\n```\n```go\n// stream_bind.go (skeleton)\n/*\n#cgo CFLAGS: -I./include\n#include \"stream.h\"\n*/\nimport \"C\"\nimport (\n  \"io\"\n)\n\nfunc StreamFromC(id int) (io.Reader, error) {\n  // binding implementation here\n  return nil, nil\n}\n```\n```go\n// consumer.go (usage)\npackage main\nimport (\n  \"io\"\n  \"fmt\"\n)\nfunc main() {\n  r, _ := StreamFromC(42)\n  buf := make([]byte, 1024)\n  for {\n    n, err := r.Read(buf)\n    if err == io.EOF { break }\n    fmt.Printf(\"read %d bytes\\n\", n)\n  }\n}\n```\n\n## Follow-up Questions\n- How would you handle backpressure if C emits chunks faster than Go consumes them?\n- How would you adapt this to multiple ids concurrently without cross-talk?","diagram":null,"difficulty":"intermediate","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Microsoft","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T17:41:57.902Z","createdAt":"2026-01-12T17:41:57.902Z"},{"id":"q-987","question":"Implement a CGO binding for a C function char* greet(const char* name) that returns a newly allocated string. Provide the C header and implementation, a Go binding using CGO that wraps greet in a safe Go function returning (string, error), and a small Go program that concurrently calls the binding from multiple goroutines and frees the allocated memory. How would you handle NULL returns and memory deallocation robustly?","answer":"Use CGO to wrap greet: convert input to a C string, call the C function, check for NULL, convert the result back to a Go string, and free both allocations. Return a Go string and an error. Ensure both","explanation":"## Why This Is Asked\nTests practical CGO understanding: safe memory ownership, error translation, and concurrency.\n\n## Key Concepts\n- CGO boundaries and memory ownership\n- Translating errors from C to Go\n- Safe deallocation of C-allocated strings\n- Concurrency: calling CGO from multiple goroutines\n\n## Code Example\n```go\n// Go binding sketch (not full code)\npackage cgowrap\nimport \"C\"\n// Greet wraps C.greet and converts result to Go string with error handling\nfunc Greet(name string) (string, error) { /* omitted for brevity in answer */ }\n```\n\n## Follow-up Questions\n- How would you model ownership if C returns allocated memory for reuse?\n- How can you detect and prevent use-after-free in long-lived Go values?","diagram":null,"difficulty":"beginner","tags":["cgoa"],"channel":"cgoa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","MongoDB","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T18:32:47.654Z","createdAt":"2026-01-12T18:32:47.654Z"}],"subChannels":["general"],"companies":["Adobe","Airbnb","Amazon","Anthropic","Apple","Bloomberg","Citadel","Cloudflare","Coinbase","Databricks","Discord","DoorDash","Goldman Sachs","Google","Hashicorp","Hugging Face","IBM","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Netflix","OpenAI","Oracle","PayPal","Plaid","Robinhood","Salesforce","Scale Ai","Slack","Snap","Snowflake","Square","Stripe","Tesla","Twitter","Two Sigma","Uber","Zoom"],"stats":{"total":86,"beginner":31,"intermediate":30,"advanced":25,"newThisWeek":35}}