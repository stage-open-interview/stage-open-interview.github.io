{"questions":[{"id":"q-1019","question":"You're operating a CNF-based API gateway cluster that terminates TLS for thousands of tenants across 3 regions. A mandate requires migrating all TLS to post-quantum algorithms with per-tenant keys sourced from an HSM, while delivering zero-downtime upgrades, per-tenant key isolation, and a rollback plan. Outline an end-to-end rollout including (a) inventory and compatibility checks, (b) PQC algorithm and certificate strategy, (c) HSM PKCS#11 integration and key rotation, (d) canary/traffic-mirror rollout and drift detection, (e) observability and rollback criteria?","answer":"Audit TLS usage per tenant; adopt a hybrid post-quantum TLS approach (Kyber/Dilithium) for session keys and per-tenant certificates; load per-tenant keys from an HSM via PKCS#11 with rotation primitiv","explanation":"## Why This Is Asked\nThis question probes practical expertise in upgrading cryptography without downtime, with tenancy isolation and HSM-backed keys. It tests rollout discipline, drift handling, and observability under real-world regulatory pressure.\n\n## Key Concepts\n- Post-quantum cryptography deployment in live CNFs\n- Per-tenant key material management with HSM (PKCS#11)\n- Zero-downtime, region-wise canary rollouts and drift detection\n- Observability: handshake metrics, cipher adoption, rollback criteria\n\n## Code Example\n```javascript\n// Pseudo-code for config wiring\nconst tlsConfig = {\n  pqc: {\n    enabled: true,\n    suites: ['Kyber512', 'Dilithium3']\n  },\n  hsm: {\n    pkcs11Module: '/usr/lib/softhsm/libsofthsm2.so',\n    slot: 1,\n    pin: 'REDACTED'\n  }\n}\n```\n\n## Follow-up Questions\n- How would you verify compatibility with legacy TLS clients during the migration?\n- How would you measure and bound the impact on tenants during the rollout?","diagram":"flowchart TD\n  A[Inventory TLS usage] --> B[Choose PQC suites]\n  B --> C[HSM PKCS11 integration]\n  C --> D[Canary rollout with traffic mirroring]\n  D --> E[Observability metrics]\n  E --> F[Rollback criteria]","difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","LinkedIn","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T19:32:58.382Z","createdAt":"2026-01-12T19:32:58.382Z"},{"id":"q-1040","question":"You're deploying a CNF-based UDP gateway across four data centers. A CVE requires hardware-backed attestation before image execution. Outline a concrete end-to-end rollout plan that (a) signs CNF images with Cosign and SBOMs, (b) enforces attestation via TPM 2.0-based attestation bundles and ImagePolicyWebhook, (c) rolls out region-by-region with traffic mirroring and per-tenant quotas, (d) implements drift detection and automated rollback on attestation failure, and (e) provides observability for attestation metrics and rollback triggers?","answer":"Sign CNF images with Cosign and SBOMs, publish to Rekor. Enforce using TPM 2.0 attestation bundles and an ImagePolicyWebhook policy so only attested images execute. Roll out region-by-region with traf","explanation":"## Why This Is Asked\nTests hardware-backed attestation, signing, and policy enforcement in CNF rollouts, plus region-by-region rollout, drift detection, and observability.\n\n## Key Concepts\n- Cosign and SBOMs with Rekor\n- TPM 2.0 attestation\n- Sigstore attestation bundles\n- ImagePolicyWebhook enforcement\n- Traffic mirroring and per-tenant quotas\n- Drift detection and automated rollback\n- Observability: attestation latency, success rate, per-tenant metrics\n\n## Code Example\n```yaml\napiVersion: policy.k8s.io/v1beta1\nkind: ImageReview\nspec:\n  image: <attested-image>\n  attestation: true\n```\n\n## Follow-up Questions\n- How would you test rollback behavior under attestation failure? \n- What metrics would you surface to detect persistent drift?\n","diagram":"flowchart TD\n  A[CNF Image] --> B[Cosign SBOM Sign]\n  B --> C[Publish to Rekor]\n  C --> D[TPM 2.0 Attestation Bundle]\n  D --> E[ImagePolicyWebhook Gate]\n  E --> F[Region 1 Canary with Traffic Mirroring]\n  F --> G[Drift Reconciliation]\n  G --> H[Observability & Rollback Triggers]","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T20:28:03.844Z","createdAt":"2026-01-12T20:28:03.844Z"},{"id":"q-1071","question":"You're deploying a CNF-based API gateway across 2 Kubernetes clusters. A recent upgrade causes a cross-tenant data bleed under load due to a shared in-memory cache. Outline a beginner-friendly, end-to-end plan to fix and roll out safely: (a) reproduce in staging with two tenants and isolated traffic, (b) implement tenant-scoped cache keys and per-tenant isolation checks, (c) add unit/integration tests for isolation, (d) perform blue/green canary rollout with tenant-based traffic splits, (e) observability: per-tenant SLA metrics and automatic rollback if bleed is detected. Include a minimal code snippet for tenant-scoped cache key?","answer":"Reproduce with two tenants in separate namespaces, enable per-tenant cache keys (tenant_id + resource_id), add a small unit test asserting no cross-tenant data is returned, roll out a blue/green canar","explanation":"## Why This Is Asked\nThis question probes practical skills in tenant isolation, cache safety, and controlled rollouts, plus test design and observability.\n\n## Key Concepts\n- Multi-tenant isolation\n- Tenant-scoped caching\n- Unit/integration tests for isolation\n- Blue/green canary rollouts with traffic splitting\n- Observability and automatic rollback\n\n## Code Example\n```javascript\nfunction cacheKey(tenantId, resourceId) {\n  return `${tenantId}:${resourceId}`;\n}\n```\n\n## Follow-up Questions\n- How would you monitor cross-tenant bleed in production?\n- How would you adapt the canary ratio if bleed indicators appear?","diagram":"flowchart TD\n  A[Start] --> B[Reproduce in staging]\n  B --> C[Implement tenant cache keys]\n  C --> D[Add tests]\n  D --> E[Blue/Green rollout]\n  E --> F[Observe -> Rollback if needed]\n","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Stripe","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T21:31:42.231Z","createdAt":"2026-01-12T21:31:42.231Z"},{"id":"q-1081","question":"You're deploying a CNF-based API gateway that uses workload identities for tenants. Describe an end-to-end plan to enforce identity attestation and per-tenant isolation using SPIRE for SPIFFE IDs, OPA Gatekeeper for policy decisions, and a local Kind testbed. Include (a) issuing and rotating SVIDs, (b) encoding tenant permissions in policies, (c) testing isolation with two tenants, and (d) observability hooks for attestation and policy evaluations?","answer":"SPIRE issues per-tenant SVIDs with 24h rotation; gateway validates SVIDs; policy via OPA Gatekeeper requires SPIFFE ID prefix spiffe://example.org/tenant-<tenant> and tenant-scoped access; test in Kin","explanation":"## Why This Is Asked\nTests knowledge of workload identity and policy enforcement in CNF deployments.\n\n## Key Concepts\n- SPIRE/SPIFFE identities for CNFs\n- OPA Gatekeeper policy enforcement\n- Per-tenant network isolation\n- Observability hooks (attestation metrics, policy latency)\n\n## Code Example\n```rego\npackage cnf.auth\n\ndefault allow = false\n\nallow {\n  input.spiffe_id.startsWith(\"spiffe://example.org/tenant-\")\n  input.tenant == data.tenants[input.spiffe_id].name\n}\n```\n\n## Follow-up Questions\n- How would you rotate SVIDs with zero downtime?\n- How would you validate policy drift and trigger rollback?","diagram":"flowchart TD\n  A[Start] --> B[SPIRE setup]\n  B --> C[OPA policy]\n  C --> D[Kind tests]\n  D --> E[Observability]","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T22:17:18.359Z","createdAt":"2026-01-12T22:17:18.359Z"},{"id":"q-1107","question":"You're deploying a CNF-based API gateway serving two tenants with strict data-retention and per-tenant log-redaction requirements. Outline an end-to-end plan using SPIRE for workload identities and OPA Gatekeeper for policy decisions to enforce data handling rules while enabling zero-downtime upgrades in a local Kind testbed. Include (a) SVID issuance/rotation tied to tenant IDs, (b) tenant-scoped policies for retention windows and redaction, (c) runtime redaction checks on logs/traces, (d) cross-tenant isolation testing under load, and (e) observability hooks for attestation, policy decisions, and redaction misses?","answer":"Propose a two-tenant end-to-end CNF gateway rollout enforcing per-tenant data-retention and log-redaction policies via SPIRE for workload identities and OPA Gatekeeper for policy decisions. Include SV","explanation":"## Why This Is Asked\n\nThis question tests practical integration of workload identity with policy enforcement in a CNF gateway, emphasizing data governance, per-tenant isolation, and non-disruptive upgrades. It requires concrete steps for credential rotation, policy encoding, runtime checks, and observability.\n\n## Key Concepts\n\n- SPIRE SVIDs and workload attestation for multitenant isolation\n- OPA Gatekeeper policy modeling per tenant (retention windows, redaction rules)\n- Runtime log redaction and per-tenant observability\n- Kind-based local testbed for end-to-end verification\n- Zero-downtime rollout with traffic shaping and drift checks\n\n## Code Example\n\n```javascript\nfunction redactLog(entry, policy) {\n  const redacted = { ...entry };\n  (policy.redactFields || []).forEach(field => {\n    if (redacted.hasOwnProperty(field)) redacted[field] = \"***REDACTED***\";\n  });\n  return redacted;\n}\n```\n\n## Follow-up Questions\n\n- How would you rotate SVIDs across tenants with revocation semantics in SPIRE?\n- How would you validate redaction coverage across logs in CI/CD and production?","diagram":null,"difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Meta","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T23:16:16.754Z","createdAt":"2026-01-12T23:16:16.754Z"},{"id":"q-1187","question":"A beginner CNF certification scenario: you implement a gated CI/CD pipeline for a CNF gateway image. Outline an end-to-end workflow to ensure image provenance before deployment: (a) sign CNF images with Cosign using a KMS-backed key, (b) generate and publish SBOMs, (c) enforce signatures via ImagePolicyWebhook, and (d) surface observability in the monitoring stack for signing success/failure and rollback signals. Provide concrete steps and minimal config snippets?","answer":"GitHub Actions CI: build CNF image, sign with Cosign using a KMS-backed key, generate and publish SBOMs, update ImagePolicyWebhook to require signed images, gate deployment on attestation success, and","explanation":"## Why This Is Asked\nTests practical understanding of image provenance gates in CNF pipelines, focusing on Cosign, SBOM, ImagePolicyWebhook, and basic observability.\n\n## Key Concepts\n- Cosign signing with a KMS-backed key\n- SBOM generation and publishing\n- ImagePolicyWebhook enforcement\n- Observability signals and rollback triggers\n- CI/CD gating (e.g., GitHub Actions)\n\n## Code Example\n```javascript\n// CI pseudo steps (pseudocode)\nconst signCmd = \"cosign sign --key kms://my/key ghcr.io/org/cnf-image:${process.env.GITHUB_SHA}\";\n```\n\n## Follow-up Questions\n- How would you test the gate without a real deployment?\n- How would you handle Cosign key rotation with zero downtime?","diagram":"flowchart TD\n  CIBuild[CI Build] --> Sign[Cosign Sign]\n  Sign --> SBOM[SBOM Gen & Publish]\n  SBOM --> Policy[ImagePolicyWebhook]\n  Policy --> Deploy[Deploy to Registry]\n  Deploy --> Observability[Observability Signals]\n","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","LinkedIn","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T04:39:07.086Z","createdAt":"2026-01-13T04:39:07.086Z"},{"id":"q-1221","question":"You're operating a CNF-based API gateway deployed across three regions behind a service mesh. Propose a practical upgrade workflow that enforces runtime integrity along with image attestations: (a) sign images with Cosign using a KMS-backed key and publish SBOMs, (b) require TPM/measured-boot attestation plus runtime integrity checks for CNFs, (c) roll out region-by-region with per-tenant canaries and live connection migration, (d) implement drift detection and automatic rollback on attestation/runtime mismatch, (e) surface observability for sign-off, attestation, and rollback triggers. Provide minimal config references?","answer":"Cosign-sign CNF images with a KMS-backed key and publish SBOMs; gate deploys via ImagePolicyWebhook. Enforce TPM/measured-boot attestation plus runtime integrity checks for CNFs. Roll out region-by-re","explanation":"## Why This Is Asked\nTests a concrete upgrade workflow combining image attestation, hardware-backed integrity, and multi-region rollout with per-tenant considerations.\n\n## Key Concepts\n- Image attestation with Cosign and SBOMs\n- TPM/measured boot and runtime integrity checks\n- ImagePolicyWebhook enforcement\n- Canary-based region rollout with live migration\n- Drift detection and automatic rollback\n- Observability for signatures, attestations, rollbacks\n\n## Code Example\n```javascript\n// Minimal policy concept (illustrative)\nconst policy = { requireAttestation: true, requireSBOM: true, tenantIsolation: true }\n```\n\n## Follow-up Questions\n- How would you validate rollback triggers under peak load?\n- What metrics validate attestation health in dashboards?","diagram":"flowchart TD\n  A[Sign image with Cosign] --> B[Publish SBOM]\n  B --> C[ImagePolicyWebhook]\n  C --> D[TPM/measured boot attestation]\n  D --> E[Runtime integrity checks]\n  E --> F[Region-by-region rollout]\n  F --> G[Drift detection]\n  G --> H[Auto rollback]","difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Netflix","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T05:33:18.061Z","createdAt":"2026-01-13T05:33:18.061Z"},{"id":"q-1347","question":"Advanced CNF certification scenario: deploy a CNF gateway across three air‑gapped data centers. Design an end‑to‑end plan to ensure image provenance and runtime integrity for updates, covering (a) offline Cosign signing with a TPM‑backed key, (b) SBOM generation and private catalog, (c) per‑tenant policy enforcement via OPA/Gatekeeper, (d) edge‑site offline attestation broker, (e) drift detection with automated rollback, and (f) observability hooks. Include concrete config examples?","answer":"Use an offline attestation flow: sign CNF images with Cosign using a TPM-backed key; publish SBOMs to a private catalog; enforce attestation via ImagePolicyWebhook with per-tenant OPA policies; deploy","explanation":"## Why This Is Asked\n\nThis question probes offline attestation, edge CNF deployment, and policy-driven updates in air‑gapped environments, ensuring provenance, integrity, and rollback safety.\n\n## Key Concepts\n\n- Offline attestation and TPM keys\n- SBOM generation and private catalogs\n- ImagePolicyWebhook + OPA/Gatekeeper policies\n- Edge/offline attestation brokers\n- Drift detection and automated rollback\n- Observability/telemetry for attestation and rollbacks\n\n## Code Example\n\n```javascript\n// Pseudo: Cosign signing with TPM key and SBOM publication\ncosign sign --key tpm-key.pem gcr.io/org/cnf-gateway:latest\ncosign generate sbom -o sbom.json gcr.io/org/cnf-gateway:latest\n```\n\n## Follow-up Questions\n\n- How would you handle clock skew between air‑gapped sites and the signing CA?\n- What metrics would you surface to detect attestation drift at scale?","diagram":"flowchart TD\n  A[CNF image] --> B[Cosign signing (TPM)]\n  B --> C[SBOM published]\n  C --> D[ImagePolicyWebhook]\n  D --> E[GitOps rollout]\n  E --> F[Attestation broker (edge)]\n  F --> G[Drift detection]\n  G --> H[Auto rollback]\n  H --> I[Observability]","difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Citadel","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T13:05:53.114Z","createdAt":"2026-01-13T13:05:53.115Z"},{"id":"q-1511","question":"Beginner CNF certification: You manage a CNF API gateway in a single Kubernetes namespace with a private registry and no external access. Outline an end-to-end plan to enforce SLSA provenance for each image before deployment, including (1) build and sign with Cosign using a KMS-backed key, (2) generate and attach SPDX SBOMs, (3) verify SLSA provenance via ImagePolicyWebhook, (4) canary upgrades with rollback on provenance failure, (5) observability for signing events, SBOM validity, and rollback triggers?","answer":"Sign CNF images with Cosign using a KMS-backed key, generate SPDX SBOMs and attach them to the image, enforce SLSA provenance with ImagePolicyWebhook, deploy via canary with rollback on provenance fai","explanation":"## Why This Is Asked\nTests practical understanding of end-to-end CNF provenance using SLSA, Cosign, SBOMs, and in-cluster enforcement, plus observable signals.\n\n## Key Concepts\n- SLSA provenance and Cosign signing with KMS keys\n- SPDX SBOMs and their association with container images\n- ImagePolicyWebhook enforcement in Kubernetes\n- Canary rollout and rollback on provenance failure\n- Observability: signing events, SBOM health, rollback signals\n\n## Code Example\n```yaml\n# Example: minimal ImagePolicyWebhook enforcing SLSA provenance (pseudo)\napiVersion: imagepolicy.k8s.io/v1alpha1\nkind: ImagePolicyRule\nmaliciousPattern: false\nattestation: true\n```\n\n```yaml\n# Sign image with Cosign (conceptual)\ncosign sign --key kms://<vault/key> registry.example.com/cnf-api gateway:1.0.0\n```\n\n```yaml\n# Canary upgrade cue (conceptual)\napiVersion: argoproj.io/v1alpha1\nkind: Rollout\nspec:\n  strategy:\n    canary:\n      steps:\n      - setWeight: 20\n      - pause: { }\n```\n\n## Follow-up Questions\n- How would you test SLSA provenance in a dry-run vs production promotion path?\n- What metrics would you surface to detect provenance drift quickly?","diagram":"flowchart TD\n  A[Code Commit] --> B[CI Build & Sign]\n  B --> C[SBOM Generation]\n  C --> D[Publish to Registry+SBOM]\n  D --> E[ImagePolicyWebhook Enforce]\n  E --> F[Canary Rollout]\n  F --> G{Provenance Valid?}\n  G -- Yes --> H[Full Rollout]\n  G -- No --> I[Rollback & Alert]","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Hashicorp","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T19:47:55.680Z","createdAt":"2026-01-13T19:47:55.681Z"},{"id":"q-1526","question":"In a CNF gateway spanning multiple tenants, implement runtime **per-tenant feature flags** controlled by a central policy server. Describe a concrete plan using SPIRE for tenant identities, OPA for policy evaluation, and a sidecar that hot-reloads policies from a central repo. Include how you detect flag revocation, perform zero-downtime updates, and observability hooks (SBOM provenance, traces, metrics)?","answer":"Implement SPIRE-based tenant identities with per-tenant feature flags controlled by OPA policy evaluation, deployed via a sidecar that hot-reloads policies from a central repository. When flags are revoked or policy evaluation fails, trigger automatic rollback with zero-downtime updates, while maintaining comprehensive observability through SBOM provenance, distributed tracing, and metrics collection.","explanation":"## Why This Is Asked\nTests ability to design runtime policy-driven features with zero-downtime upgrades, tenant identity via SPIRE, and robust observability.\n\n## Key Concepts\n- Runtime policy loading with hot reload\n- Tenant identity via SPIRE SVIDs\n- Policy evaluation with OPA\n- Rollback on revocation or evaluation failure\n- Observability: SBOM health, tracing, metrics\n\n## Code Example\n```yaml\n# Example policy snippet for per-tenant flag\npackage cf.flags\n\ndefault allow = false\n\nallow {\n  input.tenant_id == \"tenant-A\"\n  input.flags[\"new-feature\"] == true\n}\n```\n\n## Follow-up Questions\n- How would you handle policy conflicts between multiple repositories?\n- What strategies would you use for policy versioning and rollback?\n- How do you ensure policy evaluation performance at scale?","diagram":null,"difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Netflix","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T06:49:57.937Z","createdAt":"2026-01-13T20:43:42.258Z"},{"id":"q-1544","question":"You're managing a CNF-based API gateway deployed in two regions, serving three tenants with a single global CI/CD pipeline. Propose an end-to-end upgrade and rollback strategy that delivers zero downtime while guaranteeing strict tenant isolation during updates. Include deployment approach (canary vs blue-green), tenant-aware routing, per-tenant metrics and logging, rollback triggers, and how you would validate the plan in staging that mirrors production. Cite concrete tooling choices (Argo Rollouts, Istio/Envoy, OPA, Prometheus) and touchpoints?","answer":"Implement a canary rollout strategy using Argo Rollouts across both regions, gradually increasing tenant exposure in 5–10% increments. Route traffic through Istio with per-tenant headers for strict isolation, enforced by OPA Gatekeeper policies. Monitor per-tenant metrics via Prometheus and structured logging, with automated rollback triggers based on error rates, latency thresholds, or policy violations.","explanation":"## Why This Is Asked\nInterviewers assess real-world release engineering expertise for CNF environments: multi-region coordination, multi-tenant isolation, and zero-downtime upgrades.\n\n## Key Concepts\n- Canary vs blue-green deployment strategies\n- Tenant isolation through routing and policy enforcement\n- Per-tenant observability (latency, errors, rollback signals)\n- Automated rollback criteria and triggers\n- Production-mirroring staging validation\n\n## Code Example\n```yaml\napiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: gateway-canary\nspec:\n  replicas: 4\n  strategy:\n    canary:\n```","diagram":"flowchart TD\n  A[Canary rollout] --> B[Regional exposure]\n  B --> C{Tenant isolation}\n  C --> D[Per-tenant metrics]\n  D --> E[Automated rollback]","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T06:31:32.100Z","createdAt":"2026-01-13T21:32:16.410Z"},{"id":"q-1571","question":"You’re deploying a CNF API gateway across 6 regions and need strict per-tenant isolation with dynamic rate limits and auditable policy changes. Propose an end-to-end plan that uses SPIRE for per-tenant identities, OPA for policy decisions, Envoy with hot xDS updates, and a shared policy catalog. Include how you push canary upgrades, rollback on drift, and observability for quota hits and policy eval latency?","answer":"Plan an end-to-end approach to enforce per-tenant isolation and dynamic rate limits at an Envoy-based CNF gateway across six regions. Use SPIRE for per-tenant SVIDs, OPA for policy decisions, a shared policy catalog for centralized rule management, and Envoy with hot xDS updates for dynamic configuration. Implement canary upgrades using progressive traffic shifting, rollback on policy drift detection, and comprehensive observability for quota hits and policy evaluation latency.","explanation":"## Why This Is Asked\nEvaluates real-world ability to design cross-region CNF policy, identity, and drift controls.\n\n## Key Concepts\n- SPIRE SVIDs for per-tenant identities\n- OPA/REGO policies for per-tenant rules and rate limits\n- Envoy xDS for dynamic config updates\n- Cosign SBOM signing and policy pack attestations\n- Drift detection, canary rollouts, and rollback criteria\n- Observability: quota hits, policy eval latency, rollback signals\n\n## Code Example\n```javascript\nasync function fetchTenantPolicy(tenant){/* fetch and cache policy; evaluate with OPA */}\n```\n\n## Follow-up Questions\n- How would you handle policy versioning across regions?\n- What metrics would you use to trigger automatic rollbacks?\n- How do you ensure policy consistency during network partitions?","diagram":"flowchart TD\n  A[Request] --> B[SPIRE Auth]\n  B --> C[Envoy xDS]\n  C --> D[OPA Eval]\n  D --> E[Rate Limiter]\n  E --> F[Observability]","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Stripe","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T06:12:37.153Z","createdAt":"2026-01-13T22:34:39.307Z"},{"id":"q-1599","question":"Outline a beginner-friendly, end-to-end workflow to enforce image provenance and runtime integrity per-tenant before deployment, using Cosign signing, SPDX SBOMs, and admission controls (ImagePolicyWebhook + Gatekeeper/OPA). Provide concrete steps and minimal config examples?","answer":"Sign each tenant's CNF image with Cosign using a tenant-scoped key, generate an SPDX SBOM, and attach it as an image annotation. Enforce with ImagePolicyWebhook and a Gatekeeper/OPA constraint that requires both valid signatures and SBOM presence before deployment.","explanation":"## Why This Is Asked\nTests practical per-tenant provenance in CNF gateways: signing, SBOMs, and policy enforcement.\n\n## Key Concepts\n- Tenant-scoped Cosign signing\n- SPDX SBOM generation and annotation\n- Admission controls: ImagePolicyWebhook + Gatekeeper/OPA\n- Canary rollout and observability\n\n## Code Example\n```yaml\n# Gatekeeper constraint (simplified)\napiVersion: constraints.gatekeeper.sh/v1beta1\nkind: K8sCosignConstraint\nmetadata:\n  name: cnf-provenance\nspec:\n  required_signatures: 1\n  required_sboms: 1\n  image_kind: \"cnf/gateway\"\n```\n\n## Follow-up Questions\n- How would you test a tenant's","diagram":"flowchart TD\n  A[Tenant CNF upload] --> B[Cosign sign with tenant key]\n  B --> C[SBOM generation]\n  C --> D[Annotate image with SBOM]\n  D --> E[Admission via ImagePolicyWebhook]\n  E --> F[Gatekeeper/OPA policy]\n  F --> G[Deployment or rollback]","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","IBM"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T05:33:32.235Z","createdAt":"2026-01-14T02:28:29.725Z"},{"id":"q-1674","question":"Advanced CNF scenario: deploy a CNF API gateway across three geographies with a private registry and multi-tenancy. Propose an end-to-end plan to enforce per-tenant image provenance and runtime integrity, including (i) per-tenant Cosign signing keys stored in KMS/HSM, (ii) per-tenant SBOMs, (iii) admission controls using ImagePolicyWebhook/OPA, (iv) tenant-aware drift detection and rollback, and (v) observability for signing, attestation, and rollback signals. Provide concrete steps and minimal config examples?","answer":"Per-tenant provenance uses tenant-scoped Cosign keys in KMS/HSM, SBOMs published to a tenant feed, and ImagePolicyWebhook + OPA to enforce signatures at admission. Drift detection compares in-cluster ","explanation":"## Why This Is Asked\nThis question probes multi-tenant CNF provenance at scale, including per-tenant keys, drift detection, rollback, and observability.\n\n## Key Concepts\n- Tenant-scoped key management\n- Per-tenant SBOMs and provenance enforcement\n- ImagePolicyWebhook + OPA constraints\n- Drift detection and tenant-aware rollback\n- Observability: metrics, traces, audit logs\n\n## Code Example\n```javascript\n// Pseudo-code: verify image provenance per tenant\nasync function verifyProvenance(imageRef, tenant) {\n  const sigOk = await cosign.verify(imageRef, { key: `kms://${tenant}-key` });\n  const sbom = await fetchSBOM(imageRef);\n  if (sbom.tenant !== tenant) throw new Error('Tenant SBOM mismatch');\n  return sigOk;\n}\n```\n\n## Follow-up Questions\n- How would you rotate tenant keys without downtime?\n- How would you test drift detection across regions?","diagram":"flowchart TD\n  A[Tenant] --> B[Signer & SBOM Publisher]\n  B --> C[Admission Controller]\n  C --> D[Cluster]\n  D --> E[Telemetry & Rollback Engine]","difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","IBM","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T06:46:49.701Z","createdAt":"2026-01-14T06:46:49.701Z"},{"id":"q-1735","question":"Beginner CNF certification: In a multi-tenant Kubernetes cluster hosting CNF gateways in separate namespaces, design an end-to-end image provenance gate: (1) sign images with Cosign using a KMS-backed key and attach SPDX SBOMs, (2) enforce with an ImagePolicyWebhook that requires both signature and SBOM presence, (3) surface a per-tenant visibility badge on deployments, (4) provide minimal config snippets and commands to validate end-to-end in one namespace before rolling out to others?","answer":"CI signs image with Cosign using a KMS-backed key and generates an SPDX SBOM; SBOM and signature are pushed to a private registry. ImagePolicyWebhook enforces signature+SBOM at admission. A per-namesp","explanation":"## Why This Is Asked\nTests practical understanding of image provenance, Cosign SBOM integration, and admission control in CNF deployments. It asks for an end-to-end flow with concrete steps and minimal config to validate in a single namespace before broader rollout.\n\n## Key Concepts\n- Cosign signing with a KMS-backed key\n- SPDX SBOM generation and attachment\n- ImagePolicyWebhook admission checks\n- Per-tenant namespace isolation and observability\n\n## Code Example\n```yaml\n# Minimal ImagePolicyWebhook-ish configuration (conceptual)\napiVersion: admissionregistration.k8s.io/v1\nkind: ValidatingWebhookConfiguration\nmetadata:\n  name: image-provenance\nwebhooks:\n- name: image-provenance.example.com\n  clientConfig:\n    service:\n      name: image-policy\n      namespace: image-policy\n      path: \"/validate\"\n  rules:\n  - apiGroups: [\"apps\"]\n    apiVersions: [\"v1\"]\n    operations: [\"CREATE\"]\n    resources: [\"deployments\"]\n  failurePolicy: Fail\n  namespaceSelector:\n    matchLabels:\n      cnf-provenance: \"enabled\"\n```\n\n## Follow-up Questions\n- How would you test with a known-bad image? What signals would you surface in observability?\n- What changes if a tenant needs a temporary override for a signed image during rollout?","diagram":"flowchart TD\n  A[CI signs image with Cosign] --> B[SBOM generated]\n  B --> C[Push to private registry]\n  C --> D[Admission via ImagePolicyWebhook]\n  D --> E[Deployment with trust badge]\n  E --> F[Observability alerts]","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Hashicorp","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T08:57:12.709Z","createdAt":"2026-01-14T08:57:12.709Z"},{"id":"q-1793","question":"In a multi-tenant cluster hosting CNF gateway images, design a beginner end-to-end flow to enforce per-tenant image provenance using Cosign signing with tenant keys, SPDX SBOMs, and a Gatekeeper constraint that reads a per-tenant policy from a ConfigMap. Include minimal YAML for the ConstraintTemplate and Constraint, plus compliant vs noncompliant Deployment manifests, and the exact kubectl steps to validate end-to-end in a single namespace first?","answer":"Sign images with Cosign using a tenant-scoped key, attach an SPDX SBOM, and publish per-tenant policy in a ConfigMap. Implement a Gatekeeper ConstraintTemplate that checks for signature and SBOM exist","explanation":"## Why This Is Asked\n\nTests ability to design a per-tenant provenance flow, integrate image signing and SBOMs, and apply admission controls with policy-as-code. It also checks practical knowledge of Gatekeeper/OPA integration, namespace-scoped policies, and minimal test workflows.\n\n## Key Concepts\n\n- Cosign signing with tenant-specific keys\n- SPDX SBOM attachment and verification\n- Gatekeeper ConstraintTemplate and Constraint\n- Per-tenant policy in a ConfigMap\n- Minimal manifests and kubectl validation in a single namespace\n\n## Code Example\n\n```yaml\n# ConstraintTemplate (yaml)\napiVersion: templates.gatekeeper.sh/v1beta1\nkind: ConstraintTemplate\nmetadata:\n  name: k8simageprovenance\nspec:\n  crd:\n    spec:\n      names:\n        kind: K8sImageProvenance\n  targets:\n  - target: admission.k8s.gatekeeper.sh\n    rego: |\n      package k8simageprovenance\n      violation[{\"msg\": msg}] {\n        input.review.kind.kind == \"Deployment\"\n        some c in input.review.object.spec.template.spec.containers\n        not startswith(c.image, \"ghcr.io/\")\n        msg := \"image provenance missing or not tenant-approved\"\n      }\n```\n\n```yaml\n# Constraint (yaml)\napiVersion: constraints.gatekeeper.sh/v1beta1\nkind: K8sImageProvenance\nmetadata:\n  name: per-tenant-provenance\nspec:\n  enforcementAction: deny\n  parameters:\n    allowedTenant: \"tenant-a\"\n```\n\n```yaml\n# Compliant Deployment (yaml)\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: tenant-a-gateway\n  namespace: tenant-a\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: gateway\n    spec:\n      containers:\n      - name: gateway\n        image: ghcr.io/tenant-a/gateway:v1.0.0\n```\n\n```yaml\n# Noncompliant Deployment (yaml)\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: tenant-a-gateway-bad\n  namespace: tenant-a\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: gateway\n    spec:\n      containers:\n      - name: gateway\n        image: unsigned/gateway:latest\n```\n\n```bash\n# Kubectl steps (one namespace first)\nkubectl create ns tenant-a\n# 1) Register constraint template and constraint\nkubectl apply -f k8simageprovenance_template.yaml\nkubectl apply -f k8simageprovenance_constraint.yaml\n# 2) Sign and SBOM-attach a valid image (tenant-a key)\ncosign sign --key cosign-tenant-a.key ghcr.io/tenant-a/gateway:v1.0.0\n# 3) Deploy compliant manifest\nkubectl apply -f compliant-deploy.yaml -n tenant-a\n# 4) Deploy noncompliant manifest (unsigned)\nkubectl apply -f noncompliant-deploy.yaml -n tenant-a\n# 5) Check Gatekeeper denials and logs\nkubectl get events -n tenant-a\nkubectl describe deployment tenant-a-gateway-bad -n tenant-a\n```\n\n## Follow-up Questions\n- How would you rotate tenant keys without downtime?\n- How would you extend to multi-tenant namespaces concurrently?","diagram":"flowchart TD\n  A[Tenant Namespace] --> B[Compliant Image Signed]\n  B --> C[SBOM Attached]\n  C --> D[Gatekeeper Constraint Enforced]\n  D --> E[Deployment Accepted]\n  A --> F[Noncompliant Image] --> G[Denied by Gatekeeper]","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T10:56:55.662Z","createdAt":"2026-01-14T10:56:55.662Z"},{"id":"q-1812","question":"In a beginner CNF certification scenario, you operate a multi-tenant CNF gateway platform on Kubernetes with a private image registry. Describe a concrete end-to-end workflow to enforce provenance and runtime integrity for every pull: (1) embed build provenance into image labels (commit SHA, CI job, build ID), (2) sign with Cosign using a KMS-backed key and attach SPDX SBOMs, (3) enforce per-tenant policy via Gatekeeper/OPA that rejects images missing provenance or SBOM, and (4) provide a minimal test plan and config snippets to validate in a single namespace before rolling out to others?","answer":"Embed provenance as image labels (commit SHA, CI job, build ID). Sign with Cosign using a KMS-backed key and attach an SPDX SBOM. Enforce via Gatekeeper/OPA: a constraint that rejects images without p","explanation":"## Why This Is Asked\nThis question tests practical CNF provenance enforcement from build to runtime with per-tenant controls and a low-risk rollout.\n\n## Key Concepts\n- Build provenance in image labels (commit SHA, CI job, build ID)\n- Cosign signing with a KMS-backed key\n- SPDX SBOM attachment and verification\n- Gatekeeper/OPA policy enforcing provenance presence\n- Namespace-scoped testing and rollback strategy\n\n## Code Example\n```yaml\n# Gatekeeper ConstraintTemplate skeleton\napiVersion: templates.gatekeeper.sh/v1beta1\nkind: ConstraintTemplate\nmetadata:\n  name: k8sprovenance\nspec:\n  crd:\n    spec:\n      names:\n        kind: ProvenanceConstraint\n  targets:\n  - target: admission.k8s.gatekeeper.sh\n    rego: |\n      package provenance\n      # placeholder policy\n```\n\n```bash\n# Minimal test commands\nkubectl create namespace test-ns\n# deploy CNF, then verify policy & logs\nkubectl apply -n test-ns -f cnf-deploy.yaml\nkubectl get events -n test-ns | grep provenance\n```\n\n## Follow-up Questions\n- How would you adapt the workflow for a canary rollout?\n- How would you monitor policy violations at scale?\n","diagram":"flowchart TD\n  A[Build image] --> B[Sign with Cosign]\n  B --> C[Attach SBOM]\n  C --> D[Gatekeeper/OPA policy]\n  D --> E[Test in single namespace]\n  E --> F[Roll out]","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Coinbase","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T11:47:05.982Z","createdAt":"2026-01-14T11:47:05.982Z"},{"id":"q-1914","question":"In a multi-tenant CNF gateway managed by a central control plane, design an end-to-end upgrade workflow that uses per-tenant feature flags and a canary rollout with Istio, while enforcing runtime policy with OPA Gatekeeper and SPIRE-based identity. Include: (a) how CNF versions and flags are modeled in CRDs, (b) traffic splitting and health checks for safe canaries, (c) per-tenant policy evaluation, and (d) drift detection with automatic rollback and observability?","answer":"Design a per-tenant CNFUpgrade CRD describing tenantID, image, version, and featureFlags; implement a canary rollout via Istio with 10% traffic and progressive steps; encode policy decisions in OPA th","explanation":"## Why This Is Asked\nTests practical upgrade workflows for multi-tenant CNFs with policy checks, identity, and drift-driven rollback.\n\n## Key Concepts\n- per-tenant CRD design with versions and featureFlags\n- Istio canary traffic shifting and health checks\n- OPA Gatekeeper policy evaluation per tenant\n- SPIRE/SPIFFE identity for CNF components\n- drift detection and observability for rollback\n\n## Code Example\n```yaml\napiVersion: cnf.example/v1\nkind: CNFUpgrade\nmetadata:\n  name: tenant-a-upg-1\nspec:\n  tenantID: \"tenant-a\"\n  image: \"registry.example/cnf-gateway@sha256:abc123\"\n  version: \"v1.2.3\"\n  featureFlags:\n    newTLS: true\n```\n\n## Follow-up Questions\n- How would you test rollback triggers and thresholds?\n- How to scale canary to larger tenant fractions with safety gates?","diagram":null,"difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","NVIDIA","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T16:58:56.523Z","createdAt":"2026-01-14T16:58:56.523Z"},{"id":"q-2030","question":"Beginner CNF certification: How would you design an end-to-end workflow in a multi-tenant Kubernetes cluster to enforce SBOM freshness and key-rotation awareness for CNF images, so that when a Cosign key rotates SBOMs are re-generated and re-attested, and a Kyverno policy rejects images signed with old keys or missing SBOMs, with a minimal namespace-scoped test?","answer":"Implement a comprehensive SBOM freshness and key-rotation workflow by signing CNF images with Cosign using KMS-backed keys, generating SPDX SBOMs with Syft and attaching them as attestations, then enforcing compliance through Kyverno policies that require both valid signatures and current SBOMs. When Cosign key rotation occurs, automate re-signing of all images and regeneration of SBOM attestations, while updating Kyverno policies to reject images signed with previous keys or missing current SBOMs. Validate the entire workflow with namespace-scoped tests before production deployment.","explanation":"## Why This Is Asked\nThis question evaluates your ability to design end-to-end provenance controls for CNF environments, specifically addressing how key rotation impacts SBOM generation and policy enforcement in multi-tenant Kubernetes clusters.\n\n## Key Concepts\n- Cosign image signing with KMS-backed keys\n- SPDX SBOM generation and attestation workflows\n- Kyverno policy enforcement for signature and SBOM validation\n- Key rotation impact on image provenance chains\n- Namespace-scoped testing strategies and rollback procedures\n\n## Code Example\n```bash\n# Sign image with KMS-backed key\ncosign sign --key kms://mykms/path/to/key \\\n  --attachment sbom \\\n  registry.example.com/cnf:latest\n\n# Generate and attach SBOM\nsyft registry.example.com/cnf:latest \\\n  -o spdx-json > sbom.spdx\n\ncosign attest --key kms://mykms/path/to/key \\\n  --type spdx --predicate sbom.spdx \\\n  registry.example.com/cnf:latest\n```\n\n## Implementation Strategy\nDeploy this solution progressively: start with image signing, add SBOM generation, implement Kyverno policies, then automate the key rotation workflow. Test in isolated namespaces before cluster-wide deployment.","diagram":null,"difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Cloudflare","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T06:23:24.155Z","createdAt":"2026-01-14T21:37:32.682Z"},{"id":"q-2189","question":"Advanced CNF Certification: Design an end-to-end runtime policy and rollout flow to ensure that only CNFs with verifiable provenance and hardware compatibility SBOM attestations can allocate SR-IOV NICs across regions; describe data sources, policy versioning, canary rollout, and rollback, plus a minimal policy snippet?","answer":"Implement an OPA-Gatekeeper policy that gates SR-IOV enablement on CNFs only when the SBOM reports hardware: sriov, attestation is valid, and image is Cosign-signed. Use a central, versioned policy st","explanation":"## Why This Is Asked\nTests ability to design runtime provenance controls that scale across regions and vendors, focusing on drift-resistant policy evolution.\n\n## Key Concepts\n- Runtime policy versioning\n- SBOM provenance and hardware attestations\n- Canary rollouts and multi-tenant isolation\n- Drift detection and automated rollback\n- OPA/Gatekeeper integration with Cosign/SBOM flows\n\n## Code Example\n```rego\npackage cnf.provenance\ndefault allow = false\nallow {\n  input.sbom.hardware == \"sriov\"\n  input.attestation.valid\n  input.signature.valid\n}\n```\n\n## Follow-up Questions\n- How would you test policy drift in a live multi-region setup?\n- What metrics indicate a failed policy rollout and rollback trade-offs?","diagram":"flowchart TD\n  A[CNF Image] --> B[SBOM & Attestation]\n  B --> C[Policy Engine]\n  C --> D{enable_sriov?}\n  D --> E[Runtime Enforce]\n  D --> F[Reject]","difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T06:56:56.092Z","createdAt":"2026-01-15T06:56:56.092Z"},{"id":"q-2262","question":"How would you implement an end-to-end runtime-provenance strategy for upgrades in a three-region, air-gapped CNF platform hosting stateful gateways across Kubernetes clusters, without pulling new images from the registry? Include image provenance checks, TPM-backed attestation via Sigstore, in-cluster drift detection with eBPF, and a safe, low-downtime rollback plan with minimal manifests?","answer":"Adopt a four-layer flow: (1) require Cosign-signed CNF images with SBOMs and a rollback tag; (2) enforce TPM-backed attestation via Sigstore (Fulcio/ Rekor) inside each cluster; (3) run in-cluster dri","explanation":"## Why This Is Asked\nTests ability to design for multi-region, air-gapped CNFs with strict provenance and runtime security, focusing on upgrade safety without image pulls.\n\n## Key Concepts\n- Runtime attestation with TPM-backed keys (Sigstore)\n- Image provenance with SBOMs and Cosign\n- In-cluster drift detection via eBPF\n- Policy-driven rollback (OPA/Gatekeeper)\n\n## Code Example\n```\napiVersion: constraints.gatekeeper.sh/v1beta1\nkind: K8sImageProvenance\nmetadata:\n  name: require-sbom-signature\nspec:\n  match:\n    kinds:\n    - apiVersion: apps/v1\n      kind: Deployment\n  parameters:\n    requireSBOM: true\n    requireSignature: true\n```\n\n## Follow-up Questions\n- How would you test drift detection thresholds?\n- How would you simulate network partitions across regions and verify rollback?","diagram":"flowchart TD\n  A[Image Pulled] --> B[Sign & SBOM]\n  B --> C[Attestation Gate]\n  C --> D[Canary Upgrade]\n  D --> E{Drift Detected?}\n  E -- Yes --> F[Rollback]\n  E -- No --> G[Regional Rollout]","difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","NVIDIA","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T09:46:42.204Z","createdAt":"2026-01-15T09:46:42.205Z"},{"id":"q-2362","question":"Beginner CNF certification: In a multi-tenant Kubernetes cluster with a shared private registry, design an end-to-end image provenance gate that adds a freshness check: require Cosign-signed images with SPDX SBOMs, and enforce via Open Policy Agent that SBOM timestamp is within 7 days. Provide minimal constraint template, example annotation, and a one-namespace test plan?","answer":"Configure Cosign signing with a KMS-backed key, generate an SPDX SBOM and annotate the image with its timestamp, then enforce via Gatekeeper/OPA constraint requiring both signature and SBOM freshness ","explanation":"## Why This Is Asked\nTests ability to design a practical, auditable provenance gate that adds a time-based freshness check, a realistic constraint template, and a focused test path.\n\n## Key Concepts\n- Cosign signing with KMS-backed keys\n- SPDX SBOM generation and image annotations\n- SBOM freshness policy (7 days)\n- Gatekeeper/OPA constraint templates and Rego rules\n- Namespace-scoped validation and test plan\n\n## Code Example\n```yaml\n# ConstraintTemplate and Rego enforcing signature presence and SBOM freshness\n# (snippets sketched for brevity)\n```\n\n## Follow-up Questions\n- How would you adjust the freshness window for regulatory changes?\n- How do you handle SBOM revocation or key rotation?\n","diagram":"flowchart TD\nA[Build CNF image] --> B[Cosign sign]\nB --> C[Attach SBOM timestamp annotation]\nC --> D[OPA Gatekeeper constraint check]\nD --> E[Deploy to namespace]\n","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Snowflake","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T14:51:38.630Z","createdAt":"2026-01-15T14:51:38.631Z"},{"id":"q-2486","question":"Advanced CNF certification: In a four region CNF gateway fleet with a private image registry, design a scalable end-to-end workflow for per tenant image provenance and runtime attestation. Include tenant-specific signing keys, SBOMs, admission controls, and a rollback plan for regional outages. Provide concrete steps and minimal config snippets you would actually use in practice?","answer":"Design a scalable, four-region CNF gateway provenance flow: sign images with tenant KMS keys via Cosign, attach per-tenant SBOMs, publish Rekor entries, and enforce with Gatekeeper/OPA. Include runtim","explanation":"## Why This Is Asked\nTests ability to architect cross-region provenance, tenant isolation, and runtime attestation at scale, including key management and revocation.\n\n## Key Concepts\n- Tenant-scoped key management (KMS)\n- Per-tenant SBOMs and registries\n- Signed image provenance and Rekor revocation\n- Admission controls with Gatekeeper/OPA and runtime attestation\n- Multi-region rollback and observability\n\n## Code Example\n```yaml\n# Gatekeeper constraint example (minimal)\napiVersion: constraints.gatekeeper.sh/v1beta1\nkind: K8sSBOMPresent\nmetadata:\n  name: tenant-a-sbom-present\nspec:\n  tenant: \"tenant-a\"\n  registry: \"registry.example.com/tenant-a\"\n```\n\n## Follow-up Questions\n- How would you test revocation propagation across regions?\n- What metrics indicate drift or attestation failure?\n","diagram":null,"difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Netflix","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T19:48:10.381Z","createdAt":"2026-01-15T19:48:10.381Z"},{"id":"q-2560","question":"Design an end-to-end CNF image provenance and runtime attestation workflow for a globally deployed API gateway across x86_64 and ARM edge nodes with intermittent connectivity. Include per-arch signing and SBOMs, cross-arch attestation claims, an OPA policy enforcing SBOM presence and trusted architecture, and a testing plan with canary rollouts and rollback criteria?","answer":"Implement per-architecture Cosign signing with architecture-specific KMS keys, generate SBOMs using Syft for each build, attach SBOMs to the respective image manifests, and enforce both signature verification and SBOM presence through OPA policies scoped to architecture. At runtime, utilize in-toto attestations with architecture-specific claims, cache verification data locally to handle intermittent connectivity scenarios, and execute canary rollouts with automated rollback triggered by attestation failures.","explanation":"## Why This Is Asked\nThis question tests the ability to design a comprehensive cross-architecture supply chain security and runtime trust workflow that addresses edge deployment challenges, including offline scenarios and real-time policy enforcement.\n\n## Key Concepts\n- Per-architecture image signing and SBOM provenance tracking\n- Runtime attestation with architecture-aware claim verification\n- Policy enforcement using OPA Gatekeeper with architecture-specific constraints\n- Edge connectivity management and canary-driven rollback mechanisms\n\n## Code Example\n```javascript\nfunction isAllowed(image, arch) {\n  // Verify Cosign signature for specific architecture\n  const signatureValid = verifyCosignSignature(image, arch);\n  const sbomPresent = checkSBOMPresence(image, arch);\n  const attestationValid = verifyInTotoAttestation(image, arch);\n  \n  return signatureValid && sbomPresent && attestationValid;\n}\n```","diagram":"flowchart TD\n  A[Per-arch signing] --> B[SBOM attach]\n  B --> C[OPA policy]\n  C --> D[Runtime attestation]\n  D --> E[Central verifier]\n  E --> F[Canary validation and rollback]","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","IBM","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T05:24:17.533Z","createdAt":"2026-01-15T22:48:20.016Z"},{"id":"q-2638","question":"In a CNF gateway deployed across multi-cloud Kubernetes clusters, outline an end-to-end plan to guarantee runtime integrity and tenant isolation during updates, by combining hardware-backed attestation (TPM/SEV), SBOM provenance, a private attestation service, SPIRE identities, and policy enforcement with OPA Gatekeeper. Include upgrade testing (canary and rollback) and observability hooks?","answer":"Propose a plan that anchors builds to SBOMs, provisions a TPM/SEV-backed runtime attestation at startup, issues per-tenant tokens from a private attestation service, and uses SPIRE identities with OPA","explanation":"Why This Is Asked\nAssesses practical ability to design end-to-end CNF runtime integrity and tenant isolation using hardware-backed attestation, SBOM provenance, and policy enforcement across multi-cloud clusters.\n\nKey Concepts\n- Hardware-backed attestation (TPM/SEV)\n- SBOM provenance and signing\n- Private attestation service\n- SPIRE identities\n- OPA Gatekeeper policies\n- Canary upgrades and rollback\n- Observability of attestation events, drift, and SBOM provenance\n\nCode Example\n```javascript\n// Example: lightweight attestation check (pseudo)\nfunction isAttested(token, tenant) {\n  return token.verified && token.tenant === tenant;\n}\n```\n\nFollow-up Questions\n- How would you handle private attestation service downtime?\n- How do you test key rotation with minimal blast radius?","diagram":"flowchart TD\n  A[Image Build + SBOM] --> B[Sign & Attest]\n  B --> C[Runtime TPM/SEV Attestation]\n  C --> D[Private Attestation Service]\n  D --> E[SPIRE Identities & OPA Gatekeeper]\n  E --> F[Canary Upgrades with Rollback]","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T04:19:26.521Z","createdAt":"2026-01-16T04:19:26.521Z"},{"id":"q-2745","question":"In a multi-tenant CNF gateway namespace, design a beginner-end-to-end image provenance gate that: (1) embeds per-tenant labels cnf/tenant and commit in the image, (2) signs images with Cosign using a KMS-backed key and attaches an SPDX SBOM, (3) enforces with a Kyverno policy that validates both the signature and the presence of the SBOM and tenant label, (4) includes a minimal test plan and config snippets to verify in one namespace before rollout?","answer":"Implement it by signing with Cosign (KMS key), generating SBOM with a tool (syft), attaching SBOM via cosign attach sbom, labeling each image with cnf/tenant=<tenant>, commit=<sha>, then deploy a Kyve","explanation":"## Why This Is Asked\nTests practical understanding of end-to-end image provenance in CNF multi-tenant contexts, combining signing, SBOM, and policy.\n\n## Key Concepts\n- Cosign signing with KMS-backed key\n- SBOM generation/attachment\n- Tenant-scoped image labeling\n- Kyverno policy for signature/SBOM/label enforcement\n\n## Code Example\n```yaml\n# Kyverno policy (simplified)\napiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: require-provenance\nspec:\n  validationFailureAction: enforce\n  rules:\n  - name: verify-signature-and-sbom\n    match:\n      resources:\n        kinds: [Deployment]\n    validate:\n      message: \"Image must be signed and SBOM attached with tenant label\"\n      pattern:\n        spec:\n          template:\n            spec:\n              containers:\n              - image: ?\n```\n```bash\n# Cosign signing (example)\ncosign sign --key kms://my-kms/key registry/tenant/image:tag\nsyft registry/tenant/image:tag -o cyclonedx-json > sbom.json\ncosign attach sbom registry/tenant/image:tag < sbom.json\n```\n\n## Follow-up Questions\n- How would you rotate signing keys with minimal downtime?\n- How to test cross-tenant leakage in this setup?","diagram":"flowchart TD\n  A[Tenant Namespace] --> B[Image built and labeled with cnf/tenant, commit]\n  B --> C[Sign with Cosign (KMS)]\n  C --> D[Attach SBOM]\n  D --> E[Kyverno policy enforces signature, SBOM, tenant label]\n  E --> F[Test namespace validation]","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T09:53:57.764Z","createdAt":"2026-01-16T09:53:57.764Z"},{"id":"q-2814","question":"Describe a scalable, tenant-aware CNF provenance and runtime integrity flow: tenants supply per-tenant Cosign root keys and SBOM policies; images signed with tenant key and SBOM attached; admission controls enforce signature+SBOM before deployment; a runtime sidecar attests the image via TPM-backed quote and digest, blocking traffic on failure; include minimal config and test plan?","answer":"A strong answer will outline per-tenant key management with Cosign and a KMS, SBOM generation and embedding (SPDX) in image metadata, admission controls (OPA/ Gatekeeper) enforcing tenant signature+SB","explanation":"## Why This Is Asked\nThis question probes the ability to design end-to-end secure CNF deployments across tenants, including per-tenant keys, SBOM handling, admission policy, and runtime attestation.\n\n## Key Concepts\n- Tenant-scoped signing keys\n- SBOM generation and enforcement\n- Admission controls with Gatekeeper/OPA\n- Runtime attestation and sidecar enforcement\n- Observability and rollback\n\n## Code Example\n```yaml\n# Minimal Gatekeeper constraint template (illustrative)\napiVersion: constraints.gatekeeper.sh/v1beta1\nkind: CNFProvenance\nmetadata:\n  name: tenant-a_cnf_provenance\nspec:\n  match:\n    kinds:\n      - apiGroup: apps\n        kinds: [Deployment]\n  parameters:\n    requireSignature: true\n    requireSBOM: true\n    tenantMatcher: '^tenant-a-.*$'\n```\n\n## Follow-up Questions\n- How would you scale per-tenant attestation keys to 1000 tenants?\n- What failure modes exist if TPM attestation is unavailable?","diagram":"flowchart TD\n  A[Tenant Root Key] --> B[Cosign Sign Image]\n  B --> C[SBOM Attached]\n  C --> D[Admission Policy]\n  D --> E[Deployment]\n  E --> F[Runtime Attestation]\n  F --> G[Traffic Allowed]\n  F --> H[Traffic Blocked]","difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Twitter","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T13:20:47.850Z","createdAt":"2026-01-16T13:20:47.850Z"},{"id":"q-3156","question":"In a multi-tenant CNF platform running on Kubernetes across edge sites, design an end-to-end runtime attestation workflow that prevents unauthorized CNF updates from taking effect without a full image rebuild. The workflow should (1) collect hardware-backed startup attestations (TPM2.0/IMA) and publish to a central verifier, (2) publish a per-patch SBOM delta and attach a trust score, (3) enforce tenant-scoped runtime policy via OPA/Kyverno that rejects changes without valid attestation and SBOM delta, and (4) include a minimal in-namespace test plan to validate end-to-end before rollout. Provide concrete steps and minimal config snippets?","answer":"Design runtime attestation flow for a multi-tenant CNF platform: at startup, CNF emits TPM2.0/IMA attestations to a central verifier; generate and sign an SBOM delta for the patch; enforce tenant-scop","explanation":"## Why This Is Asked\n\nTests a higher‑fidelity security stance: runtime integrity, not just image provenance, across distributed edge sites.\n\n## Key Concepts\n\n- Runtime attestation using TPM2.0/IMA\n- SBOM delta management per patch\n- Per-tenant policy enforcement (OPA/Kyverno)\n- Central attestation verifier and revocation handling\n- Edge multi-site rollout and in-namespace testing\n\n## Code Example\n\n```javascript\nfunction isAttestationValid(token, delta, tenant) {\n  return token.signatureValid && delta.verified && tenant === token.tenant;\n}\n```\n\n## Follow-up Questions\n\n- How would you rotate attestation keys and revoke compromised tenants?\n- What observability would prove end-to-end attestation health in production?","diagram":null,"difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","NVIDIA","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T04:51:38.222Z","createdAt":"2026-01-17T04:51:38.223Z"},{"id":"q-3205","question":"In a multi-tenant CNF API gateway cluster on Kubernetes, a CVE hits a shared library in the gateway control plane. Describe a concrete end-to-end patch and rollout plan that preserves per-tenant SLAs while meeting CNF governance: (1) regenerate and attach SBOMs for the patched image, (2) re-sign with Cosign and rotate KMS-backed keys if required, (3) implement per-tenant canary deployments using Argo Rollouts and Istio routing with per-tenant traffic shaping, (4) validate tenant isolation and rollback criteria with automated tests, (5) include minimal config snippets and concrete commands to validate end to end?","answer":"Patch a CVE-affected CNF image and roll out via per-tenant canaries. Steps: (1) regenerate SBOMs for the patched image, (2) sign with Cosign and rotate KMS-backed keys if policy requires, (3) deploy p","explanation":"## Why This Is Asked\nTests CVE response in a CNF multi-tenant setting, covering SBOM attestation, key management, per-tenant canary rollout, and observability.\n\n## Key Concepts\n- SBOM generation and attestation\n- Cosign signing and KMS key rotation\n- Per-tenant canary rollout with Argo Rollouts and Istio\n- Rollback criteria and observability\n\n## Code Example\n```bash\n# SBOM generation (example)\nsyft gateway-image:latest -o cyclonedx-json > sbom.json\n# Signing (example)\ncosign sign --key cosign-key.pem gateway-image:latest\n```\n\n## Follow-up Questions\n- How would you test rollback under partial failure across tenants?\n- What metrics would surface to detect drift during the rollout?","diagram":"flowchart TD\n  A[Start] --> B[Patch image per tenant]\n  B --> C[Gen SBOMs]\n  C --> D[Sign & rotate keys]\n  D --> E[Per-tenant canary rollout]\n  E --> F[Isolation tests]\n  F --> G{Success?}\n  G -->|Yes| H[Promote]\n  G -->|No| I[Rollback & alert]","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Oracle","Plaid","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T06:54:00.595Z","createdAt":"2026-01-17T06:54:00.595Z"},{"id":"q-3230","question":"In an air-gapped edge CNF deployment, outline a practical end-to-end provenance workflow that signs an image with Cosign using an offline KMS key, attaches an SPDX SBOM, and transfers a portable provenance manifest to edge sites for offline verification before pull. Include steps for signing, SBOM generation, manifest format, offline verification, and a minimal in-namespace check?","answer":"Outline offline provenance: generate SBOM with Syft for the CNF image, sign with Cosign using offline KMS key, attach SBOM, create a portable manifest with image_digest, sbom_digest, nonce, build_id, ","explanation":"## Why This Is Asked\nTests understanding of CNF provenance in offline environments, a realistic edge scenario, and interoperability between signing, SBOM, and verification without live Internet.\n\n## Key Concepts\n- Air-gapped deployment, portable provenance artifacts\n- Cosign signing with offline KMS keys\n- SPDX SBOM attachment and verification\n- Offline verifier at edge sites and minimal in-namespace checks\n\n## Code Example\n```bash\n# Sign image offline (cosign with offline KMS key)\ncosign sign --key kms://offlinedkms/cnf-key registry.example.com/cnf/gateway:1.0.0\n\n# Generate SBOM and attach\nsyft registry.example.com/cnf/gateway:1.0.0 -o cyclonedx-json > sbom.json\ncosign attach sbom --sbom sbom.json registry.example.com/cnf/gateway:1.0.0\n```\n\n```json\n{\n  \"image_digest\": \"sha256:abcdef...\",\n  \"sbom_digest\": \"sha256:123456...\",\n  \"nonce\": \"n-20260117-01\",\n  \"build_id\": \"ci-42\",\n  \"signature\": \"base64sig...\"\n}\n```\n\n## Follow-up Questions\n- How would you test end-to-end in a multi-site environment?\n- What are pitfalls of offline verification and how would you mitigate key rotation and revocation?","diagram":"flowchart TD\n  Central[Central Registry] --> EdgeSite1[Edge Site 1]\n  Central --> EdgeSite2[Edge Site 2]\n  EdgeSite1 --> Verifier[Offline Verifier]\n  Verifier --> EdgeSite1\n  EdgeSite2 --> Verifier\n  Verifier --> EdgeSite2","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Google","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T07:40:50.484Z","createdAt":"2026-01-17T07:40:50.484Z"},{"id":"q-3294","question":"In a multi-tenant CNF-based firewall deployed across four regional clusters, design an end-to-end provenance workflow that (1) signs CNF images with Cosign using a region-scoped KMS key, (2) attaches a tenant-bound SPDX SBOM and a site-binding annotation, (3) enforces via a Kyverno policy that both the signature and SBOM exist and that the tenant annotation matches, and (4) supports automated cross-region key rotation and revocation. Include a one-namespace test plan and minimal config snippets?","answer":"Sign CNF images with Cosign using region KMS keys; attach an SPDX SBOM and tenant/site attestation; Kyverno policy requires signature, SBOM, and tenant/site match before deploy; support cross-region k","explanation":"## Why This Is Asked\nTests end-to-end provenance across multi-region deployments, tenant-scoped controls, and rotation events.\n\n## Key Concepts\n- Cosign with region-scoped KMS keys\n- SPDX SBOM binding to CNFs\n- Kyverno validation policies for signature, SBOM presence, and tenant/site bindings\n- Attestation storage and rotation/revocation workflows\n\n## Code Example\n```javascript\ncosign sign --key kms://region/keys/cnf-key --sbom sbom.json registry.example.com/tenant-a/cnf-gateway:1.2.3\n```\n\n## Follow-up Questions\n- How would you propagate key revocation across regions without deployment downtime?\n- How would you monitor attestation freshness and alert on SBOM drift?","diagram":null,"difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","DoorDash","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T10:33:41.174Z","createdAt":"2026-01-17T10:33:41.174Z"},{"id":"q-3379","question":"Design an **external attestation API** for a Kubernetes-based multi-tenant CNF mesh (Slack/Google/OpenAI). Given an image digest and tenant, return a signed provenance bundle containing: imageDigest, sbomHash, signerKeyID, tenant, verdict, and timestamp. Describe data model, signing flow with **Sigstore** using a per-tenant KMS key, Rekor publication, and a minimal in-namespace test exercising the API end-to-end via a ServiceAccount?","answer":"Implement a microservice that accepts imageDigest and tenant, builds a payload with imageDigest, sbomHash, tenant, timestamp, and verdict, then signs with Sigstore using a per-tenant KMS key and retur","explanation":"## Why This Is Asked\n\nTests end-to-end provenance flow across cloud-native tools, including per-tenant isolation, signing with Sigstore, and Rekor integration. It also exercises API design, data modeling, and in-cluster testing patterns relevant to CNF supply chain security.\n\n## Key Concepts\n\n- Sigstore attestation flow and Rekor integration\n- Per-tenant key management (KMS) and image provenance\n- SBOM hashing and binding to image digests\n- In-cluster E2E test via ServiceAccount\n\n## Code Example\n\n```go\n// Go pseudo-structure for attestation payload\ntype Attestation struct {\n  ImageDigest string\n  SBOMHash    string\n  Tenant      string\n  Verdict     string\n  Timestamp   time.Time\n}\n```\n\n```javascript\n// Pseudo API call\nPOST /attest { imageDigest, tenant } -> { attestationID, signature }\n```\n\n## Follow-up Questions\n\n- How would you rotate tenant keys without breaking in-flight attestations?\n- How would you audit and revoke attestations if a tenant is compromised?","diagram":"flowchart TD\n  A(API receives request) --> B[Build attestation payload]\n  B --> C[Sign with tenant KMS via Sigstore]\n  C --> D[Publish to Rekor]\n  D --> E[Return attestationID to client]","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","OpenAI","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T13:52:29.750Z","createdAt":"2026-01-17T13:52:29.750Z"},{"id":"q-3399","question":"In a globally distributed CNF platform spanning three regions, design an end-to-end governance gate for CNF updates that ensures provenance and safe rollback. Requirements: (1) per-tenant image SBOMs and Cosign signatures; (2) host attestation (TPM2.0/IMA) at update time to verify base hardware; (3) config-diff provenance by signing and attaching SBOM delta for Kubernetes manifests; (4) cross-region policy enforcement with Kyverno/OPA and a central verifier; (5) a minimal in-namespace test plan and config snippets. Provide concrete steps and minimal config?","answer":"Gate CNF updates with a cross-region provenance gate: (1) require Cosign-signed images plus SPDX SBOMs per tenant; (2) require hardware attestation (TPM2.0/IMA) verified by a central verifier before r","explanation":"## Why This Is Asked\n\nAssesses ability to build cross-region, production-grade CNF governance that combines image provenance, hardware attestation, and manifest-level provenance with policy enforcement and rollback controls. The question requires integrating Cosign, SBOMs, TPM/IMA attestations, and regionally replicated OPA/Kyverno policies, plus a concrete minimal test plan.\n\n## Key Concepts\n\n- End-to-end CNF provenance across regions\n- Tenant-scoped Cosign signatures and SPDX SBOMs\n- Hardware attestation (TPM2.0/IMA) verification\n- Delta SBOMs for Kubernetes manifests\n- Cross-region policy enforcement (Kyverno/OPA) with central verifier\n- Minimal in-namespace test for update and rollback\n\n## Code Example\n\n```javascript\n// Pseudo verifier sketch for central attestation check\nfunction verifyUpdate(imageSig, sbom, attestation) {\n  return imageSig.valid && sbom.valid && attestation.ok;\n}\n```\n\n## Follow-up Questions\n\n- How would you handle key rotation and revocation in Cosign across regions?\n- How would you simulate network partitions during a rollback test and ensure safety?","diagram":null,"difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T14:38:11.463Z","createdAt":"2026-01-17T14:38:11.464Z"},{"id":"q-3452","question":"Beginner CNF certification: In a multi-tenant Kubernetes cluster, implement end-to-end config drift protection for CNF gateway deployments. Design a flow to (1) sign gateway configs with Cosign using a KMS-backed key and publish SBOMs, (2) mount a signed config as a per-tenant ConfigMap via a controller, (3) enforce at admission time that runtime config matches the signed artifact, and (4) surface per-tenant drift alerts with minimal in-namespace tests and sample manifests. What steps and minimal snippets would you provide?","answer":"Approach: implement config drift protection for CNF gateways in a multi-tenant Kubernetes cluster. Sign tenant configs with Cosign using a KMS-backed key and publish SBOMs. Use a controller to mount t","explanation":"## Why This Is Asked\n\nThis tests practical understanding of end-to-end CNF config provenance, multi-tenant drift protection, admission control, and observability.\n\n## Key Concepts\n\n- Cosign signing with KMS\n- SBOM generation\n- Per-tenant ConfigMaps and controller-driven mounting\n- Validating admission webhook for runtime config integrity\n- Drift detection and per-tenant alerts (Prometheus/Alertmanager)\n\n## Code Example\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: tenant-a-config\n  namespace: tenant-a\ndata:\n  gateway.yaml: |\n    replicas: 1\n    image: harbor.local/cnf/gateway:signed\n```\n\n## Follow-up Questions\n\n- How would you test webhook behavior across canary and prod?\n- How would you automate rotation of KMS keys without downtime?","diagram":"flowchart TD\n  A[CNF gateway] --> B[Signed config SBOM]\n  B --> C[ConfigStore]\n  C --> D[Admission webhook]\n  D --> E[Startup with config]\n  E --> F[Drift alerts]","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Instacart","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T16:48:52.179Z","createdAt":"2026-01-17T16:48:52.179Z"},{"id":"q-3457","question":"In a shared Kubernetes CNF certification setup with multi-tenant Gatekeeper policies, design an end-to-end flow to validate and enforce per-tenant feature flags before deployment: 1) define a tenant-scoped FeaturePolicy CRD, 2) implement a ConstraintTemplate (Rego) that reads Deployment.annotations['cnf/feature'] and checks against the tenant policy, 3) enforce with Gatekeeper so disallowed flags fail admission, 4) wire a minimal CI gate to publish tenant policies and test manifests, 5) add in-namespace tests that verify allowed vs disallowed cases. What would you implement and why?","answer":"I would implement a tenant-scoped FeaturePolicy CRD and a Gatekeeper ConstraintTemplate that validates Deployment.annotations['cnf/feature'] against the tenant's allowedFlags. The CI gate publishes pe","explanation":"## Why This Is Asked\nTests practical understanding of policy-as-code, admission controls, and CNF feature gating in a real multi-tenant cluster.\n\n## Key Concepts\n- Tenant-scoped CRD for featurePolicy\n- Gatekeeper ConstraintTemplate with Rego logic\n- Per-tenant policy propagation in CI\n- In-namespace tests for allow/deny scenarios\n\n## Code Example\n```yaml\n# CRD: featurepolicies.example.com\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  name: featurepolicies.example.com\nspec:\n  group: example.com\n  versions:\n  - name: v1\n    served: true\n    storage: true\n    schema:\n      openAPIV3Schema:\n        type: object\n        properties:\n          spec:\n            type: object\n            properties:\n              tenant:\n                type: string\n              allowedFlags:\n                type: array\n                items:\n                  type: string\n```\n```rego\npackage gatekeeper.featurepolicy\n\nviolation[{\"msg\": msg}] {\n  input.review.object.kind == \"Deployment\"\n  annotations := input.review.object.metadata.annotations\n  feature := annotations[\"cnf/feature\"]\n  policy := data.tenants[input.review.object.metadata.namespace]\n  not featureR in policy.allowedFlags\n  msg := sprintf(\"disallowed feature flag: %v for tenant: %v\", [feature, input.review.object.metadata.namespace])\n}\n```\n\n## Follow-up Questions\n- How would you handle evolving policies without downtime?\n- How would you test performance impact of policy checks at scale?","diagram":"flowchart TD\n  A[Tenant Policy Created] --> B[Policy Sync to Gatekeeper]\n  B --> C[Deployment Annotated with cnf/feature]\n  C --> D{Admission Check Pass?}\n  D --> E[Allow Deployment]\n  D --> F[Deny Deployment]\n  F --> G[Test Namespace Verifies Denial]","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T17:24:08.277Z","createdAt":"2026-01-17T17:24:08.279Z"},{"id":"q-3536","question":"Beginner CNF certification: In a multi-tenant CNF gateway platform on Kubernetes, design a minimal end-to-end post-deployment image revocation flow. Include (1) a signed revocation artifact published to the central registry (pointing to revoked image digests), (2) an ImagePolicyWebhook rule that denies pods whose image digest appears in the revocation list, (3) per-tenant rollback flags surfaced per-namespace via a ConfigMap, and (4) a one-namespace validation test with minimal manifests before rollout?","answer":"Publish a signed revocation JSON {revoked: ['sha256:...']} to the central registry, signed with the same KMS key. The ImagePolicyWebhook fetches and verifies signature, denying pods with revoked diges","explanation":"## Why This Is Asked\nTests ability to design post-deployment revocation with provenance and per-tenant controls.\n\n## Key Concepts\n- Signed revocation artifacts\n- ImagePolicyWebhook checks against revocation set\n- Namespace-scoped rollback controls via ConfigMap\n- Minimal in-namespace test before rollout\n\n## Code Example\n```javascript\n// Pseudo webhook logic\nif (revokedDigests.includes(imageDigest)) {\n  denyAdmission('revoked-image');\n}\n```\n\n## Follow-up Questions\n- How would you rotate keys and revoke in-flight deployments during high-traffic?\n- How to audit decisions and surface revoke events to tenants?","diagram":null,"difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Google","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T20:36:47.824Z","createdAt":"2026-01-17T20:36:47.824Z"},{"id":"q-3689","question":"In a CNF gateway deployed across multiple clouds, design a runtime attestation workflow using Linux IMA to produce a signed attestation report for each running CNF container, verify it against a central policy server, and enforce tenant-scoped access based on attestation results. Include how to collect measurements, sign with an HSM, verify at admission, and a minimal one-namespace validation before rollout?","answer":"Design a runtime attestation workflow using Linux IMA across clouds: collect per-container measurements, sign IMA attestations with an HSM via PKCS#11, publish to a central attestation service, and ga","explanation":"## Why This Is Asked\nThis tests runtime attestation across multi-cloud CNFs, ensuring trust from build through deployment and enforcing tenant isolation at admission.\n\n## Key Concepts\n- Linux IMA and runtime integrity\n- PKCS#11/HSM signing\n- Central attestation service and baselines\n- Kubernetes ValidatingWebhookConfiguration\n- Tenant policy\n\n## Code Example\n```yaml\napiVersion: admissionregistration.k8s.io/v1\nkind: ValidatingWebhookConfiguration\nwebhooks:\n- name: attestation.example.com\n  clientConfig:\n    service:\n      name: attestation-service\n      namespace: default\n      path: /validate\n```\n\n## Follow-up Questions\n- How would you handle revocation and key rotation?\n- How would you validate attestation reports offline in air-gapped envs?","diagram":"flowchart TD\n  A[Start] --> B[Collect IMA measurements]\n  B --> C[Sign with HSM]\n  C --> D[Post to attestation service]\n  D --> E{Attestation OK?}\n  E -->|Yes| F[Allow pod admission]\n  E -->|No| G[Reject pod]","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Microsoft","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T05:39:03.719Z","createdAt":"2026-01-18T05:39:03.720Z"},{"id":"q-3852","question":"Scenario: in a multi-tenant CNF platform on Kubernetes, design an end-to-end upgrade gate that enforces tenant-specific policies at admission time. Requirements: CNF images and SPDX SBOMs must be Cosign-signed; upgrades allowed only when provenance and SBOM delta satisfy a tenant policy stored in a KMS-backed store; a TPM2.0/IMA attestation proves a trusted baseline before upgrade; include a minimal in-namespace manifest to validate in one namespace and discuss trade-offs and fallbacks?","answer":"Implement a validating admission webhook that enforces tenant-specific upgrade policies at admission. Ensure CNF images are Cosign-signed with SBOMs; compute and store SBOM deltas per tenant; require ","explanation":"## Why This Is Asked\nTests ability to design end-to-end CNF upgrade governance with provenance, attestation, and per-tenant policy.\n\n## Key Concepts\n- CNF provenance, Cosign, SBOM\n- Per-tenant policy, KMS-backed store\n- Admission control (Validating Webhook, Kyverno/OPA)\n- TPM2.0/IMA attestation, runtime gate\n\n## Code Example\n```yaml\n# Kyverno policy skeleton enforcing tenant upgrade provenance\napiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: cnf-upgrade-provenance\nspec:\n  rules:\n  - name: require-provenance\n    match:\n      resources:\n        kinds:\n        - Deployment\n    validate:\n      message: \"Upgrade must have Cosign-signed image and SBOM\"\n      pattern:\n        spec:\n          template:\n            spec:\n              containers:\n              - name: '*'\n                image: '*'\n```\n\n## Follow-up Questions\n- How would you test fail-closed behavior under network partition?\n- How would you audit policy changes in the KMS-backed store without drifting?","diagram":"flowchart TD\n  A[Tenant requests upgrade] --> B[ Admission Webhook ]\n  B --> C{Provenance OK?}\n  C -- Yes --> D[Attestation TPM/IMA check]\n  C -- No --> E[Reject upgrade]\n  D --> F{Policy match?}\n  F -- Yes --> G[Upgrade allowed]\n  F -- No --> E","difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Hugging Face","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T12:57:38.198Z","createdAt":"2026-01-18T12:57:38.198Z"},{"id":"q-3980","question":"In a multi-tenant CNF gateway platform on Kubernetes across two clouds, design an end-to-end image provenance gate for per-tenant upgrades. Requirements: (1) Cosign-sign images with a tenant-scoped KMS key and attach an SPDX SBOM, (2) a central policy (Kyverno/OPA) enforcing presence of both signature and SBOM before admission, (3) canary rollout with per-tenant rollback on SBOM or signature drift, (4) provide minimal in-namespace manifests and commands to validate end-to-end in one tenant namespace before broader rollout?","answer":"Outline a per-tenant upgrade workflow on Kubernetes: Cosign-sign the CNF image with a tenant KMS key and attach an SPDX SBOM; enforce with a central policy (Kyverno/OPA) that requires both signature a","explanation":"## Why This Is Asked\nTests real-world CNF provenance controls across tenants, regions, and tools, plus rollback and in-namespace validation.\n\n## Key Concepts\n- CNF provenance and SBOM attachment\n- Tenant-scoped Cosign signing with KMS\n- Central policy enforcement (Kyverno/OPA)\n- Canary rollouts and rollback triggers\n- Minimal in-namespace validation or test harness\n\n## Code Example\n```yaml\n# Kyverno policy skeleton enforcing signature and SBOM presence\napiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: require-sbom-signature\nspec:\n  validationFailureAction: enforce\n  rules:\n  - name: require-sbom-and-signature\n    match:\n      resources:\n        kinds: [\"Deployment\"]\n    validate:\n      message: \"Image must be signed and SBOM attached\"\n      pattern:\n        spec:\n          template:\n            spec:\n              containers: /[^\\n]+/  # placeholder\n```\n\n```bash\n# Example Cosign signing command (tenant-scoped key)\ncosign sign --key cosign-tenantA-key.pem ghcr.io/tenantA/cnf-gateway:1.2.3\n```\n\n## Follow-up Questions\n- How would you instrument auditing for failed sign/SBOM checks and trigger automatic rollbacks?\n- What tests would you add to ensure no drift between SBOM and image during upgrades?","diagram":"flowchart TD\n  A[Tenant upgrade request] --> B[Sign image w/ tenant KMS + SBOM]\n  B --> C[Policy check (signature + SBOM)]\n  C --> D[Canary rollout per tenant]\n  D --> E{SBOM/signature valid?}\n  E -- Yes --> F[Full rollout]\n  E -- No --> G[Rollback]\n\n","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Slack","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T18:40:42.036Z","createdAt":"2026-01-18T18:40:42.037Z"},{"id":"q-4065","question":"Scenario: You run a multi-tenant CNF platform on Kubernetes delivering real-time video processing at edge. Design an end-to-end update validation workflow that (1) signs new CNF images with Cosign and attaches SBOMs, (2) performs runtime attestation (TPM/IMA) and extracts a lightweight anomaly score from telemetry, (3) enforces via OPA/Kyverno that upgrades are blocked if attestation or SBOM is invalid or anomaly score is high, and (4) includes a minimal in-namespace test to verify rollout and rollback before full deployment?","answer":"Implement a comprehensive validation gate that permits upgrades only when all criteria are satisfied: (a) the CNF image is Cosign-signed using a KMS-backed key with a corresponding SBOM attached; (b) TPM/IMA runtime attestation is successfully validated by a central verifier service; (c) telemetry-derived anomaly scoring remains below the configured threshold; and (d) a namespace-scoped canary test successfully validates both rollout and rollback capabilities before proceeding with full deployment.","explanation":"## Why This Is Asked\n\nThis question evaluates your ability to design end-to-end security and operational workflows for CNF updates in multi-tenant, edge-focused Kubernetes environments, integrating supply chain security, runtime verification, monitoring, and policy-driven deployment controls.\n\n## Key Concepts\n\n- **Image provenance**: Cosign signing with KMS-backed keys and SBOM attachment\n- **Runtime attestation**: TPM/IMA measurement verification\n- **Anomaly detection**: Lightweight telemetry-based scoring\n- **Policy enforcement**: OPA/Kyverno gatekeeping mechanisms\n- **Canary validation**: Namespace-scoped testing with rollout and rollback verification","diagram":null,"difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Netflix","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T05:56:34.854Z","createdAt":"2026-01-18T22:32:24.277Z"},{"id":"q-4153","question":"In a multi-tenant CNF platform on Kubernetes delivering a real-time data plane CNF across regions, design an end-to-end upgrade validation flow that ensures zero-downtime upgrades per tenant. Include: (1) per-tenant compatibility manifests with API/ABI versions and SBOM attestations, (2) a canary rollout strategy with traffic splitting and progressive health checks, (3) cross-tenant attestation checks with a policy engine, (4) rollback plan and auditability, and (5) a one-namespace pre-check before full rollout?","answer":"Start with per-tenant upgrade manifests declaring API/ABI compatibility and SBOM attestations. Use a canary rollout in a dedicated namespace with traffic splitting (Istio) and progressive health check","explanation":"## Why This Is Asked\nTests ability to design real-world upgrade workflows that balance safety, speed, and tenant isolation in CNF platforms. Focuses on per-tenant compatibility, SBOM integrity, canary risk management, and auditable rollbacks.\n\n## Key Concepts\n- CNF upgrade pipelines with per-tenant manifests\n- SBOM attestations and API/ABI compatibility checks\n- Canary deployments and traffic shifting\n- Policy-driven cross-tenant attestations and rollback\n\n## Code Example\n```javascript\n// Pseudo manifest example\nconst tenantUpgrade = {\n  tenant: 'tenant-a',\n  targetApi: 'v2',\n  sbom: 'signed',\n  canary: true\n}\n```\n\n## Follow-up Questions\n- How would you integrate SBOM provenance with existing CI/CD tooling?\n- How do you handle regional outages during canary rollout?","diagram":"flowchart TD\n  Start[Start Upgrade] --> Fetch[Fetch Tenant Manifest & SBOM]\n  Fetch --> Canary[Deploy Canary (per-tenant)]\n  Canary --> Split[Traffic Splitting (Istio)]\n  Split --> Monitor[Monitor Latency & Attestations]\n  Monitor -->|Green| Promote[Promote to Full Rollout]\n  Monitor -->|Fail| Rollback[Rollback & Audit]\n  Promote --> Audit[Audit & Compliance]\n  Start --> Precheck[One-Namespace Pre-Check]","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Instacart","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T05:44:17.826Z","createdAt":"2026-01-19T05:44:17.826Z"},{"id":"q-4272","question":"In a CNF platform spanning on-prem, AWS, and Azure, design an end-to-end CNF image signing and key-rotation workflow using per-cloud KMS (AWS KMS, Azure Key Vault, and in-house HSM) with Cosign, SPDX SBOMs, and a cross-cloud provenance store. Ensure zero-downtime key rotation, tenant isolation, and automatic rollback if attestation fails. Provide steps, minimal manifests, and verification plan?","answer":"Describe a practical, end-to-end key-rotation workflow for CNF image signing across AWS, Azure, and on-prem. Include how Cosign keys are rotated in each KMS, how SBOMs are tied to signatures, how a ce","explanation":"## Why This Is Asked\nTests multi-cloud KMS integration, cross-tenant isolation, and downtime-free key rotation in CNF provenance.\n\n## Key Concepts\n- Cross-cloud KMS integration (AWS KMS, Azure Key Vault, on-prem HSM)\n- Cosign-based signing, SBOM binding, provenance store consistency\n- Runtime attestation enforcement during rotation\n- Rollback and rollback-triggered validation\n\n## Code Example\n```javascript\n// Pseudo-shell: rotate key in each KMS, re-sign images, publish new SBOM\ncosign generate-key-pair -kms aws-kms:alias/cnfsign\ncosign sign --key kms:aws:kms:alias/cnfsign <image>\ncosign verify <image>\n# sign SBOM and publish provenance\nsbom-tool attach --image <image> --sbom sbom.json\nprovenance-store.push <image> <sbom.json> --kms-rotation\n```\n\n## Follow-up Questions\n- How would you test rotation without affecting tenants?\n- What metrics indicate rotation health?","diagram":null,"difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Plaid","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T11:01:55.153Z","createdAt":"2026-01-19T11:01:55.153Z"},{"id":"q-4379","question":"Design an end-to-end workflow to verify integrity of dynamic CNF configuration updates (CRDs, ConfigMaps, policy) in a multi-tenant CNF gateway on Kubernetes. Include signing of config payloads, SBOM generation, admission-time enforcement, per-tenant rollback, and a minimal in-namespace test plan; detail how you would validate in a canary namespace before rollout?","answer":"Implement a CI step that signs every config payload (CRD/ConfigMap/policy) with Cosign using a KMS-backed key, attach an SBOM, and publish to a signed config registry. Use an admission controller (Kyv","explanation":"## Why This Is Asked\nTests practical end-to-end config provenance and policy enforcement for multi-tenant CNF platforms, a common production risk area beyond image provenance.\n\n## Key Concepts\n- Config payload signing with Cosign and KMS-backed keys\n- SBOM attachment for config changes\n- Admission control with Kyverno/OPA enforcing signature, SBOM, and tenant labels\n- Canary namespace validation before rollout\n- Per-tenant rollback mechanisms and status surfacing\n\n## Code Example\n```javascript\n// Pseudo workflow: verify config update integrity before applying\nasync function verifyConfigUpdate(payload, signature, sbom) {\n  const okSig = await verifySignature(payload, signature);\n  const okSBOM = await validateSBOM(payload, sbom);\n  const tenantOk = checkTenantLabel(payload);\n  return okSig && okSBOM && tenantOk;\n}\n```\n\n## Follow-up Questions\n- How would you test rollback semantics across tenants?\n- How would you handle SBOM drift when multiple tenants update concurrently?","diagram":"flowchart TD\n  A[Config Update] --> B[Sign with Cosign]\n  B --> C[Attach SBOM]\n  C --> D[Admission Check]\n  D --> E{Canary?}\n  E -->|yes| F[Publish to Tenant Namespace]\n  E -->|no| G[Rollback]","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Coinbase"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T16:45:35.769Z","createdAt":"2026-01-19T16:45:35.770Z"},{"id":"q-4427","question":"Design an end-to-end CNF upgrade gate for a multi-tenant Kubernetes platform. Requirements: (1) sign upgrade images with Cosign using a KMS-backed key and attach SPDX SBOMs; (2) compute per-tenant SBOM deltas and enforce via Kyverno to permit upgrades only with valid attestation and delta approval; (3) implement canary rollout with per-tenant rollout windows and automatic rollback; (4) include minimal manifests and commands for in-namespace validation?","answer":"Implement image signing via Cosign with a KMS-backed key; attach SBOMs; generate per-tenant SBOM deltas and enforce gates with Kyverno so upgrades proceed only if attestation is valid and delta is all","explanation":"## Why This Is Asked\nTests ability to design secure, scalable upgrade workflows across tenants with provenance, policy enforcement, and rollback.\n\n## Key Concepts\n- Image provenance with Cosign + KMS\n- SBOM delta verification per tenant\n- Kyverno policy gates + attestation\n- Canary rollout with per-tenant windows\n- Observability and audit logging\n\n## Code Example\n```yaml\n# Example Kyverno policy snippet (high-level)\napiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: cnf-upgrade-gate\nspec:\n  rules:\n  - name: require-sbom-and-attestation\n    match:\n      resources:\n        kinds: [Deployment]\n    validate:\n      message: \"SBOM and attestation required\"\n      pattern:\n        spec:\n          template:\n            metadata:\n              annotations:\n                provenance: ?\n```\n\n## Follow-up Questions\n- How would you handle key rotation for the KMS-backed Cosign signer?\n- What metrics would you surface for upgrade health across tenants?","diagram":null,"difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Discord","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T18:45:32.755Z","createdAt":"2026-01-19T18:45:32.755Z"},{"id":"q-4446","question":"CNF certification: In a multi-tenant CNF gateway platform on Kubernetes, design an end-to-end upgrade safety workflow for CNF images that guarantees API contract compatibility, tenant isolation, and safe rollback. Requirements: per-tenant upgrade windows; canary rollout; API surface contract tests; in-cluster image provenance (Cosign) with SBOM; automatic rollback on contract/test failures, latency spikes, or SBOM mismatches; include minimal manifests and testing steps?","answer":"Outline a per-tenant upgrade workflow using Argo Rollouts canary, with traffic shifting via Istio, and a pact-based API contract check before progression. Enforce image provenance with Cosign SBOM in ","explanation":"## Why This Is Asked\n\nInterview context explanation.\n\n## Key Concepts\n\n- Per-tenant upgrade windows and canary rollout\n- API surface contracts with Pact-like tests\n- Image provenance with Cosign and SBOM\n- In-cluster gate via Webhook policy\n- Robust rollback triggers (contract failure, latency spike, SBOM drift)\n\n## Code Example\n\n```javascript\n// Example snippet: canary rollout skeleton\nvar rollout = {\n  kind: 'Rollout',\n  apiVersion: 'argoproj.io/v1alpha1',\n  metadata: { name: 'cnf-gateway' },\n  spec: { /* ... */ }\n}\n```\n\n## Follow-up Questions\n\n- What signals would you monitor to trigger a rollback?\n- How would you ensure tenant SLAs are preserved during upgrades?","diagram":null,"difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Google","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T19:28:13.947Z","createdAt":"2026-01-19T19:28:13.947Z"},{"id":"q-4480","question":"In a multi-tenant CNF platform on Kubernetes serving data-plane proxies for a fintech partner, design a runtime attestation workflow that enforces per-tenant trust before a CNF is allowed to handle traffic. The solution should extend prior provenance (image signing + SBOM) to include a small in-guest attestation agent that reports a runtime hash to a per-tenant attestation service. Describe: (1) how tenants produce and publish SBOMs and runtime attestations; (2) how an admission controller enforces both image signature and runtime attestation; (3) how keys are rotated with KMS; (4) a minimal one-namespace test to validate the end-to-end; (5) failure modes and mitigations?","answer":"Explain a runtime attestation workflow: sign the CNF image with Cosign and publish the SBOM as before; add a tiny in-pod attestation agent that computes a runtime hash of critical files/modules and si","explanation":"## Why This Is Asked\n\nTests practical knowledge of runtime attestation beyond static provenance, tying build-time artifacts to in-cluster enforcement.\n\n## Key Concepts\n\n- CNF runtime attestation\n- SBOM, Cosign, image provenance\n- KMS key management and rotation\n- Admission controls (OPA/Kyverno)\n- Tenant identity (SPIRE/SPIFe)\n\n## Code Example\n\n```javascript\n// Placeholder: policy check flow for image + attestation\n```\n\n## Follow-up Questions\n\n- How would you rotate keys without breaking in-flight CNFs?\n- What are the risks of replay attacks and how would you mitigate them?\n","diagram":null,"difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Robinhood","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T20:42:29.082Z","createdAt":"2026-01-19T20:42:29.082Z"},{"id":"q-4524","question":"Beginner CNF certification: In a multi-tenant CNF gateway platform, add end-to-end provenance for runtime plugins loaded by gateways (e.g., TLS, rate-limiting, IDS) packaged as separate images. Outline an end-to-end flow to (1) sign plugin images with Cosign and attach SBOMs, (2) enforce admission-time loading of only signed plugins per-tenant, (3) surface per-tenant plugin provenance in gateway status, (4) validate in one namespace with minimal manifests before rollout?","answer":"Implement Cosign signing for plugin images using KMS-backed keys, generate and attach SPDX SBOMs to each plugin image, maintain per-tenant plugin allowlists in ConfigMaps, enforce admission-time validation through a webhook that rejects gateway pods loading unsigned plugins, and surface comprehensive provenance data in gateway status fields for tenant visibility.","explanation":"## Why This Is Asked\nThis question evaluates expertise in establishing end-to-end provenance for runtime plugins in multi-tenant CNF gateway environments, ensuring secure plugin lifecycle management with industry-standard tools.\n\n## Key Concepts\n- Cosign image signing with KMS-backed cryptographic keys\n- SPDX SBOM generation and attachment to plugin images\n- Per-tenant plugin policy enforcement via ConfigMap allowlists\n- Admission webhook validation for signed plugin loading\n- Gateway status API integration for provenance visibility\n- Namespace-scoped validation with minimal deployment footprint\n\n## Code Example\n```go\n// Admission webhook validating signed plugin images per tenant\npackage main\n\nfunc validatePluginImage(imageRef, tenantNamespace string) error {\n    // Verify Cosign signature using KMS public key\n    if !cosign.Verify(imageRef, kmsPublicKey) {\n        return fmt.Errorf(\"unsigned plugin image: %s\", imageRef)\n    }\n    \n    // Validate SBOM presence and integrity\n    if !sbom.Validate(imageRef) {\n        return fmt.Errorf(\"missing or invalid SBOM for: %s\", imageRef)\n    }\n    \n    // Check against tenant-specific allowlist\n    if !allowlist.Contains(tenantNamespace, imageRef) {\n        return fmt.Errorf(\"plugin not in tenant allowlist: %s\", imageRef)\n    }\n    return nil\n}\n```\n\n## Follow-up Considerations\n- Implement automated key rotation for long-term security\n- Design plugin update workflows maintaining provenance continuity\n- Configure monitoring for plugin compliance violations across tenants","diagram":"flowchart TD\n  A[Start] --> B[Sign plugin images with Cosign]\n  B --> C[Publish SBOMs]\n  C --> D[Admission webhook enforces signed plugins per tenant]\n  D --> E[Gateway status shows provenance per tenant]\n  E --> F[One-namespace validation test]\n  F --> G[Rollout]\n","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Scale Ai","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T06:55:04.765Z","createdAt":"2026-01-19T22:36:30.489Z"},{"id":"q-4559","question":"Design a tenant-scoped CNF image trust workflow for a multi-tenant Kubernetes CNF platform. Each tenant has a dedicated Cosign signing key stored in a KMS. Build a per-tenant admission policy (Kyverno) that: (a) validates the image digest is signed with the tenant’s key, (b) requires an SPDX SBOM, (c) enforces a tenant-specific trust score before deployment, and (d) surfaces per-tenant test status prior to rollout. Provide concrete steps and minimal in-namespace manifests to validate one tenant before broader rollout?","answer":"Implement a tenant-bound trust broker: store each tenant’s Cosign key in a KMS and expose it via per-tenant Secrets/SecretProvider. Kyverno policy validates signature against the tenant key and SBOM p","explanation":"## Why This Is Asked\nTests ability to design scalable, tenant-aware supply chain controls using real tools (Cosign, SBOMs, Kyverno, KMS) and a practical rollout strategy with canaries.\n\n## Key Concepts\n- Tenant-scoped trust and per-tenant keys\n- Cosign signing with KMS-backed keys\n- SPDX SBOM validation\n- Kyverno/Policy as code gate\n- Canary rollout and per-tenant visibility\n\n## Code Example\n```yaml\n# Kyverno policy (example outline)\napiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: tenant-signature-policy\nspec:\n  validationFailureAction: enforce\n  rules:\n  - name: require-tenant-signature\n    match:\n      resources:\n        kinds: [\"Pod\"]\n    validate:\n      image: {\n        // pseudo-field: ensure image is signed by tenant key\n      }\n```\n\n```yaml\n# Minimal in-namespace manifest (canary)\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: canary-cnf\n  namespace: tenant-a\nspec:\n  replicas: 1\n  template:\n    spec:\n      containers:\n      - name: cnf\n        image: registry.example.com/tenant-a/cnf:canary\n```\n\n## Follow-up Questions\n- How would you rotate tenant keys without downtime?\n- How do you surface per-tenant trust scores in the UI and automate rollback?","diagram":null,"difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","Scale Ai","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T23:51:23.736Z","createdAt":"2026-01-19T23:51:23.736Z"},{"id":"q-4636","question":"Design an intermediate CNF certification scenario for a hybrid cloud service mesh: implement an end-to-end runtime attestation and upgrade gate for CNFs deployed across namespaces and clouds. Include (1) a lightweight in-pod sidecar that signs an attestation report with a KMS-backed key and posts to a central attestation service, (2) a trust policy validating image provenance and attestation against a root of trust, (3) a canary upgrade strategy with per-CNF rollback based on attestation and traffic signals, and (4) minimal config snippets to validate in one namespace before wider rollout?","answer":"Implement in-cluster runtime attestation: a lightweight sidecar signs an attestation report with a KMS-backed key and posts it to a central attestation service. Gate policies enforce image provenance ","explanation":"## Why This Is Asked\nCNF reliability hinges on runtime trust alongside image provenance. This question tests practical knowledge of in-cluster attestation, trust roots, and controlled upgrades across clouds.\n\n## Key Concepts\n- Runtime attestation, KMS-backed keys, central attestation service\n- Image provenance and policy enforcement against a root of trust\n- Canary upgrades and per-CNF rollback in multi-namespace/multi-cloud\n- Minimal in-namespace validation and rollout gating\n\n## Code Example\n```yaml\n# Example policy (illustrative)\napiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: require-attestation\nspec:\n  validationFailureAction: enforce\n  rules:\n  - name: attestation-check\n    match:\n      resources:\n        kinds: [\"CNFDeployment\"]\n    validate:\n      message: \"Attestation must be present and signed\"\n      pattern:\n        metadata.attestationSigned: true\n```\n\n```yaml\n# Attestation report (illustrative)\nattestation:\n  signer: \"kms://arn:aws:kms:...\"\n  root: \"root-of-trust-xyz\"\n  status: \"valid\"\n```\n\n## Follow-up Questions\n- How would you handle attestation revocation and key rotation without downtime?\n- What are the failure modes if the central attestation service is unavailable, and how would you mitigate them?","diagram":null,"difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Cloudflare","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T05:51:15.513Z","createdAt":"2026-01-20T05:51:15.513Z"},{"id":"q-4833","question":"Advanced CNF Certification: In a CNF fleet deployed across three regions with intermittent WAN, design a fault-tolerant provenance and upgrade governance workflow. Requirements: (1) replicate SBOMs and Sigstore signatures to a central verifier using quorum-based replication, (2) per-tenant upgrade gating via OPA/Kyverno that only allows upgrades when a current attestation + SBOM digest exists, (3) partition-safe rollout with local policy persistence and automatic backoff, (4) provide minimal in-namespace tests and commands to validate a single-region upgrade before global rollout. Include data flow and minimal config examples?","answer":"Propose a fault-tolerant provenance workflow across regions: quorum-based replication of SBOMs and cosign signatures to a central verifier; tenant-scoped upgrade gates via Kyverno/OPA requiring attest","explanation":"## Why This Is Asked\nEvaluates real-world CNF governance under multi-region and partition scenarios, focusing on provenance, attestation, and policy enforcement using Sigstore, SBOM, Kyverno/OPA, and distributed consistency.\n\n## Key Concepts\n- Sigstore/cosign SBOM provenance\n- Quorum-based replication and central verifier\n- Kyverno/OPA regional policy gates\n- TPM/IMA attestation mechanisms\n- Partition-tolerant rollout strategies\n- In-namespace test scaffolding for rollback safety\n\n## Code Example\n```yaml\napiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: require-attestation-sbom\nspec:\n  validationFailureAction: enforce\n  rules:\n  - name: attestation-sbom-check\n    match:\n      resources:\n        kinds: [\"Deployment\"]\n    validate:\n      message: \"Deployment upgrade requires attestationDigest and sbomDigest\"\n      pattern:\n        metadata.annotations.attestationDigest: \"*\"\n        metadata.annotations.sbomDigest: \"*\"\n```\n\n## Follow-up Questions\n- How would you model failure modes during partition events and ensure eventual consistency?\n- What metrics and dashboards would you expose to detect drift between regional verifiers and the central ledger?","diagram":"flowchart TD\n  A[Start] --> B[Publish SBOM & cosign sigs] \n  B --> C[Quorum Verifier]\n  C --> D[Tenant Policy Gate (Kyverno/OPA)]\n  D --> E[Upgrade Allowed / Denied]\n  E --> F[Audit & Rollback Triggers]\n  F --> G[Global Rollout or Local Degradation]","difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T15:13:12.211Z","createdAt":"2026-01-20T15:13:12.212Z"},{"id":"q-4935","question":"Beginner CNF certification: In a multi-tenant Kubernetes cluster, design an end-to-end tenant-scoped key rotation policy for image signing. Each tenant uses a KMS-backed Cosign key rotated every 90 days. Describe zero-downtime rollover, SBOM updates, a grace period in ImagePolicyWebhook for old/new signatures, and a minimal one-namespace manifest to test rotation before wider rollout?","answer":"Rotate per-tenant Cosign keys with a 90-day cadence in KMS; sign new images with the new key while the old signature remains valid through a grace window; update SBOMs accordingly and publish new SBOM","explanation":"Why This Is Asked\n\nTests the ability to design a secure, tenant-aware key rotation strategy that avoids downtime while preserving provenance. It also checks integration of KMS, Cosign, SBOMs, and admission control in a realistic multi-tenant CNF platform.\n\nKey Concepts\n\n- Tenant-scoped KMS keys\n- Cosign signing and rotation\n- ImagePolicyWebhook grace window\n- SBOM versioning and updates\n- Canary validation in a single namespace\n\nCode Example\n\n```bash\n# Pseudo commands for rotation (illustrative)\ncosign generate-key-pair --kms-key \"aws-kms:key/tenantA\" --output cosign-key.pem\ncosign sign --key cosign-key.pem image:tag\n```\n\nFollow-up Questions\n\n- How would you automate rotation policy across tenants?\n- How would you detect failed rotation during rollout?","diagram":"flowchart TD\n  A[Tenant] --> B[Key Rotation]\n  B --> C[Cosign Sign]\n  C --> D[ImagePolicyWebhook Grace]\n  D --> E[K8s Deployment Rollout]\n  E --> F[SBOM Update]","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Netflix","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T20:24:58.951Z","createdAt":"2026-01-20T20:24:58.951Z"},{"id":"q-5039","question":"Cross-cluster CNF provenance and attestation: sign image with Cosign (KMS-backed key), attach SBOM, and emit a TPM/IMA attestation digest into a tamper-evident ledger shared across clusters. Enforce with Kyverno/OPA so deployments require ledger entry + SBOM hash. Provide a portable attestation manifest for new clusters to verify pre-rollout. Minimal in-namespace test plan to prove end-to-end before rollout?","answer":"Cross-cluster CNF provenance and attestation: sign image with Cosign (KMS-backed key), attach SBOM, and emit a TPM/IMA attestation digest into a tamper-evident ledger shared across clusters. Enforce with Kyverno/OPA so deployments require ledger entry + SBOM hash. Provide a portable attestation manifest for new clusters to verify pre-rollout. Minimal in-namespace test plan to prove end-to-end before rollout?","explanation":"## Why This Is Asked\nAssesses cross-cluster provenance, hardware attestation, and policy enforcement at scale.\n\n## Key Concepts\n- Cross-cluster provenance ledger\n- TPM/IMA attestation\n- SBOM binding and Cosign signatures\n- Policy as code (Kyverno/OPA)\n- Portable attestation manifest\n\n## Code Example\n```yaml\n# Kyverno policy snippet (high-level)\napiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: require-ledger-sbom\nspec:\n  rules:\n  - name: check-ledger-and-sbom\n    match:\n      resources:\n        kinds: [Deployment]\n    validate:\n      message: \"Image must be ledger-verified with SBOM hash\"\n      pattern:\n        spec:\n          containers:\n          - image: \"?*\"\n            env:\n            - name: LEDGER_DIGEST\n              value: \"?*\"\n            - name: SBOM_HASH\n              value: \"?*\"\n```","diagram":"flowchart TD\n  A[Image built] --> B[Cosign sign]\n  B --> C[Attach SBOM]\n  C --> D[Publish attestation digest]\n  D --> E[Ledger across clusters]\n  E --> F[Policy check on deploy]","difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Google","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-21T03:57:09.011Z","createdAt":"2026-01-21T02:45:56.228Z"},{"id":"q-5095","question":"Design an end-to-end ephemeral CNF lifecycle in a multi-cloud Kubernetes environment for a high-frequency risk-analysis CNF. The workflow must: (1) generate a short-lived SPIFFE identity tied to hardware-backed attestation (IMA/TPM) at boot, (2) produce a signed SBOM and a delta SBOM for each patch, (3) enforce runtime and admission policies via OPA/Kyverno to only allow CNFs with valid attestation and SBOM delta, (4) include a lightweight in-namespace test harness that verifies boot attestation, SBOM presence, and policy evaluation within 5 minutes of deployment, (5) outline rollback/revocation mechanics across clouds and tenants. Provide minimal config examples?","answer":"Propose a design where each CNF instance boots with a TPM-backed IMA attestation that ties a short-lived SPIFFE ID to a verifiable nonce, signs an SBOM and a delta SBOM with Cosign, and enforces polic","explanation":"Why This Is Asked\n- Tests practical knowledge of CNF provenance at scale across clouds\n- Combines hardware attestations, SBOMs, and policy controls\n\nKey Concepts\n- Ephemeral CNFs, SPIFFE identities, IMA/TPM attestations\n- SBOMs and delta SBOMs with Cosign signing\n- Admission and runtime policy with Kyverno/OPA\n- In-namespace test harness for fast feedback\n- Cross-cloud revocation mechanics\n\nCode Example\n```yaml\n# Kyverno policy sketch for attestation + SBOM check\napiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: require-attestation-sbom\nspec:\n  rules:\n  - name: attest-sbom-check\n    match:\n      resources:\n        kinds: [\"Deployment\"]\n    validate:\n      message: \"Attestation and SBOM required\"\n      pattern:\n        metadata:\n          annotations:\n            attest.sha256: \"*\"\n            sbom.sha256: \"*\"\n```\n\nFollow-up Questions\n- How would revocation propagate across multiple clouds and tenants?\n- How would you simulate attestation or SBOM failure in CI/CD?","diagram":"flowchart TD\n  A[Boot CNF] --> B[IMA/TPM Attestation]\n  B --> C[SPIFFE ID issuance]\n  C --> D[SBOM + delta SBOM signing]\n  D --> E[Policy evaluation (Kyverno/OPA)]\n  E --> F[Deployment or rollback]","difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Goldman Sachs","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T05:54:29.173Z","createdAt":"2026-01-21T05:54:29.173Z"},{"id":"q-5165","question":"In a CNF platform serving latency-sensitive workloads across multiple regions, implement a zero-trust image provenance gate using a central provenance service to compute a per-image provenance score. The flow should: sign with Cosign using a KMS-backed key; generate CycloneDX SBOM via Syft; publish to a provenance API; gate admission with a webhook that rejects deployments below a threshold; include an in-namespace minimal test?","answer":"Architect a ValidatingWebhook that, on image admission, fetches the provenance score from the central service and rejects if score < threshold. Implement: Cosign signing with a KMS key; SBOM via Syft ","explanation":"## Why This Is Asked\nThis question tests the ability to design a scalable, policy-driven CNF provenance gate that coordinates image signing, SBOM validation, and runtime admission checks across regions.\n\n## Key Concepts\n- Zero-trust provenance\n- Cosign with KMS-backed key\n- SBOM with Syft CycloneDX\n- Central provenance service\n- ValidatingWebhook and per-tenant OPA policies\n\n## Code Example\n```javascript\n// pseudo-config demonstrating webhook fetch and threshold check\n```\n\n## Follow-up Questions\n- How would you scale the provenance API for hundreds of tenants?\n- What failure modes and observability metrics would you add?","diagram":"flowchart TD\n  A[CNF Image] --> B[Cosign Sign]\n  B --> C[SBOM (Syft)]\n  C --> D[Provenance API]\n  D --> E[Admission Webhook]\n  E --> F[Deployment]","difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Netflix","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T08:57:32.027Z","createdAt":"2026-01-21T08:57:32.027Z"},{"id":"q-5213","question":"Beginner CNF certification: In a multi-tenant CNF gateway platform on Kubernetes, implement per-tenant Cosign key rotation for image signing. Describe how you rotate to a new KMS-backed key, regenerate SBOMs, update ImagePolicyWebhook to enforce the new key version, and validate the rotation in one namespace before wider rollout?","answer":"Per-tenant key rotation using a KMS-backed Cosign key. Sign new images with the active tenant key, regenerate SBOMs, and publish the new key-id. Update ImagePolicyWebhook to require the current tenant","explanation":"## Why This Is Asked\nThis question tests practical understanding of per-tenant provenance, rotation workflows, and admission control in Kubernetes CNF platforms. It emphasizes atomic key rotation, SBOM integrity, and minimal in-namespace validation before production rollout.\n\n## Key Concepts\n- Cosign per-tenant signing and KMS integration\n- SBOM regeneration and attachment\n- ImagePolicyWebhook versioning and admission checks\n- Namespace-scoped validation and rollback strategy\n\n## Code Example\n```javascript\n// pseudo webhook snippet: verify tenantId and keyId match image annotation\n```\n\n## Follow-up Questions\n- How would you detect and recover from failed rotation?\n- How to test rotation safety across tenants?","diagram":"flowchart TD\n  A[Rotate Key] --> B[Sign Image]\n  B --> C[Regenerate SBOM]\n  C --> D[Update Policy]\n  D --> E[Test Namespace]\n  E --> F[Rollout]","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","IBM","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T11:00:00.081Z","createdAt":"2026-01-21T11:00:00.082Z"},{"id":"q-5583","question":"Design a post-incident CNF provenance forensics workflow for a multi-tenant Kubernetes platform spanning cloud and edge. After a suspected compromised CNF image is deployed, outline isolation, data collection (Cosign signatures, SBOM, TPM/IMA attestations, registry/audit logs, manifests), timeline reconstruction via SBOM deltas, baseline comparison with a canary namespace, and an auditable runbook for rollback and evidence packaging. Include minimal in-namespace test steps?","answer":"Isolate the namespace and pause workload updates. Collect immutable provenance: Cosign signature, SBOM, TPM/IMA attestations, registry audit logs, and Kubernetes manifests. Reconstruct the incident ti","explanation":"## Why This Is Asked\nTests capability to respond to a CNF supply-chain incident with forensics rigor, cross-cloud edge concerns, and auditable outcomes.\n\n## Key Concepts\n- End-to-end provenance collection (signatures, SBOMs, attestations)\n- Forensic timeline reconstruction using SBOM deltas\n- Canary-based baseline validation and rollback planning\n\n## Code Example\n```javascript\n// Pseudo-code: assemble proof package for incident\nfunction packageEvidence(eventLogs, sboms, attestations){\n  return {logs: eventLogs, sboms, attestations, timestamp: new Date().toISOString()};\n}\n```\n\n## Follow-up Questions\n- How would you automate containment without disrupting multi-tenant workloads?\n- Which tools would you integrate for immutable evidence packaging and audit reporting?","diagram":"flowchart TD\n  A[Detect compromise] --> B[Isolate namespace]\n  B --> C[Collect provenance data]\n  C --> D[Reconstruct timeline]\n  D --> E[Validate vs baseline]\n  E --> F[Publish evidence]","difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Hugging Face","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T07:13:36.858Z","createdAt":"2026-01-22T07:13:36.858Z"},{"id":"q-5617","question":"In a multi-tenant CNF gateway platform on Kubernetes, design an Open Policy Agent (OPA) gate to enforce that every Pod image is signed with Cosign using a KMS-backed key and that an SPDX SBOM is present, with a 24-hour sandbox exemption for a new tenant namespace. Include the Rego policy, a minimal test manifest (compliant and noncompliant), and CI steps to validate policy decisions before rollout?","answer":"Use an OPA gate with a RegO policy that, on Pod admission, enforces: (1) Cosign-signature present for each image via a KMS-backed key, (2) SPDX SBOM present in the SBOM store, and (3) tenant-scoped en","explanation":"## Why This Is Asked\nThis tests practical policy-as-code for CNF pipelines: admission control, provenance enforcement, and low-friction rollout via sandbox exemptions.\n\n## Key Concepts\n- OPA/RegO policy writing for Kubernetes admission data\n- Cosign signatures with KMS-backed keys\n- SPDX SBOM provenance guarantees\n- Namespace-based sandbox exemptions and rollout strategy\n\n## Code Example\n```rego\npackage kubernetes.admission\nimport data.kubernetes.admission\n\nviolation[msg] {\n  input.kind == \\\"Pod\\\"\n  container := input.review.object.spec.containers[_]\n  not signed(container.image)\n  msg := sprintf(\\\"unverified image: %v\\\", [container.image])\n}\n\nsigned(img) {\n  startswith(img, \\\"gcr.io/\\\")\n  # Placeholder: integrate signature lookup from provenance store\n}\n```\n\n## Follow-up Questions\n- How would you implement a rollback path if a batch of pods fails policy?\n- How would you test performance impact in large clusters?","diagram":"flowchart TD\n  A[Pod Admission] --> B[Fetch image metadata]\n  B --> C{Signed and SBOM present?}\n  C -- Yes --> D[Allow]\n  C -- No --> E[Deny]","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","MongoDB","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T08:49:26.081Z","createdAt":"2026-01-22T08:49:26.081Z"},{"id":"q-5654","question":"In a Kubernetes CNF gateway fleet across regions, design an end-to-end CNF provenance and runtime attestation flow that (1) signs images with Cosign using a KMS-backed key and attaches an SPDX SBOM, (2) runs an in-cluster Attestation Service that verifies digest, SBOM, and lightweight runtime attestations and issues a verifiable token, and (3) enforces admission policy requiring both signature and attestation token before deployment. Provide minimal one-namespace manifests and commands to validate?","answer":"Two-stage: (1) CI signs the CNF image with Cosign using a KMS-backed key and attaches an SPDX SBOM to the image; (2) an in-cluster Attestation Service verifies the digest, SBOM, and a lightweight runt","explanation":"## Why This Is Asked\nTests a practical integration of image provenance with runtime attestation, ensuring defense in depth for CNF deployments in multi-region clusters.\n\n## Key Concepts\n- Image signing with Cosign and KMS-backed keys\n- SPDX SBOM association and SBOM validation\n- In-cluster attestation service generating verifiable tokens\n- Admission control enforcing both provenance and attestation\n\n## Code Example\n```javascript\n// Pseudo-code: basic attestation gate\nfunction attest(imageDigest, token, sbom) {\n  if (!verifySignature(imageDigest)) return false;\n  if (!verifySBOM(sbom)) return false;\n  if (!verifyToken(token)) return false;\n  return true;\n}\n```\n\n## Follow-up Questions\n- How would you handle key rotation and revocation in the KMS?\n- How would you simulate attestation failures in a namespace to verify policy behavior?","diagram":null,"difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","IBM","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T10:07:38.861Z","createdAt":"2026-01-22T10:07:38.861Z"},{"id":"q-5752","question":"Beginner CNF certification: In a multi-tenant Kubernetes cluster, add a per-namespace runtime license policy gate. Design an end-to-end flow to: (1) cosign-sign CNF images and attach SBOMs including licenses, (2) publish to a central registry, (3) enforce via an OPA Gatekeeper policy per-namespace that denies pods if any restricted license appears in the SBOM for that tenant, (4) provide a minimal one-namespace test with a compliant and a non-compliant image, and (5) outline how to monitor, report failures, and roll back if policy violations occur. Include minimal manifests and a short example policy snippet?","answer":"Design a per-namespace runtime license gate in a multi-tenant cluster. Sign CNF images with Cosign and embed SBOMs with licenses; push to a central registry; enforce per-tenant licenses using an OPA G","explanation":"## Why This Is Asked\nTests policy-as-code reasoning, per-tenant governance, SBOM licensing, and end-to-end flow from signing to deployment with rollback.\n\n## Key Concepts\n- Policy-as-code with OPA Gatekeeper\n- SBOM licensing and Cosign signing\n- Tenant-scoped policy configuration\n- Namespace admission flow and rollback\n- Testing with compliant vs non-compliant images\n\n## Code Example\n```javascript\n// Example: quick license check against SBOM\nfunction isLicenseCompliant(sbom, allowed) {\n  const licenses = (sbom.licenses || []).map(l => l.name.toLowerCase());\n  return allowed.every(a => licenses.includes(a.toLowerCase()));\n}\n```\n\n## Follow-up Questions\n- How would you manage dynamic license allowlists for tenants?\n- How would you roll back a deployment if a policy violation is detected?","diagram":"flowchart TD\nA[Signed CNF Image + SBOM] --> B[Push to Registry]\nB --> C[Namespace: tenant-n1]\nC --> D[OPA Gatekeeper Policy: Allowed Licenses]\nD --> E[Admission Controller]\nE --> F[CNF Deploys]\nG[Test Namespace] --> H[Compliant Image Test]\nH --> D\nI[Test Namespace] --> J[Non-Compliant Image Test]\nJ --> D","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T15:06:49.861Z","createdAt":"2026-01-22T15:06:49.862Z"},{"id":"q-5844","question":"Design a scalable edge CNF provenance and attestation workflow: 1) collect TPM/IMA startup attestations per tenant and publish to a central verifier; 2) generate per-image SBOM deltas and surface to policy engines; 3) gate deployments and upgrades with Kyverno/OPA requiring both attestation and SBOM delta; 4) implement tenant-scoped canary rollouts with minimal in-namespace tests. Provide concrete steps and minimal config snippets?","answer":"Collect TPM/IMA attestations per tenant and push to a verifier; generate SBOM deltas per image and expose to policy engines; enforce upgrades with Kyverno/OPA requiring attestation + SBOM delta; imple","explanation":"## Why This Is Asked\nTests ability to design end-to-end attestation, provenance, and governance at edge scale with tenant isolation.\n\n## Key Concepts\n- Hardware-backed attestation (TPM/IMA)\n- SBOM delta management per image\n- Policy-as-code (Kyverno/OPA)\n- Canary rollout per-namespace\n\n## Code Example\n```yaml\n# Minimal Kyverno policy snippet (illustrative)\napiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: require-attestation\nspec:\n  rules:\n  - name: attestation-check\n    match:\n      resources:\n        kinds: [\"Deployment\"]\n    validate:\n      message: \"Attestation and SBOM delta required\"\n      pattern:\n        metadata:\n          annotations:\n            attestation: \"present\"\n```\n\n## Follow-up Questions\n- How would you revoke compromised attestations and propagate revocation?\n- How do you scale SBOM storage and ensure freshness across edge sites?","diagram":null,"difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","DoorDash","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T19:06:33.421Z","createdAt":"2026-01-22T19:06:33.421Z"},{"id":"q-5883","question":"Beginner CNF certification: In a multi-tenant Kubernetes setup hosting CNF gateways, design an end-to-end policy delta verification flow for tenant policy updates. Requirements: (1) package policy changes as a signed artifact with Cosign and an SPDX SBOM, (2) validate the delta via an admission webhook against the tenant’s KMS-backed policy store, (3) run a one-namespace dry-run deployment that publishes the decision to a per-tenant ConfigMap, (4) outline minimal manifests and commands to test in one namespace before broader rollout?","answer":"Sign the policy delta artifact with Cosign using a KM-backed key and publish an SPDX SBOM; the admission webhook validates the delta digest against the tenant's policy digest stored in the KMS-backed ","explanation":"## Why This Is Asked\n\nTests ability to design an end-to-end policy delta verification flow, combining image and policy provenance concepts with per-tenant governance in a live cluster.\n\n## Key Concepts\n\n- CNF policy delta\n- Cosign signing with KM-backed keys\n- SPDX SBOM\n- Kubernetes admission webhook\n- Per-tenant ConfigMap for observability\n- Dry-run deployment for safe validation\n\n## Code Example\n\n```yaml\n# Minimal PolicyDelta CRD\napiVersion: cnf.example/v1\nkind: PolicyDelta\nmetadata:\n  name: delta-tenant-a-1\nspec:\n  tenant: tenant-a\n  deltaDigest: sha256:abcdef...\n  signedArtifact: \"cosign-ref\"\n  sbom: \"sbom-digest\"\n```\n\n```go\n// Pseudo webhook skeleton\nfunc validateDelta(req *Request) bool {\n  // fetch tenant policy digest from KM store\n  // verify deltaDigest against policy\n  // return true/false\n}\n```\n\n## Follow-up Questions\n\n- How would you version policy deltas and roll back a bad delta?\n- How would you monitor and alert on failed delta validations?","diagram":"flowchart TD\n  A[PolicyDelta] --> B[Sign with Cosign]\n  B --> C[Publish SBOM]\n  C --> D[Admission Webhook]\n  D --> E{Delta Valid?}\n  E -->|Yes| F[Dry-run Deployment]\n  E -->|No| G[Reject]","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T20:47:32.710Z","createdAt":"2026-01-22T20:47:32.711Z"},{"id":"q-5935","question":"Beginner CNF certification: In a multi-tenant CNF gateway platform on Kubernetes, implement a tenant-aware canary upgrade strategy. Requirements: (1) per-tenant canary deployment released with 1 pod vs N baseline, (2) traffic splitting via Istio VirtualService to route 10% to canary, (3) automatic rollback if error rate or latency exceeds a threshold within a defined window, (4) minimal manifests and commands to validate in one namespace before broader rollout?","answer":"Implement per-tenant canary deployment in a single namespace: deploy gateway-tenantA-canary (1 pod) alongside gateway-tenantA baseline (N pods), configure Istio VirtualService to route 10% traffic to canary and 90% to baseline, add DestinationRule for subset management.","explanation":"## Why This Is Asked\nTests practical canary rollout skills using service mesh and metrics to guard upgrades.\n\n## Key Concepts\n- Canary deployments per tenant\n- Istio VirtualService traffic splitting\n- Basic rollback and monitoring thresholds\n- Minimal, in-namespace validation\n\n## Code Example\n```yaml\n# Example: Istio VirtualService snippet for 10% canary\napiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: gateway-tenantA\nspec:\n  http:\n  - route:\n    - destination:\n        host: gateway-tenantA\n        subset: baseline\n      weight: 90\n    - destination:\n        host: gateway-tenantA\n        subset: canary\n      weight: 10\n```\n\n## Validation Commands\n```bash\nkubectl get pods -n tenant-namespace\nkubectl get virtualservice gateway-tenantA -n tenant-namespace\nkubectl get destinationrule gateway-tenantA -n tenant-namespace\n```","diagram":"flowchart TD\n  Tenant --> Baseline[G-W Gateway Baseline]\n  Tenant --> Canary[G-W Gateway Canary]\n  Baseline -- traffic --> Service[Shared Service]\n  Canary -- traffic --> Service\n  Service --> Monitor[Prometheus Alerts]--> Rollback[kubectl rollout undo]","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Robinhood","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T05:41:02.829Z","createdAt":"2026-01-22T22:41:53.999Z"},{"id":"q-5950","question":"In a multi-tenant CNF platform on Kubernetes, design an end-to-end workflow to manage third-party CNF dependencies inside container images. Your solution must generate SPDX SBOMs for all layers, sign artifacts with Cosign using a KMS-backed key, attach SBOM metadata to the image, and enforce per-tenant provenance and integrity using a combination of ImagePolicyWebhook and OPA/Kyverno policies. Include canary rollout strategy and rollback plan with minimal manifests and commands?","answer":"Architect a per-tenant supply chain that generates SPDX SBOMs for every CNF image layer, signs artifacts with Cosign using KMS-backed keys, attaches SBOM metadata as image annotations, and publishes to per-tenant trust stores. Enforce provenance through ImagePolicyWebhook combined with OPA/Kyverno policies, implementing canary rollouts with automated rollback capabilities.","explanation":"## Why This Is Asked\n\nThis question evaluates end-to-end supply chain controls for CNFs in multi-tenant Kubernetes environments, focusing on third-party dependency management, provenance verification, and policy-driven enforcement across tenant boundaries.\n\n## Key Concepts\n\n- SPDX SBOM generation for multi-layer CNF images\n- Cosign signing with KMS-backed cryptographic keys\n- Per-tenant trust stores and provenance metadata\n- ImagePolicyWebhook and OPA/Kyverno for policy enforcement\n- Canary rollout strategies with automated rollback mechanisms\n\n## Code Example\n\n```yaml\n# Minimal Kyverno policy example (illustrative)\napiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: require-cnf-provenance\nspec:\n  validationFailureAction: Enforce\n  rules:\n  - name: verify-sbom-and-signature\n    match:\n      any:\n      - resources:\n          kinds: [\"Pod\"]\n    validate:\n      pattern:\n        spec:\n          containers:\n          - image: \"?*\"\n    context:\n    - name: imageData\n      apiCall:\n        urlPath: \"/api/v1/namespaces/{{request.namespace}}/pods\"\n```\n\n## Implementation Strategy\n\n1. **SBOM Generation**: Use tools like Syft or Trivy to scan each CNF image layer and generate SPDX-compliant SBOMs\n2. **Artifact Signing**: Implement Cosign with KMS integration (AWS KMS, GCP KMS, or HashiCorp Vault)\n3. **Metadata Attachment**: Store SBOMs and signatures as image annotations or in a dedicated metadata registry\n4. **Policy Enforcement**: Deploy ImagePolicyWebhook with OPA/Kyverno policies to validate provenance before pod admission\n5. **Canary Rollout**: Use ArgoCD or Flux with progressive deployment strategies, monitoring for policy violations\n6. **Rollback Automation**: Implement automated rollback triggers based on policy failures or integrity checks","diagram":null,"difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Meta","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T05:29:36.444Z","createdAt":"2026-01-22T23:35:25.962Z"},{"id":"q-6022","question":"Beginner CNF certification: In a multi-tenant Kubernetes cluster hosting CNF gateways, design an end-to-end runtime attestation flow using software-based attestation (e.g., Keylime) to ensure only Cosign-signed images with SBOMs run in the data plane. Include steps to deploy per-node attestation agents, gate admissions with an attestation verdict, surface per-tenant visibility on deployments, and provide a minimal one-namespace validation manifest before rollout. What would you implement?","answer":"Deploy per-node Keylime agents, sign images with Cosign and SBOMs, and gate admissions with a positive attestation verdict via a ValidatingWebhook. Tag deployments with per-tenant labels and surface A","explanation":"## Why This Is Asked\nThis explores software-based attestation in CNF contexts, a practical pathway to admissions checks and tenant isolation.\n\n## Key Concepts\n- Software attestation (Keylime) vs TPM/IMA\n- Image provenance (Cosign) and SBOMs\n- Admission control (ValidatingWebhook, ImagePolicyWebhook)\n- Per-tenant visibility in Deployment status\n\n## Code Example\n```yaml\n# Webhook config sketch\napiVersion: admissionregistration.k8s.io/v1\nkind: ValidatingWebhookConfiguration\nwebhooks:\n  - name: attestation.cnf.example.com\n    clientConfig:\n      service:\n        name: attestation-service\n        namespace: cnf-system\n        path: /validate\n    rules:\n      - apiGroups: [\"apps\"]\n        apiVersions: [\"v1\"]\n        resources: [\"deployments\"]\n        operations: [\"CREATE\",\"UPDATE\"]\n```\n\n## Follow-up Questions\n- How would you test network partition between attestation services and the API server?\n- What are failure modes and how would you rollback?\n","diagram":"flowchart TD\nA[Sign image with Cosign + SBOM] --> B{Attestation OK?}\nB -- Yes --> C[Admission gate via webhook]\nB -- No --> D[Block deployment]\nC --> E[Update Deployment status with Tenant Attestation]\nE --> F[One-namespace validation before rollout]","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T05:37:41.958Z","createdAt":"2026-01-23T05:37:41.958Z"},{"id":"q-6265","question":"In a multi-tenant CNF edge gateway, design a runtime attestation flow that verifies a signed image's SBOM and a per-tenant policy before a CNF container runs on an edge node. Describe the artifacts, verification steps (SBOM provenance, signature, revocation), enforcement mechanism (OPA Gatekeeper or Kyverno), and how you surface per-tenant status and rollback triggers. What artifacts and steps would you implement?","answer":"Implement runtime attestation: pull the image digest and Cosign-signed SBOM from provenance, verify the Cosign signature with a KMS-backed key, and validate the SBOM against the tenant's policy. Check","explanation":"## Why This Is Asked\n\nThis question probes practical knowledge of CNF provenance, edge multi-tenancy, and runtime enforcement. It tests integration of signing, SBOM provenance, per-tenant policy, and robust rollback when policy or revocation checks fail.\n\n## Key Concepts\n\n- Runtime attestation at the edge\n- SBOM provenance verification\n- Signature validation with KMS-backed keys\n- Revocation checks\n- Admission control: OPA Gatekeeper vs Kyverno\n- Per-tenant observability and rollback signals\n\n## Code Example\n\n```yaml\n# Example Kyverno ConstraintTemplate snippet (simplified)\napiVersion: kyverno.io/v1\nkind: ConstraintTemplate\nmetadata:\n  name: cnf-edge-tenant-policy\nspec:\n  crd:\n    spec:\n      names:\n        kind: CNFTenantPolicy\n  targets:\n    - target: admission.k8s.io\n      rego: |\n        package cnf.edge\n        violation[\"reason\"] = r {\"tenant(\" t \")\"}\n        r := {\n          \"msg\": \"SBOM/policy mismatch for tenant\"\n        }\n        allow = false\n```\n\n## Follow-up Questions\n\n- What are the trade-offs between OPA Gatekeeper and Kyverno for this use case?\n- How would you handle offline edge nodes with intermittent connectivity?","diagram":"flowchart TD\n  A[Start] --> B[Fetch image digest & SBOM]\n  B --> C[Verify Cosign signature with KMS key]\n  C --> D[Check SBOM against tenant policy]\n  D --> E[Revocation check]\n  E --> F[Enforce with admission controller (OPA/Kyverno)]\n  F --> G[Deploy CNF or deny with status]","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Salesforce","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T16:53:34.958Z","createdAt":"2026-01-23T16:53:34.958Z"},{"id":"q-6337","question":"Design an end-to-end provenance and runtime integrity workflow for pluggable CNF plugins deployed across multiple tenants in a federated Kubernetes cluster. Requirements: (1) sign plugin images with Cosign using a KMS-backed key and attach SPDX SBOMs, (2) publish a per-plugin trust score from a central verifier, (3) gate upgrades with ImagePolicyWebhook and Kyverno/OPA that require signature, SBOM, and fresh attestation, (4) surface tenant-scoped visibility of trust and upgrade status, (5) include minimal in-namespace manifests and commands to validate end-to-end in a test namespace before broader rollout?","answer":"Sign plugin images with Cosign using a KMS-backed key and attach SBOMs; central verifier emits a per-plugin trust score; enforce via ImagePolicyWebhook and Kyverno/OPA that upgrades require signature,","explanation":"## Why This Is Asked\nTests ability to design end-to-end CNF governance, provenance, and runtime attestation across multiple tenants. \n\n## Key Concepts\n- CNF plugin provenance across tenants\n- Centralized per-plugin trust scores\n- Policy enforcement via ImagePolicyWebhook and Kyverno/OPA\n- Runtime attestation freshness and upgrade control\n- In-namespace tests and canary rollout\n\n## Code Example\n```javascript\n// Pseudo: sign a plugin image and attach SBOM via Cosign and SBOM tool\ncosign sign --key k8s://kms/cnf-plugin-key --yes my-registry/plugin:tag\ncosign generate SBOM --format spdx > plugin.sbom.json\n```\n\n## Follow-up Questions\n- How would you handle revocation and stale trust scores?\n- How would you test across tenants with varying RBAC requirements?","diagram":"flowchart TD\n  A[Tenant CNF plugins] --> B[Sign image + SBOM]\n  B --> C[Central verifier trust score]\n  C --> D[Policy enforcement (ImagePolicyWebhook, Kyverno/OPA)]\n  D --> E[Canary test in test namespace]\n  E --> F[Rollback on failure]","difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T19:47:43.313Z","createdAt":"2026-01-23T19:47:43.313Z"},{"id":"q-6384","question":"In a two-region CNF platform on Kubernetes, design an end-to-end runtime attestation pipeline using SPIRE for CNF workloads. Requirements: (1) at startup each CNF signs an attestation payload containing image digest, SBOM URI, and a config hash; (2) attestation is verifiable by a central Attestation Service; (3) a ValidatingAdmissionWebhook blocks pods lacking a valid attestation or belonging to restricted tenants; (4) provide minimal manifests and a one-namespace test plan to validate startup attestation and admission gating before rollout?","answer":"Implement a runtime attestation pipeline using SPIRE for workload identity management. Each CNF obtains an SVID at startup, computes a configuration hash and SBOM URI, then signs an attestation payload containing the image digest, SBOM URI, and configuration hash using a KMS-managed key. The signed attestation is published to a central Attestation Service for verification. A ValidatingAdmissionWebhook enforces policy by blocking pods that lack valid attestations or belong to restricted tenants.","explanation":"## Why This Is Asked\nThis question evaluates practical expertise in runtime attestation for CNF deployments, testing understanding of identity management, cryptographic signing, verification processes, and admission control in multi-region Kubernetes environments.\n\n## Key Concepts\n- SPIRE/SVID workload identity management\n- Attestation payload composition (image digest, SBOM URI, config hash)\n- Centralized verification and key management\n- ValidatingAdmissionWebhook policy enforcement\n- Tenant isolation and minimal namespace testing\n\n## Code Example\n```yaml\n# Minimal Attestation payload (conceptual)\npayload:\n  image_digest: sha256:...\n  sbom_uri: \"sbom://...\"\n  config_hash: sha256:...\nsignature: \"...\"\n```","diagram":"flowchart TD\n  A[CNF startup] --> B[Create attestation payload]\n  B --> C[Sign with KMS]\n  C --> D[Publish to Attestation Service]\n  D --> E[Admission Webhook validates]\n  E --> F[Pod running]","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","NVIDIA","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T05:33:25.180Z","createdAt":"2026-01-23T21:45:43.408Z"},{"id":"q-6418","question":"Beginner CNF certification: In a multi-tenant Kubernetes CNF gateway platform, design a runtime drift-detection gate that ensures dynamic runtime config (env vars, flags, tuning parameters) is signed and matches a tenant baseline. Outline (1) how baseline config is signed with Cosign using a KMS-backed key and SBOM, (2) how an admission webhook and a lightweight sidecar attest drift at runtime, (3) how per-tenant drift alerts surface via ConfigMaps and a minimal test manifest to validate drift in one namespace before rollouts. What steps would you take?","answer":"Sign a tenant baseline runtime configuration (environment variables, flags, tuning parameters) with Cosign using a KMS-backed key and publish an SBOM for the CNF image. Implement an admission webhook combined with a lightweight sidecar to attest the current runtime state against the signed baseline, enabling per-tenant drift detection and enforcement.","explanation":"## Why This Is Asked\nThe question evaluates practical runtime drift protection strategies for multi-tenant CNF platforms, testing knowledge of configuration signing, admission control mechanisms, and tenant-aware observability.\n\n## Key Concepts\n- Runtime configuration drift detection\n- Signed baselines with Cosign and KMS-backed keys\n- SBOM integration for provenance tracking\n- Admission webhook enforcement vs. sidecar attestation\n- Per-tenant alerting via ConfigMaps\n\n## Code Example\n```yaml\n# Minimal baseline manifest snippet\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: tenant-a-drift-baseline\n  namespace: tenant-a\ndata:\n  runtime-config.yaml: |\n    env:\n      CNF_PORT: \"8080\"\n      LOG_LEVEL: \"info\"\n    flags:\n      \"--max-connections\": \"1000\"\n    tuning:\n      memory-limit: \"512Mi\"\n      cpu-quota: \"500m\"\n```","diagram":"flowchart TD\n  A[Baseline config signed] --> B[Admission webhook validates]\n  B --> C{Drift?}\n  C -->|No| D[Pod runs]\n  C -->|Yes| E[Block pod & alert]\n  E --> F[ConfigMap per-namespace alert]","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Cloudflare"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T05:06:20.111Z","createdAt":"2026-01-23T23:30:27.928Z"},{"id":"q-6557","question":"In a multi-tenant Kubernetes-based CNF gateway platform spanning multiple clusters, design an end-to-end disaster recovery workflow for both image provenance and runtime state. Requirements: sign CNF image updates with Cosign using a KMS-backed key and attach SBOMs; back up per-tenant CRDs/etcd to a central encrypted store; implement canary rollouts with Argo Rollouts and automatic rollback on test failure; enforce cross-tenant isolation with Kyverno; provide a minimal in-namespace validation test and one-namespace rollback test before cluster-wide rollout; include minimal config snippets and commands to test the DR flow?","answer":"Propose a DR workflow: sign CNF image upgrades with Cosign using a KMS-backed key and attach SBOMs; back up per-tenant CRDs/etcd to a central, encrypted store; roll out with canaries per tenant using ","explanation":"## Why This Is Asked\nTests practical disaster recovery planning for a CNF platform that serves multiple tenants. Candidates must show hands-on familiarity with image provenance, per-tenant runtime state backups, controlled rollouts, and tenant isolation policies.\n\n## Key Concepts\n- Image signing with Cosign using a KMS-backed key and SBOMs\n- Encrypted, per-tenant backups of CRDs/etcd\n- Canary/rollback strategies with Argo Rollouts\n- Tenant isolation via Kyverno policies and RBAC\n- Minimal in-namespace DR validation tests and rollback tests\n\n## Code Example\n```yaml\napiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: cnf-rollout\nspec:\n  replicas: 2\n  strategy:\n    canary:\n      steps:\n      - setWeight: 10\n```\n\n## Follow-up Questions\n- How would you validate DR in a single namespace before promoting cluster-wide? \n- What monitoring and alerting would you add to detect and trigger automatic rollback?","diagram":"flowchart TD\n  A[Tenant Namespace] --> B[Image Provenance Check]\n  B --> C{Canary Test Pass?}\n  C -->|Yes| D[Rollout Across Clusters]\n  C -->|No| E[Rollback/Notify]\n  D --> F[DR State Sync]\n  F --> G[Encrypted Backups]","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Meta","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T08:00:29.386Z","createdAt":"2026-01-24T08:00:29.386Z"},{"id":"q-6588","question":"Beginner CNF certification: In a multi-tenant CNF gateway platform on Kubernetes, implement a minimal end-to-end runtime policy gate using Open Policy Agent (OPA). Each tenant stores a small Rego policy in a ConfigMap that constrains which nodes and which egress CIDRs their CNFs may use. An admission webhook evaluates the policy during deployment; deployments failing policy are denied. Include a test namespace manifest to validate in isolation?","answer":"Implement an admission webhook backed by OPA. Tenants store a small Rego policy in a ConfigMap, keyed by namespace, e.g., constraints for node selectors and allowed egress CIDR. The webhook fetches po","explanation":"## Why This Is Asked\nTests practical knowledge of policy-as-code and admission control in a CNF context. It requires understanding of per-tenant isolation, Rego policy design, and webhook integration without relying on image signing.\n\n## Key Concepts\n- Kubernetes admission webhooks\n- Open Policy Agent (OPA) and Rego\n- Per-tenant policy isolation via ConfigMaps\n- Namespace-scoped testing manifests and observability\n\n## Code Example\n```rego\npackage k8s.cnf.constraints\ndefault allow = false\n\n# Example policy loaded per-namespace\nallow {\n  input.kind == \"Pod\"\n  input.metadata.namespace == z\n  z := data.{namespace}.allowedNodes\n  input.spec.nodeName == allowed_node\n  allowed_node == \"worker-1\"\n}\n```\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: tenant-a-policy\n  namespace: tenant-a\ndata:\n  policy.rego: |\n    package k8s.cnf.constraints\n    default allow = false\n    allow {\n      input.kind == \"Pod\"\n      input.metadata.namespace == \"tenant-a\"\n      input.spec.nodeName == \"worker-1\"\n    }\n```\n\n## Follow-up Questions\n- How would you test policy updates without disrupting tenants?\n- What are trade-offs of per-namespace policies versus a centralized policy store?","diagram":"flowchart TD\n  A[Tenant Policy Store] --> B[Admission Webhook]\n  B --> C[CNF Deployment]\n  C --> D[Runtime Enforcement]\n  D --> E[Policy Status]","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Meta","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T08:59:11.821Z","createdAt":"2026-01-24T08:59:11.821Z"},{"id":"q-6636","question":"Advanced CNF certification: You operate a multi-tenant CNF platform on Kubernetes at scale. Design an end-to-end license-attestation and update-workflow that guarantees every deployed CNF carries a tenant-specific license attestation, validated at admission and runtime, and upgrades are gated accordingly. The flow should (1) generate a tenant-scoped SBOM at build using a KMS-backed key, (2) sign the image with Cosign and attach the SBOM, (3) publish a per-tenant update manifest signed by the tenant referencing the SBOM and license, (4) enforce with OPA/Kyverno policies that only attested updates proceed, and (5) include a minimal in-namespace test and a rollback path to the previous image. Provide concrete steps and minimal manifests?","answer":"Implement an end-to-end license-attestation flow for multi-tenant CNFs: (1) generate a tenant-scoped SBOM at build with a KMS key, (2) sign image with Cosign and attach SBOM, (3) publish a tenant-spec","explanation":"## Why This Is Asked\nTests ability to design a scalable, tenant-aware provenance and licensing gate for CNFs, combining build-time attestation, image signing, and policy-driven deployment control.\n\n## Key Concepts\n- Tenant-scoped SBOM generation and license attestation\n- Cosign signing with SBOM binding\n- Per-tenant update manifests referencing attestation data\n- OPA/Kyverno policy gating for upgrades\n- In-namespace tests and safe rollback paths\n\n## Code Example\n```rego\npackage cnf.license\n\ndeny[msg] {\n  input.request.kind == \"Deployment\"\n  not license_attested(input)\n}\n```\n\n## Follow-up Questions\n- How would you handle tenant key rotation and attestation revocation?\n- Compare integration approaches for OPA vs Kyverno in this flow.","diagram":null,"difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T10:54:18.240Z","createdAt":"2026-01-24T10:54:18.240Z"},{"id":"q-6785","question":"CNF Platform runtime attestation: In a multi-tenant CNF gateway cluster, implement an end-to-end provenance + runtime attestation workflow that validates both image signing (Cosign + SBOM) and runtime attestations (TPM/measured boot) before scheduling pods. Add admission policy rules (Kyverno/OPA) to block un-attested workloads, provide minimal manifests and commands to verify in one namespace before rollout, and outline canary and rollback steps?","answer":"Sign CNF images with Cosign using a KMS-backed key and attach an SBOM. Add a runtime attestation manifest produced by a TPM/measured-boot process that the kubelet reports for each node, and block sche","explanation":"Why This Is Asked\nTests integration of image provenance with runtime attestation in a multi-tenant CNF environment, plus policy automation and rollback\n\n## Key Concepts\n- Image provenance (Cosign + SBOM)\n- Runtime attestation (TPM/measured boot)\n- Kubernetes admission controls (Kyverno/OPA)\n- Per-tenant isolation and testability\n- Canary rollout and rollback\n\n## Code Example\n```bash\n# Sign and attest\ncosign sign -key kms-key.pem docker.io/org/cnf:tag\ncosign attest docker.io/org/cnf:tag --attestation-file attestation.yaml\n```\n```yaml\napiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: require-cnf-provenance-runtime\nspec:\n  rules:\n  - name: attest-and-sbom-check\n    match:\n      resources:\n        kinds: [\"Deployment\"]\n    validate:\n      message: \"Containers must carry cnf.io/attested and cnf.io/sbom annotations\"\n      pattern:\n        spec:\n          template:\n            metadata:\n              annotations:\n                cnf.io/attested: \"?*\"\n                cnf.io/sbom: \"?*\"\n```\n\n## Follow-up Questions\n- How would you test attestation failure paths and rollbacks?\n- How to rotate tenant-specific attestation keys without downtime?\n","diagram":null,"difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T17:31:28.802Z","createdAt":"2026-01-24T17:31:28.802Z"},{"id":"q-6862","question":"Beginner CNF certification: In a multi-tenant CNF gateway cluster on Kubernetes, design an end-to-end runtime policy enforcement flow for CNF reconfiguration changes (e.g., routing updates) that ensures only signed policy updates from a per-tenant policy store are applied, validates with a minimal in-namespace manifest, and provides rollback if drift is detected. Include concrete steps and minimal manifests?","answer":"Design a gated runtime policy flow: 1) publish per-tenant CNF reconfig policies as signed artifacts in a KMS-backed store; 2) enforce updates with an OPA Gatekeeper rule that rejects unsigned changes;","explanation":"## Why This Is Asked\n\nThis question probes runtime policy governance for CNFs, not just image provenance. It tests knowledge of per-tenant isolation, signed policy artifacts, admission controls, and safe rollback when drift is detected. It also covers how to validate changes with minimal manifests before broader rollout.\n\n## Key Concepts\n\n- OPA Gatekeeper\n- Cosign signing\n- KMS-backed policy store\n- Drift detection and rollback\n- Minimal in-namespace manifests\n\n## Code Example\n\n```rego\npackage kubernetes.admission\n\ndeny[{\"msg\": msg}] {\n  input.request.kind.kind == \"CNFConfig\"\n  not input.policySigned\n  msg := \"CNFConfig must be signed by tenant policy\"\n}\n```\n\n## Follow-up Questions\n\n- How would you test drift detection?\n- How would you roll back unsigned or mismatched updates?","diagram":"flowchart TD\n  A[Tenant Policy Artifact] --> B[Policy Store (KMS-backed)]\n  B --> C[Admission Control (OPA Gatekeeper)]\n  C --> D[Namespace CNFConfig Manifest]\n  D --> E[Drift Detector / Rollback Mechanism]","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","MongoDB","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T20:41:22.512Z","createdAt":"2026-01-24T20:41:22.512Z"},{"id":"q-7027","question":"Beginner CNF certification: In a single-cluster, multi-tenant CNF gateway platform, design a minimal per-tenant admission policy stored in a ConfigMap that enforces: (1) CNF images must be Cosign-signed with the tenant's KMS-backed key, (2) the image SBOM must be present and include a mandatory component (for example, openssl), (3) surface a per-namespace compliance badge on successful admission. Provide concrete YAML snippets for the policy and a one-namespace test manifest to validate in isolation?","answer":"Implement a per-tenant ValidatingWebhook that reads rules from a ConfigMap in namespace cnf-policies. For each Pod, verify the container image digest is Cosign-signed with the tenant's KMS key and tha","explanation":"## Why This Is Asked\n\nTests practical knowledge of per-tenant guardrails in CNF platforms, focusing on image provenance, SBOM validation, and namespace annotations to surface compliance.\n\n## Key Concepts\n\n- Kubernetes admission webhooks and ConfigMap-driven policies\n- Cosign signatures tied to tenant keys (KMS-backed)\n- SPDX SBOM presence and component checks\n- Namespace annotations as compliance badges\n\n## Code Example\n\n```yaml\n# Policy ConfigMap (cnf-policies namespace)\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: cnf-policy\n  namespace: cnf-policies\ndata:\n  policy.json: |\n    {\n      \"tenants\": {\n        \"tenant-a\": {\n          \"requiresSignature\": true,\n          \"requiredSBOMComponent\": \"openssl\"\n        }\n      }\n    }\n```\n\n```yaml\n# Test manifest (namespace: tenant-a)\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: tenant-a-cnf\n  namespace: tenant-a\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: tenant-a-cnf\n    spec:\n      containers:\n      - name: gateway\n        image: registry.example.com/cnf/gateway:1.0.0\n        ports:\n        - containerPort: 8080\n```\n\n## Follow-up Questions\n\n- How would you handle key rotation for tenant KMS keys within this policy?\n- How would you test failure modes (signature missing, SBOM incomplete) in CI/CD before production rollout?","diagram":null,"difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Hashicorp","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T06:43:19.938Z","createdAt":"2026-01-25T06:43:19.939Z"},{"id":"q-7072","question":"Design a cross-region CNF provenance gate for a 3-region gateway fleet. Enforce: (1) Cosign-signature + SPDX SBOM on every image, (2) verification against a central, immutable provenance ledger with a freshness window (≤24h) before deployment, (3) per-tenant policy via Kyverno/OPA that requires cnf/tenant labels, and (4) a minimal one-region test manifest to validate end-to-end before rollout. How would you implement and test this?","answer":"Design a cross-region provenance gate enforcing Cosign-signed images with SBOM, verify digests against a central immutable ledger with a 24h freshness window, and apply per-tenant policy via Kyverno/O","explanation":"## Why This Is Asked\nTests cross-region provenance integration, external ledger checks, and per-tenant policy enforcement in CNF workloads, plus practical testing strategy.\n\n## Key Concepts\n- Cross-region policy distribution\n- Central provenance ledger and freshness checks\n- Tenant-scoped policies with cnf/tenant labels\n- Admission webhooks vs Kyverno/OPA\n- Testing in a single region before rollout\n\n## Code Example\n```yaml\n# Kyverno policy skeleton enforcing provenance fields\napiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: cnf-provenance-policy\nspec:\n  rules:\n  - name: enforce-cosign-sbom\n    match:\n      resources:\n        kinds: [\"Deployment\",\"StatefulSet\"]\n    validate:\n      message: \"Image must be Cosign-signed and SBOM-present\"\n      pattern:\n        spec:\n          template:\n            spec:\n              containers:\n              - image: \"*\"\n```\n\n```yaml\n# Minimal one-region test manifest\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: tenant-a\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: app\n  namespace: tenant-a\n  labels:\n    app: app\n    cnf/tenant: tenant-a\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: app\n        cnf/tenant: tenant-a\n    spec:\n      containers:\n      - name: app\n        image: registry.local/cnf/tenant-a/app:1.2.3\n```\n\n## Follow-up Questions\n- How would you scale the ledger and handle key rotation?\n- What are failure modes if the ledger is unavailable or webhook latency rises?","diagram":null,"difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T07:52:00.978Z","createdAt":"2026-01-25T07:52:00.978Z"},{"id":"q-7162","question":"In a multi-tenant CNF gateway platform on Kubernetes, design a runtime attestation flow that binds image provenance (Cosign-signed + SPDX SBOM) to a boot/launch measurement verified by an in-cluster attestor, with keys stored in an HSM-backed KMS. The policy must 1) only admit pods whose attestation matches the image, 2) evict non-compliant pods, and 3) surface per-tenant audit badges. Include concrete YAML snippets for the attestor deployment, an admission/validation rule, and a one-namespace test manifest to validate in isolation?","answer":"Use an in-cluster attestor that reads the image digest, signs a PCR-like measurement (binary+config+env) with an HSM-backed key via the cluster KMS, producing a verifiable attestation. Admission contr","explanation":"## Why This Is Asked\nTests understanding of runtime attestation and CNF-scale supply chain security.\n\n## Key Concepts\n- Image provenance + runtime attestation\n- HSM/KMS-backed keys\n- In-cluster attestor sidecar\n- Admission policy with attestation verification\n- Namespace-scoped audit artifacts\n\n## Code Example\n```javascript\n// Pseudo: attestation signing (illustrative)\nattest = signPCR(binary+config+env, keyFromHSM())\nstoreAttestation(attest, namespace)\n```\n\n## Follow-up Questions\n- How would you test attestation revocation and compromised attestors?\n- What are latency implications and how would you optimize verification at scale?","diagram":"flowchart TD\n  A[Cosign-signed image + SBOM] --> B[In-cluster attestor]\n  B --> C[Attestation token (per image digest)]\n  C --> D[Admission controller validates token]\n  D --> E{Pod admitted}\n  E --> F[Audit badge per tenant]","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Snap","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T11:40:44.980Z","createdAt":"2026-01-25T11:40:44.980Z"},{"id":"q-7182","question":"Beginner CNF certification: In a multi-tenant Kubernetes cluster, design a gate that enforces both image provenance and per-tenant runtime config provenance in a single-namespace test. Outline concrete steps, and provide minimal manifests (Cosign signing with tenant KMS, SBOM attachment, ImagePolicyWebhook rule, signed per-tenant ConfigMap, and an admission webhook) plus the exact commands to validate end-to-end in isolation?","answer":"Propose a per-tenant gate enforcing both image provenance and config provenance in a single namespace test. Steps: (1) Cosign-sign CNF image with tenant KMS key and attach SPDX SBOM; (2) enforce with ","explanation":"## Why This Is Asked\nTests ability to design a practical, end-to-end CNF provenance gate involving both container images and runtime configuration. It assesses understanding of Cosign signing, SBOM requirements, admission controls, per-tenant isolation, and minimal test manifests.\n\n## Key Concepts\n- Image provenance and SBOM validation\n- Per-tenant configuration provenance via signed ConfigMaps\n- Admission controls tying image and config hashes to signed artifacts\n- Minimal in-namespace validation workflow\n\n## Code Example\n```yaml\n# Minimal admission webhook example (pseudo)\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: tenant-a-config-signature\ndata:\n  config-hash: \"sha256-...\"\n```\n\n```javascript\n// Pseudo flow for operator wiring\n// 1) Sign image with Cosign + SBOM\n// 2) Create ImagePolicyWebhook rule\n// 3) Sign runtime config hash in ConfigMap\n// 4) Admission webhook validates both artifacts\n```\n\n## Follow-up Questions\n- How would you test rollback after a failed provenance check?\n- What are the security trade-offs of storing per-tenant KMS keys in Kubernetes secrets?","diagram":"flowchart TD\n  A[Tenant Namespace] --> B[Cosign Sign Image + SBOM]\n  B --> C[ImagePolicyWebhook]\n  C --> D[Signed Per-Tenant ConfigMap]\n  D --> E[Admission Webhook: Validate Image Digest & Config Hash]\n  E --> F[Test Manifest Deployment]\n  F --> G[Compliant Deployment vs Non-Compliant]","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T13:12:24.555Z","createdAt":"2026-01-25T13:12:24.555Z"},{"id":"q-7297","question":"CNF gateway platform on Kubernetes: design a runtime attestation workflow where each CNF pod must present a signed runtime attestation token (TPM/TEE PCR) proving baseline kernel modules and loaded features. The admission flow should verify the token against a central attestation service and enforce tenant-scoped policies (allowed capabilities). Include a one-namespace test manifest and discuss key rotation and revocation?","answer":"Use a TPM/TEE-backed attestation agent inside CNF to generate a short-lived JWT containing tenant_id, PCR hash, and kernel module fingerprint. The admission webhook validates the JWT against a central","explanation":"This question tests practical runtime attestation integration beyond image signing, including TPM/TEE-based checks, token-based admission, per-tenant policy enforcement, and robust key management with revocation. It also requires a concrete test plan for validating isolation before broader rollout.","diagram":"flowchart TD\n  A[CNF Pod Start] --> B[Attestation Agent Collects TPM PCRs]\n  B --> C[Generate JWT with tenant, PCRs, kernel hash]\n  C --> D[Attestation Service Verifies JWT]\n  D --> E[Admission Webhook Grants Pod]\n  E --> F[Pod Runs with Tenant Policy]","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T17:28:08.656Z","createdAt":"2026-01-25T17:28:08.656Z"},{"id":"q-7397","question":"Advanced CNF certification: In a multi-cloud Kubernetes CNF platform, implement a zero-downtime upgrade gate that preserves runtime integrity without rebuilding images. Provide data flow and concrete manifests for: (1) per-CNF SPIFFE identity, (2) TPM/IMA attestation to a central verifier with a trust score, (3) an OPA policy that requires attestation+SBOM delta before upgrade, (4) tenant-scoped network policy via Cilium, (5) a minimal in-namespace test plan?","answer":"Proposed zero-downtime upgrade gate architecture: (1) Each CNF maintains a unique SPIFFE identity managed by SPIRE for cryptographically-secure service identification; (2) TPM/IMA attestation continuously validates runtime integrity and publishes trust scores to a central verifier; (3) An OPA policy enforces attestation verification and SBOM delta analysis before allowing upgrades; (4) Tenant-scoped network policies via Cilium provide isolation during the upgrade process; (5) A minimal in-namespace test plan validates functionality without disrupting production workloads.","explanation":"## Why This Is Asked\nAssesses ability to design end-to-end supply chain security and runtime integrity for multi-cloud CNFs, including identity management, attestation mechanisms, policy-as-code enforcement, and network isolation during zero-downtime upgrades.\n\n## Key Concepts\n- SPIFFE/SPIRE identity management\n- TPM/IMA runtime attestation\n- SPDX SBOM delta validation\n- OPA/Kyverno policy enforcement\n- Cilium eBPF network policies\n- Canary upgrade strategies\n\n## Code Example\n```yaml\n# SPIFFE identity configuration\napiVersion: spiffe.example/v1\nkind: SPIFFEIdentity\nmetadata:\n  name: cnf-identity-01\nspec:\n  spiffeID: spiffe://cluster/ns/cnf-01\n  parentID: spiffe://cluster/ns/workload-scheduler\n  ttl: 1h\n```\n\n```yaml\n# OPA upgrade gate policy\npackage cnf.upgrade\ndefault allow = false\n\nallow {\n  input.attestation.trust_score >= 80\n  input.sbom.delta.additions == 0\n  input.network_policy.isolated == true\n}\n```\n\n## Implementation Approach\nThe solution integrates identity, attestation, and policy enforcement to ensure upgrades maintain security posture while achieving zero downtime through controlled canary deployments.","diagram":"flowchart TD\n  A[CNF] --> B[Identity Issuance SPIRE]\n  B --> C[TPM/IMA Attestation]\n  C --> D[Central Verifier]\n  D --> E[OPA Upgrade Gate]\n  E --> F[Canary Rollout]\n  F --> G[Tenant Network Policy]","difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Oracle","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T05:15:43.271Z","createdAt":"2026-01-25T21:34:02.966Z"},{"id":"q-7539","question":"Beginner CNF certification: In a multi-tenant CNF gateway cluster on Kubernetes, design a tamper-evident audit trail for per-tenant image provenance and config changes. Include (1) an append-only log sink for Cosign signatures and SBOMs, (2) an admission webhook emitting tenant-scoped events on image deploys and config updates, (3) a per-tenant verifier and read-only API, and (4) minimal manifests and verification steps to validate in one namespace before rollout. Provide concrete YAMLs and commands?","answer":"Store all provenance and config events as append-only JSONL in a tenant-scoped log store, each entry signed with the tenant key. Emit events via a small controller when image pulls or config changes o","explanation":"## Why This Is Asked\nTests ability to design an auditable, tamper-evident workflow across tenants, focusing on practical components (append-only logs, signatures, per-tenant verifiers, read-only APIs) rather than theory.\n\n## Key Concepts\n- Append-only audit logs for provenance\n- Cosign signatures and SBOMs per tenant\n- Tenant-scoped verifiers and read-only audit API\n- Admission webhook triggering on deploys/config changes\n- Minimal manifests and concrete verification steps\n\n## Code Example\n```javascript\n// Example log entry (JSONL)\n{\"tenant\":\"tenant-a\",\"event\":\"image-pull\",\"image\":\"registry.example/tenant-a/app@sha256:abcdef...\",\"sig\":\"base64sig\",\"sbomDigest\":\"sha256:1234...\",\"ts\":\"2026-01-26T12:00:00Z\"}\n```\n\n## Follow-up Questions\n- How would you test log tampering resistance and key rotation strategies?\n- How would you scale the per-tenant audit API under high churn of tenants and images?","diagram":null,"difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","DoorDash","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T07:00:54.846Z","createdAt":"2026-01-26T07:00:54.846Z"},{"id":"q-7678","question":"Design an end-to-end image provenance gate for a multi-tenant CNF gateway on Kubernetes that supports per-tenant key rotation, SBOM validation, and safe rollout. Explain rotation without downtime, re-signing/validation of images, and how to validate in a single namespace before full rollout?","answer":"Per-tenant Cosign keys rotate via Vault-backed workflow; on rotation, CI re-signs new image tags and regenerates SBOMs, updating a digest map. Enforce with ImagePolicyWebhook/OPA requiring signature, ","explanation":"## Why This Is Asked\nTests real-world operations: key rotation, SBOM integrity, policy enforcement in multi-tenant CNF gateways.\n\n## Key Concepts\n- Per-tenant key management with Cosign and KMS/Vault\n- SBOM regeneration on rotation\n- Admission control with ImagePolicyWebhook/OPA\n- Namespace-scoped validation and rollback\n\n## Code Example\n```yaml\n# Example OPA policy fragment enforcing signature and SBOM for CNF images\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: cnf-image-policy\n  namespace: default\ndata:\n  policy.rego: |\n    package cnf.image\n    default allow = false\n    allow {\n      input.request.kind == \"ImageReview\"\n      input.request.object.spec.containers[_].image\n      ...\n    }\n```\n\n## Follow-up Questions\n- How would you handle cross-tenant key revocation and audit?\n- How do you ensure SBOM provenance for multi-arch images?","diagram":"flowchart TD\n  A[Tenant CNF Namespace] --> B[CI: rotate tenant key]\n  B --> C[Re-sign + SBOM regen]\n  C --> D[Policy Enforcement]\n  D --> E[Admission/Runtime deploy]\n  E --> F[Observe & Rollback if fail]","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Netflix","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T13:06:35.324Z","createdAt":"2026-01-26T13:06:35.324Z"},{"id":"q-7783","question":"CNF certification: In a multi-cloud CNF fleet, design an upgrade validation pipeline that ensures only SBOM-compliant, attested images are deployed across clusters. Include policy artifacts (OPA/Kyverno), canary rollout plan, per-tenant upgrade windows, drift detection, and rollback steps. What concrete steps and artifacts would you implement before upgrading?","answer":"I would enforce: (a) each upgrade image is Cosign-signed and SBOM includes tenant-specified components; (b) policy as code (OPA/Kyverno) encodes per-tenant upgrade windows and allowed image digests; (","explanation":"## Why This Is Asked\nThis question probes practical upgrade governance in CNF land, not just signing. It tests policy-as-code, provenance workflows, canary strategies, and rollback safety.\n\n## Key Concepts\n- SBOM validation, Cosign attestation\n- Policy-as-code (OPA/Kyverno)\n- Canary rollouts and metrics gates\n- Drift detection and rollback strategy\n\n## Code Example\n```javascript\n// placeholder\n```\n\n## Follow-up Questions\n- How would you test policy changes safely? \n- How would you scale canary across dozens of clusters?","diagram":"flowchart TD\n  A[Upgrade Request] --> B[Policy Check]\n  B --> C{Canary Phase}\n  C -->|Yes| D[Rollout]\n  D --> E{Failure}\n  E --> F[Rollback]\n  F --> G[Notify Tenant]\n  C -->|No| H[Block Upgrade]","difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T17:44:25.513Z","createdAt":"2026-01-26T17:44:25.514Z"},{"id":"q-7865","question":"Beginner CNF certification: In a single-cluster, multi-tenant CNF gateway platform, design a runtime policy that enforces per-tenant resource quotas and egress controls for CNF pods, using Kubernetes ResourceQuota, LimitRange, and a simple admission webhook that rejects deployments that request more than tenant-specific limits. Provide minimal YAML and a test manifest to validate in one namespace before rolling out to others?","answer":"Define per-tenant quotas with a Namespace ResourceQuota and LimitRange, driven by a ConfigMap tenantPolicies mapping tenant to CPU/memory caps and egress allowances. Implement a lightweight Validating","explanation":"## Why This Is Asked\nTests ability to reason about tenancy guardrails using Kubernetes primitives and a minimal webhook, aligning with CNF gateway multi-tenant constraints.\n\n## Key Concepts\n- Kubernetes ResourceQuota\n- LimitRange\n- ValidatingWebhookConfiguration\n- Per-tenant policy mapping\n\n## Code Example\n```yaml\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: tenant-a-quota\n  namespace: tenant-a\nspec:\n  hard:\n    requests.cpu: \"4\"\n    requests.memory: 8Gi\n    limits.cpu: \"8\"\n    limits.memory: 16Gi\n```\n\n```yaml\napiVersion: v1\nkind: LimitRange\nmetadata:\n  name: tenant-a-limit\n  namespace: tenant-a\nspec:\n  limits:\n  - default:\n      cpu: \"500m\"\n      memory: 256Mi\n    defaultRequest:\n      cpu: \"250m\"\n      memory: 128Mi\n    type: Container\n```\n\n## Follow-up Questions\n- How would you test the webhook locally (dry-run) and simulate tenant policies?\n- How would you handle policy updates without disruptive rollouts across namespaces?","diagram":null,"difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Goldman Sachs","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T20:52:03.389Z","createdAt":"2026-01-26T20:52:03.389Z"},{"id":"q-7921","question":"In a multi-architecture CNF gateway platform on Kubernetes (amd64 and arm64), design a practical end-to-end image provenance flow that enforces architecture-aware signing and deployment. Include (1) per-tenant Cosign signing with a tenant-scoped KMS key and arch-specific SBOM tagging, (2) an OPA Gatekeeper rule that blocks pulls when image arch mismatches node arch, (3) a minimal one-namespace test manifest showing arm64 image on an amd64 node being rejected and vice versa?","answer":"Describe an end-to-end flow: each tenant signs images with Cosign using a tenant-scoped KMS key; attach an SPDX SBOM including architecture metadata; enforce with an OPA Gatekeeper rule that denies pods whose image architecture mismatches the node architecture; validate with namespace-scoped test deployments demonstrating cross-architecture rejection.","explanation":"## Why This Is Asked\nExplores real-world cross-architecture provenance enforcement and per-tenant key management in CNF environments.\n\n## Key Concepts\n- Architecture-aware image provenance\n- Per-tenant KMS signing keys\n- SPDX SBOM with architecture metadata\n- OPA Gatekeeper policy for imagePull enforcement\n- Namespace-scoped validation tests\n\n## Code Example\n```yaml\napiVersion: constraints.gatekeeper.sh/v1beta1\nkind: K8sArchConstraint\nspec:\n match:\n   kinds:\n   - Pod\n parameters:\n   allowedArchitectures: ['amd64', 'arm64']\n```\n\n```yaml\n# test Deployment (arm64 image on amd64 node should be rejected)\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: test-arm64-deployment\n  namespace: test-namespace\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: test-arm64\n  template:\n    metadata:\n      labels:\n        app: test-arm64\n    spec:\n      nodeSelector:\n        kubernetes.io/arch: amd64\n      containers:\n      - name: test-container\n        image: example.com/app:arm64-latest\n        imagePullPolicy: Always\n```","diagram":null,"difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T06:03:16.533Z","createdAt":"2026-01-26T22:59:03.570Z"},{"id":"q-8020","question":"Advanced CNF certification: In a multi-tenant CNF mesh on Kubernetes with autoscaling, design an end-to-end provenance flow for ephemeral pods. Each new pod must derive from a Cosign-signed image with a tenant KMS-backed key and a corresponding SBOM. Implement runtime policy (OPA/Kyverno) to reject deployments lacking provenance and surface a per-tenant badge on deployments. Provide concrete manifests and test steps in a single-namespace scenario?","answer":"I would implement: sign images with Cosign using tenant KMS, generate SBOMs via Syft, publish to Rekor, and annotate Deployments with a provenance badge. Enforce with an OPA/Kyverno policy requiring i","explanation":"## Why This Is Asked\nEvaluates end-to-end provenance for ephemeral CNF pods under autoscaling, tenant isolation, and runtime policy.\n\n## Key Concepts\n- Cosign, SBOM (SPDX/CycloneDX), Rekor\n- OPA/Kyverno, per-tenant KMS keys\n- Kubernetes HPA, ephemeral pods\n\n## Code Example\n```yaml\n# Minimal Kyverno policy enforcing provenance presence on Deployments\napiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: require-provenance\nspec:\n  validationFailureAction: enforce\n  rules:\n  - name: assert-provenance\n    match:\n      resources:\n        kinds: [\"Deployment\"]\n    validate:\n      message: \"Provenance (digest + SBOM) required\"\n      pattern:\n        metadata:\n          annotations:\n            provenance/digest: ?\n```\n\n## Follow-up Questions\n- How would you test provenance during rapid scale-out events?\n- How would you adapt the flow for edge/air-gapped deployments?","diagram":"flowchart TD\n  A[Tenant Namespace] --> B[Cosign Sign Image]\n  B --> C[Attach SBOM]\n  C --> D[Publish to Rekor]\n  D --> E[Admission Gate (OPA/Kyverno)]\n  E --> F[Ephemeral CNF Pods]","difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Salesforce","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T06:00:24.023Z","createdAt":"2026-01-27T06:00:24.023Z"},{"id":"q-8192","question":"Beginner CNF certification: In a multi-tenant CNF gateway on Kubernetes, design a minimal admission flow that enforces per-tenant image provenance and license compliance. Use a per-tenant ConfigMap whitelist of allowed licenses, require Cosign-signature with the tenant key, require SBOM presence with license field, and surface a per-namespace compliance badge on successful admission. Provide minimal manifests and a one-namespace test manifest to validate in isolation?","answer":"Explain how you would implement a per-tenant admission flow that enforces Cosign-signature with the tenant key, SBOM presence, and an allowed-license whitelist stored in a ConfigMap, with a namespace ","explanation":"## Why This Is Asked\nThis angle tests understanding of runtime policy enforcement, per-tenant configuration, and basic defense-in-depth beyond SBOM/signature, focusing on license compliance as a practical gating criterion.\n\n## Key Concepts\n- Per-tenant policy storage in ConfigMaps\n- Image provenance (Cosign) and SBOM validation\n- License whitelisting and policy evaluation\n- Admission control: Kyverno or ImagePolicyWebhook\n- Namespace badge signaling\n\n## Code Example\n```bash\n# Conceptual policy placeholder\necho policy\n```\n```bash\n# Test manifest placeholder\nkubectl apply -f test-namespace.yaml\n```\n\n## Follow-up Questions\n- Kyverno vs ImagePolicyWebhook trade-offs for this policy\n- How to test across multiple tenants and namespaces?","diagram":"flowchart TD\n  A[Admission Request] --> B[Check Cosign Signature]\n  B --> C[Validate SBOM + License]\n  C --> D[Grant or Deny]\n  D --> E[Annotate Namespace Badge]","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Instacart","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T13:41:16.970Z","createdAt":"2026-01-27T13:41:16.970Z"},{"id":"q-8226","question":"In a single-namespace CNF gateway testbed, design a GitOps-driven image provenance gate using Argo CD and OPA Gatekeeper to enforce Cosign-signed images and SBOM presence. Steps: (1) sign images with Cosign using a tenant KMS-backed key and attach SBOMs, (2) publish SBOMs to a central registry, (3) implement Gatekeeper constraints that require both, (4) ensure Argo CD halts sync on violations, (5) provide minimal manifests to bootstrap in namespace 'tenant-a' and a one-namespace test manifest—how would you implement end-to-end?","answer":"Implement this by: (1) sign CNF images with Cosign using a tenant KMS-backed key and attach SBOMs, (2) publish SBOMs to a central registry, (3) deploy OPA Gatekeeper with a ConstraintTemplate and a Co","explanation":"## Why This Is Asked\nTests a realistic, integrated workflow combining GitOps, policy enforcement, and provenance in a CNF gateway context.\n\n## Key Concepts\n- GitOps (Argo CD) integration with policy gates\n- OPA Gatekeeper ConstraintTemplate and Constraint design\n- Cosign signing with tenant KMS keys and SBOM attachment\n- SBOM publishing and registry integration\n- Namespace-scoped validation and end-to-end testing\n\n## Code Example\n```yaml\n# Gatekeeper ConstraintTemplate skeleton\napiVersion: templates.gatekeeper.sh/v1beta1\nkind: ConstraintTemplate\nmetadata:\n  name: k8simageprovenance\nspec:\n  crd:\n    spec:\n      names:\n        kind: K8SImageProvenance\n  targets:\n  - target: admission.k8s.gatekeeper.sh\n    rego: |\n      package k8simageprovenance\n      # placeholder: implement checks for image.signature and image.SBOM\n```\n\n## Follow-up Questions\n- How would you adapt this for multi-tenant with per-tenant key rotation?\n- What tests would you add to CI to prevent false positives/negatives?\n","diagram":"flowchart TD\n  A[Source Images] --> B[Cosign Sign & SBOM]\n  B --> C[SBOM Registry]\n  C --> D[Gatekeeper Constraint]\n  D --> E[Argo CD Sync Blocked/Approved]","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Coinbase","LinkedIn"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T15:51:46.980Z","createdAt":"2026-01-27T15:51:46.980Z"},{"id":"q-8327","question":"Beginner CNF certification: In a single-cluster, multi-tenant CNF gateway, implement an end-to-end gate that demands Cosign-signed images with SBOMs and enforces per-namespace provenance labels (org/team) via a ConfigMap-backed admission policy; include minimal YAML policy and a one-namespace test manifest to validate before rollout?","answer":"Implement a namespace-scoped admission gate that requires Cosign-signed images with SBOMs and validates per-namespace provenance from a ConfigMap. Provide a minimal ImagePolicyWebhook rule and tenant ","explanation":"## Why This Is Asked\nTests the ability to implement gatekeeping for image provenance at the namespace boundary, using Cosign and SBOM, with a small, config-driven policy store.\n\n## Key Concepts\n- Cosign signing and SBOM attachment\n- ImagePolicyWebhook basics\n- ConfigMap as policy store\n- Namespace provenance validation\n- Minimal test manifests\n\n## Code Example\n```javascript\n// Minimal policy snippet (conceptual)\napiVersion: imagepolicy.k8s.io/v1alpha1\nkind: ImageReview\nspec:\n  imagePattern: \"*\"\n  requiredAnnotations:\n    - cosignSignature\n    - sbomDigest\n  provenance:\n    namespaceLabel:\n      key: \"cnf-tenant/org\"\n      value: \"acme\"\n```\n\n```javascript\n// Minimal test manifest (conceptual)\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: test-gateway\n  namespace: tenant-a\nspec:\n  template:\n    spec:\n      containers:\n      - name: gateway\n        image: registry.example.com/acme/gateway:1.0.0\n```\n\n## Follow-up Questions\n- How would you test rollback when policy changes?\n- How would you observe admitted vs denied events in logs?","diagram":"flowchart TD\n  A[Cosign Sign] --> B[Attach SBOM]\n  B --> C[Namespace Provenance Check]\n  C --> D[ImagePolicyWebhook]\n  D --> E[Deploy to Namespace]","difficulty":"beginner","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","DoorDash"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T19:55:24.189Z","createdAt":"2026-01-27T19:55:24.189Z"},{"id":"q-8420","question":"CNF certification: In a multi-tenant CNF gateway platform across on-prem and public cloud, design a runtime attestation workflow that ensures a running CNF instance matches its SBOM and a known-good baseline. Describe (1) a lightweight attestation agent that collects image digest, selected PIDs/modules, and critical config, (2) how to sign and relay attestations via mTLS to a central policy service, (3) how a policy engine enforces SBOM and baseline matches, and (4) a rollback/recovery path if attestation fails. Provide minimal manifest snippets and a test plan for one tenant?","answer":"Design a runtime attestation workflow for a multi-tenant CNF gateway platform. Implement a lightweight attestation agent (Go) that collects the image digest, selected PIDs/modules, and critical configuration, signs the payload with tenant-specific keys, and transmits via mTLS to a central policy engine. The policy service validates the attestation against the registered SBOM and baseline, automatically triggering rollback if violations are detected.","explanation":"## Why This Is Asked\nThis question evaluates a candidate's ability to design comprehensive runtime security controls for cloud-native network functions, focusing on continuous compliance verification and automated remediation beyond static image signing.\n\n## Key Concepts\n- Runtime attestation and drift detection\n- SBOM-based compliance validation\n- Tenant-isolated cryptographic identity\n- Mutual TLS for secure communication\n- Policy enforcement with OPA/Kyverno\n- Automated rollback and recovery mechanisms\n\n## Code Example\n```javascript\n// AttestationPayload structure\nconst payload = {\n  imageDigest: 'sha256:abc123...',\n  tenantId: 'tenant-001',\n  timestamp: Date.now(),\n  processes: [\n    { pid: 1234, name: 'nginx', modules: ['http_ssl'] },\n    { pid: 5678, name: 'application', modules: ['crypto'] }\n  ],\n  config: {\n    '/etc/nginx/nginx.conf': 'hash:sha256:def456...',\n    '/app/config.json': 'hash:sha256:ghi789...'\n  }\n};\n```","diagram":"flowchart TD\n  A[Attest] --> B[Collect runtime state]\n  B --> C[Sign payload]\n  C --> D[Send over mTLS]\n  D --> E[Policy check]\n  E --> F{OK}\n  F --> G[Grant admission]\n  E --> H[Quarantine/Rollback]","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Plaid","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-28T05:57:47.640Z","createdAt":"2026-01-27T23:45:08.768Z"},{"id":"q-847","question":"You're deploying a CNF gateway (e.g., NGINX CNF) on a 50-node Kubernetes cluster handling streaming traffic. A node eviction hits during peak load. Outline a concrete plan to maintain streaming availability, focusing on (1) graceful drain with preStop, (2) health checks/readiness/liveness, and (3) traffic affinity and pod topology, and (4) observability and rollout strategy?","answer":"Use a Deployment of 4 replicas with PodDisruptionBudget minAvailable=3 and RollingUpdate maxUnavailable=25%. Implement a preStop hook to run nginx -s quit and wait 30s for active requests. Readiness o","explanation":"## Why This Is Asked\n\nTests practical CNF operations under eviction, not just theory.\n\n## Key Concepts\n\n- PodDisruptionBudget\n- Graceful draining\n- Readiness/Liveness probes\n- Traffic affinity\n\n## Code Example\n\n```javascript\n// Drain hook example\n```\n\n## Follow-up Questions\n\n- How would you adapt this for stateful CNFs?\n- How would you observe and rollback failed rollouts?","diagram":"flowchart TD\n  A[Node Eviction] --> B[Drain Initiated]\n  B --> C[Pod Stop/Drain]\n  C --> D[Traffic Shifts]\n  D --> E[New Pod Ready]","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Netflix","Plaid","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T13:29:51.594Z","createdAt":"2026-01-12T13:29:51.594Z"},{"id":"q-918","question":"You're rolling out a CNF-based NAT gateway across a 3-region multi-cluster Kubernetes setup. A policy change must be applied without disrupting live traffic. Outline a concrete, end-to-end rollout plan emphasizing (a) shadow canaries with traffic mirroring, (b) region-by-region rollout with per-region SLI targets, (c) policy-state reconciliation and drift detection, (d) rollback conditions and observability instrumentation?","answer":"Plan a canary rollout of CNF NAT across 3 regions. Validate in a shadow region with traffic mirroring; rollout region-by-region with explicit latency, error-rate, and drop targets; run a continuous po","explanation":"## Why This Is Asked\nTests practical rollout discipline for CNFs, multi-region consistency, and robust rollback.\n\n## Key Concepts\n- Canary rollouts in CNFs across regions\n- Policy drift detection and reconciliation\n- Observability with eBPF, traces, and metrics\n- Safe rollback criteria and traffic mirroring\n- Per-region SLI targets and controlled rollout\n\n## Code Example\n```javascript\n// Pseudocode: reconcilePolicy(desired, runtime, driftThreshold) \nasync function reconcilePolicy(desired, runtime){\n  const drift = diff(desired, runtime);\n  if(drift > driftThreshold) throw new Error('Policy drift');\n  // apply reconciliation\n}\n```\n\n## Follow-up Questions\n- How would you define drift metrics and thresholds for CNFs?\n- How would you test rollback reliability under sudden latency spikes?","diagram":"flowchart TD\n  A[Policy Change Initiated] --> B{Canary Shadow?}\n  B -- Yes --> C[Shadow Region Mirroring]\n  B -- No --> D[Region-by-Region Rollout]\n  C --> E[Monitor Shadows]\n  E --> F{Drift Detected?}\n  F -- Yes --> G[Rollback and Alert]\n  F -- No --> H[Proceed Rollout]\n  D --> H\n  H --> I[Centralize Telemetry]","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Coinbase"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T15:30:48.188Z","createdAt":"2026-01-12T15:30:48.188Z"},{"id":"q-935","question":"You manage CNF-based gateways across 4 regions. A suspected supply-chain compromise requires enforcing in-cluster image attestations before rollout without downtime. Outline an end-to-end plan to (a) sign CNF images with Cosign and SBOMs, (b) enforce signatures via ImagePolicyWebhook, (c) roll out region-by-region with traffic mirroring, (d) implement drift detection and automatic rollback on attestation failure. Include observability?","answer":"Sign CNF images with Cosign and SBOMs, publish to Rekor; enforce with ImagePolicyWebhook requiring valid signature and SBOM; perform region-by-region canaries with traffic mirroring; implement drift c","explanation":"Why This Is Asked\n\nTests ability to design secure, zero-downtime CNF rollouts with supply chain attestations.\n\nKey Concepts\n\n- Image signing (Cosign), SBOMs, Rekor\n- Kubernetes policy enforcement (ImagePolicyWebhook)\n- Canary rollout, traffic mirroring, drift detection\n- Rollback criteria and observability\n\nCode Example\n\n```javascript\n// Pseudocode: drift detection between desired and deployed SBOMs\nfunction isDrifted(deployedSBOM, desiredSBOM) {\n  return deployedSBOM.hash !== desiredSBOM.hash;\n}\n```\n\nFollow-up Questions\n\n- How would you revoke a compromised image in Rekor without blocking new deployments?\n- How do you keep SBOMs up-to-date across regions during rapid changes?","diagram":"flowchart TD\n  A[Sign Image] --> B[Publish to Rekor]\n  B --> C[ImagePolicyWebhook]\n  C --> D[Canary Rollout]\n  D --> E[Drift Check]\n  E --> F[Rollback if needed]","difficulty":"intermediate","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Tesla","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T16:25:14.304Z","createdAt":"2026-01-12T16:25:14.304Z"},{"id":"q-985","question":"Design a zero-downtime, CNF-based API gateway rollout where per-tenant routing rules update live without dropping connections. Outline end-to-end steps: (a) safe rule distribution, (b) canary-ingress slicing with weighted traffic, (c) drift detection between desired and active routes, (d) observability and rollback?","answer":"Zero-downtime CNF gateway update for per-tenant routes: use a pull-based config bus for safe rule distribution, run canary shards with weighted traffic, and progressively shift tenants. Implement drif","explanation":"## Why This Is Asked\nTests mastery of live CNF config delivery under scale, using dynamic route management, traffic shaping, and robust rollback. It probes understanding of drift detection, observability integration, and safe rollout in multi-tenant environments.\n\n## Key Concepts\n- Zero-downtime rolling updates with canary deployments\n- Dynamic configuration distribution and consistency\n- Drift detection and automated rollback with observability\n\n## Code Example\n```javascript\n// Pseudo-implementation snippet to illustrate traffic weight update\nasync function rollWithCanary(nextWeight) {\n  await distributeConfig({ tenants: 'all', weight: nextWeight });\n  await monitorErrors(60_000);\n  if (riskTooHigh()) rollback();\n}\n```\n\n## Follow-up Questions\n- How would you detect hidden slippage in latency during canary?\n- How would you handle tenants with non-uniform traffic patterns during ramp?","diagram":"flowchart TD\n  A[Config Bus] --> B[Rule Distribution]\n  B --> C[Canary Shard]\n  C --> D[Metrics/Observability]\n  B --> E[Active Routes]\n  D --> F[Rollback on Regression]","difficulty":"advanced","tags":["cnf-certification"],"channel":"cnf-certification","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Meta","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T18:31:16.146Z","createdAt":"2026-01-12T18:31:16.146Z"}],"subChannels":["general"],"companies":["Adobe","Airbnb","Amazon","Anthropic","Apple","Bloomberg","Citadel","Cloudflare","Coinbase","Databricks","Discord","DoorDash","Goldman Sachs","Google","Hashicorp","Hugging Face","IBM","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Netflix","OpenAI","Oracle","PayPal","Plaid","Robinhood","Salesforce","Scale Ai","Slack","Snap","Snowflake","Square","Stripe","Tesla","Twitter","Two Sigma","Uber","Zoom"],"stats":{"total":93,"beginner":32,"intermediate":33,"advanced":28,"newThisWeek":36}}