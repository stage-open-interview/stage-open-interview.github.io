{"questions":[{"id":"q-1073","question":"Implement transpose64(uint64_t x) by treating x as an 8x8 bit matrix in row-major order (bits 0-7 are row 0, 8-15 row 1, etc.). Return the transposed matrix (bit (r,c) moves to (c,r)). Use only bitwise ops and shifts; no loops or conditionals. Provide signature and a brief justification, plus 1-2 quick examples?","answer":"Signature: uint64_t transpose64(uint64_t x). Approach: interpret x as an 8×8 bit matrix and perform fixed, branchless stage swaps: swap 1-bit pairs with mask 0x5555555555555555; swap 2-bit pairs with ","explanation":"## Why This Is Asked\nTests mastery of non-trivial bit hacks and understanding of 8×8 transpose, a common optimization in graphics, crypto, and compression. It checks for precise, branchless manipulation and correct use of masks.\n\n## Key Concepts\n- fixed-sequence bit swaps\n- 8×8 bit matrix representation\n- mask constants, shifts, no loops\n\n## Code Example\n```cpp\nuint64_t transpose64(uint64_t x) {\n    const uint64_t m1  = 0x5555555555555555ULL;\n    x = (x & m1) << 1 | (x >> 1) & m1;\n    const uint64_t m2  = 0x3333333333333333ULL;\n    x = (x & m2) << 2 | (x >> 2) & m2;\n    const uint64_t m4  = 0x0F0F0F0F0F0F0F0FULL;\n    x = (x & m4) << 4 | (x >> 4) & m4;\n    const uint64_t m8  = 0x00FF00FF00FF00FFULL;\n    x = (x & m8) << 8 | (x >> 8) & m8;\n    const uint64_t m16 = 0x0000FFFF0000FFFFULL;\n    x = (x & m16) << 16 | (x >> 16) & m16;\n    const uint64_t m32 = 0x00000000FFFFFFFFULL;\n    x = (x & m32) << 32 | (x >> 32) & m32;\n    return x;\n}\n```\n\n## Follow-up Questions\n- How would you test this with randomized 64-bit inputs to validate correctness?\n- How would you generalize to 16×16 blocks with a 256-bit input stored in four 64-bit words?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Coinbase","Hashicorp"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T21:32:59.254Z","createdAt":"2026-01-12T21:32:59.254Z"},{"id":"q-1216","question":"Implement reverse128 for a 128-bit value stored as two 64-bit halves hi and lo. Provide a function:\n\nvoid reverse128(uint64_t hi, uint64_t lo, uint64_t *out_hi, uint64_t *out_lo);\n\nThe reversal should map bit i to bit 127 - i, using only bitwise operations and shifts (no loops or conditionals). Include a brief justification and 1-2 quick test examples?","answer":"Split into two 64-bit halves. Compute rev64 of each half with the standard mask/shifts sequence, then swap halves: out_hi = reverse64(lo); out_lo = reverse64(hi). reverse64 uses the classic parallel-b","explanation":"## Why This Is Asked\nTests ability to reason about multi-word bit manipulations and safe 64→128-bit extension without loops.\n\n## Key Concepts\n- 128-bit reversal via two 64-bit reversals and swapping halves\n- Parallel-bits reversal (mask/shifts)\n- Endianness-insensitive mapping of bit indices\n\n## Code Example\n```javascript\nfunction reverse64(x) {\n  x = (x >> 1n) & 0x5555555555555555n | (x & 0x5555555555555555n) << 1n;\n  x = (x >> 2n) & 0x3333333333333333n | (x & 0x3333333333333333n) << 2n;\n  x = (x >> 4n) & 0x0F0F0F0F0F0F0F0Fn | (x & 0x0F0F0F0F0F0F0F0Fn) << 4n;\n  x = (x >> 8n) & 0x00FF00FF00FF00FFn | (x & 0x00FF00FF00FF00FFn) << 8n;\n  x = (x >> 16n) & 0x0000FFFF0000FFFFn | (x & 0x0000FFFF0000FFFFn) << 16n;\n  x = (x >> 32n) | (x << 32n);\n  return x;\n}\nfunction reverse128(hi, lo) {\n  const revLo = reverse64(lo);\n  const revHi = reverse64(hi);\n  return { hi: revLo, lo: revHi };\n}\n```\n\n## Follow-up Questions\n- How would you adapt to streaming 128-bit values?\n- How to verify correctness with random tests?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Snowflake","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T05:27:59.598Z","createdAt":"2026-01-13T05:27:59.598Z"},{"id":"q-2040","question":"Implement countTrailingZeros64(uint64_t x) using only bitwise operations and shifts (no loops or conditionals). Return 64 if x == 0. Use a De Bruijn sequence with a 64-entry lookup table. Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"The approach isolates the least significant 1 bit using y = x & -x, then maps this value to its index via a 64-entry De Bruijn lookup table: idx = table[(y * 0x03f79d71b4cb0a89ULL) >> 58]. If x == 0, return 64. This provides a constant-time, branchless solution using only bitwise operations and shifts.","explanation":"## Why This Is Asked\n\nTests mastery of constant-time bit manipulation and branchless programming, which are critical in performance-critical code paths.\n\n## Key Concepts\n\n- Trailing zero count algorithms\n- De Bruijn sequences for bit indexing\n- Branchless bit-twiddling techniques\n\n## Code Example\n\n```javascript\n// Conceptual implementation\nfunction ctz64(x) {\n  if (x === 0) return 64;\n  const y = x & -x;\n  const idx = table[(y * 0x03f79d71b4cb0a89) >>> 58];\n  return idx;\n}\n```\n\n## Follow-up Questions\n\n- How would you extend this approach for 128-bit values?\n- What compiler optimization challenges might arise with this technique?","diagram":"flowchart TD\n  A[Input x] --> B[If x==0 return 64]\n  B --> C[Compute y = x & -x]\n  C --> D[Compute idx via (y * 0x03f79d71b4cb0a89) >> 58]\n  D --> E[Return idx]","difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Oracle","Twitter","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T06:12:33.650Z","createdAt":"2026-01-14T21:45:42.837Z"},{"id":"q-2221","question":"In a 32-bit word handling module, implement rotateRight32(uint32_t n, uint32_t k) that returns n rotated right by k positions. Use only bitwise operations and shifts; no loops or conditionals. Assume 0 <= k < 32. Provide the function signature and a brief justification, plus 1–2 quick examples?","answer":"Use a constant-time rotate: k = k % 32; return (n >> k) | (n << (32 - k)); In the edge case k=0, the function returns n. For example: rotateRight32(0x12345678, 8) => 0x78123456; rotateRight32(0x800000","explanation":"## Why This Is Asked\nTests understanding of circular shifts vs normal shifts and edge-case handling in a 32-bit width.\n\n## Key Concepts\n- Circular shifts vs arithmetic/logical shifts\n- Width-aware masking and edge-cases\n- Pure bitwise operations with no loops\n\n## Code Example\n```javascript\nstatic inline uint32_t rotateRight32(uint32_t n, uint32_t k){\n  k %= 32;\n  return (n >> k) | (n << (32 - k));\n}\n```\n\n## Follow-up Questions\n- How would you adapt this for 64-bit inputs? \n- What changes if 0 < k < 64 is required?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","MongoDB","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T07:48:13.193Z","createdAt":"2026-01-15T07:48:13.193Z"},{"id":"q-2271","question":"Given a 64-bit bitboard representing an 8x8 grid (bit 0 = A1, bit 63 = H8), implement neighborMask64(uint64_t board) that returns a mask with a 1 where a bit has any of its eight neighboring cells set in the original board. Use only bitwise operations and shifts; no loops or conditionals. Provide the function signature and a brief justification, plus 1-2 quick tests?","answer":"Signature: uint64_t neighborMask64(uint64_t board); The function returns a mask where bit i is 1 if any of i's eight neighbors are 1 in the input, using only bitwise ops and shifts; no loops. Compute ","explanation":"## Why This Is Asked\nTests bitboard reasoning, edge handling, and efficient parallelism using only bitwise ops.\n\n## Key Concepts\n- Bitboard edge wrapping and file masks\n- Parallel neighbor computation via multiple shifts\n- Safe, branch-free bitwise design\n\n## Code Example\n```c\nuint64_t neighborMask64(uint64_t board) {\n    const uint64_t notA = 0xfefefefefefefefeULL;\n    const uint64_t notH = 0x7f7f7f7f7f7f7f7fULL;\n    uint64_t east  = (board & notH) << 1;\n    uint64_t west  = (board & notA) >> 1;\n    uint64_t south = board << 8;\n    uint64_t north = board >> 8;\n    uint64_t ne = (board & notH) >> 7;\n    uint64_t nw = (board & notA) >> 9;\n    uint64_t se = (board & notH) << 9;\n    uint64_t sw = (board & notA) << 7;\n    return east | west | south | north | ne | nw | se | sw;\n}\n```\n\n## Follow-up Questions\n- How would you adapt for a 32-bit board layout?\n- How would you unit-test edge cases (corners and edges) efficiently?","diagram":"flowchart TD\n  A[Input board] --> B[Compute eight directional shifts]\n  B --> C[Mask edges with notA/notH]\n  C --> D[OR all eight results]\n  D --> E[neighborMask64 output]","difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Snap","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T09:54:06.921Z","createdAt":"2026-01-15T09:54:06.921Z"},{"id":"q-2354","question":"In bit-manipulation interviews, implement rotateRight64(uint64_t n, unsigned k) that rotates n right by k bits (0 <= k < 64). Use only bitwise operations and shifts; no loops or conditionals. Provide the function signature and a brief justification, plus 1-2 quick examples demonstrating the behavior?","answer":"Return (n >> k) | (n << ((64 - k) & 63)); with k masked by 63 to avoid undefined shifts when k=0. This performs a circular shift: bits shifted out on the right wrap to the left. Example: n=0x012345678","explanation":"## Why This Is Asked\nTests ability to implement circular shifts in constant time with safe edge-case handling.\n\n## Key Concepts\n- Circular (rotating) shifts\n- Edge-case safety using masking\n- Pure bitwise operations and shifts\n\n## Code Example\n```javascript\nuint64_t rotateRight64(uint64_t n, unsigned k){\n  k &= 63;\n  return (n >> k) | (n << ((64 - k) & 63));\n}\n```\n\n## Follow-up Questions\n- How would you implement rotateLeft64 similarly?\n- How does this handle k=0 and k=63, and why is the masking essential?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Instacart"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T14:41:33.623Z","createdAt":"2026-01-15T14:41:33.623Z"},{"id":"q-2644","question":"Given a 64-bit unsigned integer n with k set bits, implement nextHigherWithSameBitCount(n) that returns the smallest y > n with popcount(y) == k; if no such y exists, return 0. Provide a function signature and 1-2 quick examples?","answer":"Use the Snoob trick: c = n & -n; r = n + c; o = n ^ r; o = (o >> 2) / c; return r | o; If n == 0 return 0. Examples: 11 (1011) -> 13 (1101); 56 (111000) -> 67 (1000011).","explanation":"## Why This Is Asked\n\nTests mastery of a classic bit-twiddling pattern to find the next permutation of a fixed-popcount bitset in constant time, without loops or branches. It also probes edge cases like overflow and zero input.\n\n## Key Concepts\n\n- Snoob algorithm for next higher with same popcount\n- 64-bit overflow behavior and edge cases (n == 0 or max with k ones)\n- Pure bitwise/shifts approach, no loops\n\n## Code Example\n\n```c\nuint64_t nextWithSamePopcount(uint64_t n) {\n  uint64_t smallest = n & -n;\n  uint64_t ripple = n + smallest;\n  uint64_t ones = n ^ ripple;\n  return ripple | ((ones >> 2) / smallest);\n}\n```\n\n## Follow-up Questions\n\n- How would you adapt this for arbitrary word size or signed integers?\n- What are the performance implications on different architectures?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T04:26:13.968Z","createdAt":"2026-01-16T04:26:13.969Z"},{"id":"q-2665","question":"Treat n as an 8x8 bit matrix in row-major order. Implement rotate90Clockwise64(uint64_t n) that returns the matrix rotated 90 degrees clockwise, using only bitwise operations and shifts (no loops or conditionals). Provide the signature and a brief justification, plus 1-2 quick examples?","answer":"Rotate 8x8 in 64-bit by: 1) transpose the 8x8 matrix in place with a fixed, loopless sequence of bitwise swaps across 1-, 2-, and 4-bit tiles; 2) reverse the order of the 8 rows to complete a 90° cloc","explanation":"## Why This Is Asked\nEfficiently rotating small bit matrices tests mastery of bitwise-twiddling without branching. It combines transposition and row-reversal in a fixed pipeline.\n\n## Key Concepts\n- In-place 8x8 transpose via staged swaps on bit-planes.\n- Row-order reversal to achieve rotation.\n- Pure bitwise operations with fixed masks.\n\n## Code Example\n```javascript\nfunction rotate90Clockwise64(n) {\n  // implement via: t = transpose8x8(n); return reverseRows(t);\n  return rotate90Clockwise64; // placeholder\n}\n```\n\n## Follow-up Questions\n- How would you adapt for 16x16 matrices? \n- What are the constant masks used for the staged swaps?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T05:48:27.872Z","createdAt":"2026-01-16T05:48:27.872Z"},{"id":"q-2723","question":"Implement a 32-bit Morton code generator morton2D(uint16_t x, uint16_t y) that interleaves bits of x and y (x bit 0 -> code bit 0, y bit 0 -> bit 1, etc.). Use only bitwise operations and shifts (no loops). Provide the signature and a brief justification, plus 1-2 examples?","answer":"Use a bit-dilating wrapper to place x and y bits into even/odd positions, then combine. Signature: uint32_t morton2D(uint16_t x, uint16_t y); Complexity: O(1). Examples: morton2D(1,0)=1; morton2D(3,5)","explanation":"## Why This Is Asked\nTests understanding of bit-level data packing and word-level efficiency.\n\n## Key Concepts\n- Bit spreading (dilating)\n- Inline masks and shifts for 32-bit results\n- Morton codes for spatial indexing\n\n## Code Example\n```javascript\nuint32_t part1by1(uint16_t n) {\n  uint32_t x = n;\n  x &= 0x0000FFFF;\n  x = (x | (x << 8)) & 0x00FF00FF;\n  x = (x | (x << 4)) & 0x0F0F0F0F;\n  x = (x | (x << 2)) & 0x33333333;\n  x = (x | (x << 1)) & 0x55555555;\n  return x;\n}\nuint32_t morton2D(uint16_t x, uint16_t y) {\n  return (part1by1(y) << 1) | part1by1(x);\n}\n```\n\n## Follow-up Questions\n- How would you extend to 3D Morton codes (x,y,z) and 64-bit result? \n- How would you adapt for non-power-of-two bit widths or streaming data?\n","diagram":"flowchart TD\n  A[Input x,y] --> B[Spread bits of x]\n  A --> C[Spread bits of y]\n  B --> D[Shift left by 1]\n  D --> E[OR with spread x]\n  C --> E","difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","IBM"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T09:36:50.388Z","createdAt":"2026-01-16T09:36:50.389Z"},{"id":"q-3186","question":"Implement a 32-bit header packer. Write a function packHeader(uint8_t version, uint8_t flags, uint16_t length) that places version in bits 31-28, flags in bits 27-20, and length in bits 19-0. Use only bitwise operations and shifts, no loops or conditionals. Provide the signature and a brief justification, plus 1-2 quick examples?","answer":"header = ((version & 0x0F) << 28) | ((flags & 0xFF) << 20) | (length & 0xFFFFF); This masks each field to its width and packs them into a 32-bit word. Examples: packHeader(0xA,0x5A,0xFFFFF) -> 0xA5AFF","explanation":"## Why This Is Asked\n\nTests the ability to pack multiple fields into a single word, a common task in serialization and network protocols. It emphasizes precise bit-width handling and avoiding branches.\n\n## Key Concepts\n\n- Bitwise masking\n- Bit shifts\n- Field packing into a 32-bit word\n\n## Code Example\n\n```javascript\nfunction packHeader(version, flags, length) {\n  return ((version & 0x0F) << 28) | ((flags & 0xFF) << 20) | (length & 0xFFFFF);\n}\n```\n\n## Follow-up Questions\n\n- How would you extract version, flags, and length from the header?\n- How would you validate inputs to prevent overflow or sign issues in languages with signed integers?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Instacart"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T05:45:01.004Z","createdAt":"2026-01-17T05:45:01.004Z"},{"id":"q-3354","question":"In a 64-bit word, four 16-bit channels are packed as R (bits 0-15), G (16-31), B (32-47), A (48-63). Implement a function swapR_B(uint64_t v) that returns a new 64-bit value with R and B swapped using only bitwise operations and shifts (no loops/conditionals). Provide the signature and a brief justification, plus 1-2 quick examples?","answer":"Signature: uint64_t swapR_B(uint64_t v); Approach: isolate channels with masks, then rearrange: r = v & 0x000000000000FFFF; g = v & 0x00000000FFFF0000; b = v & 0x0000FFFF00000000; a = v & 0xFFFF000000","explanation":"## Why This Is Asked\nTests ability to reason about 64-bit field layouts and perform cross-field moves without branches, a common pattern in graphics and encoding pipelines.\n\n## Key Concepts\n- Bit masking for 16-bit lanes\n- Cross-lane permutation with shifts\n- No loops/branches; constant-time operations\n\n## Code Example\n```c\nuint64_t swapR_B(uint64_t v) {\n  uint64_t r = v & 0x000000000000FFFFULL;\n  uint64_t g = v & 0x00000000FFFF0000ULL;\n  uint64_t b = v & 0x0000FFFF00000000ULL;\n  uint64_t a = v & 0xFFFF000000000000ULL;\n  return (r << 32) | g | (b >> 32) | a;\n}\n```\n\n## Follow-up Questions\n- How would you extend to swap G and A as well? \n- Analyze performance implications on 64-bit architectures with compiler optimizations.","diagram":"flowchart TD\n  Start[Start] --> MaskR[Mask R]\n  MaskR --> MoveR[Move R to B pos]\n  MoveR --> MaskB[Mask B]\n  MaskB --> MoveB[Move B to R pos]\n  MoveB --> Combine[Combine parts]\n  Combine --> End[End: swapped value]","difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","NVIDIA","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T13:11:34.538Z","createdAt":"2026-01-17T13:11:34.538Z"},{"id":"q-3372","question":"Implement nextGen64(uint64_t board) that applies one Life tick on an 8x8 toroidal grid. Bit i maps to cell (row=i/8, col=i%8) in row-major order. Return the next board as uint64_t. Use only bitwise operations and shifts; no loops or conditionals?","answer":"Strategy: generate eight neighbor boards with toroidal wrap (N,S,E,W,NE,NW,SE,SW); accumulate counts per cell using carry-save style addition across 64-bit lanes; then apply Life rules in parallel: ne","explanation":"## Why This Is Asked\n\nTests advanced bitboard manipulation with wrap-around. It probes staying within a single integer lane and performing per-cell logic without branching.\n\n## Key Concepts\n\n- Bitboard neighbor computation\n- Toroidal wrapping masks\n- Parallel counting of 1s\n- Bitwise rule application\n\n## Code Example\n\n```javascript\n// skeleton: compute N,S,E,W,NE,NW,SE,SW; accumulate in 3-bit per-cell counters; derive next\n```\n\n## Follow-up Questions\n\n- How would you scale to a 16x16 board while maintaining performance?\n- What micro-optimizations would you apply to reduce instruction count on 64-bit CPUs?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Hugging Face","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T13:46:13.692Z","createdAt":"2026-01-17T13:46:13.693Z"},{"id":"q-3507","question":"Implement a function isPowerOfTwo128(uint64_t hi, uint64_t lo) that returns 1 if the 128-bit value formed by hi:lo has exactly one bit set (is a power of two), else 0. Use only bitwise operations and shifts (no loops or conditionals). Provide the signature and a brief justification, plus 1–2 quick test examples?","answer":"Proposed solution: treat 128-bit value as hi:lo. It is a power of two iff exactly one half is nonzero and that half has a single 1 bit. Compute: return (hi==0) ^ (lo==0) && ((hi==0) ? ((lo & (lo-1))==","explanation":"Why This Is Asked\\n\\nAssesses ability to reason about 128-bit values and apply bit-twiddling without branching. This requires cross-half logic and edge-case handling.\\n\\nKey Concepts\\n- 128-bit decomposition into hi and lo\\n- a 64-bit value is a power of two if v & (v-1) == 0 and v != 0\\n- exactly one half nonzero implies overall power-of-two only if that half is itself a power of two\\n\\nCode Example\\n\\n```c\\nuint8_t isPowerOfTwo128(uint64_t hi, uint64_t lo) {\\n  // Exactly one half must be nonzero and that half must be a power of two\\n  int hiPow = (hi & (hi - 1)) == 0 && hi != 0;\\n  int loPow = (lo & (lo - 1)) == 0 && lo != 0;\\n  return ((hi == 0) ^ (lo == 0)) ? (hi ? hiPow : loPow) : 0;\\n}\\n```\\n\\nFollow-up Questions\\n- How would you optimize for a specific CPU architecture (e.g., using intrinsics)?\\n- How would you extend this to 256-bit values?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Apple","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T19:25:52.784Z","createdAt":"2026-01-17T19:25:52.784Z"},{"id":"q-3562","question":"Given a 128-bit value split into hi and lo, implement a rotate-left by k bits (0 <= k < 128) that returns new hi/lo using only bitwise operations and shifts, with no loops or conditionals. Provide the function signature and a brief justification, and include 1-2 quick edge-case examples?","answer":"The optimal solution uses a 128-bit intermediate value. First combine the hi and lo parts: `v = ((__uint128_t)hi << 64) | lo;`. Then mask the rotation count: `k &= 127;`. Finally perform the rotation: `r = (v << k) | (v >> (128 - k));`. Extract the results: `out_hi = (uint64_t)(r >> 64); out_lo = (uint64_t)r;`. This approach uses only bitwise operations and shifts with no loops or conditionals.","explanation":"## Why This Is Asked\n\nThis question tests cross-boundary bit manipulation and 128-bit arithmetic, which are fundamental skills in cryptography and high-performance kernel development. It also evaluates the ability to implement rotation operations without branching logic.\n\n## Key Concepts\n\n- 128-bit rotation across two 64-bit limbs\n- Using a single 128-bit intermediate simplifies boundary handling\n- Edge-case handling via rotation count masking (eliminates branches)\n\n## Code Example\n\n```cpp\nvoid rotl128(uint64_t hi, uint64_t lo, unsigned int k, uint64_t *out_hi, uint64_t *out_lo) {\n  __uint128_t v = ((__uint128_t)hi << 64) | lo;\n  k &= 127;\n  __uint128_t r = (v << k) | (v >> (128 - k));\n  *out_hi = (uint64_t)(r >> 64);\n  *out_lo = (uint64_t)r;\n}\n```\n\n## Edge Cases\n\n- `k = 0`: Returns original value unchanged\n- `k = 64`: Swaps hi and lo parts completely","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","OpenAI","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T05:45:19.754Z","createdAt":"2026-01-17T21:31:52.928Z"},{"id":"q-3602","question":"Implement parity128 for a 128-bit value stored as hi and lo: the function returns 1 if the total number of set bits across hi and lo is odd, otherwise 0. Use only bitwise operations and shifts; no loops or conditionals. Provide the function signature and a brief justification. Include 1–2 quick sanity checks (e.g., 0x0/0x0 -> 0; 0x1/0x0 -> 1)?","answer":"uint8_t parity128(uint64_t hi, uint64_t lo) { uint64_t p = hi ^ lo; p ^= p >> 32; p ^= p >> 16; p ^= p >> 8; p ^= p >> 4; p ^= p >> 2; p ^= p >> 1; return (uint8_t)(p & 1); } Branchless, O(1); works for any 128-bit input","explanation":"## Why This Is Asked\nTests ability to reduce a 128-bit input to a single bit using only shifts and XORs, a common low-level optimization pattern. It emphasizes branchless, predictable timing.\n\n## Key Concepts\n- XOR folding to accumulate parity across halves\n- Branchless, constant-time bitwise manipulation\n- Handling 128-bit input via hi/lo halves without loops\n\n## Code Example\n```javascript\nfunction parity128(hi, lo) {\n  let p = hi ^ lo;\n  p = p ^ (p >>> 32);\n  p = p ^ (p >>> 16);\n  p = p ^ (p >>> 8);\n  p = p ^ (p >>> 4);\n  p = p ^ (p >>> 2);\n  p = p ^ (p >>> 1);\n  return p & 1;\n}\n```\n\n## Follow-up Questions\n- How would you adapt this for 256-bit values?\n- What's the performance impact of using XOR vs. addition for parity?\n- Can you implement this using only addition and subtraction?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T05:29:48.928Z","createdAt":"2026-01-17T23:28:05.127Z"},{"id":"q-3864","question":"Given a 64-bit unsigned integer n, implement swapAdjacent64 that returns a value with each bit pair swapped (bit 0 <-> bit 1, bit 2 <-> bit 3, ..., bit 62 <-> bit 63) using only bitwise operations and shifts, no loops or conditionals. Provide the function signature, a short justification, and 1-2 quick examples?","answer":"uint64_t swapAdjacent64(uint64_t n) { const uint64_t E = 0x5555555555555555ULL; const uint64_t O = 0xAAAAAAAAAAAAAAAAULL; return ((n & E) << 1) | ((n & O) >> 1); } Handling all 64 bits by two masks an","explanation":"## Why This Is Asked\n\nThis tests precise bit-twiddling with non-trivial masks and no loops, a common optimization pattern.\n\n## Key Concepts\n\n- Mask construction for adjacent-bit swaps\n- Two-shift strategy and one return\n- Edge cases: 64-bit boundaries, unsigned masking\n\n## Code Example\n\n```c\nuint64_t swapAdjacent64(uint64_t n) {\n  const uint64_t E = 0x5555555555555555ULL;\n  const uint64_t O = 0xAAAAAAAAAAAAAAAAULL;\n  return ((n & E) << 1) | ((n & O) >> 1);\n}\n```\n\n## Follow-up Questions\n\n- How would you generalize to swap every 3-bit group? \n- What are the performance implications on modern CPUs?","diagram":"flowchart TD\n  A[Input: n] --> B[Mask even bits: 0x5555555555555555]\n  B --> C[Mask odd bits: 0xAAAAAAAAAAAAAAAA]\n  C --> D[Compute swapped: ((n & 0x5555555555555555) << 1) | ((n & 0xAAAAAAAAAAAAAAAA) >> 1)]\n  D --> E[Return]","difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","IBM","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T13:06:03.462Z","createdAt":"2026-01-18T13:06:03.462Z"},{"id":"q-3966","question":"Implement rotate-left by k bits for a 32-bit unsigned integer using only bitwise operations and shifts. Provide the function signature and a branch-free solution that handles k in 0..31. Explain why it works and show 1-2 quick examples?","answer":"uint32_t rotl32(uint32_t n, unsigned int k) { k &= 31u; return (n << k) | (n >> ((32u - k) & 31u)); } This wraps around cleanly even for k=0. Example: rotl32(0x80000001,1) -> 0x00000003; rotl32(0x1234","explanation":"## Why This Is Asked\nThis question tests bitwise rotation understanding and safe shift-wrapping without branches. It ensures candidates reason about edge cases and mask arithmetic to keep shifts within range.\n\n## Key Concepts\n- Bitwise rotation\n- Shift masking to avoid UB\n- Edge-case handling for k=0\n\n## Code Example\n```javascript\nfunction rotl32(n, k) {\n  k = k & 31;\n  return (n << k) | (n >>> ((32 - k) & 31));\n}\n```\n\n## Follow-up Questions\n- How would you generalize to 64-bit?\n- Why is masking with 31 important for correctness and portability?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Goldman Sachs"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T17:36:10.679Z","createdAt":"2026-01-18T17:36:10.679Z"},{"id":"q-3983","question":"Implement a 3D Morton code function morton3D(uint32_t x, uint32_t y, uint32_t z) -> uint64_t that interleaves the bits of x,y,z so that bit i of x goes to bit 3i, bit i of y to 3i+1, and bit i of z to 3i+2 for i=0..20. Use only bitwise operations and shifts (no loops or conditionals). Assume each input uses only the lower 21 bits. Context: spatial indexing for voxel data in a 3D engine?","answer":"Use a 3D bit spreader: split each input into bits spaced by two zeros, then OR with shifted versions. code: sx = part1by2(x); sy = part1by2(y); sz = part1by2(z); return sx | (sy<<1) | (sz<<2). Example","explanation":"## Why This Is Asked\nTests knowledge of deeper bit-manipulation: 3D Morton ordering for spatial indexing, with no loops and tight constants.\n\n## Key Concepts\n- Morton (z-order) encoding across 3 dimensions\n- bit spreading (part1by2) with masks/shifts\n- avoiding branches for tight hot-paths\n\n## Code Example\n```javascript\nfunction part1by2(n){\n  let x = BigInt(n) & 0x1fffffn;\n  x = (x | (x << 32n)) & 0x1f00000000ffffn;\n  x = (x | (x << 16n)) & 0x1f0000ff0000ffn;\n  x = (x | (x << 8n))  & 0x100f00f00f00f00fn;\n  x = (x | (x << 4n))  & 0x10c30c30c30c30c3n;\n  x = (x | (x << 2n))  & 0x1249249249249249n;\n  return x;\n}\nfunction morton3D(x,y,z){\n  return part1by2(x) | (part1by2(y) << 1n) | (part1by2(z) << 2n);\n}\n```\n\n## Follow-up Questions\n- How would you adapt to 32-bit inputs? Trade-offs?\n- Could you implement a inverse decode that recovers x,y,z from the code?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","MongoDB","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T18:43:50.237Z","createdAt":"2026-01-18T18:43:50.238Z"},{"id":"q-4116","question":"Implement a 32-bit rotate-left function rotl32(uint32_t n, unsigned int k) that rotates n left by k bits (i.e., bits shifted out on the left wrap around to the right). Use only bitwise operations and shifts, no loops or conditionals. Provide the function signature, a short justification, and 1-2 quick examples?","answer":"One correct approach: normalize k to 0..31 with k &= 31; then rotate left as (n << k) | (n >>> (32 - k)); cast to 32-bit unsigned. This uses only shifts and OR, handles k=0 (no change) and k=32 (wraps to original value).","explanation":"## Why This Is Asked\nTests knowledge of bit tricks and boundary handling for 32-bit values. Rotations require combining shifted parts without branching.\n\n## Key Concepts\n- Bitwise rotation using shifts\n- Modulo behavior for bit widths\n- Signed vs unsigned handling in C/JS contexts\n\n## Code Example\n```javascript\nfunction rotl32(n, k) {\n  k = k & 31; // 0..31\n  return ((n << k) | (n >>> (32 - k))) >>> 0;\n}\n```\n\n## Follow-up Questions\n- How would you implement rotl64 in C for uint64_t, ensuring performance on common compilers?\n- Could you map this to intrinsic functions (e.g., __builtin_rotate) on supported platforms?","diagram":"flowchart TD\n  Start[Input: n, k]\n  Clamp[Clamp k to 0..31]\n  Compute[Compute (n << k) | (n >>> (32 - k))]\n  Return[Return result]\n  Start --> Clamp --> Compute --> Return","difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Instacart","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T05:09:41.609Z","createdAt":"2026-01-19T02:49:43.091Z"},{"id":"q-4136","question":"Implement rotateLeft32(n, k) that rotates a 32-bit value n left by k positions using only bitwise operations and shifts (no loops or conditionals). Use a 32-bit unsigned interpretation and ensure k is treated modulo 32. Provide the function signature, a brief justification, and 1-2 quick examples?","answer":"Use k = k & 31; return ((n << k) | (n >>> ((-k) & 31))) >>> 0; This rotates within 32 bits and handles k=0 without undefined shifts. Example: rotateLeft32(0x12345678, 4) -> 0x23456781; rotateLeft32(0x","explanation":"## Why This Is Asked\nTests knowledge of bitwise rotations, a common low-level operation, and handling edge cases when k wraps around 32 without using branches. It also demonstrates how to make shifts robust against k=0 or k=31.\n\n## Key Concepts\n- Bitwise rotation using shifts and OR\n- Modulo wrapping using masking and two's complement tricks\n- Avoiding undefined shifts for k=0\n\n## Code Example\n```javascript\nfunction rotateLeft32(n, k) {\n  k = k & 31;\n  return ((n << k) | (n >>> ((-k) & 31))) >>> 0;\n}\n```\n\n## Follow-up Questions\n- How would you adapt for rotateRight32?\n- How would you test boundary cases with k=0 and k=31?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T04:39:48.146Z","createdAt":"2026-01-19T04:39:48.146Z"},{"id":"q-4148","question":"Context: In a high-performance network filter, a 64-bit mask denotes enabled features. Implement lsbIndex64(uint64_t n) that returns the index (0-63) of the least significant set bit in n, assuming n != 0. Use only bitwise operations and shifts; no loops or conditional branches. Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"Use a De Bruijn sequence: isolate LSB with v & -v, multiply by 0x03f79d71b4cb0a01, then take the top 6 bits as an index into a 64-entry table. This yields a branchless, O(1) solution for 64-bit inputs","explanation":"## Why This Is Asked\nThis evaluates mastery of branchless bit tricks and fast bit-scanning techniques essential in performance-critical code like network filtering.\n\n## Key Concepts\n- Branchless bit manipulation\n- De Bruijn sequences for bit scanning\n- Bit isolation via v & -v\n- Lookup tables for constant-time indexing\n\n## Code Example\n```javascript\nuint64_t lsbIndex64(uint64_t v) {\n  static const uint64_t debruijn = 0x03f79d71b4cb0a01ULL;\n  static const int index64[64] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n  return index64[(v & -v) * debruijn >> 58];\n}\n```\n\n## Follow-up Questions\n- How would you extend this to 128-bit values?\n- How would you handle the 0 input safely in a constant-time manner?\n","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Coinbase"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T05:39:38.404Z","createdAt":"2026-01-19T05:39:38.404Z"},{"id":"q-4193","question":"Implement rotateLeft32(uint32_t n, uint32_t k) that rotates n left by k positions. Use only bitwise operations and shifts, no loops or conditionals. Normalize k to 0..31 and return (n << kk) | (n >> ((32 - kk) & 31)). Provide the function signature and brief justification, plus 1-2 quick examples?","answer":"rotl32(uint32_t n, uint32_t k) { uint32_t kk = k & 31; return (n << kk) | (n >> ((32 - kk) & 31)); } This uses only bitwise ops, handles k=0 safely, and avoids undefined shifts. Examples: rotl32(0x800","explanation":"## Why This Is Asked\nTests understanding of bitwise rotation, a common low-level primitive in systems and cryptography. \n\n## Key Concepts\n- Bitwise rotation vs shift\n- Normalizing k with k & 31\n- Safe shifts using (32 - kk) & 31 to avoid 32-bit shifts\n\n## Code Example\n\n```c\nuint32_t rotl32(uint32_t n, uint32_t k) {\n  uint32_t kk = k & 31;\n  return (n << kk) | (n >> ((32 - kk) & 31));\n}\n```\n\n## Follow-up Questions\n- How would you adapt for 64-bit inputs?\n- What are potential compiler/target differences in shifts?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T07:07:21.491Z","createdAt":"2026-01-19T07:07:21.491Z"},{"id":"q-4436","question":"Write a 64-bit function nextBitPermutation64(uint64_t x) that returns the next higher number with the same popcount as x, or 0 if none; implement using only bitwise operations and shifts, with no loops or conditionals. Provide the signature and a brief rationale, plus 1-2 quick examples?","answer":"Approach uses the snoob trick: smallest = x & -x; ripple = x + smallest; ones = x ^ ripple; ones = (ones >> 2) / smallest; next = ripple | ones. This yields the next higher value with the same popcoun","explanation":"## Why This Is Asked\nDemonstrates mastery of fixed-popcount permutations. Tests carry propagation and ability to explain a one-shot solution without loops.\n\n## Key Concepts\n- Snoob algorithm for next with same popcount\n- Carry ripple and bitwise masks\n- Edge-case handling for zero or maximal permutations\n\n## Code Example\n```c\nstatic inline uint64_t nextBitPermutation64(uint64_t x) {\n    // Assumes x != 0 and not the maximal permutation for its popcount\n    uint64_t smallest = x & -x;\n    uint64_t ripple = x + smallest;\n    uint64_t ones = x ^ ripple;\n    ones = (ones >> 2) / smallest;\n    return ripple | ones;\n}\n```\n\n## Follow-up Questions\n- How would you adapt to arbitrary bit-widths?\n- Compare this approach to a loop-based generator in terms of performance and readability.","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T18:57:34.444Z","createdAt":"2026-01-19T18:57:34.444Z"},{"id":"q-4455","question":"In a 32-bit bitmap of flags, implement a function uint32_t popcount32(uint32_t n) that returns the number of 1-bits using only bitwise operations and shifts, with no loops or conditionals. Provide the function signature, a brief justification, and 1-2 quick examples?","answer":"Use the classic parallel bit-counting method: n = n - ((n>>1) & 0x55555555); n = (n & 0x33333333) + ((n>>2) & 0x33333333); n = (n + (n>>4)) & 0x0F0F0F0F; return (n * 0x01010101) >> 24; Example: popcou","explanation":"## Why This Is Asked\n\nTests understanding of compact bit-twiddling techniques to count bits without loops, a common interview staple for performance-critical code.\n\n## Key Concepts\n\n- Parallel bit counting (SIMD-style within a register)\n- Bit masks and shifts for aggregation\n- Portability across unsigned integers and compilers\n\n## Code Example\n\n```c\nuint32_t popcount32(uint32_t n) {\n  n = n - ((n >> 1) & 0x55555555);\n  n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n  n = (n + (n >> 4)) & 0x0F0F0F0F;\n  return (n * 0x01010101) >> 24;\n}\n```\n\n## Follow-up Questions\n\n- How would you extend to 64-bit?  \n- What tests would you add to verify edge cases (all zeros, all ones, random patterns)?","diagram":"flowchart TD\n  A[Start] --> B[Apply n - ((n>>1)&mask57)]\n  B --> C[Apply pairs mask]\n  C --> D[Apply n + (n>>4) and mask]\n  D --> E[Multiply and shift to get count]\n  E --> F[Return count]","difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Goldman Sachs","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T19:41:03.169Z","createdAt":"2026-01-19T19:41:03.170Z"},{"id":"q-4575","question":"In a 32-bit unsigned integer context, implement a rotate-left function rotl32(n, k) that shifts n left by k bits and wraps the high bits around to the low end. Do not use loops or conditionals. Provide the signature, a brief justification, and 1-2 concrete examples?","answer":"uint32_t rotl32(uint32_t n, unsigned int k) { return (n << k) | (n >> ((32 - k) & 31)); } Rationale: Pure bitwise operations with a masked right shift ensure no undefined shifts when k=0. Examples: rotl32(0x12345678, 4) = 0x23456781, rotl32(0x80000000, 1) = 0x00000001","explanation":"## Why This Is Asked\nTests understanding of bitwise rotation, edge-case safety, and avoiding branches.\n\n## Key Concepts\n- Bitwise shifts and OR to wrap bits\n- Masking to avoid undefined behavior with 0\n- Avoiding loops/conditionals in low-level operations\n\n## Code Example\n```c\nuint32_t rotl32(uint32_t n, unsigned int k) {\n  return (n << k) | (n >> ((32 - k) & 31));\n}\n```\n\n## Follow-up Questions\n- How would you generalize to 64-bit width?\n- How would you test boundary cases k=0 and k=31?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Discord","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T05:57:44.867Z","createdAt":"2026-01-20T02:26:53.749Z"},{"id":"q-4829","question":"Implement bitpack64(uint64_t v, uint64_t mask) that compresses bits from v selected by mask into the least-significant bits, preserving the relative order of those bits (i.e., the i-th set bit in mask maps to bit i in the result). Use only bitwise operations and shifts; no loops or conditionals. Provide the signature and a brief justification, plus 1-2 examples?","answer":"Use the fixed cascade compression (PDEP/compact) sequence: x = v & mask; x = (x ^ (x >> 1)) & 0x5555555555555555; x = (x ^ (x >> 2)) & 0x3333333333333333; x = (x ^ (x >> 4)) & 0x0F0F0F0F0F0F0F0F; x = ","explanation":"## Why This Is Asked\nTests non-branching bit-twiddling and packing/unpacking across a mask, a common performance pattern in high-throughput code.\n\n## Key Concepts\n- Bit masks and order-preserving packing\n- Non-branching compression via cascade masks\n- Fixed-sequence bit-manipulation tricks\n\n## Code Example\n```javascript\nfunction bitpack64(v, mask){\n  let x = v & mask;\n  x = (x ^ (x >> 1n)) & 0x5555555555555555n;\n  x = (x ^ (x >> 2n)) & 0x3333333333333333n;\n  x = (x ^ (x >> 4n)) & 0x0F0F0F0F0F0F0F0Fn;\n  x = (x ^ (x >> 8n)) & 0x00FF00FF00FF00FFn;\n  x = (x ^ (x >> 16n)) & 0x0000FFFF0000FFFFn;\n  x = (x ^ (x >> 32n)) & 0x00000000FFFFFFFFn;\n  return x;\n}\n```\n\n## Follow-up Questions\n- How would you extend to support dynamic masks without recompilation?\n- Compare performance with a loop-based approach on large data sets.","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Discord","Hugging Face"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T15:10:48.399Z","createdAt":"2026-01-20T15:10:48.399Z"},{"id":"q-4883","question":"Implement a 3D Morton code generator morton3D(uint32_t x, uint32_t y, uint32_t z) that interleaves the lower 21 bits of x, y, and z into a 63-bit code: bit i of x becomes bit 3i, bit i of y becomes bit 3i+1, bit i of z becomes bit 3i+2. Use only bitwise operations and shifts; no loops or conditionals. Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"3D Morton code: interleave the lower 21 bits of x, y, z into a 63-bit value. Use a branchless dilate-by-2 technique (part1by2) to spread bits, then code = part1by2(x) | (part1by2(y) << 1) | (part1by2(","explanation":"## Why This Is Asked\n3D Morton codes enable fast spatial indexing in grid-like domains; a branchless, fixed-bit spreading approach scales predictably. \n\n## Key Concepts\n- Morton codes for 3D require interleaving bits from three coordinates.\n- Bit spreading (dilating) inserts two zero bits between each original bit; a fixed sequence of masks/shifts yields a branchless implementation.\n- BigInt vs. Number in JavaScript: use BigInt for 64-bit results if implementing in JS; otherwise 64-bit types in C/C++ handle it natively.\n\n## Code Example\n```javascript\nfunction part1by2(n) {\n  let x = BigInt(n) & 0x1fffffn; // 21 bits\n  x = (x | (x << 32n)) & 0x1f00000000ffffn;\n  x = (x | (x << 16n)) & 0x1f0000ff0000ffn;\n  x = (x | (x << 8n)) & 0x100f00f00f00f00fn;\n  x = (x | (x << 4n)) & 0x10c30c30c30c30c3n;\n  x = (x | (x << 2n)) & 0x1249249249249249n;\n  return x;\n}\nfunction morton3D(x, y, z) {\n  return part1by2(x) | (part1by2(y) << 1n) | (part1by2(z) << 2n);\n}\n```\n\n## Follow-up Questions\n- How would you verify correctness for random inputs? \n- How to adapt to larger coordinates or alternative word sizes?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Salesforce","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T17:40:26.518Z","createdAt":"2026-01-20T17:40:26.518Z"},{"id":"q-5004","question":"Implement rotate-left for 32-bit unsigned integers: rotl32(uint32_t n, unsigned k) returns n rotated left by k bits in a 32-bit space, using only bitwise operations and shifts. Assume 0 <= k < 32. Provide the signature, a brief justification, and 1-2 quick examples?","answer":"rotl32(n,k) = (n << k) | (n >> (32 - k)); This is valid for 0 <= k < 32; uses two shifts and an OR, wrapping around high bits. Examples: rotl32(0x80000001, 1) = 0x00000003; rotl32(0x12345678, 4) = 0x23456781","explanation":"## Why This Is Asked\nTests ability to compose shifts and OR to implement rotate without loops or conditionals, a common low-level operation.\n\n## Key Concepts\n- Bitwise shifts and wrap-around semantics\n- 32-bit boundary, undefined behavior avoidance\n- Performance and portability considerations\n\n## Code Example\n\n```javascript\nfunction rotl32(n, k) {\n  return ((n << k) | (n >>> (32 - k))) >>> 0;\n}\n```\n\n## Follow-up Questions\n- What happens if k === 0? How does the expression evaluate?\n- How would you implement rotate-right similarly?\n- How would you adapt for 64-bit values in a language without native unsigned support?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Oracle","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T05:43:02.465Z","createdAt":"2026-01-20T23:34:11.401Z"},{"id":"q-5099","question":"Given a 128-bit value represented as two 64-bit halves hi and lo, implement parity128 that returns 1 if the total number of 1 bits across both halves is odd, or 0 otherwise. Use only bitwise operations and shifts, with no loops or conditionals. Provide the function signature: int parity128(uint64_t hi, uint64_t lo);?","answer":"Compute parity128 by folding across both halves: x = hi ^ lo; then reduce x with x ^= x >> 32; x ^= x >> 16; x ^= x >> 8; x ^= x >> 4; return x & 1;. This is branchless and uses parity properties: par","explanation":"## Why This Is Asked\n\nTests cross-word bit ops and branchless parity reduction. It exercises combining two 64-bit halves and a compact reduction, scalable to wider architectures.\n\n## Key Concepts\n\n- Parity via XOR folding\n- 128-bit composition hi^lo\n- Branchless reductions\n\n## Code Example\n\n```c\nint parity128(uint64_t hi, uint64_t lo) {\n  uint64_t x = hi ^ lo;\n  x ^= x >> 32;\n  x ^= x >> 16;\n  x ^= x >> 8;\n  x ^= x >> 4;\n  return x & 1;\n}\n```\n\n## Follow-up Questions\n\n- How would you extend to a 256-bit value?  - Can you adapt this for streaming parity on large data chunks?\n","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Microsoft","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T05:57:23.016Z","createdAt":"2026-01-21T05:57:23.016Z"},{"id":"q-680","question":"Given a 32-bit unsigned int n, implement a function hasAdjacentOnes(n) that returns true if n contains any two consecutive 1 bits (for example 0b1100100 has adjacent ones). Use only bitwise operations, no loops or lookups. Explain the core trick in a sentence?","answer":"Return (n & (n >> 1)) != 0. Shifting n right by 1 aligns any adjacent 1s, and ANDing with the original yields a nonzero value iff at least one adjacent pair exists. This is O(1) and uses only bitwise ","explanation":"## Why This Is Asked\n\nAssess practical bit-manipulation intuition and ability to leverage canonical tricks for constant-time checks in real code paths.\n\n## Key Concepts\n\n- Bit tricks: (x & (x >> 1)) detects adjacent 1s\n- Complexity: O(1), no loops\n- Edge cases: 0, power-of-two inputs\n\n## Code Example\n\n```javascript\nfunction hasAdjacentOnes(n) {\n  return (n & (n >> 1)) !== 0;\n}\n```\n\n## Follow-up Questions\n\n- How would you extend this to detect at least k consecutive 1s?\n- How would you adapt for signed 32-bit integers and two's complement behavior?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Oracle","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T15:57:26.049Z","createdAt":"2026-01-11T15:57:26.049Z"},{"id":"q-689","question":"Given a 32-bit unsigned integer n, implement a function isSingleEvenBitSet(n) that returns true if exactly one bit is set and that bit lies at an even index (0, 2, 4, ...). Use only bitwise operations, no loops or built-in helpers. Provide the expression and a brief justification, plus a couple of quick examples?","answer":"Use (n != 0) && ((n & (n-1)) == 0) && ((n & 0x55555555) != 0). The first two checks ensure a single set bit (power of two), and the last check verifies the bit is at an even position since 0x55555555 ","explanation":"## Why This Is Asked\n\nThis question tests precise bit-level reasoning and avoids expensive operations in tight loops, useful in storage engines and query optimizers.\n\n## Key Concepts\n\n- Single-set-bit test: (n & (n-1)) == 0\n- Even-index bit mask: 0x55555555\n- Combining tests with boolean logic for a robust check\n\n## Code Example\n\n```javascript\nfunction isSingleEvenBitSet(n) {\n  return n !== 0 && (n & (n - 1)) === 0 && (n & 0x55555555) !== 0;\n}\n```\n\n## Follow-up Questions\n\n- How would you generalize to check exactly k bits set?\n- How would you adapt to 64-bit width and different bit-ordering considerations?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","MongoDB","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T16:23:21.467Z","createdAt":"2026-01-11T16:23:21.467Z"},{"id":"q-698","question":"Implement a 32-bit unsigned integer function popcount32(n) that returns the number of set bits in n using only bitwise operations and shifts, with no loops or built-ins. Use the SWAR (SIMD Within A Register) technique: apply a sequence of masks and shifts (0x55555555, 0x33333333, 0x0F0F0F0F) and a final multiply to consolidate counts. Provide the function and a brief justification, plus a couple of quick examples?","answer":"Use SWAR (SIMD Within A Register) to count bits in a 32-bit value without loops. Steps: x = x >>> 1 & 0x55555555; x = x - x; x = (x & 0x33333333) + ((x >>> 2) & 0x33333333); x = (x + (x >>> 4)) & 0x0F","explanation":"## Why This Is Asked\n\n- Tests ability to implement a canonical bit-counting trick without loops, emphasizing constant-time operations. \n- Demonstrates careful use of masks and shifts to aggregate counts across bit groups.\n\n## Key Concepts\n\n- SWAR (parallel bit counting)\n- Bit masks 0x55555555, 0x33333333, 0x0F0F0F0F\n- Constant-time arithmetic with shifts\n\n## Code Example\n\n```javascript\nfunction popcount32(x) {\n  x = x - ((x >>> 1) & 0x55555555);\n  x = (x & 0x33333333) + ((x >>> 2) & 0x33333333);\n  x = (x + (x >>> 4)) & 0x0F0F0F0F;\n  return (x * 0x01010101) >>> 24;\n}\n```\n\n## Follow-up Questions\n\n- How would you adapt to 64-bit inputs?\n- Compare this approach to using hardware popcount instructions in terms of portability and performance.","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T17:18:07.873Z","createdAt":"2026-01-11T17:18:07.873Z"},{"id":"q-705","question":"Implement reverseBits32(n) that reverses all 32 bits in a 32-bit unsigned integer using only a fixed sequence of bitwise operations (no loops or conditionals). Use a SWAR-style approach with masks 0x55555555, 0x33333333, 0x0F0F0F0F and 0x00FF00FF, finishing with a 16-bit half-swap. Provide the function signature and a brief justification, plus a couple of quick examples?","answer":"ReverseBits32 uses a fixed, loop-free SWAR sequence. Swap adjacent bits with 0x55555555, then swap pairs with 0x33333333, then nibbles with 0x0F0F0F0F, then bytes with 0x00FF00FF, and finally swap 16-","explanation":"## Why This Is Asked\nFresh bit-hack that demonstrates mastery of fixed-step SWAR technique and portability across languages.\n\n## Key Concepts\n- SWAR fixed-masks and staged swaps\n- Bitwise rotation-free reversal\n- Unsigned 32-bit wrap handling in JavaScript/TypeScript\n\n## Code Example\n```javascript\nfunction reverseBits32(n) {\n  n = ((n >>> 1) & 0x55555555) | ((n & 0x55555555) << 1);\n  n = ((n >>> 2) & 0x33333333) | ((n & 0x33333333) << 2);\n  n = ((n >>> 4) & 0x0F0F0F0F) | ((n & 0x0F0F0F0F) << 4);\n  n = ((n >>> 8) & 0x00FF00FF) | ((n & 0x00FF00FF) << 8);\n  n = (n >>> 16) | (n << 16);\n  return n >>> 0;\n}\n```\n\n## Follow-up Questions\n- How would you adapt this for 64-bit integers in languages with 64-bit ops?\n- How to verify correctness with quick property tests (e.g., n reversing twice yields n)?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T18:28:46.088Z","createdAt":"2026-01-11T18:28:46.088Z"},{"id":"q-711","question":"In a network packet parser, a 32-bit field uses trailing-zero count to encode the length of a value. Given a 32-bit unsigned n, implement countTrailingZeros32(n) that returns the number of trailing zero bits (0-32). If n==0, return 32. Use only bitwise operations, shifts, and basic arithmetic, no loops or built-ins. Provide signature, brief justification, and 1-2 quick examples?","answer":"Use a de Bruijn sequence to map the least-significant 1 to its trailing-zero count. If n==0 return 32. Let v = n & -n; idx = (v * 0x077CB531) >> 27; tz = debruijn[idx]. This uses only bitwise ops and ","explanation":"## Why This Is Asked\nTests knowledge of fast, branchless bit tricks and constant-time bit-scanning utilities common in high-performance systems.\n\n## Key Concepts\n- Isolating least-significant 1: v = n & -n\n- De Bruijn-based indexing: map a 5-bit index to a trailing-zero count\n- Handling edge case n == 0 (return 32)\n- Static lookup table of 32 entries\n\n## Code Example\n```c\nuint32_t countTrailingZeros32(uint32_t n){\n  static const int debruijn[32] = {0,1,28,2,29,14,24,3,30,22,20,15,25,17,4,8,31,27,13,23,21,19,16,7,26,12,18,9,6,11,5,10};\n  if(n == 0) return 32;\n  uint32_t v = n & -n;\n  return debruijn[(v * 0x077CB531) >> 27];\n}\n```\n\n## Follow-up Questions\n- How would you adapt this for 64-bit inputs?\n- What are alternatives that avoid a static table, e.g., using binary search on bit groups?","diagram":"flowchart TD\n  A[n]\n  B{n == 0}\n  C[return 32]\n  D[v = n & -n]\n  E[idx = (v * 0x077CB531) >> 27]\n  F[tz = debruijn[idx]]\n  G[return tz]\n  A --> B\n  B -- yes --> C\n  B -- no --> D\n  D --> E\n  E --> F\n  F --> G","difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T19:16:13.404Z","createdAt":"2026-01-11T19:16:13.404Z"},{"id":"q-724","question":"In memory allocation, implement nextPowerOfTwo32(uint32_t n) that returns the smallest 32-bit unsigned power-of-two >= n, given n > 0, using only bitwise operations with no loops or conditionals. If the result would overflow 32 bits, return 0. What is the correct implementation signature and approach?","answer":"Branchless, constant-time trick. Use a fixed-width prefix fill: n--; n |= n >> 1; n |= n >> 2; n |= n >> 4; n |= n >> 8; n |= n >> 16; return n + 1. Works for all n>0; overflow (n>0x80000000) yields 0","explanation":"## Why This Is Asked\n\n- Demonstrates ability to replace branches with bit-twiddling for performance.\n- Applies a well-known, portable technique to a common memory-allocation problem.\n- Handles edge cases and overflow without loops.\n\n## Key Concepts\n- Prefix-fill trick to propagate the highest set bit.\n- Branchless arithmetic to compute next power of two.\n- Overflow behavior on 32-bit boundaries.\n\n## Code Example\n\n```c\nuint32_t nextPowerOfTwo32(uint32_t n) {\n  // Assumes n > 0. No explicit branches.\n  n--;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  return n + 1;\n}\n```\n\n## Follow-up Questions\n- How does this behave for n = 0x80000000 or 0xFFFFFFFF?\n- Can you adapt this to 64-bit inputs with no loops?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","IBM","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T20:24:38.993Z","createdAt":"2026-01-11T20:24:38.994Z"},{"id":"q-730","question":"Given a 32-bit unsigned integer n, implement swapAdjacentBits32(n) that returns a new 32-bit value with every adjacent bit pair swapped (bits 0-1, 2-3, ..., 30-31). Use only bitwise operations, no loops or conditionals. Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"Signature: uint32_t swapAdjacentBits32(uint32_t n);\\nApproach: res = ((n & 0x55555555) << 1) | ((n & 0xAAAAAAAA) >> 1); This is branchless and runs in constant time, swapping every adjacent bit pair. ","explanation":"## Why This Is Asked\nTests low-level bit twiddling discipline and production-ready, branchless code.\n\n## Key Concepts\n- Bit masks and shifts\n- Branchless algorithms\n- 32-bit edge handling\n\n## Code Example\n```\nuint32_t swapAdjacentBits32(uint32_t n) {\n  return ((n & 0x55555555) << 1) | ((n & 0xAAAAAAAA) >> 1);\n}\n```\n\n## Follow-up Questions\n- How would you extend to 64-bit inputs?\n- How would you test edge cases (0, all-ones) with unit tests?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Plaid","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T21:19:02.055Z","createdAt":"2026-01-11T21:19:02.055Z"},{"id":"q-738","question":"Implement a 64-bit bit reversal function reverse64(uint64_t n) that returns the bitwise reversal of n (bit 0 becomes bit 63, bit 63 becomes bit 0). Use only bitwise operations and shifts, no loops or conditionals. Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"Use a SWAR-style reversal: progressively swap 1-bit blocks, then 2-bit, 4-bit, etc., with masks (0x5555555555555555, 0x3333333333333333, 0x0F0F0F0F0F0F0F0F), then swap larger blocks and finally the tw","explanation":"## Why This Is Asked\nTests mastery of branchless, scalable bit-twiddling techniques for 64-bit inputs.\n\n## Key Concepts\n- SWAR style bit reversal\n- Masking and shifting sequences\n- Branchless algorithms for performance\n\n## Code Example\n```c\n#include <stdint.h>\n\nuint64_t reverse64(uint64_t n) {\n  n = ((n >> 1) & 0x5555555555555555ULL) | ((n & 0x5555555555555555ULL) << 1);\n  n = ((n >> 2) & 0x3333333333333333ULL) | ((n & 0x3333333333333333ULL) << 2);\n  n = ((n >> 4) & 0x0F0F0F0F0F0F0F0FULL) | ((n & 0x0F0F0F0F0F0F0F0FULL) << 4);\n  n = ((n >> 8) & 0x00FF00FF00FF00FFULL) | ((n & 0x00FF00FF00FF00FFULL) << 8);\n  n = ((n >> 16) & 0x0000FFFF0000FFFFULL) | ((n & 0x0000FFFF0000FFFFULL) << 16);\n  n = (n >> 32) | (n << 32);\n  return n;\n}\n```\n\n## Follow-up Questions\n- How would you optimize for smaller word sizes or specialized ISAs?\n- How would you adapt for 128-bit inputs and performance considerations?","diagram":"flowchart TD\n  A[Start: input n] --> B[Swap 1-bit blocks]\n  B --> C[Swap 2-bit blocks]\n  C --> D[Swap 4-bit blocks]\n  D --> E[Swap 8-bit blocks]\n  E --> F[Swap 16-bit blocks]\n  F --> G[Swap 32-bit halves]\n  G --> H[Return reversed n]","difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","MongoDB","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T22:20:40.030Z","createdAt":"2026-01-11T22:20:40.030Z"},{"id":"q-747","question":"Implement isBinaryPalindrome32(uint32_t n) that returns 1 if the 32-bit binary representation of n is a palindrome (bit0 equals bit31, bit1 equals bit30, etc.), and 0 otherwise. Use only bitwise operations and shifts; no loops or conditional branches. Provide the function signature and a brief justification, plus 1-2 quick examples.\n\nExamples:\n- 0x80000001 is a palindrome\n- 0xA5A5A5A5 is not a palindrome?","answer":"Reverse the 32 bits using a fixed sequence of mask/shift swaps (1,2,4,8,16 bit steps) and compare the result to the original. No loops or branches; returns 1 if n equals its reverse, else 0. Demonstra","explanation":"## Why This Is Asked\n\nTests the ability to implement a constant-time bit reversal to verify a binary palindrome using only bitwise ops.\n\n## Key Concepts\n\n- Palindrome property in binary\n- Bit-reversal networks with masks\n- Branch-free comparison\n\n## Code Example\n\n```javascript\n// C-like implementation (illustrative)\nint isBinaryPalindrome32(uint32_t n) {\n  uint32_t x = n;\n  x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);\n  x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);\n  x = ((x >> 4) & 0x0F0F0F0F) | ((x & 0x0F0F0F0F) << 4);\n  x = ((x >> 8) & 0x00FF00FF) | ((x & 0x00FF00FF) << 8);\n  x = (x >> 16) | (x << 16);\n  return (x == n);\n}\n```\n\n## Follow-up Questions\n\n- Extend to 64-bit inputs; what changes? \n- Compare against a loop-based reversal for performance tests.","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Google","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T23:20:55.546Z","createdAt":"2026-01-11T23:20:55.546Z"},{"id":"q-751","question":"Implement popcount64(uint64_t x) that returns the number of set bits in x using only bitwise operations and shifts, with no loops and no built-in popcount. Use a fixed SWAR approach with masks 0x5555555555555555ULL, 0x3333333333333333ULL, 0x0F0F0F0F0F0F0F0FULL and a final multiply/shift step. Provide the function signature and a brief justification, plus 1-2 quick examples of inputs and outputs?","answer":"One correct approach uses a fixed SWAR popcount: x = x - ((x>>1) & 0x5555555555555555ULL); x = (x & 0x3333333333333333ULL) + ((x>>2) & 0x3333333333333333ULL); x = (x + (x>>4)) & 0x0F0F0F0F0F0F0F0FULL;","explanation":"## Why This Is Asked\nTests ability to implement bit-twiddling without loops, using SWAR patterns for constant-time population count.\n\n## Key Concepts\n- SWAR (Small/Word-level Parallelism)\n- 64-bit masks and carry-free sums\n- No intrinsics or branches; deterministic performance\n\n## Code Example\n```javascript\nuint64_t popcount64(uint64_t x) {\n  x = x - ((x >> 1) & 0x5555555555555555ULL);\n  x = (x & 0x3333333333333333ULL) + ((x >> 2) & 0x3333333333333333ULL);\n  x = (x + (x >> 4)) & 0x0F0F0F0F0F0F0F0FULL;\n  return (x * 0x0101010101010101ULL) >> 56;\n}\n```\n\n## Follow-up Questions\n- How would you adapt this to count bits in 128-bit values? \n- What are the trade-offs vs. hardware popcnt instructions in modern CPUs?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","MongoDB","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T01:29:06.153Z","createdAt":"2026-01-12T01:29:06.153Z"},{"id":"q-757","question":"Given a 32-bit unsigned integer n, implement maskBelowLSB32(n) that returns a 32-bit mask with all bits at positions <= the least significant set bit of n turned on; if n is 0 return 0. Use bitwise operations and shifts (and optional arithmetic). Provide the signature, justification, and 1-2 examples?","answer":"Signature: uint32_t maskBelowLSB32(uint32_t n). Approach: compute lsb = n & -n; return (n==0)?0:((lsb<<1)-1). This isolates the lowest 1 and builds a lower mask by shifting and subtracting 1. Examples","explanation":"## Why This Is Asked\nTests a crisp bit-twiddling trick: constructing a mask anchored to the least significant set bit, plus proper zero handling.\n\n## Key Concepts\n- Isolating the LSB with n & -n\n- Mask construction via (lsb<<1) - 1\n- Edge-case handling for zero input\n\n## Code Example\n```javascript\nfunction maskBelowLSB32(n) {\n  const lsb = n & -n;\n  return n === 0 ? 0 : (lsb << 1) - 1;\n}\n```\n\n## Follow-up Questions\n- How would you adapt to 64-bit inputs?\n- What are the potential pitfalls on platforms with different integer sizes?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Microsoft","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T03:47:17.777Z","createdAt":"2026-01-12T03:47:17.777Z"},{"id":"q-776","question":"Implement a 64-bit bitboard function knightAttacks64(n) that returns a 64-bit mask of all squares attacked by knights, given a 64-bit bitboard n where 1s indicate knight positions. Use only bitwise operations and shifts, no loops or conditionals. Provide the signature and a brief justification, plus 1-2 quick examples?","answer":"uint64_t knightAttacks64(uint64_t knights) { const uint64_t notA=0xfefefefefefefefeULL; const uint64_t notH=0x7f7f7f7f7f7f7f7fULL; uint64_t x=knights; return ((x<<17)&notA)|((x<<15)&notH)|((x<<10)&not","explanation":"## Why This Is Asked\nTests bitboard reasoning and edge-safe shifts. Requires combining eight knight directions with edge masking in a single expression to prove correctness and performance without branching.","diagram":"flowchart TD\n  A[Input: knights] --> B[Apply 8 directional shifts]\n  B --> C[Mask edges to prevent wrap]\n  C --> D[Combine with |]\n  D --> E[Return attacks]","difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Netflix","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T05:29:43.673Z","createdAt":"2026-01-12T05:29:43.673Z"},{"id":"q-783","question":"Given a 32-bit unsigned n, implement hasPattern101(n) that returns true if there exists any i such that bits i, i+1, i+2 form 101 (n_i=1, n_{i+1}=0, n_{i+2}=1). Use only bitwise operations and shifts, no loops or conditionals. Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"Use a single expression: (n & (n >> 2) & ~(n >> 1)) != 0. It slides a 3-bit window across n, aligning bits i, i+1, i+2 so a 101 pattern yields a nonzero bit after the ANDs. It avoids loops and branche","explanation":"## Why This Is Asked\nTests ability to detect fixed bit patterns with pure bitwise ops, no loops or conditionals, reinforcing shifts, masking, and truthiness evaluation.\n\n## Key Concepts\n- Bitwise shifts align neighboring bits\n- Combining with AND tests multiple bit conditions simultaneously\n- Pure bitwise approach scales to fixed-width inputs without branching\n\n## Code Example\n```c\nbool hasPattern101(uint32_t n) {\n  return (n & (n >> 2) & ~(n >> 1)) != 0;\n}\n```\n\n## Follow-up Questions\n- How would you adapt for 64-bit inputs?\n- What edge cases exist near the topmost bits (i=29) and how does masking affect them?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Plaid","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T06:35:10.215Z","createdAt":"2026-01-12T06:35:10.215Z"},{"id":"q-791","question":"Implement parity32(n) that returns 1 if the number of set bits in a 32-bit unsigned n is odd, otherwise 0. Do not use loops or built-ins; only bitwise ops and shifts. Provide function signature parity32(uint32_t n) and a brief justification, plus 1-2 quick examples?","answer":"One way is XOR-fold parity: fold the 32 bits in halves, then propagate to LSB. Implement parity32 as p = n; p ^= p >> 16; p ^= p >> 8; p ^= p >> 4; p ^= p >> 2; p ^= p >> 1; return p & 1. This uses on","explanation":"## Why This Is Asked\nTests understanding of bitwise folding to compute parity without loops.\n\n## Key Concepts\n- Parity via XOR folding\n- Bitwise shifts to mix bits\n- No branches or loops in parity path\n\n## Code Example\n```javascript\nuint32_t parity32(uint32_t n) {\n  uint32_t p = n;\n  p ^= p >> 16;\n  p ^= p >> 8;\n  p ^= p >> 4;\n  p ^= p >> 2;\n  p ^= p >> 1;\n  return p & 1;\n}\n```\n\n## Follow-up Questions\n- How would you adapt parity32 for 64-bit inputs efficiently?\n- What are the trade-offs compared to using a popcount-based method?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","DoorDash"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T07:27:22.989Z","createdAt":"2026-01-12T07:27:22.989Z"},{"id":"q-798","question":"Implement nextHigherWithSamePopcount64(uint64_t n) that returns the smallest integer greater than n with the same number of 1-bits. Use only bitwise operations and shifts; no loops or conditionals. If no such number exists, return 0. Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"Use a single-pass, branchless bit-trick: c = n & -n; r = n + c; next = (((n ^ r) >> 2) / c) | r; This yields the next higher number with the same popcount for 64-bit inputs. Edge cases (like overflow)","explanation":"## Why This Is Asked\nShows mastery of low-level bit tricks and edge-case handling in constrained environments.\n\n## Key Concepts\n- Next permutation with fixed popcount using bit hacks\n- Branchless arithmetic for speed\n- Fixed-width overflow behavior\n\n## Code Example\n```javascript\nuint64_t nextHigherWithSamePopcount(uint64_t n) {\n  uint64_t c = n & -n;\n  uint64_t r = n + c;\n  return (((n ^ r) >> 2) / c) | r;\n}\n```\n\n## Follow-up Questions\n- How would you adapt for arbitrary width (128-bit)?\n- How does this interact with compiler optimizations and undefined behavior in signed contexts?","diagram":"flowchart TD\n  A[Start] --> B[Compute c = n & -n]\n  B --> C[Compute r = n + c]\n  C --> D[Compute next = (((n ^ r) >> 2) / c) | r]\n  D --> E[Return next]","difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T08:29:27.025Z","createdAt":"2026-01-12T08:29:27.025Z"},{"id":"q-807","question":"Implement rotateLeft128 by k on a 128-bit value stored as two 64-bit words (hi, lo). The function rotates within the 128-bit boundary by k bits (0 <= k < 128) using only bitwise operations and shifts, no loops or conditionals. Provide the signature and a brief justification, plus 1-2 quick examples?","answer":"Represent the 128-bit value as hi:lo. Normalize k to [0,127]. Let n = (hi<<64) | lo. Rotated = ((n<<k) | (n>>(128-k))) & mask128, with mask128 = ((unsigned __int128)1 << 128) - 1. New hi = rotated >> ","explanation":"## Why This Is Asked\nTests cross-boundary bit tricks and 128-bit reasoning without loops.\\n\\n## Key Concepts\n- 128-bit rotation via 64-bit halves\\n- Normalizing k to 0..127, masking to 128 bits\\n- Pure bitwise/shifts, no branches\\n\\n## Code Example\n```javascript\nfunction rotl128(hi, lo, k) {\n  const n = (BigInt(hi) << 64n) | BigInt(lo);\n  const kk = BigInt(k) & 127n;\n  const mask128 = (1n << 128n) - 1n;\n  const val = ((n << kk) | (n >> (128n - kk))) & mask128;\n  return {\n    hi: Number((val >> 64n) & ((1n << 64n) - 1n)),\n    lo: Number(val & ((1n << 64n) - 1n))\n  };\n}\n```\n\n## Follow-up Questions\n- How to implement without 128-bit types?\\n- How to test edge cases: k=0, k=127, k=64?\\n- How to port to languages with limited integer width or without unsigned128 support?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Meta","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T09:32:36.893Z","createdAt":"2026-01-12T09:32:36.893Z"},{"id":"q-814","question":"Implement interleave16(uint16_t a, uint16_t b) that returns a 32-bit value with bits interleaved as a0 b0 a1 b1 ... a15 b15, where a0 is LSB of a and b0 is LSB of b. Use only bitwise operations and shifts (no loops or conditionals). Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"Spread each 16-bit input into separate 32-bit lanes, then combine. Implement a helper spread16 that places bits at even positions with masks 0x00FF00FF, 0x0F0F0F0F, 0x33333333, 0x55555555. Then return","explanation":"## Why This Is Asked\nTests mastery of low-level bit hacks: packing, masking, and fixed-time transformations without control flow.\n\n## Key Concepts\n- Morton (Z-order) interleaving\n- Bit spreading via staged masks\n- Fixed, branchless implementation\n\n## Code Example\n```cpp\nuint32_t spread16(uint16_t v){\n  uint32_t x = v;\n  x = (x | (x << 8)) & 0x00FF00FF;\n  x = (x | (x << 4)) & 0x0F0F0F0F;\n  x = (x | (x << 2)) & 0x33333333;\n  x = (x | (x << 1)) & 0x55555555;\n  return x;\n}\nuint32_t interleave16(uint16_t a, uint16_t b){\n  return spread16(a) | (spread16(b) << 1);\n}\n```\n\n## Follow-up Questions\n- How would you generalize to interleave 32-bit values into a 64-bit result?\n- What tests would you add to validate edge cases like a or b == 0xFFFF?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Snowflake","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T10:24:33.809Z","createdAt":"2026-01-12T10:24:33.809Z"},{"id":"q-823","question":"Implement rotateLeft32(uint32_t n, unsigned int k) that returns the 32-bit value formed by rotating n left by k bits. Constraints: no loops or conditionals; handle k >= 32 by using k % 32. Provide the function signature and a brief justification, and give 1-2 quick examples?","answer":"One correct approach uses (n << k) | (n >> (32 - k)) with k %= 32. If k==0, returns n; no branches. This uses only bitwise shifts and OR. Examples: rotateLeft32(0x12345678, 4) = 0x23456781; rotateLeft","explanation":"## Why This Is Asked\nTests ability to implement a classic bit manipulation pattern without branches, reflecting real-world needs in low-level systems.\n\n## Key Concepts\n- Bitwise rotation vs shift\n- Handling 32-bit wrap with modulo 32\n- Edge case k=0 without branches\n\n## Code Example\n```javascript\nuint32_t rotateLeft32(uint32_t n, unsigned int k) {\n  k &= 31; // k % 32\n  return (n << k) | (n >> (32 - k));\n}\n```\n```\n\n## Follow-up Questions\n- How would you adapt for 64-bit values?\n- What are the hazards with signed integers and how to avoid them?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","LinkedIn","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T11:20:30.427Z","createdAt":"2026-01-12T11:20:30.427Z"},{"id":"q-830","question":"Implement xor32(uint32_t a, uint32_t b) that returns a ^ b without using the ^ operator. Use only &, |, ~ and shifts. Provide the function signature and a brief justification, plus 1-2 quick examples to verify correctness?","answer":"Use the identity a ^ b = (a | b) & ~(a & b). Implement: static inline uint32_t xor32(uint32_t a, uint32_t b) { return (a | b) & ~(a & b); }. Rationale: per-bit XOR is 1 when exactly one input bit is 1","explanation":"## Why This Is Asked\n\nTests understanding of bit-level identities and branchless implementation, common in low-level systems, kernels, and performance-critical code.\n\n## Key Concepts\n\n- De Morgan's laws and bitwise algebra\n- Implementing XOR without ^ using only &, |, ~\n- Verifying correctness with small binary-pattern examples\n\n## Code Example\n\n```javascript\n// Implementation code for xor32 (C-like)\n#include <stdint.h>\nuint32_t xor32(uint32_t a, uint32_t b) {\n  return (a | b) & ~(a & b);\n}\n```\n\n## Follow-up Questions\n\n- How would you adjust if only ~ and & were allowed (no |)?\n- How would you test edge cases like a=0, b=0 and a=0xFFFFFFFF, b=0x0F0F0F0F?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T12:42:34.459Z","createdAt":"2026-01-12T12:42:34.459Z"}],"subChannels":["general"],"companies":["Adobe","Airbnb","Amazon","Anthropic","Apple","Bloomberg","Citadel","Cloudflare","Coinbase","Databricks","Discord","DoorDash","Goldman Sachs","Google","Hashicorp","Hugging Face","IBM","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Netflix","OpenAI","Oracle","PayPal","Plaid","Salesforce","Slack","Snap","Snowflake","Stripe","Tesla","Twitter","Two Sigma","Uber","Zoom"],"stats":{"total":48,"beginner":16,"intermediate":14,"advanced":18,"newThisWeek":27}}