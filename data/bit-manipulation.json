{"questions":[{"id":"q-680","question":"Given a 32-bit unsigned int n, implement a function hasAdjacentOnes(n) that returns true if n contains any two consecutive 1 bits (for example 0b1100100 has adjacent ones). Use only bitwise operations, no loops or lookups. Explain the core trick in a sentence?","answer":"Return (n & (n >> 1)) != 0. Shifting n right by 1 aligns any adjacent 1s, and ANDing with the original yields a nonzero value iff at least one adjacent pair exists. This is O(1) and uses only bitwise ","explanation":"## Why This Is Asked\n\nAssess practical bit-manipulation intuition and ability to leverage canonical tricks for constant-time checks in real code paths.\n\n## Key Concepts\n\n- Bit tricks: (x & (x >> 1)) detects adjacent 1s\n- Complexity: O(1), no loops\n- Edge cases: 0, power-of-two inputs\n\n## Code Example\n\n```javascript\nfunction hasAdjacentOnes(n) {\n  return (n & (n >> 1)) !== 0;\n}\n```\n\n## Follow-up Questions\n\n- How would you extend this to detect at least k consecutive 1s?\n- How would you adapt for signed 32-bit integers and two's complement behavior?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Oracle","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T15:57:26.049Z","createdAt":"2026-01-11T15:57:26.049Z"}],"subChannels":["general"],"companies":["Cloudflare","Oracle","Two Sigma"],"stats":{"total":1,"beginner":0,"intermediate":1,"advanced":0,"newThisWeek":1}}