{"questions":[{"id":"q-1073","question":"Implement transpose64(uint64_t x) by treating x as an 8x8 bit matrix in row-major order (bits 0-7 are row 0, 8-15 row 1, etc.). Return the transposed matrix (bit (r,c) moves to (c,r)). Use only bitwise ops and shifts; no loops or conditionals. Provide signature and a brief justification, plus 1-2 quick examples?","answer":"Signature: uint64_t transpose64(uint64_t x). Approach: interpret x as an 8×8 bit matrix and perform fixed, branchless stage swaps: swap 1-bit pairs with mask 0x5555555555555555; swap 2-bit pairs with ","explanation":"## Why This Is Asked\nTests mastery of non-trivial bit hacks and understanding of 8×8 transpose, a common optimization in graphics, crypto, and compression. It checks for precise, branchless manipulation and correct use of masks.\n\n## Key Concepts\n- fixed-sequence bit swaps\n- 8×8 bit matrix representation\n- mask constants, shifts, no loops\n\n## Code Example\n```cpp\nuint64_t transpose64(uint64_t x) {\n    const uint64_t m1  = 0x5555555555555555ULL;\n    x = (x & m1) << 1 | (x >> 1) & m1;\n    const uint64_t m2  = 0x3333333333333333ULL;\n    x = (x & m2) << 2 | (x >> 2) & m2;\n    const uint64_t m4  = 0x0F0F0F0F0F0F0F0FULL;\n    x = (x & m4) << 4 | (x >> 4) & m4;\n    const uint64_t m8  = 0x00FF00FF00FF00FFULL;\n    x = (x & m8) << 8 | (x >> 8) & m8;\n    const uint64_t m16 = 0x0000FFFF0000FFFFULL;\n    x = (x & m16) << 16 | (x >> 16) & m16;\n    const uint64_t m32 = 0x00000000FFFFFFFFULL;\n    x = (x & m32) << 32 | (x >> 32) & m32;\n    return x;\n}\n```\n\n## Follow-up Questions\n- How would you test this with randomized 64-bit inputs to validate correctness?\n- How would you generalize to 16×16 blocks with a 256-bit input stored in four 64-bit words?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Coinbase","Hashicorp"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T21:32:59.254Z","createdAt":"2026-01-12T21:32:59.254Z"},{"id":"q-1216","question":"Implement reverse128 for a 128-bit value stored as two 64-bit halves hi and lo. Provide a function:\n\nvoid reverse128(uint64_t hi, uint64_t lo, uint64_t *out_hi, uint64_t *out_lo);\n\nThe reversal should map bit i to bit 127 - i, using only bitwise operations and shifts (no loops or conditionals). Include a brief justification and 1-2 quick test examples?","answer":"Split into two 64-bit halves. Compute rev64 of each half with the standard mask/shifts sequence, then swap halves: out_hi = reverse64(lo); out_lo = reverse64(hi). reverse64 uses the classic parallel-b","explanation":"## Why This Is Asked\nTests ability to reason about multi-word bit manipulations and safe 64→128-bit extension without loops.\n\n## Key Concepts\n- 128-bit reversal via two 64-bit reversals and swapping halves\n- Parallel-bits reversal (mask/shifts)\n- Endianness-insensitive mapping of bit indices\n\n## Code Example\n```javascript\nfunction reverse64(x) {\n  x = (x >> 1n) & 0x5555555555555555n | (x & 0x5555555555555555n) << 1n;\n  x = (x >> 2n) & 0x3333333333333333n | (x & 0x3333333333333333n) << 2n;\n  x = (x >> 4n) & 0x0F0F0F0F0F0F0F0Fn | (x & 0x0F0F0F0F0F0F0F0Fn) << 4n;\n  x = (x >> 8n) & 0x00FF00FF00FF00FFn | (x & 0x00FF00FF00FF00FFn) << 8n;\n  x = (x >> 16n) & 0x0000FFFF0000FFFFn | (x & 0x0000FFFF0000FFFFn) << 16n;\n  x = (x >> 32n) | (x << 32n);\n  return x;\n}\nfunction reverse128(hi, lo) {\n  const revLo = reverse64(lo);\n  const revHi = reverse64(hi);\n  return { hi: revLo, lo: revHi };\n}\n```\n\n## Follow-up Questions\n- How would you adapt to streaming 128-bit values?\n- How to verify correctness with random tests?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Snowflake","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T05:27:59.598Z","createdAt":"2026-01-13T05:27:59.598Z"},{"id":"q-2040","question":"Implement countTrailingZeros64(uint64_t x) using only bitwise operations and shifts (no loops or conditionals). Return 64 if x == 0. Use a De Bruijn sequence with a 64-entry lookup table. Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"The approach isolates the least significant 1 bit using y = x & -x, then maps this value to its index via a 64-entry De Bruijn lookup table: idx = table[(y * 0x03f79d71b4cb0a89ULL) >> 58]. If x == 0, return 64. This provides a constant-time, branchless solution using only bitwise operations and shifts.","explanation":"## Why This Is Asked\n\nTests mastery of constant-time bit manipulation and branchless programming, which are critical in performance-critical code paths.\n\n## Key Concepts\n\n- Trailing zero count algorithms\n- De Bruijn sequences for bit indexing\n- Branchless bit-twiddling techniques\n\n## Code Example\n\n```javascript\n// Conceptual implementation\nfunction ctz64(x) {\n  if (x === 0) return 64;\n  const y = x & -x;\n  const idx = table[(y * 0x03f79d71b4cb0a89) >>> 58];\n  return idx;\n}\n```\n\n## Follow-up Questions\n\n- How would you extend this approach for 128-bit values?\n- What compiler optimization challenges might arise with this technique?","diagram":"flowchart TD\n  A[Input x] --> B[If x==0 return 64]\n  B --> C[Compute y = x & -x]\n  C --> D[Compute idx via (y * 0x03f79d71b4cb0a89) >> 58]\n  D --> E[Return idx]","difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Oracle","Twitter","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T06:12:33.650Z","createdAt":"2026-01-14T21:45:42.837Z"},{"id":"q-2221","question":"In a 32-bit word handling module, implement rotateRight32(uint32_t n, uint32_t k) that returns n rotated right by k positions. Use only bitwise operations and shifts; no loops or conditionals. Assume 0 <= k < 32. Provide the function signature and a brief justification, plus 1–2 quick examples?","answer":"Use a constant-time rotate: k = k % 32; return (n >> k) | (n << (32 - k)); In the edge case k=0, the function returns n. For example: rotateRight32(0x12345678, 8) => 0x78123456; rotateRight32(0x800000","explanation":"## Why This Is Asked\nTests understanding of circular shifts vs normal shifts and edge-case handling in a 32-bit width.\n\n## Key Concepts\n- Circular shifts vs arithmetic/logical shifts\n- Width-aware masking and edge-cases\n- Pure bitwise operations with no loops\n\n## Code Example\n```javascript\nstatic inline uint32_t rotateRight32(uint32_t n, uint32_t k){\n  k %= 32;\n  return (n >> k) | (n << (32 - k));\n}\n```\n\n## Follow-up Questions\n- How would you adapt this for 64-bit inputs? \n- What changes if 0 < k < 64 is required?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","MongoDB","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T07:48:13.193Z","createdAt":"2026-01-15T07:48:13.193Z"},{"id":"q-2271","question":"Given a 64-bit bitboard representing an 8x8 grid (bit 0 = A1, bit 63 = H8), implement neighborMask64(uint64_t board) that returns a mask with a 1 where a bit has any of its eight neighboring cells set in the original board. Use only bitwise operations and shifts; no loops or conditionals. Provide the function signature and a brief justification, plus 1-2 quick tests?","answer":"Signature: uint64_t neighborMask64(uint64_t board); The function returns a mask where bit i is 1 if any of i's eight neighbors are 1 in the input, using only bitwise ops and shifts; no loops. Compute ","explanation":"## Why This Is Asked\nTests bitboard reasoning, edge handling, and efficient parallelism using only bitwise ops.\n\n## Key Concepts\n- Bitboard edge wrapping and file masks\n- Parallel neighbor computation via multiple shifts\n- Safe, branch-free bitwise design\n\n## Code Example\n```c\nuint64_t neighborMask64(uint64_t board) {\n    const uint64_t notA = 0xfefefefefefefefeULL;\n    const uint64_t notH = 0x7f7f7f7f7f7f7f7fULL;\n    uint64_t east  = (board & notH) << 1;\n    uint64_t west  = (board & notA) >> 1;\n    uint64_t south = board << 8;\n    uint64_t north = board >> 8;\n    uint64_t ne = (board & notH) >> 7;\n    uint64_t nw = (board & notA) >> 9;\n    uint64_t se = (board & notH) << 9;\n    uint64_t sw = (board & notA) << 7;\n    return east | west | south | north | ne | nw | se | sw;\n}\n```\n\n## Follow-up Questions\n- How would you adapt for a 32-bit board layout?\n- How would you unit-test edge cases (corners and edges) efficiently?","diagram":"flowchart TD\n  A[Input board] --> B[Compute eight directional shifts]\n  B --> C[Mask edges with notA/notH]\n  C --> D[OR all eight results]\n  D --> E[neighborMask64 output]","difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Snap","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T09:54:06.921Z","createdAt":"2026-01-15T09:54:06.921Z"},{"id":"q-2354","question":"In bit-manipulation interviews, implement rotateRight64(uint64_t n, unsigned k) that rotates n right by k bits (0 <= k < 64). Use only bitwise operations and shifts; no loops or conditionals. Provide the function signature and a brief justification, plus 1-2 quick examples demonstrating the behavior?","answer":"Return (n >> k) | (n << ((64 - k) & 63)); with k masked by 63 to avoid undefined shifts when k=0. This performs a circular shift: bits shifted out on the right wrap to the left. Example: n=0x012345678","explanation":"## Why This Is Asked\nTests ability to implement circular shifts in constant time with safe edge-case handling.\n\n## Key Concepts\n- Circular (rotating) shifts\n- Edge-case safety using masking\n- Pure bitwise operations and shifts\n\n## Code Example\n```javascript\nuint64_t rotateRight64(uint64_t n, unsigned k){\n  k &= 63;\n  return (n >> k) | (n << ((64 - k) & 63));\n}\n```\n\n## Follow-up Questions\n- How would you implement rotateLeft64 similarly?\n- How does this handle k=0 and k=63, and why is the masking essential?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Instacart"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T14:41:33.623Z","createdAt":"2026-01-15T14:41:33.623Z"},{"id":"q-2644","question":"Given a 64-bit unsigned integer n with k set bits, implement nextHigherWithSameBitCount(n) that returns the smallest y > n with popcount(y) == k; if no such y exists, return 0. Provide a function signature and 1-2 quick examples?","answer":"Use the Snoob trick: c = n & -n; r = n + c; o = n ^ r; o = (o >> 2) / c; return r | o; If n == 0 return 0. Examples: 11 (1011) -> 13 (1101); 56 (111000) -> 67 (1000011).","explanation":"## Why This Is Asked\n\nTests mastery of a classic bit-twiddling pattern to find the next permutation of a fixed-popcount bitset in constant time, without loops or branches. It also probes edge cases like overflow and zero input.\n\n## Key Concepts\n\n- Snoob algorithm for next higher with same popcount\n- 64-bit overflow behavior and edge cases (n == 0 or max with k ones)\n- Pure bitwise/shifts approach, no loops\n\n## Code Example\n\n```c\nuint64_t nextWithSamePopcount(uint64_t n) {\n  uint64_t smallest = n & -n;\n  uint64_t ripple = n + smallest;\n  uint64_t ones = n ^ ripple;\n  return ripple | ((ones >> 2) / smallest);\n}\n```\n\n## Follow-up Questions\n\n- How would you adapt this for arbitrary word size or signed integers?\n- What are the performance implications on different architectures?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T04:26:13.968Z","createdAt":"2026-01-16T04:26:13.969Z"},{"id":"q-2665","question":"Treat n as an 8x8 bit matrix in row-major order. Implement rotate90Clockwise64(uint64_t n) that returns the matrix rotated 90 degrees clockwise, using only bitwise operations and shifts (no loops or conditionals). Provide the signature and a brief justification, plus 1-2 quick examples?","answer":"Rotate 8x8 in 64-bit by: 1) transpose the 8x8 matrix in place with a fixed, loopless sequence of bitwise swaps across 1-, 2-, and 4-bit tiles; 2) reverse the order of the 8 rows to complete a 90° cloc","explanation":"## Why This Is Asked\nEfficiently rotating small bit matrices tests mastery of bitwise-twiddling without branching. It combines transposition and row-reversal in a fixed pipeline.\n\n## Key Concepts\n- In-place 8x8 transpose via staged swaps on bit-planes.\n- Row-order reversal to achieve rotation.\n- Pure bitwise operations with fixed masks.\n\n## Code Example\n```javascript\nfunction rotate90Clockwise64(n) {\n  // implement via: t = transpose8x8(n); return reverseRows(t);\n  return rotate90Clockwise64; // placeholder\n}\n```\n\n## Follow-up Questions\n- How would you adapt for 16x16 matrices? \n- What are the constant masks used for the staged swaps?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T05:48:27.872Z","createdAt":"2026-01-16T05:48:27.872Z"},{"id":"q-2723","question":"Implement a 32-bit Morton code generator morton2D(uint16_t x, uint16_t y) that interleaves bits of x and y (x bit 0 -> code bit 0, y bit 0 -> bit 1, etc.). Use only bitwise operations and shifts (no loops). Provide the signature and a brief justification, plus 1-2 examples?","answer":"Use a bit-dilating wrapper to place x and y bits into even/odd positions, then combine. Signature: uint32_t morton2D(uint16_t x, uint16_t y); Complexity: O(1). Examples: morton2D(1,0)=1; morton2D(3,5)","explanation":"## Why This Is Asked\nTests understanding of bit-level data packing and word-level efficiency.\n\n## Key Concepts\n- Bit spreading (dilating)\n- Inline masks and shifts for 32-bit results\n- Morton codes for spatial indexing\n\n## Code Example\n```javascript\nuint32_t part1by1(uint16_t n) {\n  uint32_t x = n;\n  x &= 0x0000FFFF;\n  x = (x | (x << 8)) & 0x00FF00FF;\n  x = (x | (x << 4)) & 0x0F0F0F0F;\n  x = (x | (x << 2)) & 0x33333333;\n  x = (x | (x << 1)) & 0x55555555;\n  return x;\n}\nuint32_t morton2D(uint16_t x, uint16_t y) {\n  return (part1by1(y) << 1) | part1by1(x);\n}\n```\n\n## Follow-up Questions\n- How would you extend to 3D Morton codes (x,y,z) and 64-bit result? \n- How would you adapt for non-power-of-two bit widths or streaming data?\n","diagram":"flowchart TD\n  A[Input x,y] --> B[Spread bits of x]\n  A --> C[Spread bits of y]\n  B --> D[Shift left by 1]\n  D --> E[OR with spread x]\n  C --> E","difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","IBM"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T09:36:50.388Z","createdAt":"2026-01-16T09:36:50.389Z"},{"id":"q-3186","question":"Implement a 32-bit header packer. Write a function packHeader(uint8_t version, uint8_t flags, uint16_t length) that places version in bits 31-28, flags in bits 27-20, and length in bits 19-0. Use only bitwise operations and shifts, no loops or conditionals. Provide the signature and a brief justification, plus 1-2 quick examples?","answer":"header = ((version & 0x0F) << 28) | ((flags & 0xFF) << 20) | (length & 0xFFFFF); This masks each field to its width and packs them into a 32-bit word. Examples: packHeader(0xA,0x5A,0xFFFFF) -> 0xA5AFF","explanation":"## Why This Is Asked\n\nTests the ability to pack multiple fields into a single word, a common task in serialization and network protocols. It emphasizes precise bit-width handling and avoiding branches.\n\n## Key Concepts\n\n- Bitwise masking\n- Bit shifts\n- Field packing into a 32-bit word\n\n## Code Example\n\n```javascript\nfunction packHeader(version, flags, length) {\n  return ((version & 0x0F) << 28) | ((flags & 0xFF) << 20) | (length & 0xFFFFF);\n}\n```\n\n## Follow-up Questions\n\n- How would you extract version, flags, and length from the header?\n- How would you validate inputs to prevent overflow or sign issues in languages with signed integers?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Instacart"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T05:45:01.004Z","createdAt":"2026-01-17T05:45:01.004Z"},{"id":"q-3354","question":"In a 64-bit word, four 16-bit channels are packed as R (bits 0-15), G (16-31), B (32-47), A (48-63). Implement a function swapR_B(uint64_t v) that returns a new 64-bit value with R and B swapped using only bitwise operations and shifts (no loops/conditionals). Provide the signature and a brief justification, plus 1-2 quick examples?","answer":"Signature: uint64_t swapR_B(uint64_t v); Approach: isolate channels with masks, then rearrange: r = v & 0x000000000000FFFF; g = v & 0x00000000FFFF0000; b = v & 0x0000FFFF00000000; a = v & 0xFFFF000000","explanation":"## Why This Is Asked\nTests ability to reason about 64-bit field layouts and perform cross-field moves without branches, a common pattern in graphics and encoding pipelines.\n\n## Key Concepts\n- Bit masking for 16-bit lanes\n- Cross-lane permutation with shifts\n- No loops/branches; constant-time operations\n\n## Code Example\n```c\nuint64_t swapR_B(uint64_t v) {\n  uint64_t r = v & 0x000000000000FFFFULL;\n  uint64_t g = v & 0x00000000FFFF0000ULL;\n  uint64_t b = v & 0x0000FFFF00000000ULL;\n  uint64_t a = v & 0xFFFF000000000000ULL;\n  return (r << 32) | g | (b >> 32) | a;\n}\n```\n\n## Follow-up Questions\n- How would you extend to swap G and A as well? \n- Analyze performance implications on 64-bit architectures with compiler optimizations.","diagram":"flowchart TD\n  Start[Start] --> MaskR[Mask R]\n  MaskR --> MoveR[Move R to B pos]\n  MoveR --> MaskB[Mask B]\n  MaskB --> MoveB[Move B to R pos]\n  MoveB --> Combine[Combine parts]\n  Combine --> End[End: swapped value]","difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","NVIDIA","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T13:11:34.538Z","createdAt":"2026-01-17T13:11:34.538Z"},{"id":"q-3372","question":"Implement nextGen64(uint64_t board) that applies one Life tick on an 8x8 toroidal grid. Bit i maps to cell (row=i/8, col=i%8) in row-major order. Return the next board as uint64_t. Use only bitwise operations and shifts; no loops or conditionals?","answer":"Strategy: generate eight neighbor boards with toroidal wrap (N,S,E,W,NE,NW,SE,SW); accumulate counts per cell using carry-save style addition across 64-bit lanes; then apply Life rules in parallel: ne","explanation":"## Why This Is Asked\n\nTests advanced bitboard manipulation with wrap-around. It probes staying within a single integer lane and performing per-cell logic without branching.\n\n## Key Concepts\n\n- Bitboard neighbor computation\n- Toroidal wrapping masks\n- Parallel counting of 1s\n- Bitwise rule application\n\n## Code Example\n\n```javascript\n// skeleton: compute N,S,E,W,NE,NW,SE,SW; accumulate in 3-bit per-cell counters; derive next\n```\n\n## Follow-up Questions\n\n- How would you scale to a 16x16 board while maintaining performance?\n- What micro-optimizations would you apply to reduce instruction count on 64-bit CPUs?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Hugging Face","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T13:46:13.692Z","createdAt":"2026-01-17T13:46:13.693Z"},{"id":"q-3507","question":"Implement a function isPowerOfTwo128(uint64_t hi, uint64_t lo) that returns 1 if the 128-bit value formed by hi:lo has exactly one bit set (is a power of two), else 0. Use only bitwise operations and shifts (no loops or conditionals). Provide the signature and a brief justification, plus 1–2 quick test examples?","answer":"Proposed solution: treat 128-bit value as hi:lo. It is a power of two iff exactly one half is nonzero and that half has a single 1 bit. Compute: return (hi==0) ^ (lo==0) && ((hi==0) ? ((lo & (lo-1))==","explanation":"Why This Is Asked\\n\\nAssesses ability to reason about 128-bit values and apply bit-twiddling without branching. This requires cross-half logic and edge-case handling.\\n\\nKey Concepts\\n- 128-bit decomposition into hi and lo\\n- a 64-bit value is a power of two if v & (v-1) == 0 and v != 0\\n- exactly one half nonzero implies overall power-of-two only if that half is itself a power of two\\n\\nCode Example\\n\\n```c\\nuint8_t isPowerOfTwo128(uint64_t hi, uint64_t lo) {\\n  // Exactly one half must be nonzero and that half must be a power of two\\n  int hiPow = (hi & (hi - 1)) == 0 && hi != 0;\\n  int loPow = (lo & (lo - 1)) == 0 && lo != 0;\\n  return ((hi == 0) ^ (lo == 0)) ? (hi ? hiPow : loPow) : 0;\\n}\\n```\\n\\nFollow-up Questions\\n- How would you optimize for a specific CPU architecture (e.g., using intrinsics)?\\n- How would you extend this to 256-bit values?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Apple","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T19:25:52.784Z","createdAt":"2026-01-17T19:25:52.784Z"},{"id":"q-3562","question":"Given a 128-bit value split into hi and lo, implement a rotate-left by k bits (0 <= k < 128) that returns new hi/lo using only bitwise operations and shifts, with no loops or conditionals. Provide the function signature and a brief justification, and include 1-2 quick edge-case examples?","answer":"The optimal solution uses a 128-bit intermediate value. First combine the hi and lo parts: `v = ((__uint128_t)hi << 64) | lo;`. Then mask the rotation count: `k &= 127;`. Finally perform the rotation: `r = (v << k) | (v >> (128 - k));`. Extract the results: `out_hi = (uint64_t)(r >> 64); out_lo = (uint64_t)r;`. This approach uses only bitwise operations and shifts with no loops or conditionals.","explanation":"## Why This Is Asked\n\nThis question tests cross-boundary bit manipulation and 128-bit arithmetic, which are fundamental skills in cryptography and high-performance kernel development. It also evaluates the ability to implement rotation operations without branching logic.\n\n## Key Concepts\n\n- 128-bit rotation across two 64-bit limbs\n- Using a single 128-bit intermediate simplifies boundary handling\n- Edge-case handling via rotation count masking (eliminates branches)\n\n## Code Example\n\n```cpp\nvoid rotl128(uint64_t hi, uint64_t lo, unsigned int k, uint64_t *out_hi, uint64_t *out_lo) {\n  __uint128_t v = ((__uint128_t)hi << 64) | lo;\n  k &= 127;\n  __uint128_t r = (v << k) | (v >> (128 - k));\n  *out_hi = (uint64_t)(r >> 64);\n  *out_lo = (uint64_t)r;\n}\n```\n\n## Edge Cases\n\n- `k = 0`: Returns original value unchanged\n- `k = 64`: Swaps hi and lo parts completely","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","OpenAI","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T05:45:19.754Z","createdAt":"2026-01-17T21:31:52.928Z"},{"id":"q-3602","question":"Implement parity128 for a 128-bit value stored as hi and lo: the function returns 1 if the total number of set bits across hi and lo is odd, otherwise 0. Use only bitwise operations and shifts; no loops or conditionals. Provide the function signature and a brief justification. Include 1–2 quick sanity checks (e.g., 0x0/0x0 -> 0; 0x1/0x0 -> 1)?","answer":"uint8_t parity128(uint64_t hi, uint64_t lo) { uint64_t p = hi ^ lo; p ^= p >> 32; p ^= p >> 16; p ^= p >> 8; p ^= p >> 4; p ^= p >> 2; p ^= p >> 1; return (uint8_t)(p & 1); } Branchless, O(1); works for any 128-bit input","explanation":"## Why This Is Asked\nTests ability to reduce a 128-bit input to a single bit using only shifts and XORs, a common low-level optimization pattern. It emphasizes branchless, predictable timing.\n\n## Key Concepts\n- XOR folding to accumulate parity across halves\n- Branchless, constant-time bitwise manipulation\n- Handling 128-bit input via hi/lo halves without loops\n\n## Code Example\n```javascript\nfunction parity128(hi, lo) {\n  let p = hi ^ lo;\n  p = p ^ (p >>> 32);\n  p = p ^ (p >>> 16);\n  p = p ^ (p >>> 8);\n  p = p ^ (p >>> 4);\n  p = p ^ (p >>> 2);\n  p = p ^ (p >>> 1);\n  return p & 1;\n}\n```\n\n## Follow-up Questions\n- How would you adapt this for 256-bit values?\n- What's the performance impact of using XOR vs. addition for parity?\n- Can you implement this using only addition and subtraction?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T05:29:48.928Z","createdAt":"2026-01-17T23:28:05.127Z"},{"id":"q-3864","question":"Given a 64-bit unsigned integer n, implement swapAdjacent64 that returns a value with each bit pair swapped (bit 0 <-> bit 1, bit 2 <-> bit 3, ..., bit 62 <-> bit 63) using only bitwise operations and shifts, no loops or conditionals. Provide the function signature, a short justification, and 1-2 quick examples?","answer":"uint64_t swapAdjacent64(uint64_t n) { const uint64_t E = 0x5555555555555555ULL; const uint64_t O = 0xAAAAAAAAAAAAAAAAULL; return ((n & E) << 1) | ((n & O) >> 1); } Handling all 64 bits by two masks an","explanation":"## Why This Is Asked\n\nThis tests precise bit-twiddling with non-trivial masks and no loops, a common optimization pattern.\n\n## Key Concepts\n\n- Mask construction for adjacent-bit swaps\n- Two-shift strategy and one return\n- Edge cases: 64-bit boundaries, unsigned masking\n\n## Code Example\n\n```c\nuint64_t swapAdjacent64(uint64_t n) {\n  const uint64_t E = 0x5555555555555555ULL;\n  const uint64_t O = 0xAAAAAAAAAAAAAAAAULL;\n  return ((n & E) << 1) | ((n & O) >> 1);\n}\n```\n\n## Follow-up Questions\n\n- How would you generalize to swap every 3-bit group? \n- What are the performance implications on modern CPUs?","diagram":"flowchart TD\n  A[Input: n] --> B[Mask even bits: 0x5555555555555555]\n  B --> C[Mask odd bits: 0xAAAAAAAAAAAAAAAA]\n  C --> D[Compute swapped: ((n & 0x5555555555555555) << 1) | ((n & 0xAAAAAAAAAAAAAAAA) >> 1)]\n  D --> E[Return]","difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","IBM","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T13:06:03.462Z","createdAt":"2026-01-18T13:06:03.462Z"},{"id":"q-3966","question":"Implement rotate-left by k bits for a 32-bit unsigned integer using only bitwise operations and shifts. Provide the function signature and a branch-free solution that handles k in 0..31. Explain why it works and show 1-2 quick examples?","answer":"uint32_t rotl32(uint32_t n, unsigned int k) { k &= 31u; return (n << k) | (n >> ((32u - k) & 31u)); } This wraps around cleanly even for k=0. Example: rotl32(0x80000001,1) -> 0x00000003; rotl32(0x1234","explanation":"## Why This Is Asked\nThis question tests bitwise rotation understanding and safe shift-wrapping without branches. It ensures candidates reason about edge cases and mask arithmetic to keep shifts within range.\n\n## Key Concepts\n- Bitwise rotation\n- Shift masking to avoid UB\n- Edge-case handling for k=0\n\n## Code Example\n```javascript\nfunction rotl32(n, k) {\n  k = k & 31;\n  return (n << k) | (n >>> ((32 - k) & 31));\n}\n```\n\n## Follow-up Questions\n- How would you generalize to 64-bit?\n- Why is masking with 31 important for correctness and portability?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Goldman Sachs"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T17:36:10.679Z","createdAt":"2026-01-18T17:36:10.679Z"},{"id":"q-3983","question":"Implement a 3D Morton code function morton3D(uint32_t x, uint32_t y, uint32_t z) -> uint64_t that interleaves the bits of x,y,z so that bit i of x goes to bit 3i, bit i of y to 3i+1, and bit i of z to 3i+2 for i=0..20. Use only bitwise operations and shifts (no loops or conditionals). Assume each input uses only the lower 21 bits. Context: spatial indexing for voxel data in a 3D engine?","answer":"Use a 3D bit spreader: split each input into bits spaced by two zeros, then OR with shifted versions. code: sx = part1by2(x); sy = part1by2(y); sz = part1by2(z); return sx | (sy<<1) | (sz<<2). Example","explanation":"## Why This Is Asked\nTests knowledge of deeper bit-manipulation: 3D Morton ordering for spatial indexing, with no loops and tight constants.\n\n## Key Concepts\n- Morton (z-order) encoding across 3 dimensions\n- bit spreading (part1by2) with masks/shifts\n- avoiding branches for tight hot-paths\n\n## Code Example\n```javascript\nfunction part1by2(n){\n  let x = BigInt(n) & 0x1fffffn;\n  x = (x | (x << 32n)) & 0x1f00000000ffffn;\n  x = (x | (x << 16n)) & 0x1f0000ff0000ffn;\n  x = (x | (x << 8n))  & 0x100f00f00f00f00fn;\n  x = (x | (x << 4n))  & 0x10c30c30c30c30c3n;\n  x = (x | (x << 2n))  & 0x1249249249249249n;\n  return x;\n}\nfunction morton3D(x,y,z){\n  return part1by2(x) | (part1by2(y) << 1n) | (part1by2(z) << 2n);\n}\n```\n\n## Follow-up Questions\n- How would you adapt to 32-bit inputs? Trade-offs?\n- Could you implement a inverse decode that recovers x,y,z from the code?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","MongoDB","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T18:43:50.237Z","createdAt":"2026-01-18T18:43:50.238Z"},{"id":"q-4116","question":"Implement a 32-bit rotate-left function rotl32(uint32_t n, unsigned int k) that rotates n left by k bits (i.e., bits shifted out on the left wrap around to the right). Use only bitwise operations and shifts, no loops or conditionals. Provide the function signature, a short justification, and 1-2 quick examples?","answer":"One correct approach: normalize k to 0..31 with k &= 31; then rotate left as (n << k) | (n >>> (32 - k)); cast to 32-bit unsigned. This uses only shifts and OR, handles k=0 (no change) and k=32 (wraps to original value).","explanation":"## Why This Is Asked\nTests knowledge of bit tricks and boundary handling for 32-bit values. Rotations require combining shifted parts without branching.\n\n## Key Concepts\n- Bitwise rotation using shifts\n- Modulo behavior for bit widths\n- Signed vs unsigned handling in C/JS contexts\n\n## Code Example\n```javascript\nfunction rotl32(n, k) {\n  k = k & 31; // 0..31\n  return ((n << k) | (n >>> (32 - k))) >>> 0;\n}\n```\n\n## Follow-up Questions\n- How would you implement rotl64 in C for uint64_t, ensuring performance on common compilers?\n- Could you map this to intrinsic functions (e.g., __builtin_rotate) on supported platforms?","diagram":"flowchart TD\n  Start[Input: n, k]\n  Clamp[Clamp k to 0..31]\n  Compute[Compute (n << k) | (n >>> (32 - k))]\n  Return[Return result]\n  Start --> Clamp --> Compute --> Return","difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Instacart","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T05:09:41.609Z","createdAt":"2026-01-19T02:49:43.091Z"},{"id":"q-4136","question":"Implement rotateLeft32(n, k) that rotates a 32-bit value n left by k positions using only bitwise operations and shifts (no loops or conditionals). Use a 32-bit unsigned interpretation and ensure k is treated modulo 32. Provide the function signature, a brief justification, and 1-2 quick examples?","answer":"Use k = k & 31; return ((n << k) | (n >>> ((-k) & 31))) >>> 0; This rotates within 32 bits and handles k=0 without undefined shifts. Example: rotateLeft32(0x12345678, 4) -> 0x23456781; rotateLeft32(0x","explanation":"## Why This Is Asked\nTests knowledge of bitwise rotations, a common low-level operation, and handling edge cases when k wraps around 32 without using branches. It also demonstrates how to make shifts robust against k=0 or k=31.\n\n## Key Concepts\n- Bitwise rotation using shifts and OR\n- Modulo wrapping using masking and two's complement tricks\n- Avoiding undefined shifts for k=0\n\n## Code Example\n```javascript\nfunction rotateLeft32(n, k) {\n  k = k & 31;\n  return ((n << k) | (n >>> ((-k) & 31))) >>> 0;\n}\n```\n\n## Follow-up Questions\n- How would you adapt for rotateRight32?\n- How would you test boundary cases with k=0 and k=31?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T04:39:48.146Z","createdAt":"2026-01-19T04:39:48.146Z"},{"id":"q-4148","question":"Context: In a high-performance network filter, a 64-bit mask denotes enabled features. Implement lsbIndex64(uint64_t n) that returns the index (0-63) of the least significant set bit in n, assuming n != 0. Use only bitwise operations and shifts; no loops or conditional branches. Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"Use a De Bruijn sequence: isolate LSB with v & -v, multiply by 0x03f79d71b4cb0a01, then take the top 6 bits as an index into a 64-entry table. This yields a branchless, O(1) solution for 64-bit inputs","explanation":"## Why This Is Asked\nThis evaluates mastery of branchless bit tricks and fast bit-scanning techniques essential in performance-critical code like network filtering.\n\n## Key Concepts\n- Branchless bit manipulation\n- De Bruijn sequences for bit scanning\n- Bit isolation via v & -v\n- Lookup tables for constant-time indexing\n\n## Code Example\n```javascript\nuint64_t lsbIndex64(uint64_t v) {\n  static const uint64_t debruijn = 0x03f79d71b4cb0a01ULL;\n  static const int index64[64] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n  return index64[(v & -v) * debruijn >> 58];\n}\n```\n\n## Follow-up Questions\n- How would you extend this to 128-bit values?\n- How would you handle the 0 input safely in a constant-time manner?\n","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Coinbase"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T05:39:38.404Z","createdAt":"2026-01-19T05:39:38.404Z"},{"id":"q-4193","question":"Implement rotateLeft32(uint32_t n, uint32_t k) that rotates n left by k positions. Use only bitwise operations and shifts, no loops or conditionals. Normalize k to 0..31 and return (n << kk) | (n >> ((32 - kk) & 31)). Provide the function signature and brief justification, plus 1-2 quick examples?","answer":"rotl32(uint32_t n, uint32_t k) { uint32_t kk = k & 31; return (n << kk) | (n >> ((32 - kk) & 31)); } This uses only bitwise ops, handles k=0 safely, and avoids undefined shifts. Examples: rotl32(0x800","explanation":"## Why This Is Asked\nTests understanding of bitwise rotation, a common low-level primitive in systems and cryptography. \n\n## Key Concepts\n- Bitwise rotation vs shift\n- Normalizing k with k & 31\n- Safe shifts using (32 - kk) & 31 to avoid 32-bit shifts\n\n## Code Example\n\n```c\nuint32_t rotl32(uint32_t n, uint32_t k) {\n  uint32_t kk = k & 31;\n  return (n << kk) | (n >> ((32 - kk) & 31));\n}\n```\n\n## Follow-up Questions\n- How would you adapt for 64-bit inputs?\n- What are potential compiler/target differences in shifts?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T07:07:21.491Z","createdAt":"2026-01-19T07:07:21.491Z"},{"id":"q-4436","question":"Write a 64-bit function nextBitPermutation64(uint64_t x) that returns the next higher number with the same popcount as x, or 0 if none; implement using only bitwise operations and shifts, with no loops or conditionals. Provide the signature and a brief rationale, plus 1-2 quick examples?","answer":"Approach uses the snoob trick: smallest = x & -x; ripple = x + smallest; ones = x ^ ripple; ones = (ones >> 2) / smallest; next = ripple | ones. This yields the next higher value with the same popcoun","explanation":"## Why This Is Asked\nDemonstrates mastery of fixed-popcount permutations. Tests carry propagation and ability to explain a one-shot solution without loops.\n\n## Key Concepts\n- Snoob algorithm for next with same popcount\n- Carry ripple and bitwise masks\n- Edge-case handling for zero or maximal permutations\n\n## Code Example\n```c\nstatic inline uint64_t nextBitPermutation64(uint64_t x) {\n    // Assumes x != 0 and not the maximal permutation for its popcount\n    uint64_t smallest = x & -x;\n    uint64_t ripple = x + smallest;\n    uint64_t ones = x ^ ripple;\n    ones = (ones >> 2) / smallest;\n    return ripple | ones;\n}\n```\n\n## Follow-up Questions\n- How would you adapt to arbitrary bit-widths?\n- Compare this approach to a loop-based generator in terms of performance and readability.","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T18:57:34.444Z","createdAt":"2026-01-19T18:57:34.444Z"},{"id":"q-4455","question":"In a 32-bit bitmap of flags, implement a function uint32_t popcount32(uint32_t n) that returns the number of 1-bits using only bitwise operations and shifts, with no loops or conditionals. Provide the function signature, a brief justification, and 1-2 quick examples?","answer":"Use the classic parallel bit-counting method: n = n - ((n>>1) & 0x55555555); n = (n & 0x33333333) + ((n>>2) & 0x33333333); n = (n + (n>>4)) & 0x0F0F0F0F; return (n * 0x01010101) >> 24; Example: popcou","explanation":"## Why This Is Asked\n\nTests understanding of compact bit-twiddling techniques to count bits without loops, a common interview staple for performance-critical code.\n\n## Key Concepts\n\n- Parallel bit counting (SIMD-style within a register)\n- Bit masks and shifts for aggregation\n- Portability across unsigned integers and compilers\n\n## Code Example\n\n```c\nuint32_t popcount32(uint32_t n) {\n  n = n - ((n >> 1) & 0x55555555);\n  n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n  n = (n + (n >> 4)) & 0x0F0F0F0F;\n  return (n * 0x01010101) >> 24;\n}\n```\n\n## Follow-up Questions\n\n- How would you extend to 64-bit?  \n- What tests would you add to verify edge cases (all zeros, all ones, random patterns)?","diagram":"flowchart TD\n  A[Start] --> B[Apply n - ((n>>1)&mask57)]\n  B --> C[Apply pairs mask]\n  C --> D[Apply n + (n>>4) and mask]\n  D --> E[Multiply and shift to get count]\n  E --> F[Return count]","difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Goldman Sachs","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T19:41:03.169Z","createdAt":"2026-01-19T19:41:03.170Z"},{"id":"q-4575","question":"In a 32-bit unsigned integer context, implement a rotate-left function rotl32(n, k) that shifts n left by k bits and wraps the high bits around to the low end. Do not use loops or conditionals. Provide the signature, a brief justification, and 1-2 concrete examples?","answer":"uint32_t rotl32(uint32_t n, unsigned int k) { return (n << k) | (n >> ((32 - k) & 31)); } Rationale: Pure bitwise operations with a masked right shift ensure no undefined shifts when k=0. Examples: rotl32(0x12345678, 4) = 0x23456781, rotl32(0x80000000, 1) = 0x00000001","explanation":"## Why This Is Asked\nTests understanding of bitwise rotation, edge-case safety, and avoiding branches.\n\n## Key Concepts\n- Bitwise shifts and OR to wrap bits\n- Masking to avoid undefined behavior with 0\n- Avoiding loops/conditionals in low-level operations\n\n## Code Example\n```c\nuint32_t rotl32(uint32_t n, unsigned int k) {\n  return (n << k) | (n >> ((32 - k) & 31));\n}\n```\n\n## Follow-up Questions\n- How would you generalize to 64-bit width?\n- How would you test boundary cases k=0 and k=31?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Discord","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T05:57:44.867Z","createdAt":"2026-01-20T02:26:53.749Z"},{"id":"q-4829","question":"Implement bitpack64(uint64_t v, uint64_t mask) that compresses bits from v selected by mask into the least-significant bits, preserving the relative order of those bits (i.e., the i-th set bit in mask maps to bit i in the result). Use only bitwise operations and shifts; no loops or conditionals. Provide the signature and a brief justification, plus 1-2 examples?","answer":"Use the fixed cascade compression (PDEP/compact) sequence: x = v & mask; x = (x ^ (x >> 1)) & 0x5555555555555555; x = (x ^ (x >> 2)) & 0x3333333333333333; x = (x ^ (x >> 4)) & 0x0F0F0F0F0F0F0F0F; x = ","explanation":"## Why This Is Asked\nTests non-branching bit-twiddling and packing/unpacking across a mask, a common performance pattern in high-throughput code.\n\n## Key Concepts\n- Bit masks and order-preserving packing\n- Non-branching compression via cascade masks\n- Fixed-sequence bit-manipulation tricks\n\n## Code Example\n```javascript\nfunction bitpack64(v, mask){\n  let x = v & mask;\n  x = (x ^ (x >> 1n)) & 0x5555555555555555n;\n  x = (x ^ (x >> 2n)) & 0x3333333333333333n;\n  x = (x ^ (x >> 4n)) & 0x0F0F0F0F0F0F0F0Fn;\n  x = (x ^ (x >> 8n)) & 0x00FF00FF00FF00FFn;\n  x = (x ^ (x >> 16n)) & 0x0000FFFF0000FFFFn;\n  x = (x ^ (x >> 32n)) & 0x00000000FFFFFFFFn;\n  return x;\n}\n```\n\n## Follow-up Questions\n- How would you extend to support dynamic masks without recompilation?\n- Compare performance with a loop-based approach on large data sets.","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Discord","Hugging Face"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T15:10:48.399Z","createdAt":"2026-01-20T15:10:48.399Z"},{"id":"q-4883","question":"Implement a 3D Morton code generator morton3D(uint32_t x, uint32_t y, uint32_t z) that interleaves the lower 21 bits of x, y, and z into a 63-bit code: bit i of x becomes bit 3i, bit i of y becomes bit 3i+1, bit i of z becomes bit 3i+2. Use only bitwise operations and shifts; no loops or conditionals. Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"3D Morton code: interleave the lower 21 bits of x, y, z into a 63-bit value. Use a branchless dilate-by-2 technique (part1by2) to spread bits, then code = part1by2(x) | (part1by2(y) << 1) | (part1by2(","explanation":"## Why This Is Asked\n3D Morton codes enable fast spatial indexing in grid-like domains; a branchless, fixed-bit spreading approach scales predictably. \n\n## Key Concepts\n- Morton codes for 3D require interleaving bits from three coordinates.\n- Bit spreading (dilating) inserts two zero bits between each original bit; a fixed sequence of masks/shifts yields a branchless implementation.\n- BigInt vs. Number in JavaScript: use BigInt for 64-bit results if implementing in JS; otherwise 64-bit types in C/C++ handle it natively.\n\n## Code Example\n```javascript\nfunction part1by2(n) {\n  let x = BigInt(n) & 0x1fffffn; // 21 bits\n  x = (x | (x << 32n)) & 0x1f00000000ffffn;\n  x = (x | (x << 16n)) & 0x1f0000ff0000ffn;\n  x = (x | (x << 8n)) & 0x100f00f00f00f00fn;\n  x = (x | (x << 4n)) & 0x10c30c30c30c30c3n;\n  x = (x | (x << 2n)) & 0x1249249249249249n;\n  return x;\n}\nfunction morton3D(x, y, z) {\n  return part1by2(x) | (part1by2(y) << 1n) | (part1by2(z) << 2n);\n}\n```\n\n## Follow-up Questions\n- How would you verify correctness for random inputs? \n- How to adapt to larger coordinates or alternative word sizes?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Salesforce","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T17:40:26.518Z","createdAt":"2026-01-20T17:40:26.518Z"},{"id":"q-5004","question":"Implement rotate-left for 32-bit unsigned integers: rotl32(uint32_t n, unsigned k) returns n rotated left by k bits in a 32-bit space, using only bitwise operations and shifts. Assume 0 <= k < 32. Provide the signature, a brief justification, and 1-2 quick examples?","answer":"rotl32(n,k) = (n << k) | (n >> (32 - k)); This is valid for 0 <= k < 32; uses two shifts and an OR, wrapping around high bits. Examples: rotl32(0x80000001, 1) = 0x00000003; rotl32(0x12345678, 4) = 0x23456781","explanation":"## Why This Is Asked\nTests ability to compose shifts and OR to implement rotate without loops or conditionals, a common low-level operation.\n\n## Key Concepts\n- Bitwise shifts and wrap-around semantics\n- 32-bit boundary, undefined behavior avoidance\n- Performance and portability considerations\n\n## Code Example\n\n```javascript\nfunction rotl32(n, k) {\n  return ((n << k) | (n >>> (32 - k))) >>> 0;\n}\n```\n\n## Follow-up Questions\n- What happens if k === 0? How does the expression evaluate?\n- How would you implement rotate-right similarly?\n- How would you adapt for 64-bit values in a language without native unsigned support?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Oracle","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-21T05:43:02.465Z","createdAt":"2026-01-20T23:34:11.401Z"},{"id":"q-5099","question":"Given a 128-bit value represented as two 64-bit halves hi and lo, implement parity128 that returns 1 if the total number of 1 bits across both halves is odd, or 0 otherwise. Use only bitwise operations and shifts, with no loops or conditionals. Provide the function signature: int parity128(uint64_t hi, uint64_t lo);?","answer":"Compute parity128 by folding across both halves: x = hi ^ lo; then reduce x with x ^= x >> 32; x ^= x >> 16; x ^= x >> 8; x ^= x >> 4; return x & 1;. This is branchless and uses parity properties: par","explanation":"## Why This Is Asked\n\nTests cross-word bit ops and branchless parity reduction. It exercises combining two 64-bit halves and a compact reduction, scalable to wider architectures.\n\n## Key Concepts\n\n- Parity via XOR folding\n- 128-bit composition hi^lo\n- Branchless reductions\n\n## Code Example\n\n```c\nint parity128(uint64_t hi, uint64_t lo) {\n  uint64_t x = hi ^ lo;\n  x ^= x >> 32;\n  x ^= x >> 16;\n  x ^= x >> 8;\n  x ^= x >> 4;\n  return x & 1;\n}\n```\n\n## Follow-up Questions\n\n- How would you extend to a 256-bit value?  - Can you adapt this for streaming parity on large data chunks?\n","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Microsoft","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T05:57:23.016Z","createdAt":"2026-01-21T05:57:23.016Z"},{"id":"q-5347","question":"Implement swapAdjacentNibbles64 to swap every pair of adjacent 4-bit nibbles in a 64-bit unsigned value. Use only bitwise operations and shifts; no loops or conditionals. Provide the function signature and a brief justification. Include 1-2 quick tests?","answer":"uint64_t swapAdjacentNibbles64(uint64_t x){ const uint64_t lo=0x0F0F0F0F0F0F0F0FULL; const uint64_t hi=0xF0F0F0F0F0F0F0F0ULL; return ((x & lo) << 4) | ((x & hi) >> 4); } // Tests: swapAdjacentNibbles6","explanation":"Why This Is Asked: validates use of precise bit-packing tricks and non-branching transformations. Key: isolate even/odd nibbles with masks, shift, and combine. Edge cases include all-zero and alternating patterns. The approach scales to other word sizes by adjusting masks.","diagram":"flowchart TD\n  A[Input x] --> B[Mask with 0x0F0F0F0F0F0F0F0F and 0xF0F0F0F0F0F0F0F0]\n  B --> C[Shift left 4, shift right 4]\n  C --> D[OR together to form result]\n  D --> E[Return result]","difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","OpenAI","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T19:01:45.668Z","createdAt":"2026-01-21T19:01:45.668Z"},{"id":"q-5598","question":"In a streaming sensor context, a 32-bit unsigned word is expected to alternate bits (0101... or 1010...). Implement hasAlternatingBits(uint32_t n) that returns true if n has alternating bits, using only bitwise operations and shifts (no loops). Provide the signature, a brief justification, and 1-2 quick examples?","answer":"Uses a standard trick: collapse the alternating pattern with x = n ^ (n >>> 1); if x is 2^k - 1, bits alternate. In 32-bit, test (x & (x + 1)) == 0. Ensure unsigned wrap with >>>. Example: 0x55555555 ","explanation":"## Why This Is Asked\nAssesses pattern recognition and solid bit-twiddling under time pressure.\n\n## Key Concepts\n- Alternating bit patterns (0101..., 1010...)\n- Using XOR with shifted version to collapse pattern\n- Detecting all-ones masks with (x & (x+1)) == 0\n\n## Code Example\n```javascript\nfunction hasAlternatingBits(n) {\n  const x = (n ^ (n >>> 1)) >>> 0;\n  return (x & (x + 1)) === 0;\n}\n```\n\n## Follow-up Questions\n- How would you adapt for 64-bit inputs?\n- How to implement without using addition?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","LinkedIn","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T07:51:06.851Z","createdAt":"2026-01-22T07:51:06.851Z"},{"id":"q-5698","question":"Given a 64-bit unsigned integer x, implement countTrailingZeros64(x) that returns the number of trailing zero bits in x. Use only bitwise operations and shifts (no loops or conditionals) and a de Bruijn sequence; return 64 if x is 0. Provide the function signature and a brief justification?","answer":"To count trailing zeros, isolate the least significant set bit with v = x & -x. Map v to an index using a 64-entry de Bruijn table: index = (v * 0x03f79d71b4cb0a89ULL) >> 58; return debruijn[index], w","explanation":"## Why This Is Asked\n- Tests knowledge of bit tricks and avoiding branches in hot paths.\n- Probes whether the candidate can implement a classic de Bruijn based trailing-zero counter.\n\n## Key Concepts\n- Bitwise arithmetic, two's complement negation, de Bruijn indexing, handling x==0.\n\n## Code Example\n```javascript\nunsigned int countTrailingZeros64(uint64_t x) {\n    if (x == 0) return 64;\n    static const int debruijn64[64] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                                    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n                                    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n                                    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63};\n    uint64_t v = x & -x;\n    return debruijn64[(v * 0x03f79d71b4cb0a89ULL) >> 58];\n}\n```\n\n## Follow-up Questions\n- How would you modify for 32-bit inputs?\n- Compare this to using built-ins like __builtin_ctzll in terms of portability and code size.","diagram":"flowchart TD\n  A[Input: x] --> B{x == 0?}\n  B -- Yes --> C[Return 64]\n  B -- No --> D[Compute v = x & -x]\n  D --> E[Index = (v * 0x03f79d71b4cb0a89ULL) >> 58]\n  E --> F[Return debruijn[index]]","difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Instacart","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T11:45:02.158Z","createdAt":"2026-01-22T11:45:02.158Z"},{"id":"q-5775","question":"Implement parity64(uint64_t x) that returns 1 if x has an odd number of set bits, otherwise 0, using only bitwise operations and shifts (no loops or conditionals). Provide the signature and a short justification, plus 1-2 quick examples?","answer":"Use fold-and-XOR to collapse bit parity: x ^= x >> 32; x ^= x >> 16; x ^= x >> 8; x ^= x >> 4; return (0x6996 >> (x & 0xF)) & 1; This runs in O(1) and avoids branches. Examples: parity64(0x1) = 1; par","explanation":"## Why This Is Asked\nTests understanding of efficient bit-hacks and how to compute parity without loops or branching, which is common in performance-critical systems.\n\n## Key Concepts\n- Bit folding using XOR and shifts to aggregate bit information\n- Constant-time parity methods and small lookup tables\n- Branchless implementation for predictable performance\n\n## Code Example\n```javascript\nuint64_t parity64(uint64_t x) {\n  x ^= x >> 32;\n  x ^= x >> 16;\n  x ^= x >> 8;\n  x ^= x >> 4;\n  return (0x6996 >> (x & 0xF)) & 1;\n}\n```\n\n## Follow-up Questions\n- How would you adapt for 128-bit values?\n- Compare with using builtin parity intrinsics in terms of portability and performance.","diagram":"flowchart TD\n  A[Input: x] --> B{x != 0?}\n  B -- Yes --> C[Fold: x ^= x>>32; x^= x>>16; x^= x>>8; x^= x>>4;]\n  C --> D[Compute parity: (0x6996 >> (x&0xF)) & 1]\n  D --> E[Return 0/1]\n  B -- No --> F[Return 0]\n  style A fill:#f9f,stroke:#333,stroke-width:1px\n  style B fill:#fff,stroke:#333,stroke-width:1px\n  style C fill:#e6f,stroke:#333,stroke-width:1px\n  style D fill:#e6f,stroke:#333,stroke-width:1px\n  style E fill:#fff,stroke:#333,stroke-width:1px\n  style F fill:#fff,stroke:#333,stroke-width:1px","difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","Instacart","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T16:03:52.585Z","createdAt":"2026-01-22T16:03:52.585Z"},{"id":"q-5882","question":"In a 64-bit word representing an 8x8 bitboard (bit 0..7 row0, ..., bit 56..63 row7), implement rotate90_8x8(uint64_t board) that returns the board rotated clockwise by 90 degrees. Use only bitwise operations and shifts; no loops or conditionals. Provide the signature and a brief justification, plus 1-2 quick examples?","answer":"Rotate an 8x8 bitboard clockwise by 90 degrees using only bitwise ops, not loops or branches. Treat the 64-bit word as an 8x8 matrix; perform an in‑place 8×8 transpose via a fixed sequence of block sw","explanation":"## Why This Is Asked\n\nTests ability to design complex, branchless bitboard operations; rotating an 8x8 grid requires a full matrix transpose plus a final mirror, which is nontrivial and commonly used in games/graphics.\n\n## Key Concepts\n\n- Branchless bit-twiddling\n- 8x8 matrix transpose via block swaps\n- Row/column permutation\n\n## Code Example\n\n```javascript\nfunction rotate90_8x8(board){\n  let t = board;\n  // 6-stage in-place transpose using block swaps with masks (omitted details)\n  // Mirror rows to complete rotation\n  // (implementation details omitted)\n  return t;\n}\n```\n\n## Follow-up Questions\n\n- How would you generalize to 16x16 or arbitrary N?\n- What micro-optimizations exist for different CPU architectures?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Netflix","Salesforce","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T20:46:52.651Z","createdAt":"2026-01-22T20:46:52.651Z"},{"id":"q-5914","question":"Implement nextPermutation64(uint64_t v) that returns the next higher 64-bit value with the same number of set bits in binary (same popcount), using only bitwise operations and shifts (no loops or conditionals). If no such number exists, return 0. Signature: uint64_t nextPermutation64(uint64_t v); Provide 1-2 quick examples: nextPermutation64(3) -> 5; nextPermutation64(0x8000000000000000) -> 0?","answer":"Use the snoob (successor of next higher number with same bit count) algorithm. If v is 0 or all-ones, return 0. Let c = v & -v; ripple = v + c; ones = v ^ ripple; next = ripple | ((ones >> 2) / c); return next & 0xFFFFFFFFFFFFFFFF.","explanation":"## Why This Is Asked\nTests deep knowledge of bit manipulation techniques for combinatorial enumeration without branching.\n\n## Key Concepts\n- Next higher number with same popcount (snoob algorithm)\n- Handling 64-bit overflow with masking\n- Pure bitwise operations and shifts only\n- Edge cases are constant-time checks\n\n## Code Example\n```javascript\nfunction nextPermutation64(v) {\n  const MASK = (1n << 64n) - 1n;\n  if (v === 0n || v === MASK) return 0n;\n  const c = v & -v;\n  const ripple = v + c;\n  const ones = v ^ ripple;\n  const next = ripple | ((ones >> 2n) / c);\n  return next & MASK;\n}\n```","diagram":"flowchart TD\n  A[Input v (64-bit)] --> B[Compute smallest = v & -v]\n  B --> C[Compute ripple = v + smallest]\n  C --> D[Compute ones = v ^ ripple]\n  D --> E[Compute next = ripple | ((ones >> 2) / smallest)]\n  E --> F[Mask to 64 bits and return]\n","difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Discord","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T05:53:47.356Z","createdAt":"2026-01-22T21:51:55.440Z"},{"id":"q-5938","question":"Given a 128-bit value stored as two 64-bit words hi and lo, implement isolateLeastBit128 that outputs only the least significant 1 bit of the 128-bit value across out_hi and out_lo; if the input is zero, both outputs must be zero. Use only bitwise operations and shifts (no loops or conditionals). Provide the function signature and a brief approach, with 1-2 quick examples?","answer":"To isolate the least significant set bit in a 128-bit value stored as hi and lo words, compute lo_lsb = lo & -lo and hi_lsb = hi & -hi. Use branchless masking: nonzero_lo = -(lo != 0), zero_lo = -(lo == 0). Then *out_lo = lo_lsb & nonzero_lo and *out_hi = hi_lsb & zero_lo. When input is zero, both outputs become zero.","explanation":"## Why This Is Asked\nThis evaluates your ability to extend bit manipulation techniques to multi-register data structures while maintaining branchless performance.\n\n## Key Concepts\n- Two's complement negation for 64-bit words\n- Isolating least significant set bit with x & -x\n- Branchless masking using arithmetic on boolean predicates\n\n## Code Example\n```javascript\nvoid isolateLeastBit128(uint64_t hi, uint64_t lo, uint64_t *out_hi, uint64_t *out_lo) {\n  uint64_t lo_lsb = lo & -lo;\n  uint64_t hi_lsb = hi & -hi;\n  uint64_t nonzero_lo = -(lo != 0);\n  uint64_t zero_lo = -(lo == 0);\n  *out_lo = lo_lsb & nonzero_lo;\n  *out_hi = hi_lsb & zero_lo;\n}\n```\n\n## Example\nInput: hi=0x8000, lo=0x0C00 → Output: out_hi=0x0000, out_lo=0x0400\nInput: hi=0x0000, lo=0x0000 → Output: out_hi=0x0000, out_lo=0x0000","diagram":"flowchart TD\n  A[Start] --> B{lo != 0}\n  B -- Yes --> C[out_lo = lo & -lo; out_hi = 0]\n  B -- No --> D[out_lo = 0; out_hi = hi & -hi]\n  C --> E[Done]\n  D --> E","difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Plaid","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T05:39:51.690Z","createdAt":"2026-01-22T22:48:02.799Z"},{"id":"q-5968","question":"Implement nextBitPermutation64(uint64_t x) that, given a 64‑bit word with k set bits, returns the next higher value with the same k set bits, or 0 if none. Use only bitwise operations and shifts; no loops or conditionals. Signature: uint64_t nextBitPermutation64(uint64_t x); Provide 1–2 small examples to illustrate?","answer":"Use the canonical Snoob trick: `smallest = x & -x; ripple = x + smallest; ones = ripple & -ripple; next = ripple | (((ones ^ ripple) >> 2) / smallest); return next;` If no higher permutation exists for the given bit pattern, the function returns 0.","explanation":"## Why This Is Asked\n\nTests knowledge of advanced bit-twiddling for permutation of set bits. Evaluates ability to craft constant-time logic without loops and to reason about edge cases of the last permutation.\n\n## Key Concepts\n\n- Next higher permutation with fixed popcount\n- Edge-case handling (max permutation -> 0)\n- Pure bitwise operations and shifts; no loops or branches\n- Efficient 64-bit handling and overflow behavior\n\n## Code Example\n\n```javascript\nuint64_t nextBitPermutation64(uint64_t x) {\n  uint64_t smallest = x & -x;\n  uint64_t ripple = x + smallest;\n  uint64_t ones = ripple & -ripple;\n  uint64_t next = ripple | (((ones ^ ripple) >> 2) / smallest);\n  return next;\n}\n```\n\n## Examples\n\n- `nextBitPermutation64(0b0011)` returns `0b0101` (next permutation with 2 set bits)\n- `nextBitPermutation64(0b1100)` returns `0b10000` (next permutation with 2 set bits)\n- `nextBitPermutation64(0b111000)` returns `0b1000011` (next permutation with 3 set bits)","diagram":"flowchart TD\n  A[Input x] --> B[Compute smallest = x & -x]\n  B --> C[Compute ripple = x + smallest]\n  C --> D[Compute ones = ripple & -ripple]\n  D --> E[Compute next = ripple | (((ones ^ ripple) >> 2) / smallest)]\n  E --> F[Return next or 0 if no higher permutation]","difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Snap","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T05:02:44.537Z","createdAt":"2026-01-22T23:53:09.164Z"},{"id":"q-6043","question":"Implement rotateLeft32(uint32_t n, uint32_t k) to rotate a 32-bit unsigned integer n left by k bits. No loops or conditionals; normalize k with k &= 31. Provide the function signature, a short justification, and 1-2 quick examples?","answer":"Signature: uint32_t rotateLeft32(uint32_t n, uint32_t k); Normalize k: k &= 31. Return: (n << k) | (n >> (32 - k)). This uses only shifts and OR and handles k=0 gracefully. Examples: rotateLeft32(0x12","explanation":"## Why This Is Asked\nThis question tests understanding of bitwise rotations, a common low-level operation, using only non-branching bitwise operators. It ensures candidates normalize k and recognize wrap-around semantics for unsigned types.\n\n## Key Concepts\n- Bitwise shifts and OR for rotation\n- Normalizing rotation amount with 31 mask\n- Unsigned arithmetic avoids UB on shifts\n\n## Code Example\n```cpp\nuint32_t rotateLeft32(uint32_t n, uint32_t k) {\n  k &= 31;\n  return (n << k) | (n >> (32 - k));\n}\n```\n\n## Follow-up Questions\n- How would this change for rotateRight32 or 64-bit width?\n- What are edge-case tests you’d add (e.g., k=0, k=31)?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T06:47:37.856Z","createdAt":"2026-01-23T06:47:37.859Z"},{"id":"q-6135","question":"Implement a function swapEndian32(uint32_t n) that returns n with its byte order reversed (endianness swap). Use only bitwise operations and shifts—no loops or conditionals. Provide the signature, a short justification, and 1-2 quick examples?","answer":"uint32_t swapEndian32(uint32_t n) { return (n >> 24) | ((n >> 8) & 0x0000FF00) | ((n << 8) & 0x00FF0000) | (n << 24); } Example: 0x01234567 -> 0x67452301; 0xAABBCCDD -> 0xDDCCBBAA.","explanation":"## Why This Is Asked\nEndianness is a practical concern in systems and networking. This question tests precise bit-twiddling with masks and shifts, without relying on loops. It also checks understanding of how a 32-bit word maps to byte positions.\n\n## Key Concepts\n- Byte extraction with masks\n- Shifting to relocate bytes\n- Endianness awareness and portability\n- No loops; pure bitwise operations\n\n## Code Example\n```c\nuint32_t swapEndian32(uint32_t n) {\n  return (n >> 24) | ((n >> 8) & 0x0000FF00) | ((n << 8) & 0x00FF0000) | (n << 24);\n}\n```\n\n## Follow-up Questions\n- How would you generalize to 64-bit values?\n- How would you implement an endianness swap for 16-bit values or for an array of 32-bit words efficiently?","diagram":"flowchart TD\n  A[Input: 32-bit n] --> B[Mask & extract bytes]\n  B --> C[Shift bytes to swapped positions]\n  C --> D[OR results into final value]\n  D --> E[Return swapped value]","difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T10:12:29.096Z","createdAt":"2026-01-23T10:12:29.096Z"},{"id":"q-6147","question":"Given a 32-bit unsigned integer n, implement hasAlternatingBits(n) that returns 1 if all adjacent bit pairs alternate (0101... or 1010...), and 0 otherwise. Use only bitwise operations and shifts, no loops or conditionals. Provide the signature and a brief justification, plus 1-2 quick examples?","answer":"A robust pattern check uses n ^ (n >> 1) to detect alternation. If adjacent bits differ, the result's lower 31 bits are all 1s. Compute t = n ^ (n >> 1); return ((t & 0x7FFFFFFF) == 0x7FFFFFFF) ? 1 : ","explanation":"## Why This Is Asked\n\nThis question tests deriving a pure bitwise predicate for a regular pattern without branches.\n\n## Key Concepts\n- XOR of adjacent bits flags changes\n- Masking with 0x7FFFFFFF resolves MSB ambiguity\n- 32-bit unsigned arithmetic and portability\n\n## Code Example\n```c\nint hasAlternatingBits(uint32_t n) {\n  uint32_t t = n ^ (n >> 1);\n  return (t & 0x7FFFFFFF) == 0x7FFFFFFF;\n}\n```\n\n## Follow-up Questions\n- How would you extend to 64-bit inputs?\n- What tests would you add for edge cases (MSB variations)?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Scale Ai","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T10:56:17.987Z","createdAt":"2026-01-23T10:56:17.987Z"},{"id":"q-6197","question":"In a 64-bit bitmap, implement a function nextWithSameBitCount(uint64_t x) that returns the next higher number with the same number of set bits. Do this without loops or conditionals, using only bitwise operations and shifts. If no such number exists (x==0 or x is all ones), return x. Provide the implementation and 1-2 quick examples?","answer":"Use the Snoob trick: uint64_t nextWithSameBitCount(uint64_t x){ uint64_t smallest = x & -x; uint64_t ripple = x + smallest; uint64_t ones = x ^ ripple; ones = (ones >> 2) / smallest; return ripple | o","explanation":"## Why This Is Asked\n\nTests the ability to derive a compact, branch-free bit-twisting routine for combinatorial generation.\n\n## Key Concepts\n\n- Next permutation with fixed popcount via snoob\n- Branchless 64-bit arithmetic and overflow behavior\n- Edge-case handling in tests\n\n## Code Example\n\n```javascript\nuint64_t nextWithSameBitCount(uint64_t x){\n  uint64_t smallest = x & -x;\n  uint64_t ripple = x + smallest;\n  uint64_t ones = x ^ ripple;\n  ones = (ones >> 2) / smallest;\n  return ripple | ones;\n}\n```\n\n## Follow-up Questions\n\n- How would you adapt for arbitrary precision (128-bit) using two limbs?\n- How would you detect when no next permutation exists efficiently?","diagram":"flowchart TD\n  A[Input x] --> B[smallest = x & -x]\n  B --> C[ripple = x + smallest]\n  C --> D[ones = x ^ ripple]\n  D --> E[ones = (ones >> 2) / smallest]\n  E --> F[next = ripple | ones]","difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Tesla","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T13:40:54.700Z","createdAt":"2026-01-23T13:40:54.700Z"},{"id":"q-6206","question":"Implement rotateLeft64(uint64_t n, unsigned int k) that rotates a 64-bit word left by k bits. Use only bitwise operations and shifts; no loops or conditionals. Provide the function signature and ensure it handles 0 <= k < 64, including k=0 without undefined shifts. Example: rotateLeft64(0x0123456789ABCDEF, 8) -> 0x23456789ABCDEF01.?","answer":"uint64_t rotateLeft64(uint64_t n, unsigned int k) { unsigned int s = k & 63; return (n << s) | (n >> ((0 - s) & 63)); } This branchless approach masks k to [0,63] and uses (0 - s) & 63 to compute 64 -","explanation":"## Why This Is Asked\nTests the ability to implement a core low-level primitive in a branchless, edge-case-safe way, a common requirement in bitboard games, crypto utilities, and high-performance kernels.\n\n## Key Concepts\n- Bitwise rotation semantics (wraps around word).\n- Safe shifts with modulo-64 trick: ((0 - s) & 63).\n- Branchless implementation for predictable performance.\n\n## Code Example\n```javascript\nuint64_t rotateLeft64(uint64_t n, unsigned int k) {\n  unsigned int s = k & 63;\n  return (n << s) | (n >> ((0 - s) & 63));\n}\n```\n\n## Follow-up Questions\n- How would you generalize to 128-bit words?\n- What are potential portability concerns across compilers regarding shift behavior?","diagram":"flowchart TD\n  A[Start] --> B[Mask k: s = k & 63]\n  B --> C[Compute: (n << s) | (n >> ((0 - s) & 63))]\n  C --> D[Return result]\n  D --> E[End]","difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Scale Ai","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T14:37:32.141Z","createdAt":"2026-01-23T14:37:32.141Z"},{"id":"q-6434","question":"Design a constant-time 64-bit popcount function that counts set bits in a 64-bit unsigned integer using only bitwise operations and shifts, with no loops or conditionals and no CPU intrinsics. Provide the signature and a short justification of the method, plus 1-2 quick example inputs/outputs?","answer":"Use the parallel bit-count (Hamming weight) method. 1) x = x - ((x >> 1) & 0x5555555555555555); 2) x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333); 3) x = (x + (x >> 4)) & 0x0F0F0F0F0F0F0F0F; 4) return (x * 0x0101010101010101) >> 56;","explanation":"## Why This Is Asked\nTests mastery of bit-twiddling and performance, ensuring implementation without branching or CPU intrinsics.\n\n## Key Concepts\n- Population count (Hamming weight) via parallel reduction\n- 64-bit masks and overflow-safe multiplications\n- No loops or branches\n\n## Code Example\n```c\nuint64_t popcount64(uint64_t x) {\n  x = x - ((x >> 1) & 0x5555555555555555ULL);\n  x = (x & 0x3333333333333333ULL) + ((x >> 2) & 0x3333333333333333ULL);\n  x = (x + (x >> 4)) & 0x0F0F0F0F0F0F0F0FULL;\n  return (x * 0x0101010101010101ULL) >> 56;\n}\n```\n\n## Examples\n- Input: `0b10101010` (170) → Output: `4`\n- Input: `0xFFFFFFFFFFFFFFFF` → Output: `64`","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","NVIDIA","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T05:00:37.386Z","createdAt":"2026-01-23T23:51:37.153Z"},{"id":"q-6484","question":"Given a 128-bit unsigned integer represented as two 64-bit halves hi and lo, implement a function popcount128(uint64_t hi, uint64_t lo) that returns the total number of set bits in the 128-bit value. Use only bitwise operations and shifts (no loops or conditionals). Provide the function signature and a brief justification, and include 1-2 quick edge-case examples?","answer":"Use a branchless 64-bit popcount kernel on hi and lo, then sum. Implement 64-bit popcount with the standard masks: x = x - ((x>>1)&0x5555555555555555ULL); x = (x & 0x3333333333333333ULL) + ((x>>2)&0x3","explanation":"## Why This Is Asked\nTests extending known 64-bit tricks to 128-bit values with branchless code.\n\n## Key Concepts\n- Branchless bit counting\n- 64-bit popcount kernel\n- Combining results across two words\n\n## Code Example\n```c\nstatic inline uint64_t popcount64(uint64_t x){\n  x -= (x >> 1) & 0x5555555555555555ULL;\n  x = (x & 0x3333333333333333ULL) + ((x >> 2) & 0x3333333333333333ULL);\n  x = (x + (x >> 4)) & 0x0F0F0F0F0F0F0F0FULL;\n  return (x * 0x0101010101010101ULL) >> 56;\n}\n\nuint8_t popcount128(uint64_t hi, uint64_t lo){\n  return (uint8_t)(popcount64(hi) + popcount64(lo));\n}\n```\n\n## Follow-up Questions\n- How would you adapt this for SIMD/vectorized paths?\n- How would you test correctness across random 128-bit inputs?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Google","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T04:21:21.860Z","createdAt":"2026-01-24T04:21:21.860Z"},{"id":"q-6740","question":"Implement int isPalindrome64(uint64_t n) that returns 1 if the 64-bit word reads the same left-to-right as right-to-left (bit i equals bit 63-i for all i), using only bitwise operations and shifts. Do not use loops or conditionals. Provide the function signature, a brief justification of approach, and 1-2 quick examples?","answer":"Compute a full 64-bit reversal with SWAR: swap adjacent bits, then 2-, 4-, 8-, 16-bit blocks using masks 0x5555555555555555, 0x3333333333333333, 0x0F0F0F0F0F0F0F0F, 0x00FF00FF00FF00FF, 0x0000FFFF0000F","explanation":"## Why This Is Asked\nTests ability to design branchless bit tricks for palindrome detection on 64-bit values, a common bitboard problem.\n\n## Key Concepts\n- SWAR-based bit reversal\n- Branchless boolean results\n- Fixed-width masking patterns\n\n## Code Example\n\n```javascript\nfunction reverse64(n) {\n  n = ((n >> 1n) & 0x5555555555555555n) | ((n & 0x5555555555555555n) << 1n);\n  n = ((n >> 2n) & 0x3333333333333333n) | ((n & 0x3333333333333333n) << 2n);\n  n = ((n >> 4n) & 0x0F0F0F0F0F0F0F0Fn) | ((n & 0x0F0F0F0F0F0F0F0Fn) << 4n);\n  n = ((n >> 8n) & 0x00FF00FF00FF00FFn) | ((n & 0x00FF00FF00FF00FFn) << 8n);\n  n = ((n >> 16n) & 0x0000FFFF0000FFFFn) | ((n & 0x0000FFFF0000FFFFn) << 16n);\n  n = (n >> 32n) | (n << 32n);\n  return n;\n}\nfunction isPalindrome64(n) {\n  return reverse64(n) === n;\n}\n```","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","NVIDIA","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T15:33:37.683Z","createdAt":"2026-01-24T15:33:37.683Z"},{"id":"q-680","question":"Given a 32-bit unsigned int n, implement a function hasAdjacentOnes(n) that returns true if n contains any two consecutive 1 bits (for example 0b1100100 has adjacent ones). Use only bitwise operations, no loops or lookups. Explain the core trick in a sentence?","answer":"Return (n & (n >> 1)) != 0. Shifting n right by 1 aligns any adjacent 1s, and ANDing with the original yields a nonzero value iff at least one adjacent pair exists. This is O(1) and uses only bitwise ","explanation":"## Why This Is Asked\n\nAssess practical bit-manipulation intuition and ability to leverage canonical tricks for constant-time checks in real code paths.\n\n## Key Concepts\n\n- Bit tricks: (x & (x >> 1)) detects adjacent 1s\n- Complexity: O(1), no loops\n- Edge cases: 0, power-of-two inputs\n\n## Code Example\n\n```javascript\nfunction hasAdjacentOnes(n) {\n  return (n & (n >> 1)) !== 0;\n}\n```\n\n## Follow-up Questions\n\n- How would you extend this to detect at least k consecutive 1s?\n- How would you adapt for signed 32-bit integers and two's complement behavior?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Oracle","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T15:57:26.049Z","createdAt":"2026-01-11T15:57:26.049Z"},{"id":"q-689","question":"Given a 32-bit unsigned integer n, implement a function isSingleEvenBitSet(n) that returns true if exactly one bit is set and that bit lies at an even index (0, 2, 4, ...). Use only bitwise operations, no loops or built-in helpers. Provide the expression and a brief justification, plus a couple of quick examples?","answer":"Use (n != 0) && ((n & (n-1)) == 0) && ((n & 0x55555555) != 0). The first two checks ensure a single set bit (power of two), and the last check verifies the bit is at an even position since 0x55555555 ","explanation":"## Why This Is Asked\n\nThis question tests precise bit-level reasoning and avoids expensive operations in tight loops, useful in storage engines and query optimizers.\n\n## Key Concepts\n\n- Single-set-bit test: (n & (n-1)) == 0\n- Even-index bit mask: 0x55555555\n- Combining tests with boolean logic for a robust check\n\n## Code Example\n\n```javascript\nfunction isSingleEvenBitSet(n) {\n  return n !== 0 && (n & (n - 1)) === 0 && (n & 0x55555555) !== 0;\n}\n```\n\n## Follow-up Questions\n\n- How would you generalize to check exactly k bits set?\n- How would you adapt to 64-bit width and different bit-ordering considerations?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","MongoDB","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T16:23:21.467Z","createdAt":"2026-01-11T16:23:21.467Z"},{"id":"q-6910","question":"Implement a function parity32(uint32_t n) that returns 1 if the number of set bits in n is odd and 0 otherwise, using only bitwise operations and shifts (no loops or conditionals)?","answer":"Fold the bits using XOR reductions: n ^= n >> 16; n ^= n >> 8; n ^= n >> 4; n ^= n >> 2; n ^= n >> 1; return n & 1; This achieves O(1) time complexity while preserving parity through XOR folding.","explanation":"## Why This Is Asked\nTests compact, branch-free parity calculation using classic bit-twiddling techniques.\n\n## Key Concepts\n- Parity calculation through XOR folding\n- Bitwise shifts and XOR operations\n- Elimination of loops and conditional branches\n\n## Code Example\n```javascript\nfunction parity32(n) {\n  n ^= n >>> 16;\n  n ^= n >>> 8;\n  n ^= n >>> 4;\n  n ^= n >>> 2;\n  n ^= n >>> 1;\n  return n & 1;\n}\n```\n\n## Follow-up Questions\n- How would you extend this implementation to 64-bit parity calculation?\n- Design an approach for computing streaming parity over a byte array?","diagram":"flowchart TD\nA[Input 32-bit n] --> B[XOR folds: n ^= n>>16]\nB --> C[XOR: n ^= n>>8]\nC --> D[XOR: n ^= n>>4]\nD --> E[XOR: n ^= n>>2]\nE --> F[XOR: n ^= n>>1]\nF --> G[Return n & 1]","difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Square","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T05:55:48.214Z","createdAt":"2026-01-24T22:33:37.005Z"},{"id":"q-698","question":"Implement a 32-bit unsigned integer function popcount32(n) that returns the number of set bits in n using only bitwise operations and shifts, with no loops or built-ins. Use the SWAR (SIMD Within A Register) technique: apply a sequence of masks and shifts (0x55555555, 0x33333333, 0x0F0F0F0F) and a final multiply to consolidate counts. Provide the function and a brief justification, plus a couple of quick examples?","answer":"Use SWAR (SIMD Within A Register) to count bits in a 32-bit value without loops. Steps: x = x >>> 1 & 0x55555555; x = x - x; x = (x & 0x33333333) + ((x >>> 2) & 0x33333333); x = (x + (x >>> 4)) & 0x0F","explanation":"## Why This Is Asked\n\n- Tests ability to implement a canonical bit-counting trick without loops, emphasizing constant-time operations. \n- Demonstrates careful use of masks and shifts to aggregate counts across bit groups.\n\n## Key Concepts\n\n- SWAR (parallel bit counting)\n- Bit masks 0x55555555, 0x33333333, 0x0F0F0F0F\n- Constant-time arithmetic with shifts\n\n## Code Example\n\n```javascript\nfunction popcount32(x) {\n  x = x - ((x >>> 1) & 0x55555555);\n  x = (x & 0x33333333) + ((x >>> 2) & 0x33333333);\n  x = (x + (x >>> 4)) & 0x0F0F0F0F;\n  return (x * 0x01010101) >>> 24;\n}\n```\n\n## Follow-up Questions\n\n- How would you adapt to 64-bit inputs?\n- Compare this approach to using hardware popcount instructions in terms of portability and performance.","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T17:18:07.873Z","createdAt":"2026-01-11T17:18:07.873Z"},{"id":"q-6998","question":"Implement reverseBitsInBytes64(uint64_t n) that reverses the bits inside each 8-bit byte of n, while preserving byte order. Use only bitwise operations and shifts, no loops or conditionals. In a high-throughput binary-diffing pipeline, this per-byte reversal improves diffusion without changing layout. Provide the function signature, a brief justification, and 1-2 quick examples?","answer":"Signature: uint64_t reverseBitsInBytes64(uint64_t n); Approach: apply a fixed mask/shift sequence to reverse bits within every byte in parallel, keeping byte positions intact. This is branchless and c","explanation":"## Why This Is Asked\n\nIn high-throughput diffing pipelines, diffusion-boosting byte-wise bit reversal can be done with a fixed, branchless sequence, testing mastery of multi-stage bit manipulations.\n\n## Key Concepts\n\n- Parallel bit-twiddling across 8-byte lanes\n- Masks: 0x0F0F0F0F0F0F0F0F, 0x3333333333333333, 0x5555555555555555\n- Branchless, constant-time operations\n\n## Code Example\n\n```javascript\nfunction reverseBitsInBytes64(n) {\n  n = ((n >>> 4n) | (n << 4n)) & 0x0F0F0F0F0F0F0F0Fn;\n  n = ((n >>> 2n) & 0x3333333333333333n) | ((n & 0x3333333333333333n) << 2n);\n  n = ((n >>> 1n) & 0x5555555555555555n) | ((n & 0x5555555555555555n) << 1n);\n  return n;\n}\n```\n\n## Follow-up Questions\n\n- How would you test edge cases (0, all ones, alternating patterns)?\n- How does endianness affect results across platforms?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T04:34:10.690Z","createdAt":"2026-01-25T04:34:10.690Z"},{"id":"q-7031","question":"Implement rotateLeft64(uint64_t x, unsigned int k) that returns x rotated left by k bits, using only shifts and bitwise operators (no loops or conditionals). Normalize k with k % 64. Provide the function signature and a brief justification, and give 1-2 quick edge-case examples?","answer":"Use a standard rotate formula: reduce k to 0..63 with k &= 63, then return (x << k) | (x >> ((64 - k) & 63)). For example, x=0x0123456789ABCDEF, k=8 yields 0x23456789ABCDEF01; k=0 returns x; k=32 swap","explanation":"## Why This Is Asked\nTests precise bit-twiddling without branches; validates wraparound understanding and constant-time composition.\n\n## Key Concepts\n- Bitwise rotation (circular shift)\n- Modulo reduction via masking (k & 63)\n- Safe right-shift with masking to avoid undefined behavior\n\n## Code Example\n```javascript\nuint64_t rotateLeft64(uint64_t x, unsigned int k) {\n  k &= 63;\n  return (x << k) | (x >> ((64 - k) & 63));\n}\n```\n\n## Follow-up Questions\n- How would you implement rotateRight64 using the same pattern?\n- How would you vectorize this for an array of 64-bit words using SIMD intrinsics?","diagram":"flowchart TD\n  A[Input: x, k] --> B[Normalize k: k & 63]\n  B --> C[Compute left: x << k]\n  B --> D[Compute right: x >> ((64 - k) & 63)]\n  C --> E[Merge: (left) | (right)]\n  D --> E\n  E --> F[Output: rotated value]","difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Microsoft","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T06:49:09.447Z","createdAt":"2026-01-25T06:49:09.448Z"},{"id":"q-705","question":"Implement reverseBits32(n) that reverses all 32 bits in a 32-bit unsigned integer using only a fixed sequence of bitwise operations (no loops or conditionals). Use a SWAR-style approach with masks 0x55555555, 0x33333333, 0x0F0F0F0F and 0x00FF00FF, finishing with a 16-bit half-swap. Provide the function signature and a brief justification, plus a couple of quick examples?","answer":"ReverseBits32 uses a fixed, loop-free SWAR sequence. Swap adjacent bits with 0x55555555, then swap pairs with 0x33333333, then nibbles with 0x0F0F0F0F, then bytes with 0x00FF00FF, and finally swap 16-","explanation":"## Why This Is Asked\nFresh bit-hack that demonstrates mastery of fixed-step SWAR technique and portability across languages.\n\n## Key Concepts\n- SWAR fixed-masks and staged swaps\n- Bitwise rotation-free reversal\n- Unsigned 32-bit wrap handling in JavaScript/TypeScript\n\n## Code Example\n```javascript\nfunction reverseBits32(n) {\n  n = ((n >>> 1) & 0x55555555) | ((n & 0x55555555) << 1);\n  n = ((n >>> 2) & 0x33333333) | ((n & 0x33333333) << 2);\n  n = ((n >>> 4) & 0x0F0F0F0F) | ((n & 0x0F0F0F0F) << 4);\n  n = ((n >>> 8) & 0x00FF00FF) | ((n & 0x00FF00FF) << 8);\n  n = (n >>> 16) | (n << 16);\n  return n >>> 0;\n}\n```\n\n## Follow-up Questions\n- How would you adapt this for 64-bit integers in languages with 64-bit ops?\n- How to verify correctness with quick property tests (e.g., n reversing twice yields n)?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T18:28:46.088Z","createdAt":"2026-01-11T18:28:46.088Z"},{"id":"q-711","question":"In a network packet parser, a 32-bit field uses trailing-zero count to encode the length of a value. Given a 32-bit unsigned n, implement countTrailingZeros32(n) that returns the number of trailing zero bits (0-32). If n==0, return 32. Use only bitwise operations, shifts, and basic arithmetic, no loops or built-ins. Provide signature, brief justification, and 1-2 quick examples?","answer":"Use a de Bruijn sequence to map the least-significant 1 to its trailing-zero count. If n==0 return 32. Let v = n & -n; idx = (v * 0x077CB531) >> 27; tz = debruijn[idx]. This uses only bitwise ops and ","explanation":"## Why This Is Asked\nTests knowledge of fast, branchless bit tricks and constant-time bit-scanning utilities common in high-performance systems.\n\n## Key Concepts\n- Isolating least-significant 1: v = n & -n\n- De Bruijn-based indexing: map a 5-bit index to a trailing-zero count\n- Handling edge case n == 0 (return 32)\n- Static lookup table of 32 entries\n\n## Code Example\n```c\nuint32_t countTrailingZeros32(uint32_t n){\n  static const int debruijn[32] = {0,1,28,2,29,14,24,3,30,22,20,15,25,17,4,8,31,27,13,23,21,19,16,7,26,12,18,9,6,11,5,10};\n  if(n == 0) return 32;\n  uint32_t v = n & -n;\n  return debruijn[(v * 0x077CB531) >> 27];\n}\n```\n\n## Follow-up Questions\n- How would you adapt this for 64-bit inputs?\n- What are alternatives that avoid a static table, e.g., using binary search on bit groups?","diagram":"flowchart TD\n  A[n]\n  B{n == 0}\n  C[return 32]\n  D[v = n & -n]\n  E[idx = (v * 0x077CB531) >> 27]\n  F[tz = debruijn[idx]]\n  G[return tz]\n  A --> B\n  B -- yes --> C\n  B -- no --> D\n  D --> E\n  E --> F\n  F --> G","difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T19:16:13.404Z","createdAt":"2026-01-11T19:16:13.404Z"},{"id":"q-7134","question":"Given two 128-bit unsigned integers represented as hi/lo 64-bit halves, implement add128 that computes their sum into out_hi/out_lo without using loops or conditionals beyond arithmetic. Provide the function signature and a brief justification, plus 1-2 quick test cases?","answer":"Implement add128 to sum two 128-bit integers stored as hi/lo halves. Signature: void add128(uint64_t a_hi, uint64_t a_lo, uint64_t b_hi, uint64_t b_lo, uint64_t *out_hi, uint64_t *out_lo); Compute lo ","explanation":"## Why This Is Asked\nTests ability to perform multi-word arithmetic with pure bitwise/arith operations, handling carry without branches.\n\n## Key Concepts\n- 128-bit arithmetic via two 64-bit halves\n- Carry propagation using unsigned overflow properties\n- Branchless computation\n\n## Code Example\n```c\nvoid add128(uint64_t a_hi, uint64_t a_lo, uint64_t b_hi, uint64_t b_lo, uint64_t *out_hi, uint64_t *out_lo){\n  uint64_t lo = a_lo + b_lo;\n  uint64_t carry = (lo < a_lo);\n  uint64_t hi = a_hi + b_hi + carry;\n  *out_hi = hi;\n  *out_lo = lo;\n}\n```\n\n## Follow-up Questions\n- How would you extend this to 256-bit operands?\n- What are the potential pitfalls on platforms with different endianness?","diagram":"flowchart TD\n  A[Input A hi/lo] --> B[Input B hi/lo]\n  B --> C[Compute lo = A lo + B lo]\n  C --> D[Compute carry = lo < A lo]\n  D --> E[Compute hi = A hi + B hi + carry]\n  E --> F[Output hi/lo]","difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Coinbase","DoorDash"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T10:38:46.680Z","createdAt":"2026-01-25T10:38:46.680Z"},{"id":"q-724","question":"In memory allocation, implement nextPowerOfTwo32(uint32_t n) that returns the smallest 32-bit unsigned power-of-two >= n, given n > 0, using only bitwise operations with no loops or conditionals. If the result would overflow 32 bits, return 0. What is the correct implementation signature and approach?","answer":"Branchless, constant-time trick. Use a fixed-width prefix fill: n--; n |= n >> 1; n |= n >> 2; n |= n >> 4; n |= n >> 8; n |= n >> 16; return n + 1. Works for all n>0; overflow (n>0x80000000) yields 0","explanation":"## Why This Is Asked\n\n- Demonstrates ability to replace branches with bit-twiddling for performance.\n- Applies a well-known, portable technique to a common memory-allocation problem.\n- Handles edge cases and overflow without loops.\n\n## Key Concepts\n- Prefix-fill trick to propagate the highest set bit.\n- Branchless arithmetic to compute next power of two.\n- Overflow behavior on 32-bit boundaries.\n\n## Code Example\n\n```c\nuint32_t nextPowerOfTwo32(uint32_t n) {\n  // Assumes n > 0. No explicit branches.\n  n--;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  return n + 1;\n}\n```\n\n## Follow-up Questions\n- How does this behave for n = 0x80000000 or 0xFFFFFFFF?\n- Can you adapt this to 64-bit inputs with no loops?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","IBM","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T20:24:38.993Z","createdAt":"2026-01-11T20:24:38.994Z"},{"id":"q-7267","question":"Implement parity128(hi, lo) that returns 1 if the 128-bit value has an odd number of set bits. In a crypto/block-processing pipeline, quickly derive parity for a 128-bit block without loops. Signature: int parity128(uint64_t hi, uint64_t lo); Use only bitwise shifts and XORs. Provide 1-2 quick examples?","answer":"One approach: parity128(hi,lo) returns 1 for odd popcount. Compute x = hi ^ lo; then fold to 1 bit with x ^= x >> 32; x ^= x >> 16; x ^= x >> 8; x ^= x >> 4; x ^= x >> 2; x ^= x >> 1; return x & 1; Co","explanation":"## Why This Is Asked\n\nThe parity check is a common error-detection primitive in data blocks and crypto pipelines. This task tests ability to perform a full 128-bit reduction with pure bitwise ops, no branches, and constant time.\n\n## Key Concepts\n\n- 128-bit value represented as hi/lo.\n- Parity reduction via XOR folding.\n- Branchless implementation for performance.\n\n## Code Example\n\n```javascript\nint parity128(uint64_t hi, uint64_t lo) {\n  uint64_t x = hi ^ lo;\n  x ^= x >> 32;\n  x ^= x >> 16;\n  x ^= x >> 8;\n  x ^= x >> 4;\n  x ^= x >> 2;\n  x ^= x >> 1;\n  return (int)(x & 1);\n}\n```\n\n## Follow-up Questions\n\n- How would you adapt parity128 for native 128-bit ints on platforms with __int128?\n- What are the trade-offs if you can't rely on unsigned shifts across all compilers?","diagram":"flowchart TD\n  A[Input: hi, lo] --> B[Compute x = hi ^ lo]\n  B --> C[Fold to 1 bit with x ^= x >> 32]\n  C --> D[Further fold with >>16, >>8, >>4, >>2, >>1]\n  D --> E[Return x & 1]\n  E --> F[Parity result (0 or 1)]","difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Google","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T15:53:20.537Z","createdAt":"2026-01-25T15:53:20.537Z"},{"id":"q-730","question":"Given a 32-bit unsigned integer n, implement swapAdjacentBits32(n) that returns a new 32-bit value with every adjacent bit pair swapped (bits 0-1, 2-3, ..., 30-31). Use only bitwise operations, no loops or conditionals. Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"Signature: uint32_t swapAdjacentBits32(uint32_t n);\\nApproach: res = ((n & 0x55555555) << 1) | ((n & 0xAAAAAAAA) >> 1); This is branchless and runs in constant time, swapping every adjacent bit pair. ","explanation":"## Why This Is Asked\nTests low-level bit twiddling discipline and production-ready, branchless code.\n\n## Key Concepts\n- Bit masks and shifts\n- Branchless algorithms\n- 32-bit edge handling\n\n## Code Example\n```\nuint32_t swapAdjacentBits32(uint32_t n) {\n  return ((n & 0x55555555) << 1) | ((n & 0xAAAAAAAA) >> 1);\n}\n```\n\n## Follow-up Questions\n- How would you extend to 64-bit inputs?\n- How would you test edge cases (0, all-ones) with unit tests?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Plaid","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T21:19:02.055Z","createdAt":"2026-01-11T21:19:02.055Z"},{"id":"q-738","question":"Implement a 64-bit bit reversal function reverse64(uint64_t n) that returns the bitwise reversal of n (bit 0 becomes bit 63, bit 63 becomes bit 0). Use only bitwise operations and shifts, no loops or conditionals. Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"Use a SWAR-style reversal: progressively swap 1-bit blocks, then 2-bit, 4-bit, etc., with masks (0x5555555555555555, 0x3333333333333333, 0x0F0F0F0F0F0F0F0F), then swap larger blocks and finally the tw","explanation":"## Why This Is Asked\nTests mastery of branchless, scalable bit-twiddling techniques for 64-bit inputs.\n\n## Key Concepts\n- SWAR style bit reversal\n- Masking and shifting sequences\n- Branchless algorithms for performance\n\n## Code Example\n```c\n#include <stdint.h>\n\nuint64_t reverse64(uint64_t n) {\n  n = ((n >> 1) & 0x5555555555555555ULL) | ((n & 0x5555555555555555ULL) << 1);\n  n = ((n >> 2) & 0x3333333333333333ULL) | ((n & 0x3333333333333333ULL) << 2);\n  n = ((n >> 4) & 0x0F0F0F0F0F0F0F0FULL) | ((n & 0x0F0F0F0F0F0F0F0FULL) << 4);\n  n = ((n >> 8) & 0x00FF00FF00FF00FFULL) | ((n & 0x00FF00FF00FF00FFULL) << 8);\n  n = ((n >> 16) & 0x0000FFFF0000FFFFULL) | ((n & 0x0000FFFF0000FFFFULL) << 16);\n  n = (n >> 32) | (n << 32);\n  return n;\n}\n```\n\n## Follow-up Questions\n- How would you optimize for smaller word sizes or specialized ISAs?\n- How would you adapt for 128-bit inputs and performance considerations?","diagram":"flowchart TD\n  A[Start: input n] --> B[Swap 1-bit blocks]\n  B --> C[Swap 2-bit blocks]\n  C --> D[Swap 4-bit blocks]\n  D --> E[Swap 8-bit blocks]\n  E --> F[Swap 16-bit blocks]\n  F --> G[Swap 32-bit halves]\n  G --> H[Return reversed n]","difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","MongoDB","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T22:20:40.030Z","createdAt":"2026-01-11T22:20:40.030Z"},{"id":"q-7469","question":"In a low-level bitboard parser, implement ctz64(uint64_t n) that returns the number of trailing zero bits in n, i.e., the index of the least-significant 1. If n == 0 return 64. Use only bitwise operations and shifts; no loops or conditionals. Provide the function signature and a brief justification, plus 1-2 quick examples.\n\n```c\nint ctz64(uint64_t n);\n```?","answer":"The implementation uses the de Bruijn sequence technique: if n == 0 return 64; isolate the least significant bit with t = n & -n; compute index = (t * 0x03f79d71b4cb0a01ULL) >> 58; then perform a 64-entry table lookup to obtain the position. This approach is branchless and operates in constant time.","explanation":"## Why This Is Asked\nAdvanced bit manipulation questions assess knowledge of branchless arithmetic and de Bruijn indexing techniques.\n\n## Key Concepts\n- Bit manipulation: isolating the least significant bit using two's complement arithmetic\n- De Bruijn sequence mapping for constant-time position lookup\n- Branchless, constant-time operations\n- Proper edge-case handling for n == 0\n\n## Code Example\n```c\nint ctz64(uint64_t n) {\n  // Implementation uses de Bruijn indexing\n  uint64_t t = n & -n;\n  // table[index] yields trailing-zero count\n  return table[(t * 0x03f79d71b4cb0a01ULL) >> 58];\n}\n```","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T05:34:30.399Z","createdAt":"2026-01-26T02:43:17.235Z"},{"id":"q-747","question":"Implement isBinaryPalindrome32(uint32_t n) that returns 1 if the 32-bit binary representation of n is a palindrome (bit0 equals bit31, bit1 equals bit30, etc.), and 0 otherwise. Use only bitwise operations and shifts; no loops or conditional branches. Provide the function signature and a brief justification, plus 1-2 quick examples.\n\nExamples:\n- 0x80000001 is a palindrome\n- 0xA5A5A5A5 is not a palindrome?","answer":"Reverse the 32 bits using a fixed sequence of mask/shift swaps (1,2,4,8,16 bit steps) and compare the result to the original. No loops or branches; returns 1 if n equals its reverse, else 0. Demonstra","explanation":"## Why This Is Asked\n\nTests the ability to implement a constant-time bit reversal to verify a binary palindrome using only bitwise ops.\n\n## Key Concepts\n\n- Palindrome property in binary\n- Bit-reversal networks with masks\n- Branch-free comparison\n\n## Code Example\n\n```javascript\n// C-like implementation (illustrative)\nint isBinaryPalindrome32(uint32_t n) {\n  uint32_t x = n;\n  x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);\n  x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);\n  x = ((x >> 4) & 0x0F0F0F0F) | ((x & 0x0F0F0F0F) << 4);\n  x = ((x >> 8) & 0x00FF00FF) | ((x & 0x00FF00FF) << 8);\n  x = (x >> 16) | (x << 16);\n  return (x == n);\n}\n```\n\n## Follow-up Questions\n\n- Extend to 64-bit inputs; what changes? \n- Compare against a loop-based reversal for performance tests.","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Google","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T23:20:55.546Z","createdAt":"2026-01-11T23:20:55.546Z"},{"id":"q-751","question":"Implement popcount64(uint64_t x) that returns the number of set bits in x using only bitwise operations and shifts, with no loops and no built-in popcount. Use a fixed SWAR approach with masks 0x5555555555555555ULL, 0x3333333333333333ULL, 0x0F0F0F0F0F0F0F0FULL and a final multiply/shift step. Provide the function signature and a brief justification, plus 1-2 quick examples of inputs and outputs?","answer":"One correct approach uses a fixed SWAR popcount: x = x - ((x>>1) & 0x5555555555555555ULL); x = (x & 0x3333333333333333ULL) + ((x>>2) & 0x3333333333333333ULL); x = (x + (x>>4)) & 0x0F0F0F0F0F0F0F0FULL;","explanation":"## Why This Is Asked\nTests ability to implement bit-twiddling without loops, using SWAR patterns for constant-time population count.\n\n## Key Concepts\n- SWAR (Small/Word-level Parallelism)\n- 64-bit masks and carry-free sums\n- No intrinsics or branches; deterministic performance\n\n## Code Example\n```javascript\nuint64_t popcount64(uint64_t x) {\n  x = x - ((x >> 1) & 0x5555555555555555ULL);\n  x = (x & 0x3333333333333333ULL) + ((x >> 2) & 0x3333333333333333ULL);\n  x = (x + (x >> 4)) & 0x0F0F0F0F0F0F0F0FULL;\n  return (x * 0x0101010101010101ULL) >> 56;\n}\n```\n\n## Follow-up Questions\n- How would you adapt this to count bits in 128-bit values? \n- What are the trade-offs vs. hardware popcnt instructions in modern CPUs?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","MongoDB","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T01:29:06.153Z","createdAt":"2026-01-12T01:29:06.153Z"},{"id":"q-7529","question":"In a bitfield-based feature flag system used to enable or disable capabilities for individual users, implement a 64-bit popcount function that returns the number of set bits using only bitwise operations and shifts (no loops or conditionals). Provide the function signature and a short justification, plus 1-2 quick examples?","answer":"uint64_t popcount64(uint64_t x); Approach: fixed-sequence masks perform Hamming weight without branches. Only bitwise shifts and masks; it's O(1) and avoids misprediction costs. Examples: popcount64(0","explanation":"## Why This Is Asked\nThis checks understanding of fixed-sequence bit tricks and performance constraints in bitfield work.\n\n## Key Concepts\n- Hamming weight via parallel summation\n- Masks like 0x5555555555555555, 0x3333333333333333, 0x0F0F0F0F0F0F0F0F\n\n## Code Example\n```javascript\n// Implementation using BigInt for 64-bit precision\nfunction popcount64(x) {\n  x = (x) & 0xFFFFFFFFFFFFFFFFn;\n  x = x - ((x >> 1n) & 0x5555555555555555n);\n  x = (x & 0x3333333333333333n) + ((x >> 2n) & 0x3333333333333333n);\n  x = (x + (x >> 4n)) & 0x0F0F0F0F0F0F0F0Fn;\n  x = x + (x >> 8n);\n  x = x + (x >> 16n);\n  x = x + (x >> 32n);\n  return Number(x & 0x7Fn);\n}\n```\n\n## Follow-up Questions\n- What are the trade-offs vs lookup-table popcount in fixed-width code?\n- How would you adapt this for SIMD or wider widths?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Snap","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T05:58:03.005Z","createdAt":"2026-01-26T05:58:03.005Z"},{"id":"q-757","question":"Given a 32-bit unsigned integer n, implement maskBelowLSB32(n) that returns a 32-bit mask with all bits at positions <= the least significant set bit of n turned on; if n is 0 return 0. Use bitwise operations and shifts (and optional arithmetic). Provide the signature, justification, and 1-2 examples?","answer":"Signature: uint32_t maskBelowLSB32(uint32_t n). Approach: compute lsb = n & -n; return (n==0)?0:((lsb<<1)-1). This isolates the lowest 1 and builds a lower mask by shifting and subtracting 1. Examples","explanation":"## Why This Is Asked\nTests a crisp bit-twiddling trick: constructing a mask anchored to the least significant set bit, plus proper zero handling.\n\n## Key Concepts\n- Isolating the LSB with n & -n\n- Mask construction via (lsb<<1) - 1\n- Edge-case handling for zero input\n\n## Code Example\n```javascript\nfunction maskBelowLSB32(n) {\n  const lsb = n & -n;\n  return n === 0 ? 0 : (lsb << 1) - 1;\n}\n```\n\n## Follow-up Questions\n- How would you adapt to 64-bit inputs?\n- What are the potential pitfalls on platforms with different integer sizes?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Microsoft","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T03:47:17.777Z","createdAt":"2026-01-12T03:47:17.777Z"},{"id":"q-7591","question":"Given two 32-bit unsigned integers a and b, implement interleave32(uint32_t a, uint32_t b) -> uint64_t that returns a 64-bit value by interleaving bits: bit i of a becomes bit 2i, bit i of b becomes bit 2i+1, for i in 0..31. Use only bitwise ops and shifts; no loops or conditionals. Provide the function signature, approach, and 1-2 quick edge cases (e.g., a=0,b=0 -> 0; a=0xFFFFFFFF,b=0 -> 0x5555555555555555; a=0xFFFFFFFF,b=0xFFFFFFFF -> 0xFFFFFFFFFFFFFFFF)?","answer":"Interleave by dilating each input to 64 bits, placing a's bits on the even positions and b's on the odd. Use a standard 'part1by1' sequence: y = x; y = (y | (y << 16)) & 0x0000FFFF0000FFFFULL; y = (y ","explanation":"## Why This Is Asked\nInterleaving bits is a practical pattern in spatial indexing (Morton codes) and graphics. This tests branch-free bit twiddling and understanding of bit spreading.\n\n## Key Concepts\n- Bit spreading (part1by1)\n- Masked shifts and combiners\n- Branch-free composition for 64-bit results\n\n## Code Example\n```javascript\nuint64_t spread32(uint32_t x){\n  uint64_t y = x;\n  y = (y | (y << 16)) & 0x0000FFFF0000FFFFULL;\n  y = (y | (y << 8))  & 0x00FF00FF00FF00FFULL;\n  y = (y | (y << 4))  & 0x0F0F0F0F0F0F0F0FULL;\n  y = (y | (y << 2))  & 0x3333333333333333ULL;\n  y = (y | (y << 1))  & 0x5555555555555555ULL;\n  return y;\n}\nuint64_t interleave32(uint32_t a, uint32_t b){\n  return spread32(a) | (spread32(b) << 1);\n}\n```\n\n## Follow-up Questions\n- How would you extend to 64-bit inputs to a 128-bit output?\n- What intrinsics would you use on your platform?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Amazon","Lyft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T08:59:00.752Z","createdAt":"2026-01-26T08:59:00.752Z"},{"id":"q-7609","question":"Advanced bit manipulation task: treat a 64-bit word as an 8x8 bitboard in row-major order (row0 bits 0–7, row7 bits 56–63). Implement rotate90(uint64_t board) that returns the board rotated 90 degrees clockwise, using only bitwise operations and shifts (no loops or conditionals). Provide the function signature and a brief justification, plus 1-2 quick checks (e.g., board=0 -> 0; a single 1 at (r,c) ends at (c,7-r))?","answer":"Signature: uint64_t rotate90(uint64_t board). Approach: view board as 8x8 grid; perform a 4-pass transpose and a final row reversal using fixed masks and shifts, e.g., swap bits with masks like 0xAA55","explanation":"## Why This Is Asked\nTests ability to model a 2D grid in a 64-bit word and perform in-place bitwise permutations for rotation.\n\n## Key Concepts\n- Bitboard representation and mapping\n- In-place 2D transpose via masks\n- Row reversal to complete rotation\n- Avoiding loops and branches\n\n## Code Example\n```javascript\n// Pseudo-implementation outline demonstrating steps\nfunction rotate90(board){ /* 4-pass transpose + row reverse */ return board; }\n```\n\n## Follow-up Questions\n- How would you extend to rotate 45 degrees?\n- How would you adapt to non-square boards?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T09:49:14.962Z","createdAt":"2026-01-26T09:49:14.963Z"},{"id":"q-7650","question":"In a network protocol header, a 64-bit word packs fields at arbitrary bit positions. Implement uint64_t extractBits(uint64_t word, int start, int width) that returns the width-bit field starting at bit start (LSB bit 0). Use only bitwise ops and shifts; no loops or conditionals. Assume 1 <= width <= 64. Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"uint64_t extractBits(uint64_t word, int start, int width) { return (word >> start) & ((~0ULL) >> (64 - width)); } Assumes 1 <= width <= 64. Examples: word=0x0123456789ABCDEF, start=8, width=8 -> 0xCD;","explanation":"## Why This Is Asked\nTests precise bitfield extraction in arbitrary alignments, a common requirement in parsers and low-level codecs. No loops or branches; relies on safe shifts and masks.\n\n## Key Concepts\n- Dynamic masking with shifts\n- Handling width up to 64 without UB\n- LSB 0 indexing, endianness-agnostic interpretation\n\n## Code Example\n```javascript\nuint64_t extractBits(uint64_t word, int start, int width) {\n  return (word >> start) & ((~0ULL) >> (64 - width));\n}\n```\n\n## Follow-up Questions\n- How would you adapt for start and width as signed inputs?  \n- How to validate input without affecting performance?  ","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T11:07:05.690Z","createdAt":"2026-01-26T11:07:05.691Z"},{"id":"q-7659","question":"Implement select64(uint64_t n, unsigned k) that returns the index (0-63) of the k-th set bit in n (0-based) using only bitwise operations and shifts; no loops or conditionals. If fewer than k+1 ones exist, behavior is undefined. Provide the signature, a brief justification, and 1-2 quick edge cases (e.g., n=0 -> undefined; n=0b10110, k=1 -> index 3)?","answer":"Branchless select64 via SWAR. Compute cumulative ones in 1-,2-,4-,8-,16-bit blocks using masks and shifts; locate the 16-bit region containing the k-th 1 by subtracting block counts from k. Repeat ins","explanation":"## Why This Is Asked\nTests proficiency in advanced bit manipulation, branchless algorithms, and indexing within packed data structures.\n\n## Key Concepts\n- Branchless techniques using masks and shifts\n- SWAR-style population counting\n- Block-wise binary search on bit regions\n- Edge-case handling and undefined behavior when k exceeds popcount\n\n## Code Example\n```javascript\nfunction select64(n, k) {\n  // placeholder\n}\n```\n\n## Follow-up Questions\n- How would you adapt to 128-bit inputs?\n- What if k is compile-time constant; any optimizations?\n","diagram":"flowchart TD\n  A[Start] --> B[SWAR block counts]\n  B --> C[Locate region containing k-th 1]\n  C --> D[Offset within region]\n  D --> E[Return index]","difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T11:44:29.159Z","createdAt":"2026-01-26T11:44:29.160Z"},{"id":"q-776","question":"Implement a 64-bit bitboard function knightAttacks64(n) that returns a 64-bit mask of all squares attacked by knights, given a 64-bit bitboard n where 1s indicate knight positions. Use only bitwise operations and shifts, no loops or conditionals. Provide the signature and a brief justification, plus 1-2 quick examples?","answer":"uint64_t knightAttacks64(uint64_t knights) { const uint64_t notA=0xfefefefefefefefeULL; const uint64_t notH=0x7f7f7f7f7f7f7f7fULL; uint64_t x=knights; return ((x<<17)&notA)|((x<<15)&notH)|((x<<10)&not","explanation":"## Why This Is Asked\nTests bitboard reasoning and edge-safe shifts. Requires combining eight knight directions with edge masking in a single expression to prove correctness and performance without branching.","diagram":"flowchart TD\n  A[Input: knights] --> B[Apply 8 directional shifts]\n  B --> C[Mask edges to prevent wrap]\n  C --> D[Combine with |]\n  D --> E[Return attacks]","difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Netflix","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T05:29:43.673Z","createdAt":"2026-01-12T05:29:43.673Z"},{"id":"q-783","question":"Given a 32-bit unsigned n, implement hasPattern101(n) that returns true if there exists any i such that bits i, i+1, i+2 form 101 (n_i=1, n_{i+1}=0, n_{i+2}=1). Use only bitwise operations and shifts, no loops or conditionals. Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"Use a single expression: (n & (n >> 2) & ~(n >> 1)) != 0. It slides a 3-bit window across n, aligning bits i, i+1, i+2 so a 101 pattern yields a nonzero bit after the ANDs. It avoids loops and branche","explanation":"## Why This Is Asked\nTests ability to detect fixed bit patterns with pure bitwise ops, no loops or conditionals, reinforcing shifts, masking, and truthiness evaluation.\n\n## Key Concepts\n- Bitwise shifts align neighboring bits\n- Combining with AND tests multiple bit conditions simultaneously\n- Pure bitwise approach scales to fixed-width inputs without branching\n\n## Code Example\n```c\nbool hasPattern101(uint32_t n) {\n  return (n & (n >> 2) & ~(n >> 1)) != 0;\n}\n```\n\n## Follow-up Questions\n- How would you adapt for 64-bit inputs?\n- What edge cases exist near the topmost bits (i=29) and how does masking affect them?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Plaid","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T06:35:10.215Z","createdAt":"2026-01-12T06:35:10.215Z"},{"id":"q-7874","question":"Implement nextBitPerm64(uint64_t x) that returns the next higher number with the same number of set bits (popcount) as x, in numeric order. Use only bitwise ops and shifts; no loops or conditionals. If no such number exists, behavior is undefined. Signature: uint64_t nextBitPerm64(uint64_t x). Edge cases: x==0 (undefined); maximum permutation for its popcount (undefined). Example: 0b1010 -> 0b1100?","answer":"Use the snoob trick: smallest = x & -x; ripple = x + smallest; ones = x ^ ripple; ones = (ones >> 2) / smallest; return ripple | ones; This generates the next higher permutation with identical popcoun","explanation":"## Why This Is Asked\nTests precise bit trick mastery and edge-case handling.\n\n## Key Concepts\n- Bit hacks\n- popcount and next permutation\n- Undefined behavior on max value\n\n## Code Example\n```javascript\nfunction nextBitPerm64(x) {\n  const smallest = x & -x;\n  const ripple = x + smallest;\n  const ones = x ^ ripple;\n  const shifted = (ones >> 2) / smallest;\n  return ripple | shifted;\n}\n```\n\n## Follow-up Questions\n- How would you adapt for 32-bit or arbitrary width?\n- What are the performance implications on different CPUs?\n","diagram":"flowchart TD\n  A[Input x] --> B{Is x the max with its popcount?}\n  B --> C[No next]\n  B --> D[Compute smallest = x & -x]\n  D --> E[ripple = x + smallest]\n  E --> F[ones = x ^ ripple]\n  F --> G[ones = (ones >> 2) / smallest]\n  G --> H[Return ripple | ones]","difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Instacart"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T21:32:11.774Z","createdAt":"2026-01-26T21:32:11.776Z"},{"id":"q-7902","question":"Implement bswap64(uint64_t x) that reverses endianness by swapping the eight bytes of x (byte0 with byte7, byte1 with byte6, byte2 with byte5, byte3 with byte4) using only bitwise operations and shifts; no loops or conditionals. Provide the function signature and a brief rationale, and include one quick check: 0x0123456789ABCDEF -> 0xEFCDAB8967452301?","answer":"Three-pass byte shuffle using bitwise operations and shifts: `x = ((x & 0x00FF00FF00FF00FFULL) << 8) | ((x >> 8) & 0x00FF00FF00FF00FFULL); x = ((x & 0x0000FFFF0000FFFFULL) << 16) | ((x >> 16) & 0x0000FFFF0000FFFFULL); x = (x << 32) | (x >> 32);`","explanation":"## Why This Is Asked\n\nThis tests precise bit manipulation skills for rearranging 8-byte blocks without loops, essential for portable endianness handling in systems programming.\n\n## Key Concepts\n\n- Byte-level masking with 64-bit constants\n- Multi-stage shuffles to minimize operations\n- Endianness portability across platforms\n\n## Code Example\n\n```c\nuint64_t bswap64(uint64_t x) {\n  x = ((x & 0x00FF00FF00FF00FFULL) << 8) | ((x >> 8) & 0x00FF00FF00FF00FFULL);\n  x = ((x & 0x0000FFFF0000FFFFULL) << 16) | ((x >> 16) & 0x0000FFFF0000FFFFULL);\n  return (x << 32) | (x >> 32);\n}\n```\n\n## Follow-up Questions\n\n- How would you verify correctness of this implementation?\n- What are the trade-offs between this approach and using built-in byte swap functions?\n- How would this differ on a little-endian vs big-endian system?","diagram":"flowchart TD\n  A[Input x] --> B[Stage1: swap 8-bit blocks]\n  B --> C[Stage2: swap 16-bit blocks]\n  C --> D[Stage3: swap 32-bit halves]\n  D --> E[Output swapped]","difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","PayPal","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T04:59:07.882Z","createdAt":"2026-01-26T22:36:05.725Z"},{"id":"q-791","question":"Implement parity32(n) that returns 1 if the number of set bits in a 32-bit unsigned n is odd, otherwise 0. Do not use loops or built-ins; only bitwise ops and shifts. Provide function signature parity32(uint32_t n) and a brief justification, plus 1-2 quick examples?","answer":"One way is XOR-fold parity: fold the 32 bits in halves, then propagate to LSB. Implement parity32 as p = n; p ^= p >> 16; p ^= p >> 8; p ^= p >> 4; p ^= p >> 2; p ^= p >> 1; return p & 1. This uses on","explanation":"## Why This Is Asked\nTests understanding of bitwise folding to compute parity without loops.\n\n## Key Concepts\n- Parity via XOR folding\n- Bitwise shifts to mix bits\n- No branches or loops in parity path\n\n## Code Example\n```javascript\nuint32_t parity32(uint32_t n) {\n  uint32_t p = n;\n  p ^= p >> 16;\n  p ^= p >> 8;\n  p ^= p >> 4;\n  p ^= p >> 2;\n  p ^= p >> 1;\n  return p & 1;\n}\n```\n\n## Follow-up Questions\n- How would you adapt parity32 for 64-bit inputs efficiently?\n- What are the trade-offs compared to using a popcount-based method?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","DoorDash"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T07:27:22.989Z","createdAt":"2026-01-12T07:27:22.989Z"},{"id":"q-7926","question":"Implement isPalindrome128(uint64_t hi, uint64_t lo) that returns 1 if the 128-bit value hi:lo is a bitwise palindrome (bits read the same forward and backward). Use only bitwise operations and shifts; no loops or conditionals. Provide the signature, a brief justification, and 1–2 quick examples?","answer":"Signature: `int isPalindrome128(uint64_t hi, uint64_t lo);`\n\nApproach: Compute the bit-reversed 128-bit value `(rhi, rlo)` using `reverse128(hi, lo, &rhi, &rlo)` and return `1` if it matches the original value, `0` otherwise. This provides a constant-time, branchless solution that correctly handles edge cases such as all-zeros and all-ones patterns.\n\nExamples:\n- `isPalindrome128(0x8000000000000001, 0x0000000000000000)` returns `1` (palindrome)\n- `isPalindrome128(0x123456789ABCDEF0, 0x0FEDCBA987654321)` returns `0` (not palindrome)","explanation":"## Why This Is Asked\nThis question tests the ability to reason about 128-bit bit patterns and leverage existing helper functions to implement non-trivial properties without using conditional branches.\n\n## Key Concepts\n- Bit reversal and palindrome detection in 128-bit space\n- Constant-time, branchless implementation\n- Integration with existing `reverse128` utility\n\n## Code Example\n```c\nint isPalindrome128(uint64_t hi, uint64_t lo) {\n  uint64_t rhi, rlo;\n  reverse128(hi, lo, &rhi, &rlo);\n  return (rhi == hi && rlo == lo);\n}\n```\n\n## Follow-up Questions\n- How would you extend this approach to 256-bit values?\n- What optimizations could be applied if the function were called frequently?","diagram":"flowchart TD\n  A[Input: hi:lo] --> B[Call reverse128(hi,lo)]\n  B --> C[Obtain rhi:rlo]\n  C --> D[Compare rhi==hi and rlo==lo]\n  D --> E[Return 1 if equal, else 0]","difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["NVIDIA","Slack","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T06:02:10.830Z","createdAt":"2026-01-26T23:42:37.595Z"},{"id":"q-798","question":"Implement nextHigherWithSamePopcount64(uint64_t n) that returns the smallest integer greater than n with the same number of 1-bits. Use only bitwise operations and shifts; no loops or conditionals. If no such number exists, return 0. Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"Use a single-pass, branchless bit-trick: c = n & -n; r = n + c; next = (((n ^ r) >> 2) / c) | r; This yields the next higher number with the same popcount for 64-bit inputs. Edge cases (like overflow)","explanation":"## Why This Is Asked\nShows mastery of low-level bit tricks and edge-case handling in constrained environments.\n\n## Key Concepts\n- Next permutation with fixed popcount using bit hacks\n- Branchless arithmetic for speed\n- Fixed-width overflow behavior\n\n## Code Example\n```javascript\nuint64_t nextHigherWithSamePopcount(uint64_t n) {\n  uint64_t c = n & -n;\n  uint64_t r = n + c;\n  return (((n ^ r) >> 2) / c) | r;\n}\n```\n\n## Follow-up Questions\n- How would you adapt for arbitrary width (128-bit)?\n- How does this interact with compiler optimizations and undefined behavior in signed contexts?","diagram":"flowchart TD\n  A[Start] --> B[Compute c = n & -n]\n  B --> C[Compute r = n + c]\n  C --> D[Compute next = (((n ^ r) >> 2) / c) | r]\n  D --> E[Return next]","difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T08:29:27.025Z","createdAt":"2026-01-12T08:29:27.025Z"},{"id":"q-8007","question":"Implement a function lsbIndex64(uint64_t n) that returns the 0-based index of the least significant set bit in n, using only bitwise operations and shifts (no loops or conditionals). Use a de Bruijn sequence approach. If n is zero, behavior is undefined. Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"Isolate the LSB with t = n & -n, then map to index64[(t * 0x03f79d71b4cb0a89) >> 58], where index64 is a 64-entry table giving the bit position. This yields O(1) branchless code and handles nonzero in","explanation":"## Why This Is Asked\n\nTests ability to extract a single bit position without branches, a core skill in low-level optimizations.\n\n## Key Concepts\n\n- Trailing-set-bit extraction via n & -n\n- De Bruijn sequence trick to index a 64-entry table\n- Branchless, constant-time bit twiddling\n- Undefined for n==0; caller must guard\n\n## Code Example\n\n```javascript\nfunction lsbIndex64(n) {\n  const index64 = [0,1,2,3,4,5,6,7,56,57,58,59,60,61,62,63,\n                   8,9,10,11,12,13,14,15,48,49,50,51,52,53,54,55,\n                   16,17,18,19,20,21,22,23,40,41,42,43,44,45,46,47,\n                   24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39];\n  const t = n & -n;\n  return index64[(t * 0x03f79d71b4cb0a89) >>> 58];\n}\n```\n\n## Follow-up Questions\n\n- How would you adapt this for 128-bit inputs? \n- What are alternative approaches and their trade-offs?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","NVIDIA","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T05:45:10.813Z","createdAt":"2026-01-27T05:45:10.813Z"},{"id":"q-8036","question":"Implement rotateLeft32(uint32_t n, unsigned r) that returns n rotated left by r bits on 32-bit width using only bitwise operations and shifts. The rotation must wrap around; use r mod 32 and avoid loops or conditionals. Provide the function signature, a brief justification, and 1-2 quick examples?","answer":"Code: uint32_t rotateLeft32(uint32_t n, unsigned r) { unsigned s = r & 31; return (n << s) | (n >> (32 - s)); } Rationale: s = r & 31 reduces r modulo 32, preventing UB for shifts by 32; the left and ","explanation":"## Why This Is Asked\n\nTests ability to implement a small, practical bit rotation using only shifts and OR, a common low-level operation in compilers and algorithms.\n\n## Key Concepts\n\n- Bit shifts and masking\n- Width awareness and undefined behavior avoidance\n- Circular wrap-around without loops\n\n## Code Example\n\n```c\nuint32_t rotateLeft32(uint32_t n, unsigned r) {\n  unsigned s = r & 31;\n  return (n << s) | (n >> (32 - s));\n}\n```\n\n## Follow-up Questions\n\n- How would you generalize to 64-bit n?\n- What if language semantics define undefined shift amounts; how to guard?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Citadel","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T06:58:22.097Z","createdAt":"2026-01-27T06:58:22.097Z"},{"id":"q-807","question":"Implement rotateLeft128 by k on a 128-bit value stored as two 64-bit words (hi, lo). The function rotates within the 128-bit boundary by k bits (0 <= k < 128) using only bitwise operations and shifts, no loops or conditionals. Provide the signature and a brief justification, plus 1-2 quick examples?","answer":"Represent the 128-bit value as hi:lo. Normalize k to [0,127]. Let n = (hi<<64) | lo. Rotated = ((n<<k) | (n>>(128-k))) & mask128, with mask128 = ((unsigned __int128)1 << 128) - 1. New hi = rotated >> ","explanation":"## Why This Is Asked\nTests cross-boundary bit tricks and 128-bit reasoning without loops.\\n\\n## Key Concepts\n- 128-bit rotation via 64-bit halves\\n- Normalizing k to 0..127, masking to 128 bits\\n- Pure bitwise/shifts, no branches\\n\\n## Code Example\n```javascript\nfunction rotl128(hi, lo, k) {\n  const n = (BigInt(hi) << 64n) | BigInt(lo);\n  const kk = BigInt(k) & 127n;\n  const mask128 = (1n << 128n) - 1n;\n  const val = ((n << kk) | (n >> (128n - kk))) & mask128;\n  return {\n    hi: Number((val >> 64n) & ((1n << 64n) - 1n)),\n    lo: Number(val & ((1n << 64n) - 1n))\n  };\n}\n```\n\n## Follow-up Questions\n- How to implement without 128-bit types?\\n- How to test edge cases: k=0, k=127, k=64?\\n- How to port to languages with limited integer width or without unsigned128 support?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Meta","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T09:32:36.893Z","createdAt":"2026-01-12T09:32:36.893Z"},{"id":"q-814","question":"Implement interleave16(uint16_t a, uint16_t b) that returns a 32-bit value with bits interleaved as a0 b0 a1 b1 ... a15 b15, where a0 is LSB of a and b0 is LSB of b. Use only bitwise operations and shifts (no loops or conditionals). Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"Spread each 16-bit input into separate 32-bit lanes, then combine. Implement a helper spread16 that places bits at even positions with masks 0x00FF00FF, 0x0F0F0F0F, 0x33333333, 0x55555555. Then return","explanation":"## Why This Is Asked\nTests mastery of low-level bit hacks: packing, masking, and fixed-time transformations without control flow.\n\n## Key Concepts\n- Morton (Z-order) interleaving\n- Bit spreading via staged masks\n- Fixed, branchless implementation\n\n## Code Example\n```cpp\nuint32_t spread16(uint16_t v){\n  uint32_t x = v;\n  x = (x | (x << 8)) & 0x00FF00FF;\n  x = (x | (x << 4)) & 0x0F0F0F0F;\n  x = (x | (x << 2)) & 0x33333333;\n  x = (x | (x << 1)) & 0x55555555;\n  return x;\n}\nuint32_t interleave16(uint16_t a, uint16_t b){\n  return spread16(a) | (spread16(b) << 1);\n}\n```\n\n## Follow-up Questions\n- How would you generalize to interleave 32-bit values into a 64-bit result?\n- What tests would you add to validate edge cases like a or b == 0xFFFF?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Snowflake","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T10:24:33.809Z","createdAt":"2026-01-12T10:24:33.809Z"},{"id":"q-8158","question":"Given a 128-bit value represented by two 64-bit unsigned integers hi and lo (hi = most significant 64 bits, lo = least), implement a function extractBits128(uint64_t hi, uint64_t lo, int pos, int width) that returns the width-bit field starting at bit position pos (0-based) as a 64-bit value, using only bitwise operations and shifts and no loops or conditionals. Assume 0 < width <= 64 and 0 <= pos <= 127 and pos + width <= 128. Provide the function signature and a brief justification, and include 1-2 quick edge-case examples?","answer":"Proposed signature: uint64_t extractBits128(uint64_t hi, uint64_t lo, int pos, int width); Approach: form V=(hi<<64)|lo, then return (V>>pos) & MASK(width). Mask handles width=64 without shifting by 6","explanation":"## Why This Is Asked\nTests crossing-boundary bit extraction on a 128-bit value with no branching, mirroring real-world crypto/low-level data parsing tasks.\n\n## Key Concepts\n- Cross-boundary bit manipulation.\n- Mask generation for widths up to 64 without 64-bit overflow.\n- Handling 128-bit values via hi/lo halves (no loops).\n\n## Code Example\n```javascript\nfunction extractBits128(hi, lo, pos, width) {\n  const V = (BigInt(hi) << 64n) | BigInt(lo);\n  const mask = width === 64 ? (1n << 64n) - 1n : (1n << BigInt(width)) - 1n;\n  return (V >> BigInt(pos)) & mask;\n}\n```","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Instacart"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T11:48:38.396Z","createdAt":"2026-01-27T11:48:38.396Z"},{"id":"q-8172","question":"Given a 128-bit unsigned value represented as two 64-bit halves hi and lo (hi is the high 64 bits, lo the low 64 bits), implement int isPowerOfTwo128(uint64_t hi, uint64_t lo) that returns 1 if the 128-bit value is a power of two (exactly one bit set across the 128 bits), and 0 otherwise. Must use only bitwise operations and shifts (no loops), avoid branching constructs. Provide the function signature, a brief justification, and 1-2 edge-case examples?","answer":"Approach: determine which 64-bit limb can contain the single 1. If lo != 0, ensure hi == 0 and (lo & (lo-1)) == 0. If lo == 0, ensure hi != 0 and (hi & (hi-1)) == 0. Return 1 when either condition hol","explanation":"## Why This Is Asked\nTests 128-bit reasoning, non-branching logic, and careful boundary handling across hi/lo halves. The value is a power of two when exactly one bit in the 128-bit space is set.\n\n## Key Concepts\n- 128-bit value split into hi/lo; treat as two 64-bit lanes.\n- Power-of-two check: a nonzero 64-bit word is a power of two if (x & (x-1)) == 0.\n- Branchless composition: the single 1 must reside either in lo (and hi == 0) or in hi (and lo == 0).\n\n## Code Example\n```javascript\n// Implementation sketch in C-like syntax (language-agnostic semantics)\nint isPowerOfTwo128(uint64_t hi, uint64_t lo) {\n  unsigned int loCase = (lo != 0) && ((lo & (lo - 1)) == 0) && (hi == 0);\n  unsigned int hiCase = (hi != 0) && ((hi & (hi - 1)) == 0) && (lo == 0);\n  return (loCase || hiCase) ? 1 : 0;\n}\n```\n\n## Follow-up Questions\n- How would you adapt this to an embedded environment with no 64-bit ops available?\n- How would you verify correctness across all 128-bit values efficiently?","diagram":"flowchart TD\n  A[128-bit value (hi,lo)] --> B{lo != 0}\n  B -- yes --> C[Check lo is power of two and hi == 0]\n  B -- no --> D{hi != 0}\n  D -- yes --> E[Check hi is power of two and lo == 0]\n  D -- no --> F[Return 0]\n  C --> G[Return 1 if true, else 0]\n  E --> G\n  F --> G","difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T13:15:57.226Z","createdAt":"2026-01-27T13:15:57.226Z"},{"id":"q-8212","question":"Implement a rotate-right by k bits on a 128-bit value stored as hi and lo: void rotateRight128(uint64_t hi, uint64_t lo, unsigned int k, uint64_t *out_hi, uint64_t *out_lo); Rotate by k with 0 <= k < 128 using only bitwise operations and shifts, no loops or conditionals. Ensure k is reduced modulo 128 and the operation is branchless. Provide the function signature, a brief justification, and 1-2 quick edge-case tests?","answer":"Pack hi/lo into a 128-bit value, rotate right by k, then unpack. Let kk = k & 127; __uint128_t v = (((__uint128_t)hi) << 64) | lo; v = (v >> kk) | (v << ((128 - kk) % 128)); *out_hi = (uint64_t)(v >> ","explanation":"## Why This Is Asked\nTests branchless 128-bit rotation using only shifts.\n\n## Key Concepts\n- View 128-bit value via 128-bit type\n- Branchless rotation with shifts and modulo\n- Correct unpacking into hi/lo\n\n## Code Example\n```c\nvoid rotateRight128(uint64_t hi, uint64_t lo, unsigned int k, uint64_t *out_hi, uint64_t *out_lo) {\n  unsigned int kk = k & 127;\n  __uint128_t v = (((__uint128_t)hi) << 64) | lo;\n  v = (v >> kk) | (v << ((128 - kk) % 128));\n  *out_hi = (uint64_t)(v >> 64);\n  *out_lo = (uint64_t)v;\n}\n```\n\n## Follow-up Questions\n- How would you implement without 128-bit type support?\n- What are performance trade-offs for different compilers?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Plaid","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T15:00:28.522Z","createdAt":"2026-01-27T15:00:28.523Z"},{"id":"q-823","question":"Implement rotateLeft32(uint32_t n, unsigned int k) that returns the 32-bit value formed by rotating n left by k bits. Constraints: no loops or conditionals; handle k >= 32 by using k % 32. Provide the function signature and a brief justification, and give 1-2 quick examples?","answer":"One correct approach uses (n << k) | (n >> (32 - k)) with k %= 32. If k==0, returns n; no branches. This uses only bitwise shifts and OR. Examples: rotateLeft32(0x12345678, 4) = 0x23456781; rotateLeft","explanation":"## Why This Is Asked\nTests ability to implement a classic bit manipulation pattern without branches, reflecting real-world needs in low-level systems.\n\n## Key Concepts\n- Bitwise rotation vs shift\n- Handling 32-bit wrap with modulo 32\n- Edge case k=0 without branches\n\n## Code Example\n```javascript\nuint32_t rotateLeft32(uint32_t n, unsigned int k) {\n  k &= 31; // k % 32\n  return (n << k) | (n >> (32 - k));\n}\n```\n```\n\n## Follow-up Questions\n- How would you adapt for 64-bit values?\n- What are the hazards with signed integers and how to avoid them?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","LinkedIn","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T11:20:30.427Z","createdAt":"2026-01-12T11:20:30.427Z"},{"id":"q-830","question":"Implement xor32(uint32_t a, uint32_t b) that returns a ^ b without using the ^ operator. Use only &, |, ~ and shifts. Provide the function signature and a brief justification, plus 1-2 quick examples to verify correctness?","answer":"Use the identity a ^ b = (a | b) & ~(a & b). Implement: static inline uint32_t xor32(uint32_t a, uint32_t b) { return (a | b) & ~(a & b); }. Rationale: per-bit XOR is 1 when exactly one input bit is 1","explanation":"## Why This Is Asked\n\nTests understanding of bit-level identities and branchless implementation, common in low-level systems, kernels, and performance-critical code.\n\n## Key Concepts\n\n- De Morgan's laws and bitwise algebra\n- Implementing XOR without ^ using only &, |, ~\n- Verifying correctness with small binary-pattern examples\n\n## Code Example\n\n```javascript\n// Implementation code for xor32 (C-like)\n#include <stdint.h>\nuint32_t xor32(uint32_t a, uint32_t b) {\n  return (a | b) & ~(a & b);\n}\n```\n\n## Follow-up Questions\n\n- How would you adjust if only ~ and & were allowed (no |)?\n- How would you test edge cases like a=0, b=0 and a=0xFFFFFFFF, b=0x0F0F0F0F?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T12:42:34.459Z","createdAt":"2026-01-12T12:42:34.459Z"},{"id":"q-8353","question":"In a compact protocol header, pack three fields into a 32-bit word: version (4 bits at bits 28-31), type (8 bits at 20-27), length (20 bits at 0-19). Implement packHeader(uint8_t version, uint8_t type, uint32_t length) using only bitwise operations and shifts (no loops). Provide the signature, a brief justification, and 1-2 examples (e.g., packHeader(3,0x12,0x34) -> 0x31200034; packHeader(0xA,0xFF,0xFFFFF) -> 0xA0FFFFFF)?","answer":"Mask each field to its width, shift to its target position, and OR the results. Signature: uint32_t packHeader(uint8_t version, uint8_t type, uint32_t length). Example results: packHeader(3,0x12,0x34)","explanation":"## Why This Is Asked\nTests ability to compose bit-fields into a compact word, a common protocol task.\n\n## Key Concepts\n- Bit masking\n- Bit shifts\n- Width enforcement\n\n## Code Example\n```javascript\n// C-like pseudocode for clarity\nuint32_t packHeader(uint8_t version, uint8_t type, uint32_t length) {\n  return ((uint32_t)(version & 0xF) << 28) | ((uint32_t)(type & 0xFF) << 20) | (length & 0xFFFFF);\n}\n```\n\n## Follow-up Questions\n- How would you validate inputs without branching?\n- How would you extend to 64-bit headers with more fields?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Bloomberg","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T20:58:05.556Z","createdAt":"2026-01-27T20:58:05.556Z"},{"id":"q-8372","question":"Implement popcount64(uint64_t x) that returns the number of set bits in x using only bitwise operations and shifts (no loops, no builtins). Use a SWAR (SIMD within a register) sequence of masks and adds. Provide the function signature and a brief justification, plus 1-2 quick edge cases?","answer":"SWAR-based popcount64 implementation using fixed-depth reduction. The algorithm processes bits in parallel through successive masking and addition stages:\n\n```c\nunsigned int popcount64(uint64_t x) {\n    x = x - ((x >> 1) & 0x5555555555555555ULL);\n    x = (x & 0x3333333333333333ULL) + ((x >> 2) & 0x3333333333333333ULL);\n    x = (x + (x >> 4)) & 0x0F0F0F0F0F0F0F0FULL;\n    x = x + (x >> 8);\n    x = x + (x >> 16);\n    x = x + (x >> 32);\n    return x & 0xFF;\n}\n```\n\nEdge cases: `popcount64(0) = 0` (no bits set), `popcount64(0xFFFFFFFFFFFFFFFFULL) = 64` (all bits set).","explanation":"## Why This Is Asked\n\nThis question tests deep understanding of bit manipulation techniques, specifically SWAR (SIMD Within A Register) algorithms that achieve O(log n) complexity without loops or branching.\n\n## Key Concepts\n\n- **SWAR Reduction**: Processes multiple bit groups simultaneously using carefully designed masks\n- **Fixed-Depth Algorithm**: Counts bits in exactly log₂(64) = 6 operations, independent of input\n- **Mask Patterns**: \n  - `0x5555...` isolates individual bits for pair counting\n  - `0x3333...` groups bits into nibbles for 4-bit counting\n  - `0x0F0F...` creates byte-aligned counts for final reduction\n- **Portability**: Works on any platform with 64-bit unsigned integers\n\n## Performance Characteristics\n\nThe SWAR approach eliminates branching and loop overhead, making it ideal for performance-critical code where builtin functions are unavailable or when consistent timing is required.","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-28T05:20:19.981Z","createdAt":"2026-01-27T21:50:27.688Z"},{"id":"q-8426","question":"Implement rotateRight64(uint64_t n, unsigned k) that rotates the 64-bit word n to the right by k positions. Use only bitwise operations and shifts; no loops or conditionals. Mask k to 0..63 and provide the signature, a brief justification, and 1-2 quick examples (e.g., rotateRight64(1,1) -> 0x8000000000000000; rotateRight64(0x0123456789ABCDEF,8) -> 0xEF0123456789ABCD)?","answer":"static uint64_t rotateRight64(uint64_t n, unsigned k) { unsigned r = k & 63; return (n >> r) | (n << ((64 - r) & 63)); } // r constrains k to [0,63]; branchless implementation; handles k=0 correctly. Examples: rotateRight64(1,1) -> 0x8000000000000000; rotateRight64(0x0123456789ABCDEF,8) -> 0xEF0123456789ABCD","explanation":"## Why This Is Asked\nThis tests the ability to implement a branchless, 64-bit rotate using masking and shifts—a fundamental low-level technique in performance-critical code.\n\n## Key Concepts\n- 64-bit masking with &63 to constrain the rotation range\n- Branchless rotation via (n >> r) | (n << (64 - r))\n- Edge-case handling for k=0 without conditional branches\n\n## Code Example\n```javascript\nfunction rotateRight64(n, k) {\n  const r = k & 63;\n  return (n >>> r) | (n << ((64 - r) & 63));\n}\n```\n\n## Follow-up Questions\n- How would you generalize to arbitrary word sizes (e.g., 32-bit or 128-bit)?\n- What are the trade-offs between rotate left and rotate right operations?\n- How would this implementation behave on architectures with native rotate instructions?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Citadel"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-28T05:55:22.381Z","createdAt":"2026-01-27T23:52:22.977Z"},{"id":"q-8488","question":"Implement countOneRuns64(uint64_t n) that returns the number of contiguous runs of 1s in the 64-bit binary representation of n (leading zeros are ignored). Use only bitwise operations and shifts; no loops or conditionals. Provide the function signature, a brief justification, and 1-2 quick edge cases (e.g., n=0 -> 0; n=0x5D -> 3)?","answer":"Proposed: countOneRuns64(n) = popcount(n & ~(n << 1)). Implement popcount with standard 64-bit bit-twiddling: x = starts; x = x - ((x >> 1) & 0x5555555555555555ULL); x = (x & 0x3333333333333333ULL) + ","explanation":"## Why This Is Asked\nTests ability to count 1-runs in a 64-bit word using bit-twiddling with no loops.\n\n## Key Concepts\n- Start mask n & ~(n << 1) identifies 1-run starts\n- Parallel popcount technique to count bits\n- Edge cases: all zeros, runs spanning MSB\n\n## Code Example\n```cpp\nuint64_t countOneRuns64(uint64_t n){\n  uint64_t starts = n & ~(n << 1);\n  uint64_t x = starts;\n  x = x - ((x >> 1) & 0x5555555555555555ULL);\n  x = (x & 0x3333333333333333ULL) + ((x >> 2) & 0x3333333333333333ULL);\n  x = (x + (x >> 4)) & 0x0F0F0F0F0F0F0F0FULL;\n  return (x * 0x0101010101010101ULL) >> 56;\n}\n```\n\n## Follow-up Questions\n- How would you adapt for 128-bit operands?\n- Compare this approach to a loop-based scan in terms of latency and pipeline efficiency.","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Microsoft","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-28T05:42:42.496Z","createdAt":"2026-01-28T05:42:42.496Z"}],"subChannels":["general"],"companies":["Adobe","Airbnb","Amazon","Anthropic","Apple","Bloomberg","Citadel","Cloudflare","Coinbase","Databricks","Discord","DoorDash","Goldman Sachs","Google","Hashicorp","Hugging Face","IBM","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Netflix","OpenAI","Oracle","PayPal","Plaid","Robinhood","Salesforce","Scale Ai","Slack","Snap","Snowflake","Square","Stripe","Tesla","Twitter","Two Sigma","Uber","Zoom"],"stats":{"total":87,"beginner":25,"intermediate":27,"advanced":35,"newThisWeek":39}}