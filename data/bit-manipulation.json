{"questions":[{"id":"q-1073","question":"Implement transpose64(uint64_t x) by treating x as an 8x8 bit matrix in row-major order (bits 0-7 are row 0, 8-15 row 1, etc.). Return the transposed matrix (bit (r,c) moves to (c,r)). Use only bitwise ops and shifts; no loops or conditionals. Provide signature and a brief justification, plus 1-2 quick examples?","answer":"Signature: uint64_t transpose64(uint64_t x). Approach: interpret x as an 8×8 bit matrix and perform fixed, branchless stage swaps: swap 1-bit pairs with mask 0x5555555555555555; swap 2-bit pairs with ","explanation":"## Why This Is Asked\nTests mastery of non-trivial bit hacks and understanding of 8×8 transpose, a common optimization in graphics, crypto, and compression. It checks for precise, branchless manipulation and correct use of masks.\n\n## Key Concepts\n- fixed-sequence bit swaps\n- 8×8 bit matrix representation\n- mask constants, shifts, no loops\n\n## Code Example\n```cpp\nuint64_t transpose64(uint64_t x) {\n    const uint64_t m1  = 0x5555555555555555ULL;\n    x = (x & m1) << 1 | (x >> 1) & m1;\n    const uint64_t m2  = 0x3333333333333333ULL;\n    x = (x & m2) << 2 | (x >> 2) & m2;\n    const uint64_t m4  = 0x0F0F0F0F0F0F0F0FULL;\n    x = (x & m4) << 4 | (x >> 4) & m4;\n    const uint64_t m8  = 0x00FF00FF00FF00FFULL;\n    x = (x & m8) << 8 | (x >> 8) & m8;\n    const uint64_t m16 = 0x0000FFFF0000FFFFULL;\n    x = (x & m16) << 16 | (x >> 16) & m16;\n    const uint64_t m32 = 0x00000000FFFFFFFFULL;\n    x = (x & m32) << 32 | (x >> 32) & m32;\n    return x;\n}\n```\n\n## Follow-up Questions\n- How would you test this with randomized 64-bit inputs to validate correctness?\n- How would you generalize to 16×16 blocks with a 256-bit input stored in four 64-bit words?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Coinbase","Hashicorp"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T21:32:59.254Z","createdAt":"2026-01-12T21:32:59.254Z"},{"id":"q-1216","question":"Implement reverse128 for a 128-bit value stored as two 64-bit halves hi and lo. Provide a function:\n\nvoid reverse128(uint64_t hi, uint64_t lo, uint64_t *out_hi, uint64_t *out_lo);\n\nThe reversal should map bit i to bit 127 - i, using only bitwise operations and shifts (no loops or conditionals). Include a brief justification and 1-2 quick test examples?","answer":"Split into two 64-bit halves. Compute rev64 of each half with the standard mask/shifts sequence, then swap halves: out_hi = reverse64(lo); out_lo = reverse64(hi). reverse64 uses the classic parallel-b","explanation":"## Why This Is Asked\nTests ability to reason about multi-word bit manipulations and safe 64→128-bit extension without loops.\n\n## Key Concepts\n- 128-bit reversal via two 64-bit reversals and swapping halves\n- Parallel-bits reversal (mask/shifts)\n- Endianness-insensitive mapping of bit indices\n\n## Code Example\n```javascript\nfunction reverse64(x) {\n  x = (x >> 1n) & 0x5555555555555555n | (x & 0x5555555555555555n) << 1n;\n  x = (x >> 2n) & 0x3333333333333333n | (x & 0x3333333333333333n) << 2n;\n  x = (x >> 4n) & 0x0F0F0F0F0F0F0F0Fn | (x & 0x0F0F0F0F0F0F0F0Fn) << 4n;\n  x = (x >> 8n) & 0x00FF00FF00FF00FFn | (x & 0x00FF00FF00FF00FFn) << 8n;\n  x = (x >> 16n) & 0x0000FFFF0000FFFFn | (x & 0x0000FFFF0000FFFFn) << 16n;\n  x = (x >> 32n) | (x << 32n);\n  return x;\n}\nfunction reverse128(hi, lo) {\n  const revLo = reverse64(lo);\n  const revHi = reverse64(hi);\n  return { hi: revLo, lo: revHi };\n}\n```\n\n## Follow-up Questions\n- How would you adapt to streaming 128-bit values?\n- How to verify correctness with random tests?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Snowflake","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T05:27:59.598Z","createdAt":"2026-01-13T05:27:59.598Z"},{"id":"q-680","question":"Given a 32-bit unsigned int n, implement a function hasAdjacentOnes(n) that returns true if n contains any two consecutive 1 bits (for example 0b1100100 has adjacent ones). Use only bitwise operations, no loops or lookups. Explain the core trick in a sentence?","answer":"Return (n & (n >> 1)) != 0. Shifting n right by 1 aligns any adjacent 1s, and ANDing with the original yields a nonzero value iff at least one adjacent pair exists. This is O(1) and uses only bitwise ","explanation":"## Why This Is Asked\n\nAssess practical bit-manipulation intuition and ability to leverage canonical tricks for constant-time checks in real code paths.\n\n## Key Concepts\n\n- Bit tricks: (x & (x >> 1)) detects adjacent 1s\n- Complexity: O(1), no loops\n- Edge cases: 0, power-of-two inputs\n\n## Code Example\n\n```javascript\nfunction hasAdjacentOnes(n) {\n  return (n & (n >> 1)) !== 0;\n}\n```\n\n## Follow-up Questions\n\n- How would you extend this to detect at least k consecutive 1s?\n- How would you adapt for signed 32-bit integers and two's complement behavior?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Oracle","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T15:57:26.049Z","createdAt":"2026-01-11T15:57:26.049Z"},{"id":"q-689","question":"Given a 32-bit unsigned integer n, implement a function isSingleEvenBitSet(n) that returns true if exactly one bit is set and that bit lies at an even index (0, 2, 4, ...). Use only bitwise operations, no loops or built-in helpers. Provide the expression and a brief justification, plus a couple of quick examples?","answer":"Use (n != 0) && ((n & (n-1)) == 0) && ((n & 0x55555555) != 0). The first two checks ensure a single set bit (power of two), and the last check verifies the bit is at an even position since 0x55555555 ","explanation":"## Why This Is Asked\n\nThis question tests precise bit-level reasoning and avoids expensive operations in tight loops, useful in storage engines and query optimizers.\n\n## Key Concepts\n\n- Single-set-bit test: (n & (n-1)) == 0\n- Even-index bit mask: 0x55555555\n- Combining tests with boolean logic for a robust check\n\n## Code Example\n\n```javascript\nfunction isSingleEvenBitSet(n) {\n  return n !== 0 && (n & (n - 1)) === 0 && (n & 0x55555555) !== 0;\n}\n```\n\n## Follow-up Questions\n\n- How would you generalize to check exactly k bits set?\n- How would you adapt to 64-bit width and different bit-ordering considerations?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","MongoDB","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T16:23:21.467Z","createdAt":"2026-01-11T16:23:21.467Z"},{"id":"q-698","question":"Implement a 32-bit unsigned integer function popcount32(n) that returns the number of set bits in n using only bitwise operations and shifts, with no loops or built-ins. Use the SWAR (SIMD Within A Register) technique: apply a sequence of masks and shifts (0x55555555, 0x33333333, 0x0F0F0F0F) and a final multiply to consolidate counts. Provide the function and a brief justification, plus a couple of quick examples?","answer":"Use SWAR (SIMD Within A Register) to count bits in a 32-bit value without loops. Steps: x = x >>> 1 & 0x55555555; x = x - x; x = (x & 0x33333333) + ((x >>> 2) & 0x33333333); x = (x + (x >>> 4)) & 0x0F","explanation":"## Why This Is Asked\n\n- Tests ability to implement a canonical bit-counting trick without loops, emphasizing constant-time operations. \n- Demonstrates careful use of masks and shifts to aggregate counts across bit groups.\n\n## Key Concepts\n\n- SWAR (parallel bit counting)\n- Bit masks 0x55555555, 0x33333333, 0x0F0F0F0F\n- Constant-time arithmetic with shifts\n\n## Code Example\n\n```javascript\nfunction popcount32(x) {\n  x = x - ((x >>> 1) & 0x55555555);\n  x = (x & 0x33333333) + ((x >>> 2) & 0x33333333);\n  x = (x + (x >>> 4)) & 0x0F0F0F0F;\n  return (x * 0x01010101) >>> 24;\n}\n```\n\n## Follow-up Questions\n\n- How would you adapt to 64-bit inputs?\n- Compare this approach to using hardware popcount instructions in terms of portability and performance.","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T17:18:07.873Z","createdAt":"2026-01-11T17:18:07.873Z"},{"id":"q-705","question":"Implement reverseBits32(n) that reverses all 32 bits in a 32-bit unsigned integer using only a fixed sequence of bitwise operations (no loops or conditionals). Use a SWAR-style approach with masks 0x55555555, 0x33333333, 0x0F0F0F0F and 0x00FF00FF, finishing with a 16-bit half-swap. Provide the function signature and a brief justification, plus a couple of quick examples?","answer":"ReverseBits32 uses a fixed, loop-free SWAR sequence. Swap adjacent bits with 0x55555555, then swap pairs with 0x33333333, then nibbles with 0x0F0F0F0F, then bytes with 0x00FF00FF, and finally swap 16-","explanation":"## Why This Is Asked\nFresh bit-hack that demonstrates mastery of fixed-step SWAR technique and portability across languages.\n\n## Key Concepts\n- SWAR fixed-masks and staged swaps\n- Bitwise rotation-free reversal\n- Unsigned 32-bit wrap handling in JavaScript/TypeScript\n\n## Code Example\n```javascript\nfunction reverseBits32(n) {\n  n = ((n >>> 1) & 0x55555555) | ((n & 0x55555555) << 1);\n  n = ((n >>> 2) & 0x33333333) | ((n & 0x33333333) << 2);\n  n = ((n >>> 4) & 0x0F0F0F0F) | ((n & 0x0F0F0F0F) << 4);\n  n = ((n >>> 8) & 0x00FF00FF) | ((n & 0x00FF00FF) << 8);\n  n = (n >>> 16) | (n << 16);\n  return n >>> 0;\n}\n```\n\n## Follow-up Questions\n- How would you adapt this for 64-bit integers in languages with 64-bit ops?\n- How to verify correctness with quick property tests (e.g., n reversing twice yields n)?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T18:28:46.088Z","createdAt":"2026-01-11T18:28:46.088Z"},{"id":"q-711","question":"In a network packet parser, a 32-bit field uses trailing-zero count to encode the length of a value. Given a 32-bit unsigned n, implement countTrailingZeros32(n) that returns the number of trailing zero bits (0-32). If n==0, return 32. Use only bitwise operations, shifts, and basic arithmetic, no loops or built-ins. Provide signature, brief justification, and 1-2 quick examples?","answer":"Use a de Bruijn sequence to map the least-significant 1 to its trailing-zero count. If n==0 return 32. Let v = n & -n; idx = (v * 0x077CB531) >> 27; tz = debruijn[idx]. This uses only bitwise ops and ","explanation":"## Why This Is Asked\nTests knowledge of fast, branchless bit tricks and constant-time bit-scanning utilities common in high-performance systems.\n\n## Key Concepts\n- Isolating least-significant 1: v = n & -n\n- De Bruijn-based indexing: map a 5-bit index to a trailing-zero count\n- Handling edge case n == 0 (return 32)\n- Static lookup table of 32 entries\n\n## Code Example\n```c\nuint32_t countTrailingZeros32(uint32_t n){\n  static const int debruijn[32] = {0,1,28,2,29,14,24,3,30,22,20,15,25,17,4,8,31,27,13,23,21,19,16,7,26,12,18,9,6,11,5,10};\n  if(n == 0) return 32;\n  uint32_t v = n & -n;\n  return debruijn[(v * 0x077CB531) >> 27];\n}\n```\n\n## Follow-up Questions\n- How would you adapt this for 64-bit inputs?\n- What are alternatives that avoid a static table, e.g., using binary search on bit groups?","diagram":"flowchart TD\n  A[n]\n  B{n == 0}\n  C[return 32]\n  D[v = n & -n]\n  E[idx = (v * 0x077CB531) >> 27]\n  F[tz = debruijn[idx]]\n  G[return tz]\n  A --> B\n  B -- yes --> C\n  B -- no --> D\n  D --> E\n  E --> F\n  F --> G","difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T19:16:13.404Z","createdAt":"2026-01-11T19:16:13.404Z"},{"id":"q-724","question":"In memory allocation, implement nextPowerOfTwo32(uint32_t n) that returns the smallest 32-bit unsigned power-of-two >= n, given n > 0, using only bitwise operations with no loops or conditionals. If the result would overflow 32 bits, return 0. What is the correct implementation signature and approach?","answer":"Branchless, constant-time trick. Use a fixed-width prefix fill: n--; n |= n >> 1; n |= n >> 2; n |= n >> 4; n |= n >> 8; n |= n >> 16; return n + 1. Works for all n>0; overflow (n>0x80000000) yields 0","explanation":"## Why This Is Asked\n\n- Demonstrates ability to replace branches with bit-twiddling for performance.\n- Applies a well-known, portable technique to a common memory-allocation problem.\n- Handles edge cases and overflow without loops.\n\n## Key Concepts\n- Prefix-fill trick to propagate the highest set bit.\n- Branchless arithmetic to compute next power of two.\n- Overflow behavior on 32-bit boundaries.\n\n## Code Example\n\n```c\nuint32_t nextPowerOfTwo32(uint32_t n) {\n  // Assumes n > 0. No explicit branches.\n  n--;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  return n + 1;\n}\n```\n\n## Follow-up Questions\n- How does this behave for n = 0x80000000 or 0xFFFFFFFF?\n- Can you adapt this to 64-bit inputs with no loops?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","IBM","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T20:24:38.993Z","createdAt":"2026-01-11T20:24:38.994Z"},{"id":"q-730","question":"Given a 32-bit unsigned integer n, implement swapAdjacentBits32(n) that returns a new 32-bit value with every adjacent bit pair swapped (bits 0-1, 2-3, ..., 30-31). Use only bitwise operations, no loops or conditionals. Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"Signature: uint32_t swapAdjacentBits32(uint32_t n);\\nApproach: res = ((n & 0x55555555) << 1) | ((n & 0xAAAAAAAA) >> 1); This is branchless and runs in constant time, swapping every adjacent bit pair. ","explanation":"## Why This Is Asked\nTests low-level bit twiddling discipline and production-ready, branchless code.\n\n## Key Concepts\n- Bit masks and shifts\n- Branchless algorithms\n- 32-bit edge handling\n\n## Code Example\n```\nuint32_t swapAdjacentBits32(uint32_t n) {\n  return ((n & 0x55555555) << 1) | ((n & 0xAAAAAAAA) >> 1);\n}\n```\n\n## Follow-up Questions\n- How would you extend to 64-bit inputs?\n- How would you test edge cases (0, all-ones) with unit tests?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Plaid","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T21:19:02.055Z","createdAt":"2026-01-11T21:19:02.055Z"},{"id":"q-738","question":"Implement a 64-bit bit reversal function reverse64(uint64_t n) that returns the bitwise reversal of n (bit 0 becomes bit 63, bit 63 becomes bit 0). Use only bitwise operations and shifts, no loops or conditionals. Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"Use a SWAR-style reversal: progressively swap 1-bit blocks, then 2-bit, 4-bit, etc., with masks (0x5555555555555555, 0x3333333333333333, 0x0F0F0F0F0F0F0F0F), then swap larger blocks and finally the tw","explanation":"## Why This Is Asked\nTests mastery of branchless, scalable bit-twiddling techniques for 64-bit inputs.\n\n## Key Concepts\n- SWAR style bit reversal\n- Masking and shifting sequences\n- Branchless algorithms for performance\n\n## Code Example\n```c\n#include <stdint.h>\n\nuint64_t reverse64(uint64_t n) {\n  n = ((n >> 1) & 0x5555555555555555ULL) | ((n & 0x5555555555555555ULL) << 1);\n  n = ((n >> 2) & 0x3333333333333333ULL) | ((n & 0x3333333333333333ULL) << 2);\n  n = ((n >> 4) & 0x0F0F0F0F0F0F0F0FULL) | ((n & 0x0F0F0F0F0F0F0F0FULL) << 4);\n  n = ((n >> 8) & 0x00FF00FF00FF00FFULL) | ((n & 0x00FF00FF00FF00FFULL) << 8);\n  n = ((n >> 16) & 0x0000FFFF0000FFFFULL) | ((n & 0x0000FFFF0000FFFFULL) << 16);\n  n = (n >> 32) | (n << 32);\n  return n;\n}\n```\n\n## Follow-up Questions\n- How would you optimize for smaller word sizes or specialized ISAs?\n- How would you adapt for 128-bit inputs and performance considerations?","diagram":"flowchart TD\n  A[Start: input n] --> B[Swap 1-bit blocks]\n  B --> C[Swap 2-bit blocks]\n  C --> D[Swap 4-bit blocks]\n  D --> E[Swap 8-bit blocks]\n  E --> F[Swap 16-bit blocks]\n  F --> G[Swap 32-bit halves]\n  G --> H[Return reversed n]","difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","MongoDB","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T22:20:40.030Z","createdAt":"2026-01-11T22:20:40.030Z"},{"id":"q-747","question":"Implement isBinaryPalindrome32(uint32_t n) that returns 1 if the 32-bit binary representation of n is a palindrome (bit0 equals bit31, bit1 equals bit30, etc.), and 0 otherwise. Use only bitwise operations and shifts; no loops or conditional branches. Provide the function signature and a brief justification, plus 1-2 quick examples.\n\nExamples:\n- 0x80000001 is a palindrome\n- 0xA5A5A5A5 is not a palindrome?","answer":"Reverse the 32 bits using a fixed sequence of mask/shift swaps (1,2,4,8,16 bit steps) and compare the result to the original. No loops or branches; returns 1 if n equals its reverse, else 0. Demonstra","explanation":"## Why This Is Asked\n\nTests the ability to implement a constant-time bit reversal to verify a binary palindrome using only bitwise ops.\n\n## Key Concepts\n\n- Palindrome property in binary\n- Bit-reversal networks with masks\n- Branch-free comparison\n\n## Code Example\n\n```javascript\n// C-like implementation (illustrative)\nint isBinaryPalindrome32(uint32_t n) {\n  uint32_t x = n;\n  x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);\n  x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);\n  x = ((x >> 4) & 0x0F0F0F0F) | ((x & 0x0F0F0F0F) << 4);\n  x = ((x >> 8) & 0x00FF00FF) | ((x & 0x00FF00FF) << 8);\n  x = (x >> 16) | (x << 16);\n  return (x == n);\n}\n```\n\n## Follow-up Questions\n\n- Extend to 64-bit inputs; what changes? \n- Compare against a loop-based reversal for performance tests.","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Google","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T23:20:55.546Z","createdAt":"2026-01-11T23:20:55.546Z"},{"id":"q-751","question":"Implement popcount64(uint64_t x) that returns the number of set bits in x using only bitwise operations and shifts, with no loops and no built-in popcount. Use a fixed SWAR approach with masks 0x5555555555555555ULL, 0x3333333333333333ULL, 0x0F0F0F0F0F0F0F0FULL and a final multiply/shift step. Provide the function signature and a brief justification, plus 1-2 quick examples of inputs and outputs?","answer":"One correct approach uses a fixed SWAR popcount: x = x - ((x>>1) & 0x5555555555555555ULL); x = (x & 0x3333333333333333ULL) + ((x>>2) & 0x3333333333333333ULL); x = (x + (x>>4)) & 0x0F0F0F0F0F0F0F0FULL;","explanation":"## Why This Is Asked\nTests ability to implement bit-twiddling without loops, using SWAR patterns for constant-time population count.\n\n## Key Concepts\n- SWAR (Small/Word-level Parallelism)\n- 64-bit masks and carry-free sums\n- No intrinsics or branches; deterministic performance\n\n## Code Example\n```javascript\nuint64_t popcount64(uint64_t x) {\n  x = x - ((x >> 1) & 0x5555555555555555ULL);\n  x = (x & 0x3333333333333333ULL) + ((x >> 2) & 0x3333333333333333ULL);\n  x = (x + (x >> 4)) & 0x0F0F0F0F0F0F0F0FULL;\n  return (x * 0x0101010101010101ULL) >> 56;\n}\n```\n\n## Follow-up Questions\n- How would you adapt this to count bits in 128-bit values? \n- What are the trade-offs vs. hardware popcnt instructions in modern CPUs?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","MongoDB","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T01:29:06.153Z","createdAt":"2026-01-12T01:29:06.153Z"},{"id":"q-757","question":"Given a 32-bit unsigned integer n, implement maskBelowLSB32(n) that returns a 32-bit mask with all bits at positions <= the least significant set bit of n turned on; if n is 0 return 0. Use bitwise operations and shifts (and optional arithmetic). Provide the signature, justification, and 1-2 examples?","answer":"Signature: uint32_t maskBelowLSB32(uint32_t n). Approach: compute lsb = n & -n; return (n==0)?0:((lsb<<1)-1). This isolates the lowest 1 and builds a lower mask by shifting and subtracting 1. Examples","explanation":"## Why This Is Asked\nTests a crisp bit-twiddling trick: constructing a mask anchored to the least significant set bit, plus proper zero handling.\n\n## Key Concepts\n- Isolating the LSB with n & -n\n- Mask construction via (lsb<<1) - 1\n- Edge-case handling for zero input\n\n## Code Example\n```javascript\nfunction maskBelowLSB32(n) {\n  const lsb = n & -n;\n  return n === 0 ? 0 : (lsb << 1) - 1;\n}\n```\n\n## Follow-up Questions\n- How would you adapt to 64-bit inputs?\n- What are the potential pitfalls on platforms with different integer sizes?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Microsoft","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T03:47:17.777Z","createdAt":"2026-01-12T03:47:17.777Z"},{"id":"q-776","question":"Implement a 64-bit bitboard function knightAttacks64(n) that returns a 64-bit mask of all squares attacked by knights, given a 64-bit bitboard n where 1s indicate knight positions. Use only bitwise operations and shifts, no loops or conditionals. Provide the signature and a brief justification, plus 1-2 quick examples?","answer":"uint64_t knightAttacks64(uint64_t knights) { const uint64_t notA=0xfefefefefefefefeULL; const uint64_t notH=0x7f7f7f7f7f7f7f7fULL; uint64_t x=knights; return ((x<<17)&notA)|((x<<15)&notH)|((x<<10)&not","explanation":"## Why This Is Asked\nTests bitboard reasoning and edge-safe shifts. Requires combining eight knight directions with edge masking in a single expression to prove correctness and performance without branching.","diagram":"flowchart TD\n  A[Input: knights] --> B[Apply 8 directional shifts]\n  B --> C[Mask edges to prevent wrap]\n  C --> D[Combine with |]\n  D --> E[Return attacks]","difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Netflix","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T05:29:43.673Z","createdAt":"2026-01-12T05:29:43.673Z"},{"id":"q-783","question":"Given a 32-bit unsigned n, implement hasPattern101(n) that returns true if there exists any i such that bits i, i+1, i+2 form 101 (n_i=1, n_{i+1}=0, n_{i+2}=1). Use only bitwise operations and shifts, no loops or conditionals. Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"Use a single expression: (n & (n >> 2) & ~(n >> 1)) != 0. It slides a 3-bit window across n, aligning bits i, i+1, i+2 so a 101 pattern yields a nonzero bit after the ANDs. It avoids loops and branche","explanation":"## Why This Is Asked\nTests ability to detect fixed bit patterns with pure bitwise ops, no loops or conditionals, reinforcing shifts, masking, and truthiness evaluation.\n\n## Key Concepts\n- Bitwise shifts align neighboring bits\n- Combining with AND tests multiple bit conditions simultaneously\n- Pure bitwise approach scales to fixed-width inputs without branching\n\n## Code Example\n```c\nbool hasPattern101(uint32_t n) {\n  return (n & (n >> 2) & ~(n >> 1)) != 0;\n}\n```\n\n## Follow-up Questions\n- How would you adapt for 64-bit inputs?\n- What edge cases exist near the topmost bits (i=29) and how does masking affect them?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Plaid","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T06:35:10.215Z","createdAt":"2026-01-12T06:35:10.215Z"},{"id":"q-791","question":"Implement parity32(n) that returns 1 if the number of set bits in a 32-bit unsigned n is odd, otherwise 0. Do not use loops or built-ins; only bitwise ops and shifts. Provide function signature parity32(uint32_t n) and a brief justification, plus 1-2 quick examples?","answer":"One way is XOR-fold parity: fold the 32 bits in halves, then propagate to LSB. Implement parity32 as p = n; p ^= p >> 16; p ^= p >> 8; p ^= p >> 4; p ^= p >> 2; p ^= p >> 1; return p & 1. This uses on","explanation":"## Why This Is Asked\nTests understanding of bitwise folding to compute parity without loops.\n\n## Key Concepts\n- Parity via XOR folding\n- Bitwise shifts to mix bits\n- No branches or loops in parity path\n\n## Code Example\n```javascript\nuint32_t parity32(uint32_t n) {\n  uint32_t p = n;\n  p ^= p >> 16;\n  p ^= p >> 8;\n  p ^= p >> 4;\n  p ^= p >> 2;\n  p ^= p >> 1;\n  return p & 1;\n}\n```\n\n## Follow-up Questions\n- How would you adapt parity32 for 64-bit inputs efficiently?\n- What are the trade-offs compared to using a popcount-based method?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","DoorDash"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T07:27:22.989Z","createdAt":"2026-01-12T07:27:22.989Z"},{"id":"q-798","question":"Implement nextHigherWithSamePopcount64(uint64_t n) that returns the smallest integer greater than n with the same number of 1-bits. Use only bitwise operations and shifts; no loops or conditionals. If no such number exists, return 0. Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"Use a single-pass, branchless bit-trick: c = n & -n; r = n + c; next = (((n ^ r) >> 2) / c) | r; This yields the next higher number with the same popcount for 64-bit inputs. Edge cases (like overflow)","explanation":"## Why This Is Asked\nShows mastery of low-level bit tricks and edge-case handling in constrained environments.\n\n## Key Concepts\n- Next permutation with fixed popcount using bit hacks\n- Branchless arithmetic for speed\n- Fixed-width overflow behavior\n\n## Code Example\n```javascript\nuint64_t nextHigherWithSamePopcount(uint64_t n) {\n  uint64_t c = n & -n;\n  uint64_t r = n + c;\n  return (((n ^ r) >> 2) / c) | r;\n}\n```\n\n## Follow-up Questions\n- How would you adapt for arbitrary width (128-bit)?\n- How does this interact with compiler optimizations and undefined behavior in signed contexts?","diagram":"flowchart TD\n  A[Start] --> B[Compute c = n & -n]\n  B --> C[Compute r = n + c]\n  C --> D[Compute next = (((n ^ r) >> 2) / c) | r]\n  D --> E[Return next]","difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T08:29:27.025Z","createdAt":"2026-01-12T08:29:27.025Z"},{"id":"q-807","question":"Implement rotateLeft128 by k on a 128-bit value stored as two 64-bit words (hi, lo). The function rotates within the 128-bit boundary by k bits (0 <= k < 128) using only bitwise operations and shifts, no loops or conditionals. Provide the signature and a brief justification, plus 1-2 quick examples?","answer":"Represent the 128-bit value as hi:lo. Normalize k to [0,127]. Let n = (hi<<64) | lo. Rotated = ((n<<k) | (n>>(128-k))) & mask128, with mask128 = ((unsigned __int128)1 << 128) - 1. New hi = rotated >> ","explanation":"## Why This Is Asked\nTests cross-boundary bit tricks and 128-bit reasoning without loops.\\n\\n## Key Concepts\n- 128-bit rotation via 64-bit halves\\n- Normalizing k to 0..127, masking to 128 bits\\n- Pure bitwise/shifts, no branches\\n\\n## Code Example\n```javascript\nfunction rotl128(hi, lo, k) {\n  const n = (BigInt(hi) << 64n) | BigInt(lo);\n  const kk = BigInt(k) & 127n;\n  const mask128 = (1n << 128n) - 1n;\n  const val = ((n << kk) | (n >> (128n - kk))) & mask128;\n  return {\n    hi: Number((val >> 64n) & ((1n << 64n) - 1n)),\n    lo: Number(val & ((1n << 64n) - 1n))\n  };\n}\n```\n\n## Follow-up Questions\n- How to implement without 128-bit types?\\n- How to test edge cases: k=0, k=127, k=64?\\n- How to port to languages with limited integer width or without unsigned128 support?","diagram":null,"difficulty":"advanced","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Meta","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T09:32:36.893Z","createdAt":"2026-01-12T09:32:36.893Z"},{"id":"q-814","question":"Implement interleave16(uint16_t a, uint16_t b) that returns a 32-bit value with bits interleaved as a0 b0 a1 b1 ... a15 b15, where a0 is LSB of a and b0 is LSB of b. Use only bitwise operations and shifts (no loops or conditionals). Provide the function signature and a brief justification, plus 1-2 quick examples?","answer":"Spread each 16-bit input into separate 32-bit lanes, then combine. Implement a helper spread16 that places bits at even positions with masks 0x00FF00FF, 0x0F0F0F0F, 0x33333333, 0x55555555. Then return","explanation":"## Why This Is Asked\nTests mastery of low-level bit hacks: packing, masking, and fixed-time transformations without control flow.\n\n## Key Concepts\n- Morton (Z-order) interleaving\n- Bit spreading via staged masks\n- Fixed, branchless implementation\n\n## Code Example\n```cpp\nuint32_t spread16(uint16_t v){\n  uint32_t x = v;\n  x = (x | (x << 8)) & 0x00FF00FF;\n  x = (x | (x << 4)) & 0x0F0F0F0F;\n  x = (x | (x << 2)) & 0x33333333;\n  x = (x | (x << 1)) & 0x55555555;\n  return x;\n}\nuint32_t interleave16(uint16_t a, uint16_t b){\n  return spread16(a) | (spread16(b) << 1);\n}\n```\n\n## Follow-up Questions\n- How would you generalize to interleave 32-bit values into a 64-bit result?\n- What tests would you add to validate edge cases like a or b == 0xFFFF?","diagram":null,"difficulty":"intermediate","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Snowflake","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T10:24:33.809Z","createdAt":"2026-01-12T10:24:33.809Z"},{"id":"q-823","question":"Implement rotateLeft32(uint32_t n, unsigned int k) that returns the 32-bit value formed by rotating n left by k bits. Constraints: no loops or conditionals; handle k >= 32 by using k % 32. Provide the function signature and a brief justification, and give 1-2 quick examples?","answer":"One correct approach uses (n << k) | (n >> (32 - k)) with k %= 32. If k==0, returns n; no branches. This uses only bitwise shifts and OR. Examples: rotateLeft32(0x12345678, 4) = 0x23456781; rotateLeft","explanation":"## Why This Is Asked\nTests ability to implement a classic bit manipulation pattern without branches, reflecting real-world needs in low-level systems.\n\n## Key Concepts\n- Bitwise rotation vs shift\n- Handling 32-bit wrap with modulo 32\n- Edge case k=0 without branches\n\n## Code Example\n```javascript\nuint32_t rotateLeft32(uint32_t n, unsigned int k) {\n  k &= 31; // k % 32\n  return (n << k) | (n >> (32 - k));\n}\n```\n```\n\n## Follow-up Questions\n- How would you adapt for 64-bit values?\n- What are the hazards with signed integers and how to avoid them?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","LinkedIn","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T11:20:30.427Z","createdAt":"2026-01-12T11:20:30.427Z"},{"id":"q-830","question":"Implement xor32(uint32_t a, uint32_t b) that returns a ^ b without using the ^ operator. Use only &, |, ~ and shifts. Provide the function signature and a brief justification, plus 1-2 quick examples to verify correctness?","answer":"Use the identity a ^ b = (a | b) & ~(a & b). Implement: static inline uint32_t xor32(uint32_t a, uint32_t b) { return (a | b) & ~(a & b); }. Rationale: per-bit XOR is 1 when exactly one input bit is 1","explanation":"## Why This Is Asked\n\nTests understanding of bit-level identities and branchless implementation, common in low-level systems, kernels, and performance-critical code.\n\n## Key Concepts\n\n- De Morgan's laws and bitwise algebra\n- Implementing XOR without ^ using only &, |, ~\n- Verifying correctness with small binary-pattern examples\n\n## Code Example\n\n```javascript\n// Implementation code for xor32 (C-like)\n#include <stdint.h>\nuint32_t xor32(uint32_t a, uint32_t b) {\n  return (a | b) & ~(a & b);\n}\n```\n\n## Follow-up Questions\n\n- How would you adjust if only ~ and & were allowed (no |)?\n- How would you test edge cases like a=0, b=0 and a=0xFFFFFFFF, b=0x0F0F0F0F?","diagram":null,"difficulty":"beginner","tags":["bit-manipulation"],"channel":"bit-manipulation","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T12:42:34.459Z","createdAt":"2026-01-12T12:42:34.459Z"}],"subChannels":["general"],"companies":["Adobe","Amazon","Apple","Bloomberg","Citadel","Cloudflare","Coinbase","Databricks","DoorDash","Google","Hashicorp","IBM","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","Netflix","Oracle","PayPal","Plaid","Slack","Snap","Snowflake","Stripe","Twitter","Two Sigma","Uber","Zoom"],"stats":{"total":21,"beginner":7,"intermediate":8,"advanced":6,"newThisWeek":21}}