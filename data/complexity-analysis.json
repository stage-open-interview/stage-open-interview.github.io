{"questions":[{"id":"q-678","question":"In a directed acyclic graph with N nodes and M edges, all edge costs are nonnegative. Compute the minimum-cost path from S to T. Costs can decrease online; design a strategy to maintain shortest paths with updates, aiming for sublinear re-computation on average. Provide initial complexity and amortized update complexity, plus memory usage and practical optimizations?","answer":"Initial: run a topological DP in O(N+M) to obtain dist to all nodes. Online decreases trigger relaxations: if w(u,v) decreases and dist[u]+w(u,v) < dist[v], update dist[v] and propagate to successors ","explanation":"## Why This Is Asked\n\nTests online update handling, DAG shortest paths, and amortized analysis.\n\n## Key Concepts\n\n- DAG shortest paths via topological order\n- Dynamic relaxations under decreasing edge weights\n- Amortized analysis and worst-case bounds\n\n## Code Example\n\n```javascript\nfunction updateShortestPaths(n, adj, dist, s, t, u, v, wOld, wNew){\n  // assume we know wOld and wNew with a decrease; perform relaxation\n  if(dist[u] + wNew < dist[v]){\n    dist[v] = dist[u] + wNew;\n    // push v to a queue and relax its outgoing edges\n  }\n  // ... full propagation would run until convergence\n}\n```\n\n## Follow-up Questions\n\n- How would you adapt for non-DAG graphs?\n- How does update order affect performance in practice?","diagram":"flowchart TD\n  A[Initial topological DP] --> B[Edge decrease detected]\n  B --> C[Relax dist[v]]\n  C --> D[Propagate changes]\n  D --> E[Converged]","difficulty":"advanced","tags":["complexity-analysis"],"channel":"complexity-analysis","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Meta","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T15:56:43.115Z","createdAt":"2026-01-11T15:56:43.115Z"},{"id":"q-690","question":"Design a data structure to support two online operations on an integer array A of length N: 1) rangeAdd(l, r, delta) adds delta to A[i] for l <= i <= r, 2) queryMaxSubarray() returns the maximum subarray sum of the current A. Provide a structure that supports both operations in O(log N) time, describe what to store per node, how to merge children, and how to apply a lazy add. Include correctness and complexity considerations?","answer":"Use a segment tree with lazy propagation. Each node stores: total sum, max prefix, max suffix, and max subarray. To add v to a range, lazily update the node: adjust sum, pref, suff, and propagate lazi","explanation":"## Why This Is Asked\nTests ability to combine range updates with non-linear objective (max subarray) and shows knowledge of segment trees, lazy propagation, and invariants under updates.\n\n## Key Concepts\n- Segment tree with lazy propagation\n- Node values: sum, max prefix, max suffix, max subarray\n- Merge operation correctness\n- Complexity analysis: O(log N) per op, O(N) memory\n- Edge cases: all negative arrays, large deltas, non-overlapping ranges\n\n## Code Example\n```javascript\nclass Node { constructor(sum=0,pref=-Infinity,suff=-Infinity,best=-Infinity){ this.sum=sum; this.pref=pref; this.suff=suff; this.best=best; } }\n```\n\n## Follow-up Questions\n- How would you adapt if rangeAdd is replaced with rangeMultiply?\n- How would you extend to support range assign and query across multiple segments?","diagram":null,"difficulty":"intermediate","tags":["complexity-analysis"],"channel":"complexity-analysis","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T16:23:52.242Z","createdAt":"2026-01-11T16:23:52.242Z"}],"subChannels":["general"],"companies":["Goldman Sachs","Lyft","Meta","Microsoft","Oracle"],"stats":{"total":2,"beginner":0,"intermediate":1,"advanced":1,"newThisWeek":2}}