{"questions":[{"id":"linux-foundation-sysadmin-essential-commands-1768169900531-0","question":"Which command creates a gzipped tarball of the contents of the directory /srv/app, excluding the file config.yaml?","answer":"[{\"id\":\"a\",\"text\":\"tar czf /backup/app.tar.gz -C /srv/app --exclude=config.yaml .\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"tar czf /backup/app.tar.gz -C /srv/app/config.yaml .\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"tar czf /backup/app.tar.gz -C /srv/app --exclude=/srv/app/config.yaml .\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"tar czf /backup/app.tar.gz -C /srv/app --exclude=config.yaml\",\"isCorrect\":false}]","explanation":"## Correct Answer\nA. The command tar czf /backup/app.tar.gz -C /srv/app --exclude=config.yaml . creates a gzipped tarball of the directory /srv/app, excluding the file named config.yaml. The -C /srv/app switches to that directory, and the trailing . includes all contents. The --exclude flag patterns exclude matching paths from the archive.\n\n## Why Other Options Are Wrong\n- B attempts to archive a single file path instead of the directory contents and would not produce the full directory tree as intended.\n- C uses an absolute path in --exclude which tar may interpret relative to the -C path and could fail to exclude the intended file.\n- D uses a non-existent short option -exclude and would fail to parse.\n\n## Key Concepts\n- Tar with compression: czf\n- -C to change directory before archiving\n- --exclude to skip patterns\n- including the contents of a directory with .\n\n## Real-World Application\n- Backing up an application directory while omitting sensitive or large config files during automated backups.","diagram":null,"difficulty":"intermediate","tags":["Linux","Essential Commands","AWS","Kubernetes","Terraform","certification-mcq","domain-weight-25"],"channel":"linux-foundation-sysadmin","subChannel":"essential-commands","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T22:18:20.535Z","createdAt":"2026-01-11 22:18:20"},{"id":"linux-foundation-sysadmin-essential-commands-1768169900531-1","question":"You want to list the 20 most recently modified files under /var/log, including their full paths, and constrain results to regular files only. Which command is most robust?","answer":"[{\"id\":\"a\",\"text\":\"find /var/log -type f -printf '%T@ %p\\\\n' | sort -n | tail -n 20\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"ls -ltR /var/log | head -n 20\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"find /var/log -type d -mtime -1\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"stat -c '%y %n' /var/log/* | sort -n | tail -n 20\",\"isCorrect\":false}]","explanation":"## Correct Answer\nA. The find command with -type f restricts to files, -printf '%T@ %p' prints a timestamp and path, and sorting by time then tail -n 20 returns the 20 most recently modified files with full paths.\n\n## Why Other Options Are Wrong\n- B lists entries recursively but may include directories and non-files, and head -n 20 may miss the actual most recently modified files and not show full paths consistently.\n- C searches only directories, not files.\n- D uses wildcard expansion that may fail with spaces or hidden files and does not filter by modification time as robustly.\n\n## Key Concepts\n- find with -type f and -printf\n- Sorting by timestamp to identify recent changes\n- Handling full paths for real-world log audits\n\n## Real-World Application\n- Quickly auditing the most recently updated log files for incident response or troubleshooting.","diagram":null,"difficulty":"intermediate","tags":["Linux","Essential Commands","AWS","Kubernetes","Terraform","certification-mcq","domain-weight-25"],"channel":"linux-foundation-sysadmin","subChannel":"essential-commands","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T22:18:21.057Z","createdAt":"2026-01-11 22:18:21"},{"id":"linux-foundation-sysadmin-essential-commands-1768169900531-2","question":"Which command prints the top memory consuming process's PID and RSS value, ignoring the header line, in a single line?","answer":"[{\"id\":\"a\",\"text\":\"ps -eo pid,rss,cmd --sort=-rss | awk 'NR==2{print $1, $2}'\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"ps -eo pid,rss,cmd --sort=-rss | sed -n '2p'\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"ps -eo pid,rss,cmd --sort=-rss | tail -n +2 | head -n 1\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"ps aux --sort=-rss | head -n 1\",\"isCorrect\":false}]","explanation":"## Correct Answer\nA. The command prints only the PID and RSS fields for the second line of the ps output, which corresponds to the top memory-consuming process when sorted by RSS. The use of awk ensures only PID and RSS are shown.\n\n## Why Other Options Are Wrong\n- B prints the entire line which also contains the CMD, not just PID and RSS.\n- C skips the header but may return the top line differently depending on environment and still includes more fields if not filtered.\n- D shows the header line or the first line of ps output in some environments, which does not guarantee extracting PID and RSS of the top memory process.\n\n## Key Concepts\n- ps with --sort=-rss for memory ranking\n- awk to select specific columns\n- Excluding the header for clean data extraction\n\n## Real-World Application\n- Quickly triaging memory hogs on a live server during incident response.","diagram":null,"difficulty":"intermediate","tags":["Linux","Essential Commands","AWS","Kubernetes","Terraform","certification-mcq","domain-weight-25"],"channel":"linux-foundation-sysadmin","subChannel":"essential-commands","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T22:18:21.523Z","createdAt":"2026-01-11 22:18:21"},{"id":"q-881","question":"On a Linux host, a long-running daemon writes to `/var/log/myapp.log` and is managed by systemd, but log rotation occasionally causes logging to stop after rotation. Propose a practical fix to ensure logging continues after rotation without restarting the daemon. Include the exact approach and a sample logrotate config snippet and testing steps?","answer":"Configure logrotate to reopen the log file after rotation instead of copying or truncating. After rotating, signal the daemon to reopen logs (e.g., SIGHUP). The config should include a postrotate that","explanation":"## Why This Is Asked\nTests practical handling of log rotation, signals, and ensuring service continuity without downtime. It checks knowledge of logrotate postrotate scripts, choosing the right approach (signal vs copytruncate), and how to validate in a controlled test.\n\n## Key Concepts\n- logrotate configuration fields and postrotate scripts\n- signaling daemons (SIGHUP) to reopen logs\n- copytruncate vs signaling trade-offs\n- testing routine for rotation\n\n## Code Example\n```bash\n/var/log/myapp.log {\n  rotate 5\n  weekly\n  missingok\n  notifempty\n  postrotate\n    kill -HUP `cat /var/run/myapp.pid` 2>/dev/null || true\n  endscript\n}\n```\n\n## Follow-up Questions\n- What are the trade-offs of copytruncate vs signaling?\n- How would you monitor and alert if log rotation fails to reopen logs?","diagram":null,"difficulty":"beginner","tags":["linux-foundation-sysadmin"],"channel":"linux-foundation-sysadmin","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Meta","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T13:59:55.582Z","createdAt":"2026-01-12T13:59:55.582Z"},{"id":"q-888","question":"A production Linux host runs a data-backup agent that uses /var/lib/backup/backup.lock to enforce a single instance. Sometimes a stale lock remains after a crash, blocking new runs; the agent also leaves non-terminating children on stop, risking partial backups. Propose a systemd‑based lifecycle fix: ensure one instance, auto-clean stale lock, and graceful stop with timeout and fallback to kill. Include concrete unit snippets and verification steps?","answer":"Use a systemd unit with Type=forking, PIDFile, and ExecStartPre that checks and clears a stale lock: if /var/lib/backup/backup.lock exists and its PID is not running, delete it. Stop uses KillMode=con","explanation":"## Why This Is Asked\nTests understanding of robust service lifecycle management with systemd, handling singleton constraints, and clean termination of complex processes.\n\n## Key Concepts\n- systemd lifecycle: ExecStartPre, ExecStop, KillMode, TimeoutStopSec\n- singleton enforcement via lock files\n- graceful termination vs. forceful kill for child processes\n\n## Code Example\n```ini\n; /etc/systemd/system/backup-agent.service\n[Unit]\nDescription=Backup Agent\nAfter=network.target\n\n[Service]\nType=forking\nPIDFile=/var/run/backup/backup.pid\nExecStartPre=/bin/sh -c 'LOCK=/var/lib/backup/backup.lock; if [ -e \"$LOCK\" ]; then pid=$(cat \"$LOCK\"); if [ -d /proc/$pid ]; then exit 1; else rm -f \"$LOCK\"; fi; fi'\nExecStart=/usr/local/bin/backup-agent\nExecStop=/bin/kill -TERM $MAINPID\nExecStopPost=/bin/rm -f /var/lib/backup/backup.lock\nTimeoutStopSec=120s\nKillMode=control-group\nRestart=on-failure\n```\n\n## Follow-up Questions\n- How would you test idempotency for consecutive startups?\n- How would you adapt if the agent uses a PID file instead of a lock file?","diagram":null,"difficulty":"advanced","tags":["linux-foundation-sysadmin"],"channel":"linux-foundation-sysadmin","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T14:27:44.056Z","createdAt":"2026-01-12T14:27:44.056Z"},{"id":"linux-foundation-sysadmin-operation-running-1768206659074-0","question":"On a server running systemd, the persistent journal is consuming disk space. You want to reduce the stored logs to a maximum 500M while preserving the most recent logs. Which command should you run?","answer":"[{\"id\":\"a\",\"text\":\"journalctl --rotate && journalctl --vacuum-size=500M\",\"isCorrect\":false},{\"id\":\"b\",\"text\":\"journalctl --vacuum-size=500M\",\"isCorrect\":true},{\"id\":\"c\",\"text\":\"systemctl restart systemd-journald\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"rm -rf /var/log/journal/*\",\"isCorrect\":false}]","explanation":"## Q1 Correct Answer\n- B\n\n## Why Other Options Are Wrong\n- A: Rotating logs without vacuuming may not reduce total space to the desired limit and can still leave old entries. Vacuum requires size limit and keeps recent data when combined with rotation; using only rotate without vacuum is insufficient.\n- C: Restarting the service does not reduce the amount of stored logs; it only restarts the daemon and may trigger a new log file but does not enforce retention.\n- D: Manual deletion of journal files can corrupt the journal or lose the ability to query it reliably; it bypasses proper retention policies and may break integrity.\n\n## Key Concepts\n- Systemd journal retention\n- journalctl vacuum options\n- Persistent vs volatile journald storage\n\n## Real-World Application\n- You implement automated log retention for hosts running systemd, ensuring disk space is reclaimed without losing access to the most recent events.","diagram":null,"difficulty":"intermediate","tags":["Linux","systemd","journald","AWS","Kubernetes","certification-mcq","domain-weight-20"],"channel":"linux-foundation-sysadmin","subChannel":"operation-running","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T08:30:59.075Z","createdAt":"2026-01-12 08:30:59"},{"id":"linux-foundation-sysadmin-operation-running-1768206659074-1","question":"You maintain a daemon on a systemd-based host. The daemon occasionally terminates due to transient errors. You want systemd to restart it automatically but with a backoff to avoid flapping. Which unit configuration is correct?","answer":"[{\"id\":\"a\",\"text\":\"Restart=on-failure, RestartSec=10s\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"Restart=always, RestartSec=0s\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"Restart=on-success, RestartSec=60s\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"TimeoutStartSec=2s, StartLimitInterval=60s\",\"isCorrect\":false}]","explanation":"## Q2 Correct Answer\n- A\n\n## Why Other Options Are Wrong\n- B: Restart=always restarts the service even on normal exits or successes, which can cause unnecessary restarts.\n- C: Restart=on-success would only restart on a clean exit, which is not suitable for transient failures.\n- D: TimeoutStartSec and StartLimitInterval are unrelated to implementing a backoff restart policy and do not guarantee backoff behavior.\n\n## Key Concepts\n- systemd Restart options\n- Backoff strategies\n- StartLimit to prevent crash loops\n\n## Real-World Application\n- Applying backoff policies prevents log floods and helps maintain service stability during transient issues.","diagram":null,"difficulty":"intermediate","tags":["Linux","systemd","monitoring","AWS","Kubernetes","certification-mcq","domain-weight-20"],"channel":"linux-foundation-sysadmin","subChannel":"operation-running","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T08:30:59.498Z","createdAt":"2026-01-12 08:30:59"},{"id":"linux-foundation-sysadmin-operation-running-1768206659074-2","question":"A backup script run by cron fails because required commands are not in cron's default PATH. What change will most reliably ensure the script runs under cron?","answer":"[{\"id\":\"a\",\"text\":\"Call absolute paths for all commands and set PATH explicitly at the top of the script\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"Source the user's profile from cron before running the script\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"Move binaries into a directory that is in cron's default PATH\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Run the script using at instead of cron\",\"isCorrect\":false}]","explanation":"## Q3 Correct Answer\n- A\n\n## Why Other Options Are Wrong\n- B: Cron typically does not source user profiles; relying on profiles is not dependable for cron jobs.\n- C: Moving binaries to fit cron's PATH is impractical and can introduce maintenance issues; absolute paths are more reliable.\n- D: Using at changes scheduling semantics and is not a drop-in replacement for cron for recurring backups.\n\n## Key Concepts\n- Cron PATH limitations\n- Absolute paths in scripts\n- Environment isolation for scheduled jobs\n\n## Real-World Application\n- Ensures scheduled backups run reliably in production environments by eliminating PATH-related failures.","diagram":null,"difficulty":"intermediate","tags":["Linux","cron","shell","AWS","Kubernetes","certification-mcq","domain-weight-20"],"channel":"linux-foundation-sysadmin","subChannel":"operation-running","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T08:30:59.912Z","createdAt":"2026-01-12 08:30:59"},{"id":"linux-foundation-sysadmin-service-config-1768225717070-0","question":"Which approach ensures a systemd service runs with environment variables loaded from a file and restarts on failure while avoiding credential leakage?","answer":"[{\"id\":\"a\",\"text\":\"Place environment variables directly in the systemd unit and set Restart=always, User=appuser.\",\"isCorrect\":false},{\"id\":\"b\",\"text\":\"Use EnvironmentFile=/etc/app.env with restricted permissions, and set Restart=on-failure, User=appuser, WorkingDirectory=/opt/app.\",\"isCorrect\":true},{\"id\":\"c\",\"text\":\"Run the app as root and use Type=forking with a shell wrapper.\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Store credentials in /etc/profile.d and rely on PAM to inject environment.\",\"isCorrect\":false}]","explanation":"## Correct Answer\nThe correct option is B. Using EnvironmentFile loads environment variables from a dedicated file, keeping credentials separate from the unit file and allowing proper access controls. Restart=on-failure reduces unnecessary restarts on clean exits, and running as a non-privileged User improves security.\n\n## Why Other Options Are Wrong\n- A: While valid, embedding env vars in the unit is less maintainable and can expose secrets if the unit file is read by multiple admins; it also uses Restart=always which restarts even on clean exits.\n- C: Running as root and forking is insecure and unnecessary for most services; Type=simple is the default and safer when balanced with explicit startup behavior.\n- D: /etc/profile.d is not read by systemd services, so env vars would not be reliably loaded at service startup.\n\n## Key Concepts\n- Systemd EnvironmentFile mechanism\n- Service security and restart behavior\n\n## Real-World Application\n- Use EnvironmentFile for scalable, secure service configuration in production, with proper file permissions and a dedicated service user.","diagram":null,"difficulty":"intermediate","tags":["Linux","systemd","security","service-configuration","Kubernetes","AWS","Terraform","Logging","certification-mcq","domain-weight-20"],"channel":"linux-foundation-sysadmin","subChannel":"service-config","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T13:48:37.071Z","createdAt":"2026-01-12 13:48:37"},{"id":"linux-foundation-sysadmin-service-config-1768225717070-1","question":"To raise the per-service file descriptor limit for a high-traffic web server without editing the main unit file, which approach is best practice?","answer":"[{\"id\":\"a\",\"text\":\"Edit the nginx.service file to include LimitNOFILE=100000.\",\"isCorrect\":false},{\"id\":\"b\",\"text\":\"Create a drop-in override at /etc/systemd/system/nginx.service.d/override.conf with [Service] LimitNOFILE=100000, then run systemctl daemon-reload and restart.\",\"isCorrect\":true},{\"id\":\"c\",\"text\":\"Set a global limit in /etc/security/limits.conf for the nginx user.\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Use ulimit -n 100000 in the startup script and assume system-wide propagation.\",\"isCorrect\":false}]","explanation":"## Correct Answer\nOption B is correct because a drop-in override preserves the main unit intact and applies the limit only to the specific service. It also ensures the change survives daemon reloads after systemd reloads its configuration.\n\n## Why Other Options Are Wrong\n- A: Editing the main unit is less maintainable and risks conflicts with package updates; overrides are preferred.\n- C: Global limits may behave unexpectedly for other services and require pam or login session handling, which is not targeted.\n- D: ulmit affects shells, not the systemd service manager, and may not apply reliably during service startup.\n\n## Key Concepts\n- Systemd drop-in overrides\n- LimitNOFILE and service-specific resource control\n\n## Real-World Application\n- Use drop-in overrides to fine-tune resource limits per service in production without altering packaged unit files.","diagram":null,"difficulty":"intermediate","tags":["Linux","systemd","Networking","Kubernetes","AWS","Terraform","Logging","NGINX","certification-mcq","domain-weight-20"],"channel":"linux-foundation-sysadmin","subChannel":"service-config","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T13:48:37.611Z","createdAt":"2026-01-12 13:48:38"},{"id":"linux-foundation-sysadmin-service-config-1768225717070-2","question":"You want to harden SSH so that password authentication is disabled but key-based logins are allowed, and root login is disabled. Which configuration snippet in /etc/ssh/sshd_config achieves this correctly?","answer":"[{\"id\":\"a\",\"text\":\"PasswordAuthentication no and PermitRootLogin prohibit-password, then restart sshd.\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"PasswordAuthentication no, but PermitRootLogin yes, and rely on PAM to block passwords.\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"PasswordAuthentication yes and PermitRootLogin prohibit-password to force non-root logins.\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Disable SSH entirely and rely on physical access.\",\"isCorrect\":false}]","explanation":"## Correct Answer\nOption A is correct because it explicitly disables password-based authentication while allowing key-based logins via the SSH daemon and prohibits root SSH logins. Restarting sshd applies the changes.\n\n## Why Other Options Are Wrong\n- B: Root login is still allowed if PermitRootLogin is not properly set, and PAM alone cannot reliably enforce key-based authentication for all cases.\n- C: Enabling password authentication defeats the goal of password-less login, and prohibit-password for root does not cover non-root accounts.\n- D: Disabling SSH entirely is unacceptable for remote administration.\n\n## Key Concepts\n- SSH hardening best practices\n- SSHD configuration directives: PasswordAuthentication, PermitRootLogin\n\n## Real-World Application\n- Enabling key-based access while restricting root and password login is a standard security hardening step for servers exposed to untrusted networks.","diagram":null,"difficulty":"intermediate","tags":["Linux","SSH","Security","Access-Management","Kubernetes","AWS","Terraform","Logging","certification-mcq","domain-weight-20"],"channel":"linux-foundation-sysadmin","subChannel":"service-config","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T13:48:38.130Z","createdAt":"2026-01-12 13:48:38"},{"id":"linux-foundation-sysadmin-service-config-1768225717070-3","question":"A service writes high-volume logs to stdout and you want systemd to forward these logs to rsyslog for centralized logging, with log rotation handling. Which configuration sequence is correct?","answer":"[{\"id\":\"a\",\"text\":\"Enable ForwardToSyslog in /etc/systemd/journald.conf, configure rsyslog to write to /var/log/app/app.log, and set up logrotate for that file.\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"Direct the application to write to /var/log/app/app.log and configure rsyslog only, skipping journald.\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"Disable journald and write logs directly to /var/log/messages.\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Only configure rsyslog without systemd journal forwarding or log rotation.\",\"isCorrect\":false}]","explanation":"## Correct Answer\nOption A is correct because enabling ForwardToSyslog allows systemd journals to forward entries to rsyslog, enabling centralized logging. Configuring rsyslog to write to a dedicated file under /var/log/app and applying logrotate ensures manageable log sizes and rotations.\n\n## Why Other Options Are Wrong\n- B: Directing logs to a file via the application bypasses systemd/journald forwarding and misses unified log handling.\n- C: Disabling journald reduces the reliability of centralized logging and can complicate troubleshooting.\n- D: Without journald forwarding, you may lose structured metadata systemd provides; combining journald forwarding with rsyslog is preferred.\n\n## Key Concepts\n- Journald forwarding to syslog\n- rsyslog configuration and logrotate\n\n## Real-World Application\n- Centralized, rotated logging is critical for observable systems in production and for compliance audits.","diagram":null,"difficulty":"intermediate","tags":["Linux","systemd","Logging","rsyslog","logrotate","Kubernetes","AWS","Terraform","certification-mcq","domain-weight-20"],"channel":"linux-foundation-sysadmin","subChannel":"service-config","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T13:48:38.318Z","createdAt":"2026-01-12 13:48:38"},{"id":"linux-foundation-sysadmin-service-config-1768225717070-4","question":"Your application service depends on a PostgreSQL database running on localhost:5432. You want startup to wait until the database is reachable before starting the app. Which combination is considered best practice?","answer":"[{\"id\":\"a\",\"text\":\"Add After=postgresql.service to the unit file.\",\"isCorrect\":false},{\"id\":\"b\",\"text\":\"Add After=postgresql.service and ExecStartPre=/usr/local/bin/wait-for-db.sh localhost 5432 30.\",\"isCorrect\":true},{\"id\":\"c\",\"text\":\"Rely on systemd’s network-online.target to guarantee DB readiness.\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Use a separate restart policy that restarts the app if DB is unavailable.\",\"isCorrect\":false}]","explanation":"## Correct Answer\nOption B is correct because it combines a dependency on the database service with an explicit startup wait script that checks actual connectivity before launching the app, ensuring startup only proceeds when the DB is reachable.\n\n## Why Other Options Are Wrong\n- A: After=postgresql.service ensures ordering but does not guarantee the DB is ready to accept connections.\n- C: network-online.target only ensures network availability, not database readiness.\n- D: A restart policy does not guarantee initial startup sequencing or DB reachability.\n\n## Key Concepts\n- Systemd service dependencies\n- ExecStartPre health checks\n\n## Real-World Application\n- Implementing health checks at startup prevents race conditions between services in critical environments.","diagram":null,"difficulty":"intermediate","tags":["Linux","systemd","PostgreSQL","Kubernetes","AWS","Terraform","Database","certification-mcq","domain-weight-20"],"channel":"linux-foundation-sysadmin","subChannel":"service-config","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T13:48:38.498Z","createdAt":"2026-01-12 13:48:38"}],"subChannels":["essential-commands","general","operation-running","service-config"],"companies":["Apple","Goldman Sachs","Meta","Plaid","Snowflake"],"stats":{"total":13,"beginner":1,"intermediate":11,"advanced":1,"newThisWeek":13}}