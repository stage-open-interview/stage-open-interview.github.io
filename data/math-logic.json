{"questions":[{"id":"q-1133","question":"Scenario: a constraint-satisfaction problem with four tasks A,B,C,D each can be in domains {Pending, Running, Done}. Constraints: (A = Done) → (B = Running); (B = Running) → (C = Done); (C = Pending) → (D = Running); and (A = Pending) ∨ (D = Done). Is there a feasible assignment with at least one Running? Explain reasoning and outline a backtracking algorithm with forward-checking and 3-valued propagation to decide arbitrary such constraint sets?","answer":"Yes. Example: A=Done, B=Running, C=Done, D=Done satisfies all constraints and uses at least one Running. A=Done implies B=Running; B=Running implies C=Done; C≠Pending avoids the third rule; D=Done sat","explanation":"## Why This Is Asked\nTests ability to model tri-state CSPs with implications and a simple propagation strategy.\n\n## Key Concepts\n- Tri-state domains; constraint propagation; forward-checking; simple arc-consistency.\n- Handling conditional constraints like X=Done → Y=Running.\n\n## Code Example\n```javascript\n// minimal constraint-checker and backtracker skeleton\n```\n\n## Follow-up Questions\n- How would you extend to n variables? \n- How does you handle cycles in implications?\n","diagram":"flowchart TD\n  Start((Start))\n  ChooseVar[Choose variable with smallest domain]\n  AssignVal[Assign a domain value]\n  Propagate[Propagate constraints]\n  Conf{Conflict?}\n  Backtrack[Backtrack or fail]\n  Accept[Accept solution]\n  Start --> ChooseVar\n  ChooseVar --> AssignVal\n  AssignVal --> Propagate\n  Propagate --> Conf\n  Conf -- yes --> Backtrack\n  Conf -- no --> Accept\n  Backtrack --> ChooseVar","difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Lyft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T01:24:07.311Z","createdAt":"2026-01-13T01:24:07.311Z"},{"id":"q-1253","question":"Scenario: A deployment feature-flag policy defines three booleans F1, F2, F3 with these constraints: F1 -> F2, F2 -> F3, and exactly one of F1 and F3 is true, plus at least one flag is true. Is there a satisfying assignment? If yes, give one; if not, explain why. Then outline a tiny solver that encodes such constraints into a 2-SAT instance using an implication graph and SCC, with pseudocode?","answer":"Yes. A valid assignment is F1=0, F3=1, F2=0 (or 1). Check: F1->F2 is true; F2->F3 is true since F3=1; XOR true since 0≠1; at least one flag true via F3. Encoding: CNF is (¬F1 ∨ F2) ∧ (¬F2 ∨ F3) ∧ (F1 ","explanation":"## Why This Is Asked\nTests translating a small DSL of implications and XOR constraints into a 2-SAT form, then reasoning about satisfiability and a scalable solver using implication graphs and SCC.\n\n## Key Concepts\n- 2-SAT encoding\n- Implication graph and SCC\n- XOR-to-CNF transformation\n- Tarjan/Kosaraju SCC-based solver\n\n## Code Example\n```javascript\n// Pseudocode: build clauses, then run SCC to check contradictions\n```\n\n## Follow-up Questions\n- How does this scale to n flags with arbitrary XOR constraints?\n- How would you handle dynamic updates to constraints without recomputing from scratch?","diagram":"flowchart TD\n  F1[F1] --> F2[F2]\n  F2[F2] --> F3[F3]\n  XOR[XOR(F1,F3)] --> F1\n  XOR --> F3","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Meta","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T06:46:28.035Z","createdAt":"2026-01-13T06:46:28.035Z"},{"id":"q-1915","question":"You design a tiny policy engine for network ports where each port's state is Allow, Deny, or Unknown (A, D, U). Ports: 80, 443, 22, 23, 8080. Constraints: (80 → 443), (22 ∨ 23), (80 ∨ 22), (443 → ¬23). Is there an assignment with U that does not force any constraint to be definitively false? Explain how you would implement a 3-valued backtracking propagation to verify arbitrary such rule sets?","answer":"Yes. Using Kleene three-valued logic, A→B equals ¬A ∨ B with F<U<T. Propose: set 80=T, 443=U, 22=T, 23=F, 8080=T. Evaluate: 80→443: T→U = U (not false); 22∨23: T∨F = T; 80∨22: T∨T = T; 443→¬23: U→¬F =","explanation":"## Why This Is Asked\nTests ability to reason with tri-valued logic in practical rule systems, requiring concrete evaluation and a structured backtracking plan.\n\n## Key Concepts\n- 3-valued semantics (Kleene)\n- Implication as ¬A ∨ B\n- Backtracking with propagation of U\n\n## Code Example\n```javascript\nfunction phoVal(a){ /* placeholder: tri-valued logic emulation */ }\n```\n\n## Follow-up Questions\n- How would you extend to 4-valued logic with ‘Unknown but decidable’? \n- How does short-circuiting affect propagation in large rule sets?","diagram":"flowchart TD\n  A[80] --> B[443]\n  C[22] --> D[23]\n  E[80] --> F[22]\n  G[443] --> H[23]","difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","LinkedIn","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T16:59:35.366Z","createdAt":"2026-01-14T16:59:35.366Z"},{"id":"q-1930","question":"In a policy graph with rules of the form (P ∧ Q) → R, (P ∧ R) → S, and (Q ∧ S) → T, plus a set of base facts that you may set to true as needed, is there an assignment making T true without violating any rule? Provide an algorithm to compute a minimal witness (smallest base set) and apply it to this instance to show T is derivable with base facts {P, Q}?","answer":"Yes. With base facts P and Q true, R becomes true via (P ∧ Q) → R; then S via (P ∧ R) → S; then T via (Q ∧ S) → T. A minimal witness is {P, Q}. The algorithm uses forward-chaining with a small DFS/BFS","explanation":"## Why This Is Asked\n\nTo evaluate ability to design minimal-witness solvers for Horn-like rules and detect derivability with backtracking.\n\n## Key Concepts\n\n- Horn clauses\n- Minimal witness extraction\n- Forward-chaining with backtracking\n- Cycle detection in derivations\n\n## Code Example\n\n```javascript\n// simple forward-chaining for (A∧B)→C rules\nfunction canDerive(target, base, rules){\n  const derived = new Set(base);\n  let changed = true;\n  while (changed) {\n    changed = false;\n    for (const [A,B,C] of rules){\n      if (derived.has(A) && derived.has(B) && !derived.has(C)){\n        derived.add(C);\n        changed = true;\n      }\n    }\n  }\n  return derived.has(target);\n}\n```\n\n## Follow-up Questions\n\n- How would you extend to arbitrary antecedent sizes or negative literals?\n- How would you enumerate all minimal witnesses or detect unsatisfiable cycles in large graphs?","diagram":"flowchart TD\n  P(Base: P) --> R(R derived)\n  Q(Base: Q) --> R\n  R --> S\n  S --> T","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Databricks","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T17:45:24.925Z","createdAt":"2026-01-14T17:45:24.925Z"},{"id":"q-2088","question":"You manage access flags as a directed graph with A ≤ B meaning 'A true implies B true'. Given a required set T of flags that must be true, decide if a consistent assignment exists and produce the least-true model containing T. Describe a linear-time forward-closure algorithm that propagates truth along edges until a fixpoint, and how it handles cycles. Include a concrete 6-flag example with 7 relations?","answer":"Initialize a queue with the required set T and mark all flags in T as true. While the queue is not empty, pop a flag x and for each outgoing edge x→y, if y is not yet true, mark it as true and push y onto the queue. After propagation terminates, the true set represents the least upward-closed model containing T. This algorithm runs in O(V + E) time and handles cycles naturally: when a cycle is encountered, each flag is processed at most once, and the algorithm still produces the correct fixed-point.","explanation":"## Why This Is Asked\nTests understanding of graph reachability and fixed-point semantics in logical implications, with practical applications in policy and permission systems.\n\n## Key Concepts\n- Upward-closure in partially ordered sets\n- Fixed-point computation via forward-closure\n- Linear-time graph traversal algorithms\n- Cycle handling through visited state management\n\n## Code Example\n```javascript\nfunction propagate(T, edges) {\n  const trueSet = new Set(T);\n  const queue = [...T];\n  const adjacency = new Map();\n  \n  for (const [a, b] of edges) {\n    if (!adjacency.has(a)) adjacency.set(a, []);\n    adjacency.get(a).push(b);\n  }\n  \n  while (queue.length > 0) {\n    const x = queue.shift();\n    for (const y of adjacency.get(x) || []) {\n      if (!trueSet.has(y)) {\n        trueSet.add(y);\n        queue.push(y);\n      }\n    }\n  }\n  \n  return trueSet;\n}\n```\n\n## Example\nConsider flags {A,B,C,D,E,F} with relations: A→B, B→C, C→A (cycle), A→D, D→E, E→F, B→F. If T={A}, propagation yields {A,B,C,D,E,F} as the least model containing T.","diagram":null,"difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Goldman Sachs","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T05:03:46.198Z","createdAt":"2026-01-14T23:39:30.930Z"},{"id":"q-2194","question":"Given a finite Kripke model M = (W, {R_a, R_b}, V) with W = {w1,w2,w3}, agents a,b, and a proposition p with V(p) = {w1,w2}. After a public announcement of p, compute the updated model M|p and determine which worlds satisfy K_a p and K_b p. Then describe a linear-time algorithm using product update and forward closure to handle arbitrary finite models and sequences of announcements, including a small 3-world example to illustrate the steps?","answer":"Use public announcement logic: update M to M|p by discarding worlds not in V(p) and restricting R_i to surviving worlds. Then Ki p holds in w iff every w' with w R_i w' satisfies p in M|p. In the 3-wo","explanation":"## Why This Is Asked\nTests ability to apply public announcements to epistemic models and design a practical solver that scales with model size.\n\n## Key Concepts\n- Kripke models and accessibility relations\n- Public announcements and product update\n- Knowledge operator Ki and post-update evaluation\n- Linear-time propagation and fixpoint reasoning\n\n## Code Example\n```javascript\n// Minimal representation and product update sketch\nfunction productUpdate(W, relations, V, pSet) {\n  const Wp = W.filter(w => pSet.has(w));\n  const Rp = {};\n  for (const [AG, rel] of Object.entries(relations)) {\n    Rp[AG] = new Map();\n    for (const w of Wp) {\n      Rp[AG].set(w, rel.get(w).filter(v => pSet.has(v)));\n    }\n  }\n  return { W: Wp, relations: Rp };\n}\n\nfunction knows(pSet, w, agentRel) {\n  const targets = agentRel.get(w) || [];\n  return targets.every(u => pSet.has(u));\n}\n``` \n\n## Follow-up Questions\n- How to extend to more agents or multi-modal knowledge (common knowledge)?\n- How would you optimize for many sequential announcements or large models?\n- What are potential numerical issues with non-deterministic updates in practice?","diagram":"flowchart TD\n  A[Worlds W] -->|R_a| B[W1, W2, W3]\n  A -->|R_b| C[Edges per agent]\n  D{Announce p?}\n  D -->|Yes| E[M|p: remove non-p worlds]\n  E --> F[Evaluate Ki p on M|p]\n  F --> G[Update knowledge for each w]\n  G --> H[Scales to sequences of announcements]","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Instacart","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T07:02:41.111Z","createdAt":"2026-01-15T07:02:41.111Z"},{"id":"q-2286","question":"Design a solver for booleans with two constraint types: XOR constraints (subset S XOR = b) and at-least-k constraints on subsets. How would you decide satisfiability efficiently, encode the mix for a practical solver, and handle contradictions and scalability?","answer":"Model XOR constraints as a GF(2) linear system Ax = b. Encode at-least-k by introducing slack booleans and a CNF or linear encoding. Solve with sparse Gaussian elimination, then verify at-least constr","explanation":"## Why This Is Asked\nThis question probes the candidate's ability to combine algebraic reasoning (GF(2)) with combinatorial SAT techniques, and to design a solver architecture that scales with constraints. It tests encoding decisions, data structures (sparse matrices), and how to expose contradictions early.\n\n## Key Concepts\n- GF(2) linear algebra\n- Slack-variable encodings for at-least\n- Sparse Gaussian elimination\n- Constraint propagation and unsat witnesses\n\n## Code Example\n```\n// Pseudocode: assemble matrix A, vector b; run elimination; derive x; verify constraints\n```\n\n## Follow-up Questions\n- How would you extend to dynamic constraint streams?\n- How to optimize memory for very large x?","diagram":"flowchart TD\n  S[Parse constraints] --> E[Translate XORs to GF(2) system]\n  E --> L[Extend with slack vars for at-least constraints]\n  L --> SOL[Solve with sparse Gauss + LP-like check]\n  SOL --> V[Return solution or UNSAT]","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Instacart","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T10:46:41.704Z","createdAt":"2026-01-15T10:46:41.704Z"},{"id":"q-2441","question":"In a 3-valued logic with T, F, U, build a tiny circuit: inputs A, B, C; gates: G1 = A AND B; G2 = B OR C; G3 = NOT G1; G4 = G2 AND G3. Is there an assignment to (A, B, C) using U that yields G4 = U after standard Kleene-style tables? Explain how you would implement a small propagator to verify arbitrary such circuits?","answer":"Yes. Set A=B=C=U. Then G1 = U AND U = U; G2 = U OR U = U; G3 = NOT U = U; G4 = U AND U = U. To verify arbitrary circuits, implement a fixed-point propagator: maintain a worklist of gates, apply 3-valu","explanation":"## Why This Is Asked\nTests practical understanding of Kleene three-valued logic and how to implement a propagator for arbitrary circuits, a common check in hardware simulators and policy engines.\n\n## Key Concepts\n- Three-valued logic (T, F, U) and Kleene tables\n- Propagation with fixed-point iteration\n- Handling cycles in DAG vs. cyclic graphs\n\n## Code Example\n```javascript\nfunction kleeneAnd(a,b){ if(a===false || b===false) return false; if(a===true && b===true) return true; return 'U'; }\nfunction kleeneOr(a,b){ if(a===true || b===true) return true; if(a===false && b===false) return false; return 'U'; }\nfunction kleeneNot(a){ if(a===true) return false; if(a===false) return true; return 'U'; }\n```\n\n## Follow-up Questions\n- How would you scale this to circuits with hundreds of gates?\n- How would you extend to more truth values or probabilistic states?","diagram":"flowchart TD\n  A[A] --> G1[G1 = A AND B]\n  B[B] --> G1\n  B --> G2[G2 = B OR C]\n  C[C] --> G2\n  G1 --> G3[NOT G1]\n  G2 --> G4[G4 = G2 AND G3]\n  G3 --> G4","difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","NVIDIA","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T17:58:51.134Z","createdAt":"2026-01-15T17:58:51.134Z"},{"id":"q-2496","question":"Scenario: four attributes X,Y,Z,W take values 0,1, or U. Constraints: X+Y ≥ 1, Y ≥ Z, Z+W ≥ 1, W ≤ X. Is there an assignment that uses U for at least one variable while satisfying all constraints? Outline a straightforward 3-valued propagation plus backtracking to verify arbitrary such constraint sets?","answer":"Yes. Model X,Y,Z,W ∈ {0,1,U}. Use 3-valued propagation: tighten domains per constraint (e.g., X+Y≥1 excludes X=0 and Y=0; Z+W≥1 excludes Z=0 and W=0; W≤X bans W=1 if X=0). Then backtrack on U, trying ","explanation":"## Why This Is Asked\nTests ability to design a tiny constraint solver using 3-valued logic and backtracking, with a concrete, solvable example.\n\n## Key Concepts\n- 3-valued propagation\n- Domain narrowing for inequalities\n- Backtracking search\n- Early pruning and consistency checks\n\n## Code Example\n```javascript\n// Pseudocode for propagation and backtracking\n```\n## Follow-up Questions\n- How would you extend to non-linear constraints?\n- How does propagation complexity grow with variables?","diagram":"flowchart TD\n  X[X] -->|≥1| Y[Y]\n  Y -->|≥Z| Z[Z]\n  Z -->|≥1| W[W]\n  W -->|≤| X2[X]\n","difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Meta","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T20:37:09.469Z","createdAt":"2026-01-15T20:37:09.470Z"},{"id":"q-2696","question":"Design a tiny policy-engine puzzle: There are flags F1..F5 taking values Enable (E), Disable (D), or Unknown (U). Constraints:\n- If F1 is E then F2 is E.\n- If F2 is D then F3 is D.\n- If F4 is E then F5 is E.\n- At least one of F1 or F3 must be E unless F5 is D.\n- F3 cannot be E if F4 is D.\nIs there an assignment that uses U for at least one flag and satisfies all constraints? Propose a 3-valued propagation with backtracking approach and apply it to the concrete instantiation: F1=U, F2=U, F3=U, F4=D, F5=U; determine feasibility?","answer":"Yes. Example: F1=E, F2=E, F3=D, F4=D, F5=U satisfies all constraints and uses U. F1→F2 triggers F2=E; F1=E keeps F2 consistent; F4=D forbids F3=E; F5≠D requires F1 or F3=E, with F1=E this is satisfied","explanation":"## Why This Is Asked\nEvaluates ability to reason with partial information and implement a practical 3-valued constraint propagator with backtracking for policy-like rules.\n\n## Key Concepts\n- 3-valued logic propagation (E, D, U)\n- implication and unless-style constraints\n- backtracking with pruning on Unknowns\n\n## Code Example\n```javascript\n// Pseudo-propagation skeleton for 3-valued constraints\nfunction propagate(assign, rules) {\n  // rules: [{type:'imp', if: {F1:'E'}, then:{F2:'E'}}, ...]\n  // returns whether a satisfiable extension exists and updated assign\n}\n```\n\n## Follow-up Questions\n- How to detect cycles that force contradictions?\n- How to scale the approach to thousands of flags and complex constraints?","diagram":"flowchart TD\n  F1[E] --> F2[E]\n  F2[D] --> F3[D]\n  F4[E] --> F5[E]\n  F5 -->|not D| F1\n  subgraph Constraints\n  end","difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Slack","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T07:33:07.312Z","createdAt":"2026-01-16T07:33:07.312Z"},{"id":"q-3078","question":"You model a SQL-like WHERE clause with 4 predicates A,B,C,D each taking values TRUE, FALSE, or UNKNOWN. The formula is F = (A OR NOT B) AND (C XOR D). Is there an assignment that uses at least one UNKNOWN and makes F evaluate to TRUE under Kleene three-valued logic? Outline a concrete 3-valued propagation algorithm and a backtracking strategy to verify arbitrary such constraints?","answer":"Yes. For variables A, B, C, D ∈ {TRUE, FALSE, UNKNOWN}, the formula F = (A OR NOT B) AND (C XOR D) evaluates to TRUE with the assignment A = UNKNOWN, B = FALSE, C = TRUE, D = FALSE. Under Kleene's three-valued logic: NOT B = TRUE, so A OR NOT B = TRUE; and C XOR D = TRUE XOR FALSE = TRUE. Therefore, F = TRUE ∧ TRUE = TRUE, satisfying the requirement of using at least one UNKNOWN while making the formula evaluate to TRUE.","explanation":"## Why This Is Asked\n\nThis question evaluates the candidate's understanding of three-valued logic as implemented in SQL systems, where NULL values introduce UNKNOWN states that must propagate through logical expressions according to Kleene's truth tables.\n\n## Key Concepts\n\n- **Kleene Three-Valued Logic**: Extends classical logic with UNKNOWN (U) to handle missing/NULL data\n- **Truth Table Propagation**: Systematic application of Kleene's rules to reduce variable domains\n- **Constraint Propagation**: Forward checking algorithm that prunes inconsistent value assignments\n- **Backtracking Strategy**: Search with domain reduction and early failure detection\n\n## Algorithm Implementation\n\n```javascript\n// Kleene truth table operations\nfunction kleeneNot(x) { \n  return x === 'T' ? 'F' : x === 'F' ? 'T' : 'U';\n}\n\nfunction kleeneOr(a, b) {\n  if (a === 'T' || b === 'T') return 'T';\n  if (a === 'F' && b === 'F') return 'F';\n  return 'U';\n}\n\nfunction kleeneAnd(a, b) {\n  if (a === 'F' || b === 'F') return 'F';\n  if (a === 'T' && b === 'T') return 'T';\n  return 'U';\n}\n\nfunction kleeneXor(a, b) {\n  return kleeneOr(kleeneAnd(a, kleeneNot(b)), kleeneAnd(kleeneNot(a), b));\n}\n\n// Constraint propagation with backtracking\nfunction propagate(variables, targetValue) {\n  const domains = Object.keys(variables).reduce((acc, key) => {\n    acc[key] = ['T', 'F', 'U'];\n    return acc;\n  }, {});\n  \n  function backtrack() {\n    const unassigned = Object.keys(domains).filter(k => domains[k].length > 1);\n    if (!unassigned.length) {\n      const result = evaluateFormula(domains);\n      return result === targetValue;\n    }\n    \n    const varName = unassigned[0];\n    for (const value of domains[varName]) {\n      const savedDomains = JSON.parse(JSON.stringify(domains));\n      domains[varName] = [value];\n      \n      if (forwardCheck() && backtrack()) return true;\n      \n      Object.assign(domains, savedDomains);\n    }\n    return false;\n  }\n  \n  function forwardCheck() {\n    // Apply Kleene constraints to reduce inconsistent domains\n    return true; // Implement domain reduction logic\n  }\n  \n  function evaluateFormula(domains) {\n    const A = domains.A[0], B = domains.B[0];\n    const C = domains.C[0], D = domains.D[0];\n    const left = kleeneOr(A, kleeneNot(B));\n    const right = kleeneXor(C, D);\n    return kleeneAnd(left, right);\n  }\n  \n  return backtrack();\n}\n```\n\nThis approach systematically explores the search space while leveraging Kleene's logical rules to prune inconsistent assignments early, ensuring efficient constraint satisfaction in three-valued logic contexts.","diagram":"flowchart TD\n  Q[Query model] --> P[Propagate with Kleene tables]\n  P --> C[Prune domains]\n  C --> A[Accept / Backtrack]\n  A --> Q","difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Goldman Sachs","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T05:12:32.066Z","createdAt":"2026-01-16T23:46:48.399Z"},{"id":"q-3166","question":"You maintain a tiny 3-valued data-validation rule engine. Variables X, Y, Z, W take values True, False, Unknown. Constraints: (X OR Y) AND (X AND Z) -> W AND (W OR Z) is True. Is there an assignment with at least one Unknown that makes the whole formula True? Provide a concrete assignment and concise justification?","answer":"Yes. Example: X = U, Y = T, Z = F, W = T. Evaluate: X OR Y = T; X AND Z = U AND F = F; (X AND Z) -> W = T; W OR Z = T. All subexpressions evaluate to True, and X remains Unknown, satisfying the condit","explanation":"## Why This Is Asked\nTests ability to reason with Kleene-style 3-valued logic and design tiny propagators for constraint sets.\n\n## Key Concepts\n- 3-valued logic (True, False, Unknown)\n- Kleene-style truth tables\n- Satisfiability with Unknowns and propagation\n\n## Code Example\n```javascript\n// simple evaluator sketch\nfunction not3(v){ return v=== 'T' ? 'F' : v==='F' ? 'T' : 'U'; }\nfunction or3(a,b){ if(a==='T' || b==='T') return 'T'; if(a==='F' && b==='F') return 'F'; return 'U'; }\nfunction and3(a,b){ if(a==='F' || b==='F') return 'F'; if(a==='T' && b==='T') return 'T'; return 'U'; }\nfunction imp3(a,b){ // a -> b  is (!a) OR b\n  const na = not3(a); if(na==='T' && b==='F') return 'F'; if(na==='T') return b; if(na==='F') return 'T'; return 'U'; }\n```\n\n## Follow-up Questions\n- How would you implement a propagator to handle larger rule sets?\n- How does short-circuiting affect unknown propagation in practice?","diagram":null,"difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T05:31:36.212Z","createdAt":"2026-01-17T05:31:36.212Z"},{"id":"q-3247","question":"Given a directed graph where each node i has a threshold t_i (0 ≤ t_i ≤ indeg(i)) and a node is true iff at least t_i of its in-neighbors are true, does there exist a fixed point S containing a specified T? If yes, compute the least such fixed point. Outline a linear-time propagation algorithm that handles cycles and illustrate with a concrete 6-node, 7-edge example?","answer":"Start with S = T. Maintain count[v] = number of in-neighbors of v in S. Initialize with T, queue them. When you pop u, for each v in succ(u), increment count[v]; if count[v] ≥ t_v and v ∉ S, add v to ","explanation":"## Why This Is Asked\nTests understanding of least fixed-point computation in monotone boolean networks with thresholds and how to implement an efficient propagation algorithm that converges even with cycles.\n\n## Key Concepts\n- Monotone operators and least fixed points\n- Threshold-based activation with in-neighbor counting\n- Queue-driven BFS-like propagation\n- Handling cycles via convergence to a fixpoint\n\n## Code Example\n```javascript\n// Pseudo-implementation of the propagation\nfunction leastFixedPoint(T, edges, thresh) {\n  const n = thresh.length;\n  const succ = Array.from({length: n}, () => []);\n  for (const [u,v] of edges) succ[u].push(v);\n  const count = Array(n).fill(0);\n  const inSet = Array(n).fill(false);\n  const q = [];\n  for (const i of T) { inSet[i] = true; q.push(i); }\n  while (q.length) {\n    const u = q.shift();\n    for (const v of succ[u]) {\n      count[v]++;\n      if (!inSet[v] && count[v] >= thresh[v]) {\n        inSet[v] = true;\n        q.push(v);\n      }\n    }\n  }\n  return Array.from({length: n}, (_,i) => i).filter(i => inSet[i]);\n}\n```\n\n## Follow-up Questions\n- How would you adapt for weighted thresholds or non-monotone edges?\n- How would you prove the result is the least fixed point containing T?","diagram":"flowchart TD\n  A[Nodes A-F] --> B[Edge A->B]\n  A --> C[Edge A->C]\n  B --> D[D node]\n  C --> D\n  D --> E\n  E --> F\n  F --> D","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T08:42:43.337Z","createdAt":"2026-01-17T08:42:43.337Z"},{"id":"q-3329","question":"Given N boolean flags X1..XN and constraints Xi XOR Xj = c (c in {0,1}) and optional fixed Xi = di, determine if the system is consistent and output a model with the minimum number of true flags. Describe a linear-time algorithm to check consistency, derive per-component solutions, and pick root values to minimize total true bits. For a concrete 5-flag example with 6 constraints, what is the minimum-weight solution?","answer":"Build a graph with edges i-j labeled c for Xi XOR Xj = c and mark fixed nodes Xi = di. For each connected component, compute dist[i] by DFS: Xi = Xroot XOR dist[i]. If a cycle yields inconsistent dist","explanation":"## Why This Is Asked\n\nTests ability to model XOR constraints as graph edges, detect cycle inconsistencies, and design a linear-time minimization of a solution under free roots. Combines graph algorithms with a small amount of linear algebra over GF(2) and a practical optimization goal.\n\n## Key Concepts\n\n- XOR constraints on pairs -> edge-labeled graph\n- Cycle parity consistency\n- Component-wise root assignment and fixed-node propagation\n- Minimizing Hamming weight under linear constraints\n\n## Code Example\n\n```javascript\n// Pseudo-implementation sketch (not complete)\nfunction minWeightXor(n, edges, fixed){\n  // build graph, DFS to compute dist and check consistency\n  // if fixed, deduce root; else pick root to minimize weight\n}\n```\n\n## Follow-up Questions\n\n- How would you handle additional constraints Xi = NOT Xj?\n- How to extend to handle weighted costs or non-binary states?","diagram":"flowchart TD\n  A[Build constraint graph: edges Xi XOR Xj = c, optional Xi = di]\n  B[Check cycle consistency by dist parity]\n  C[Apply fixed-node constraints to deduce root]\n  D[If no fixed root, compute weights for root 0/1]\n  E[Assemble final minimum-weight solution]\n  F[Return infeasible if inconsistency]\n\n  A --> B\n  B --> C\n  C --> D\n  D --> E\n  E --> F","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Discord","LinkedIn"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T11:36:45.152Z","createdAt":"2026-01-17T11:36:45.152Z"},{"id":"q-3355","question":"In a tiny 3-valued dataflow analysis with values {T, F, U}, given SSA vars B, C, E (inputs) and derived A = B AND C; D = NOT E; F = D OR A. Is there a choice of B, C, E from {T, F, U} such that after Kleene-style propagation to a fixpoint, F evaluates to U? Explain the propagation steps and a succinct algorithm to verify arbitrary such sets?","answer":"Yes. Take B=U, C=T, E=U. Then A=U∧T=U; D=¬U=U; F=U∨U=U. A worklist-based fixpoint with Kleene truth tables (NOT, AND, OR) propagates until no change. This demonstrates existence and provides a scalabl","explanation":"## Why This Is Asked\nTests 3-valued dataflow reasoning, fixpoint propagation, and translating logic into a workable algorithm.\n\n## Key Concepts\n- Kleene three-valued logic (T, F, U)\n- Worklist/fixpoint propagation\n- Dataflow dependency graphs\n- Handling cycles and convergence\n\n## Code Example\n```javascript\n// Kleene 3-valued logic\nconst T = true, F = false, U = 'U';\nfunction not(x){ if (x===T) return F; if (x===F) return T; return U; }\nfunction and(a,b){ if (a===F || b===F) return F; if (a===T && b===T) return T; return U; }\nfunction or(a,b){ if (a===T || b===T) return T; if (a===F && b===F) return F; return U; }\n\n// program: A = B AND C; D = NOT E; F = D OR A\nlet B = U, C = T, E = U;\nlet A = and(B, C);\nlet D = not(E);\nlet F = or(D, A);\n```\n\n## Follow-up Questions\n- How would you extend to cycles and determine worst-case iterations?\n- How would you optimize for sparse graphs and pruning impossible combinations?","diagram":"flowchart TD\n  B[Input: B] --> A[A = B AND C]\n  C[Input: C] --> A\n  E[Input: E] --> D[D = NOT E]\n  A --> F[F = D OR A]\n  D --> F","difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Scale Ai","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T13:12:10.843Z","createdAt":"2026-01-17T13:12:10.843Z"},{"id":"q-3607","question":"Design a tiny policy engine for a microservice access rule set in 3-valued logic (T, F, U). Variables A,B,C,D ∈ {T,F,U}. Constraints: (A ∧ B) → D; (¬A ∨ C) → D; (D ∧ ¬C) → A. Is there an assignment to (A,B,C,D) using U that does not force any constraint to be definitively false? Explain propagation steps and outline an algorithm to verify arbitrary such rule sets?","answer":"Yes. One valid assignment is A=U, B=F, C=U, D=U. Under Kleene's three-valued logic (¬U=U, F∧x=F, T∧x=x, etc.), the constraints evaluate as follows: 1) A∧B = F, and F→D = T; 2) ¬A∨C = U, and U→D = U; 3) D∧¬C = U, and U→A = U. None of the constraints evaluates to false. A tri-valued propagator iteratively applies constraint rules until reaching a fixpoint, using Kleene semantics to handle unknown values.","explanation":"## Why This Is Asked\nThis question tests the ability to reason with three-valued semantics in policy rule evaluation and to design a generic propagator for real-world constraints.\n\n## Key Concepts\n- Kleene three-valued logic semantics\n- Implication evaluation under unknown values\n- Constraint propagation mechanisms\n- Fixpoint iteration algorithms\n- Practical design patterns for policy engines\n\n## Code Example\n```javascript\n// Kleene three-valued logic implementation\nfunction not(x) { \n  if (x === 'T') return 'F'; \n  if (x === 'F') return 'T'; \n  return 'U'; \n}\n\nfunction and(x, y) { \n  if (x === 'F' || y === 'F') return 'F'; \n  if (x === 'U' || y === 'U') return 'U'; \n  return 'T'; \n}\n\nfunction or(x, y) { \n  if (x === 'T' || y === 'T') return 'T'; \n  if (x === 'U' || y === 'U') return 'U'; \n  return 'F'; \n}\n\nfunction implies(x, y) { \n  if (x === 'F') return 'T'; \n  if (x === 'U') return y === 'T' ? 'T' : 'U'; \n  return y; \n}\n\n// Constraint propagator\nfunction propagate(constraints, variables) {\n  let changed = true;\n  while (changed) {\n    changed = false;\n    for (const constraint of constraints) {\n      const result = evaluate(constraint, variables);\n      if (result === 'F') return false;\n      // Update variables based on constraint results\n      // Implementation depends on constraint type\n    }\n  }\n  return true;\n}\n```\n\n## Algorithm Outline\n1. Initialize variables with given values\n2. Iteratively apply constraints using Kleene semantics\n3. Track variable changes until fixpoint reached\n4. Return false if any constraint evaluates to false\n5. Return true with final variable assignment otherwise","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T05:28:47.370Z","createdAt":"2026-01-17T23:33:17.256Z"},{"id":"q-3685","question":"Let V be a set of boolean variables. We have Horn clauses of the form (A1 ∧ ... ∧ Ap) -> B. Each variable v has a nonnegative cost c(v) for setting it true. Given a required set T ⊆ V that must be true and a budget K, decide if there exists a model with T true and total cost ≤ K, and produce the minimum-cost model if possible. Explain a forward-chaining approach to minimize cost, handle cycles, and illustrate with a small 5-variable example showing two feasible models with different costs?","answer":"Use a forward-chaining closure over Horn clauses with costs. Start from T, maintain a min-cost true-set S; only trigger a clause (A1 ∧ ... ∧ Ap) -> B when all antecedents are in S, then add B if its c","explanation":"## Why This Is Asked\nTests ability to design a cost-aware Horn-solver, handling cycles, and producing a minimal-cost solution while respecting a budget.\n\n## Key Concepts\n- Horn clauses; forward-chaining; fixpoint\n- Cost-weighted model; budget-constrained search\n- Strongly connected components to manage cycles\n\n## Code Example\n```javascript\n// sketch of forward-chaining with costs\n```\n\n## Follow-up Questions\n- How would you prove correctness of your approach?\n- How would you extend to non-Horn clauses or multiple budgets per user?","diagram":"flowchart TD\n  Start[Start] --> Fire[Rule firing]\n  Fire --> Add[Add var to S]\n  Add --> Budget{Budget OK?}\n  Budget -- Yes --> Finish[Finish]\n  Budget -- No --> Stop[Stop]\n  Fire --> Cycle[Handle cycles]\\nvia SCC condensation","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Netflix","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T05:36:35.982Z","createdAt":"2026-01-18T05:36:35.982Z"},{"id":"q-3801","question":"Scenario: Build a tiny constraint solver for four gates Ship1..Ship4 in 3-valued logic (T, F, U). Constraints: (Ship1 ∧ Ship2) → Ship3; Ship2 ∨ Ship4; Ship1 ∨ ¬Ship3; Ship4 → ¬Ship1. Is there an assignment using U that does not force any constraint to be false? Propose a 3-valued backtracking propagation approach to verify arbitrary such rule sets?","answer":"Yes. A safe assignment: Ship1=U, Ship2=T, Ship3=U, Ship4=U. Evaluate: (Ship1∧Ship2)→Ship3 = U→U; Ship2∨Ship4 = T; Ship1∨¬Ship3 = U; Ship4→¬Ship1 = U. No constraint is false. Propagate by fixed-point: ","explanation":"## Why This Is Asked\nA practical test of applying 3-valued logic to constraint propagation in a tiny engine, with cycles and mixed truths.\n\n## Key Concepts\n- 3-valued logic (T, F, U)\n- Kleene semantics for NOT/AND/OR\n- Constraint propagation and fixpoint\n- Backtracking verification for arbitrary sets\n\n## Code Example\n```javascript\nfunction not(v){ return v===\"T\"?\"F\": v===\"F\"?\"T\":\"U\"; }\nfunction and(a,b){ if(a===\"F\"||b===\"F\") return \"F\"; if(a===\"T\"&&b===\"T\") return \"T\"; return \"U\"; }\n```\n\n## Follow-up Questions\n- How to scale to dozens of vars?\n- What optimizations for convergence? \n- How to detect inevitable F under inconsistent constraints?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","DoorDash","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T10:30:22.338Z","createdAt":"2026-01-18T10:30:22.338Z"},{"id":"q-3850","question":"Scenario: A tiny policy engine uses four predicates P,Q,R,S ∈ {T, F, U} with Kleene three-valued logic. Constraints: P ∨ Q = T; R ∧ S = F; P → R = T; Q → S = F. Is there an assignment that includes at least one U and that makes all constraints evaluate as required? Explain a simple 3-valued propagation approach to verify arbitrary such rule sets?","answer":"Yes. Example: P=U, Q=T, R=T, S=F. Then P ∨ Q = T due to Q; R ∧ S = F since S=F; P → R = T because ¬P ∨ R yields U ∨ T = T; Q → S = F since T → F = F. A 3-valued propagator uses Kleene truth tables, pr","explanation":"## Why This Is Asked\n\nTests understanding of Kleene three-valued logic through small, concrete constraints and requires applying a propagation-based approach to tri-valued SAT problems.\n\n## Key Concepts\n\n- Kleene three-valued logic (T, F, U)\n- Implication with U\n- 3-valued constraint propagation\n\n## Code Example\n\n```javascript\nfunction not(x){ return x=== 'T' ? 'F' : x==='F' ? 'T' : 'U'; }\nfunction or(a,b){ if(a==='T' || b==='T') return 'T'; if(a==='F' && b==='F') return 'F'; return 'U'; }\n```\n\n## Follow-up Questions\n\n- How would you extend to 5 predicates with cycles?\n- How would you implement a fixed-point propagator for arbitrary constraints?","diagram":null,"difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Discord","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T12:56:36.892Z","createdAt":"2026-01-18T12:56:36.893Z"},{"id":"q-4095","question":"Scenario: A tiny feature-flag policy engine with four features F1..F4, states in {T, F, U}. Constraints: (F1 → F2), (F2 → F3), (F3 → ¬F4), (F4 → F1). Is there an assignment that uses U for at least one flag and preserves all constraints as not definitively false? Outline a simple 3-valued propagation/backtracking approach to verify arbitrary such rule sets?","answer":"Yes. For example, set F1=U, F2=U, F3=U, and F4=F. Under Kleene semantics, the constraints F1→F2, F2→F3, and F3→¬F4 remain not definitively false, while F4→F1 (F→U) is also not false. Build a fixed-point propagator using Kleene three-valued logic to iteratively apply constraints until reaching a stable state, then backtrack on Unknown assignments when needed.","explanation":"## Why This Is Asked\nTests ability to reason about 3-valued logic in cycles and implement a propagator with backtracking on a constraint graph.\n\n## Key Concepts\n- Kleene three-valued logic (T, F, U)\n- Implication semantics with U\n- Constraint propagation and fixpoint\n- Backtracking on Unknown assignments\n\n## Code Example\n```javascript\nfunction kleeneNot(v){ return v==='T'?'F':v==='F'?'T':'U'; }\nfunction kleeneOr(a,b){ if(a==='T' || b==='T') return 'T'; if(a==='F' && b==='F') return 'F'; return 'U'; }\nfunction propagate(state, constraints){ /* placeholder: propagate until no changes, then backt","diagram":"flowchart TD\n  F1 --> F2\n  F2 --> F3\n  F3 --> ¬F4\n  F4 --> F1","difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Snap","Two Sigma","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T05:39:41.010Z","createdAt":"2026-01-18T23:38:33.836Z"},{"id":"q-4139","question":"In a microservice health policy, four services A, B, C, D can be Up, Down, or Unknown. Over two time steps t=0 and t=1, constraints: 1) If A is Up at t=0, then B is Up at t=1; 2) If D is Unknown at t=0, then B is Up at t=1 or C is Down at t=1; 3) If B is Down at t=0, then A is Down at t=1; 4) At each time t, at least one service is Unknown. Is there an assignment for (A, B, C, D) at t=0 and t=1 that satisfies all constraints with at least one Unknown at each time? Propose a 3-valued backtracking propagation approach to verify arbitrary such policy sets?","answer":"Yes. Example: t0 A=Unknown, B=Down, C=Unknown, D=Unknown; t1 A=Down, B=Up, C=Down, D=Unknown. All constraints are satisfied and each time contains an Unknown. Propagation approach: model states {Up,Do","explanation":"## Why This Is Asked\n\nTests a practical grasp of temporal logic with partial information and how to design and verify policy constraints in a real system using 3-valued logic.\n\n## Key Concepts\n\n- Temporal 3-valued constraint propagation\n- Kleene-style semantics for implication with Unknown\n- Backtracking search on partial assignments\n- Scalable policy verification across time horizons\n\n## Code Example\n\n```javascript\n// Pseudocode: propagate constraints from t to t+1\nfunction propagate(state, constraints) {\n  // state: {A0,B0,C0,D0,A1,B1,C1,D1}\n  // constraints: list of temporal rules\n  // return: updated state with propagated truths/Unknowns or conflict\n}\n```\n\n## Follow-up Questions\n\n- How would you scale to horizon H with many services?\n- How would you handle inconsistent constraints or non-monotonic rules?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Netflix","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T04:41:22.439Z","createdAt":"2026-01-19T04:41:22.439Z"},{"id":"q-4171","question":"Scenario: A tiny propositional graph uses three signals A, B, C drawn from {T, F, U}. Constraints: (A → (B ∨ C)), ((B ∧ ¬C) → A), and ((A ∨ B) → ¬C). Is there an assignment that uses at least one U and keeps every constraint not definitively F? Outline a simple 3-valued propagation approach to verify arbitrary such rule sets?","answer":"Yes. For example, A = U, B = F, C = F satisfies all constraints under Kleene’s 3-valued logic: B∨C = F; ¬A = U; A→(B∨C) = U. ¬C = T; B∧¬C = F; F→A = T. A∨B = U; U→¬C = T. This uses U and avoids any co","explanation":"## Why This Is Asked\nTests practical understanding of Kleene-style 3-valued logic, including how ∨, ∧, ¬, and → behave with U, plus a concrete propagation/backtracking workflow on small constraint graphs.\n\n## Key Concepts\n- Kleene three-valued logic semantics\n- Implication as ¬A ∨ B\n- Propagation to fixed points in small graphs\n- Backtracking to explore assignments with U\n\n## Code Example\n```javascript\nfunction not(v){ return v==='T'?'F':v==='F'?'T':'U'; }\nfunction or(a,b){ if(a==='T'||b==='T') return 'T'; if(a==='U'||b==='U') return 'U'; return 'F'; }\nfunction imp(a,b){ return or(not(a), b); }\n```\n\n## Follow-up Questions\n- How would you scale to graphs with 10+ nodes while preserving not-definitively-F guarantees?\n- What strategies ensure termination and avoid infinite backtracking in larger rule sets?","diagram":"flowchart TD\n  A[A] --> B[B]\n  B --> C[C]\n  C --> D[D]\n  D --> A\n","difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T05:58:11.483Z","createdAt":"2026-01-19T05:58:11.483Z"},{"id":"q-4234","question":"You are given a graph with boolean variables p_v for each node, and edges (u,v,w) enforcing p_u XOR p_v = w ∈ {0,1}. A subset S of nodes is forced to true. Determine if a consistent assignment exists and produce one that minimizes the total number of true variables. Describe a linear-time solver that propagates parity per connected component, detects contradictions, and decides root flips; include a 5-node example with 6 edges to illustrate solvable and unsolvable cases?","answer":"Traverse parity constraints per connected component. Root each component at 0 and propagate p[v] = p[u] XOR w. If a conflict occurs, no solution. If any node in the forced set lies in the component, t","explanation":"## Why This Is Asked\n\nTests ability to translate parity constraints into graph-based propagation and to reason about feasibility and optimality under partial assignments, all in linear time.\n\n## Key Concepts\n\n- Parity constraints on graphs\n- BFS/DFS propagation\n- Component-wise optimization\n- Contradiction detection\n\n## Code Example\n\n```javascript\n// BFS-based parity solver sketch\n```\n\n## Follow-up Questions\n\n- How would you handle edges with uncertain parity or noisy constraints?\n- How would this extend to 3-way XOR (triadic) constraints and still preserve linear-time solvability?","diagram":null,"difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Meta","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T09:48:35.141Z","createdAt":"2026-01-19T09:48:35.142Z"},{"id":"q-4261","question":"Given a directed graph of boolean flags with two constraint types: (i) A -> B meaning A true forces B true, and (ii) XOR clauses among disjoint pairs (e.g., exactly one of X and Y is true), plus a required set T that must be true. Decide if there exists an assignment satisfying all constraints and produce the smallest model (fewest true flags) containing T. Provide a small 6-flag example using both constraint types and describe a practical solver that combines forward-propagation with a parity solver (2-SAT) for the XORs?","answer":"Compute the forward-closure of A -> B from T, yielding F; for each XOR pair (u, v) add clauses (u ∨ v) ∧ (¬u ∨ ¬v) and run a 2-SAT on the current forced truths. If satisfiable, pick a minimal model by","explanation":"## Why This Is Asked\nThe problem blends forward-closure propagation with parity constraints, testing both algorithm design and practical encoding choices. Candidates must articulate a concrete solver that scales with variable count and constraint density, and reason about minimal models.\n\n## Key Concepts\n- Forward-closure propagation for implications\n- Exact-one (XOR) constraints encoded as 2-SAT clauses\n- Achieving a minimal model containing a given truth set\n\n## Code Example\n```javascript\n// Outline solver (not complete)\nfunction solve(V, Imp, XORs, T) {\n  // 1) closure: propagate A->B from T\n  // 2) build 2-SAT from XORs\n  // 3) check satisfiability and derive minimal model\n}\n```\n\n## Follow-up Questions\n- How would you extend to overlapping XOR groups? \n- How would you prove the derived model is minimal under common heuristics?","diagram":"flowchart TD\n  T[Target set] --> F[Forward-closure]\n  F --> S{SAT?}\n  S -- Yes --> M[Minimal model]\n  S -- No --> UNSAT","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T10:50:51.368Z","createdAt":"2026-01-19T10:50:51.369Z"},{"id":"q-4430","question":"Scenario: You maintain a 3-valued logic validator for three signals S1, S2, S3 in {T, F, U}. Constraints: (S1 -> S2), (S2 ∨ S3), (S1 ∧ ¬S3) -> T. Is there an assignment using at least one U that preserves all constraints as not definitively false? Outline a concrete 3-valued propagation strategy and a concrete backtracking sketch?","answer":"Yes. Initialize S1,S2,S3 = U and apply forward-propagation rules: for (S1 -> S2), if S1 is T then S2 must be T; for (S2 ∨ S3), if both S2 and S3 are F then constraint is F; propagate until fixpoint. I","explanation":"## Why This Is Asked\nTests ability to design a tiny 3-valued solver: propagation, clash detection, and controlled backtracking while preserving non-boolean placeholders.\n\n## Key Concepts\n- 3-valued logic propagation\n- Forward-checking and fixpoint computation\n- Backtracking with Unknowns to preserve flexibility\n\n## Code Example\n```javascript\nfunction propagate(vars, constraints) {\n  // vars: {S1: T|F|U, S2: T|F|U, S3: T|F|U}\n  // constraints: list of functions returning {changed, ok}\n  // Minimal sketch for illustration\n  let changed = true;\n  while (changed) {\n    changed = false;\n    for (const c of constraints) {\n      const res = c(vars);\n      if (res.changed) changed = true;\n      if (!res.ok) return {ok: false};\n    }\n  }\n  return {ok: true, vars};\n}\n```","diagram":null,"difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Tesla","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T18:48:21.985Z","createdAt":"2026-01-19T18:48:21.985Z"},{"id":"q-4739","question":"Scenario: A tiny policy-flag set F1..F4 uses three-valued logic {T, F, U}. Constraints: (F1 → F2), (F1 ⊕ F3) [exactly-one true], (F2 ∨ F4), (F3 → ¬F4). Is there an assignment with at least one U that keeps every constraint not definitively false? Outline a 3-valued propagation/backtracking approach to verify such constraint sets?","answer":"Yes. Example: F1=F, F2=T, F3=U, F4=F. Then F1→F2 is T; F1⊕F3 yields U (not definitively false); F2∨F4 is T; F3→¬F4 is U→T, which is not false. Approach: treat U as unknown, apply unit rules (A→B becom","explanation":"## Why This Is Asked\nTests 3-valued reasoning on small CSPs, especially with XOR-like constraints and propagation/backtracking in practice.\n\n## Key Concepts\n- Three-valued logic Kleene semantics (T, F, U)\n- Exact-one constraint handling with U\n- Propagation + backtracking in CSPs\n\n## Code Example\n```javascript\n// Skeleton: propagate3Val(A,B,C,...) returns fixed point or cases to backtrack\nfunction propagate3(vals, constraints){/*...*/ }\n```\n\n## Follow-up Questions\n- How would you extend to n-ary XOR constraints?\n- How change if ⊕ is replaced by at-most-one constraints?\n","diagram":"flowchart TD\n  F1[F1] --> F2\n  F1 --> F3\n  F2 --> F4\n  F3 --> F4","difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Microsoft","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T10:38:54.988Z","createdAt":"2026-01-20T10:38:54.989Z"},{"id":"q-4903","question":"Suppose a deployment feature graph: nodes are features with weight w(v) (cost to enable). Edges u→v mean enabling u forces v. A required set T must be enabled. Find a closed set S containing T that minimizes sum_{v∈S} w(v). Propose a polynomial-time max-flow reduction, describe the construction, and illustrate how it handles negative weights and the required set with a 6-node example?","answer":"Use minimum-weight closure via max-flow. Build a network: source to v with w(v)>0 (cap w(v)); v to sink with w(v)<0 (cap -w(v)); for each edge u→v add an infinite-capacity edge u→v. For the required s","explanation":"## Why This Is Asked\n\nTests the ability to translate a logical-constraint problem (closure under implications with a required subset) into a tractable optimization via a standard reduction. It also probes handling of mixed-weight nodes and feasibility guarantees.\n\n## Key Concepts\n\n- Minimum-weight closure problem on a directed graph\n- Max-flow / min-cut duality for selecting a closed set\n- Handling positive and negative weights via source/sink arcs\n- Enforcing a required set with infinite-capacity edges\n\n## Code Example\n\n```javascript\nfunction minWeightClosure(V, w, T, E) {\n  // Build flow network:\n  // S -> v cap = w(v) if w(v) > 0\n  // v -> T cap = -w(v) if w(v) < 0\n  // u -> v cap = INF for each (u,v) in E\n  // S -> t INF for each t in T to enforce required set\n  // Run max-flow; S-side of min-cut is the chosen closure\n}\n```\n\n## Follow-up Questions\n\n- How would you optimize for sparse graphs or dynamic T updates?\n- How does the reduction adapt if some weights must be integers only or if you require multiple disjoint closed sets?","diagram":"flowchart TD\n  S(Source) --> P[Positive weight nodes]\n  S --> N[Negative weight nodes]\n  P --> t((Sink))\n  N --> t\n  P --INF--> I[Implication U→V]\n  S --INF--> R[Enforce T]","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T18:01:52.175Z","createdAt":"2026-01-20T18:01:52.175Z"},{"id":"q-4953","question":"You have four variables X1..X4 in {T, F, U}. Constraints: (X1 ∧ X2) → X3, (X2 ∨ X4) ∨ X1, and (¬X4) → (X1 ∨ X3). Using Kleene 3-valued logic (¬: T↔F, U→U; ∧/∨ as min/max with T>U>F), is there an assignment with at least one U such that no constraint evaluates to F? Outline a backtracking propagation approach and provide a small example walk-through?","answer":"Yes. An example assignment satisfying the requirements is X2=U, X1=T, X4=F, X3=F. Using Kleene's 3-valued logic with numerical encoding (T=2, U=1, F=0), where ¬T=F, ¬F=T, ¬U=U; ∧=min, ∨=max, and →(a,b)=¬a ∨ b, we evaluate: (X1 ∧ X2) → X3 = ¬(min(2,1)) ∨ 0 = ¬1 ∨ 0 = 1 ∨ 0 = 1 (U). This assignment contains exactly one unknown value (U) and ensures no constraint evaluates to false (F).","explanation":"## Why This Is Asked\nThis question evaluates understanding of 3-valued logic systems and constraint propagation techniques in scenarios with incomplete information.\n\n## Key Concepts\n- Kleene's 3-valued logic semantics (T>U>F ordering)\n- Truth tables: ¬U=U, ∧/∨ as min/max operations\n- Implication definition: A → B ≡ ¬A ∨ B\n- Backtracking with unknown values and constraint propagation\n- Concrete validation through systematic evaluation\n\n## Code Example\n```javascript\n// Kleene 3-valued logic evaluation helpers\nconst vals = {T: 2, U: 1, F: 0};\nfunction not(x) { return x === 2 ? 0 : x === 0 ? 2 : 1; }\nfunction and(a, b) { return Math.min(a, b); }\nfunction or(a, b) { return Math.max(a, b); }\nfunction implies(a, b) { return or(not(a), b); }\n```","diagram":null,"difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-21T06:15:25.925Z","createdAt":"2026-01-20T20:49:07.661Z"},{"id":"q-5000","question":"Scenario: A promo-eligibility rule-set for an e-commerce checkout uses four signals P1..P4 in {T, F, U}. Constraints: (P1 → P2), (P2 ∨ P3) → P4, (P1 ∨ ¬P3) → P2, (¬P4) → (P1 ∧ P3). Is there an assignment with at least one U such that no constraint evaluates to F? Outline a simple 3-valued backtracking propagation strategy and walk through a small example?","answer":"Approach: Model implication A→B as ¬A ∨ B and use Kleene's three-valued logic with ordering T>U>F. Initialize all signals as U, propagate constraints using max for ∨ and min for ∧. If any constraint evaluates to F, backtrack by systematically upgrading antecedent signals to T or adjusting consequent signals to satisfy the violated constraint.","explanation":"## Why This Is Asked\nTests ability to reason with Kleene three-valued logic and implement a propagation/backtracking workflow for policy-like constraints in e-commerce systems.\n\n## Key Concepts\n- Kleene three-valued logic: T>U>F ordering\n- Truth tables: negation maps T↔F, U→U\n- Implication transformation: A→B ≡ ¬A ∨ B\n- Constraint propagation with systematic backtracking\n\n## Code Example\n```javascript\nconst order = { F: 0, U: 1, T: 2 };\nfunction not(a) { return a === 'T' ? 'F' : a === 'F' ? 'T' : 'U'; }\nfunction max(x, y) { return order[x] >= order[y] ? x : y; }\nfunction min(x, y) { return order[x] <= order[y] ? x : y; }\n```","diagram":null,"difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Instacart"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-21T05:44:30.135Z","createdAt":"2026-01-20T22:58:23.104Z"},{"id":"q-5059","question":"You have four boolean-like variables X1..X4 taking values in {T, F, U}. Rules are Horn-like implications:\n- (X1 = T) → (X3 = T)\n- (X2 = T) → (X4 = T)\n- (X3 = F) → (X1 = F)\n- (X4 = F) → (X2 = F)\n\nYour task: determine whether there exists an assignment with at least one U such that no rule evaluates to F, and provide a backtracking with forward propagation approach, including a tiny 4-variable walk-through showing a valid example?","answer":"Approach: use a small backtracking with forward-propagation on a 4-variable constraint graph. Start with at least one U; repeatedly apply rules: if antecedent true forces consequent true; if consequen","explanation":"## Why This Is Asked\nTests ability to design and reason about constrained, multi-valued logic with propagation and backtracking, mirroring solver internals.\n\n## Key Concepts\n- Three-valued logic propagation (T, F, U)\n- Horn-like implications\n- Backtracking with forward-propagation and early pruning\n\n## Code Example\n```javascript\n// sketch: propagate(rule): if antecedent is T, set consequent to T; if consequent is F, fail\nfunction propagate(state) {\n  let changed = false;\n  for (const r of rules) {\n    if (r.antecedent(state) === true) {\n      if (state[r.consequent] !== 'T') { state[r.consequent] = 'T'; changed = true; }\n    }\n  }\n  return changed;\n}\n```\n\n## Follow-up Questions\n- How would you extend to n variables and cycles while guaranteeing termination?\n- How would you implement heuristics to choose which U to branch on first to minimize backtracks?","diagram":null,"difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T04:15:36.479Z","createdAt":"2026-01-21T04:15:36.479Z"},{"id":"q-5122","question":"Design a tiny access-control graph with four nodes R1..R4; each node's state is True, False, or Unknown (T, F, U). Policy edges: R1→R2, (R3 ∨ R4) is required, and ¬R4 → R1. Is there an assignment with at least one U such that all constraints avoid being definitively False under Kleene 3-valued semantics? Propose a 3-valued propagation algorithm (fixpoint) to verify arbitrary sets of such rules, with a short walk-through on a small example?","answer":"Yes. Setting all nodes to U yields no constraint that's definitively False, since ¬U = U and A→B is ¬A ∨ B, which evaluates to U ∨ U = U. Use a fixpoint propagation: init all to U, repeatedly apply al","explanation":"## Why This Is Asked\nTests ability to model policy constraints with 3-valued logic and reason about propagation and backtracking.\n\n## Key Concepts\n- Kleene 3-valued logic (T, F, U)\n- Implication as ¬A ∨ B\n- Fixpoint (propagation) algorithms for constraint sets\n\n## Code Example\n```javascript\n// Kleene 3-valued implication helper (A, B in {T,F,U})\nfunction not(x){ return x==='T'?'F': x==='F'?'T':'U'; }\nfunction or(x,y){ return (x==='T'||y==='T')?'T': (x==='U'||y==='U')?'U':'F'; }\nfunction implies(a,b){ return or(not(a), b); }\n```\n\n## Follow-up Questions\n- How would you extend to detect and handle inconsistent states (both T and F) within a single node?\n- How does cycle detection affect the fixed-point propagation in large policy graphs?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T07:10:27.159Z","createdAt":"2026-01-21T07:10:27.159Z"},{"id":"q-5132","question":"Scenario: A compile-time flag set controls an experimental build. Flags F1..F4 in {T, F, U}. Constraints: (F1 XOR F2) must be True (exactly one of F1,F2 is T), (F2 OR F3) must be True, and (F4 -> NOT F1). Is there an assignment with at least one U such that no constraint evaluates to F under Kleene 3-valued semantics? Provide a concrete backtracking propagation plan?","answer":"Yes. Treat F1 XOR F2 as (F1 AND NOT F2) OR (NOT F1 AND F2). Under Kleene, NOT U = U, U AND T = U, U OR F = U; a single U can propagate to U on F2 OR F3. Start with at least one U (e.g., F1 = U, F2 = F","explanation":"## Why This Is Asked\nTests ability to reason about tri-state constraints with XOR and how propagation interacts with backtracking.\n\n## Key Concepts\n- Kleene 3-valued semantics for AND, OR, NOT with U as indeterminate\n- Encoding XOR as (A AND NOT B) OR (NOT A AND B)\n- DFS/backtracking with fixpoint propagation to keep at least one U\n\n## Code Example\n```javascript\nfunction not(v){ return v==='T' ? 'F' : v==='F' ? 'T' : 'U'; }\nfunction xor(a,b){ const t = (a==='T') + (b==='T'); if (t===1) return 'T'; if (a==='U' || b==='U') return 'U'; return 'F'; }\n```\n\n## Follow-up Questions\n- How would you extend to N flags with mutual exclusions?\n- How does short-circuiting affect propagation when U is present?","diagram":"flowchart TD\n  Q[Question] --> A[Encode XOR with 3-valued logic]\n  A --> B[Propagate and check for F]\n  B --> C[Backtrack if needed]\n  C --> D[Return result]","difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T07:41:36.539Z","createdAt":"2026-01-21T07:41:36.539Z"},{"id":"q-5190","question":"In a feature-flag system with 6 flags F1..F6 taking values {T, U, F}, use Kleene 3-valued logic (¬: T↔F, U→U; ∧/∨ as min/max with T>U>F). Constraints: (F1 ∧ F2) → F3; (F2 ∨ F4) → F5; (¬F6) → (F1 ∨ F3). Also require: there exists an assignment with at least one U such that no constraint evaluates to F. Determine if such an assignment exists, and outline a backtracking forward-checking algorithm that handles cycles and preserves the least-true model under these semantics. Then walk through a concrete 6-flag instance?","answer":"Yes. Example: F1=U, F2=T, F3=U, F4=F, F5=T, F6=F yields all constraints as U or T (none F). Propagation uses (A∧B)→C as (¬A∨¬B∨C), and ∧/∨ as min/max; backtracking assigns unassigned vars, propagates ","explanation":"## Why This Is Asked\n\nTests fluency with 3-valued logic, constraint propagation, and backtracking in a non-classical setting.\n\n## Key Concepts\n\n- Kleene three-valued logic semantics\n- Constraint encoding as implications\n- Fixpoint propagation and backtracking\n\n## Code Example\n\n```javascript\n// Simple Kleene implication (A -> B) as (¬A) ∨ B\nfunction not(v){ return v==='T'?'F':v==='F'?'T':'U'; }\nfunction or(a,b){ return a==='T' || b==='T' ? 'T' : a==='U' || b==='U' ? 'U' : 'F'; }\nfunction imply(a,b){ return or(not(a), b); }\n```\n\n## Follow-up Questions\n\n- How would you extend to multiple interdependent constraints with cycles?\n- How to prove existence of a U-laden satisfying assignment using monotone operators and a least-fixpoint?","diagram":null,"difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Citadel","Databricks"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T10:15:08.679Z","createdAt":"2026-01-21T10:15:08.679Z"},{"id":"q-5205","question":"In a tiny temporal logic puzzle, you have four signals S1..S4. Each signal at each time step t ∈ {0,1,2} can take values {T, F, U}. Constraints (for t ∈ {0,1}):\n- If S1(t) = T then S2(t+1) ≠ F\n- If S3(t) = F then S4(t+1) = T\n- If S2(t) = U then S1(t+1) = U\nIs there a trace of length 3 (t = 0..2) with at least one U that makes none of the constraints evaluate to F at any time? Outline a 3-valued temporal propagation/backtracking approach and provide a small example walk-through?","answer":"Yes. Example trace (t=0..2): S1=[T, F, U], S2=[F, U, T], S3=[U, U, U], S4=[U, F, U]. Check: t0 S1(0)=T forces S2(1)≠F (S2(1)=U). t1 S2(1)=U forces S1(2)=U (S1(2)=U). No constraint fires to F anywhere;","explanation":"## Why This Is Asked\nTests reasoning about temporal tri-valued constraints and backtracking under time progression, mirroring real policy engines.\n\n## Key Concepts\n- Temporal constraint propagation with 3-valued logic\n- Guarded implications across time steps\n- Fixpoint iteration and backtracking for feasibility with Unknowns\n\n## Code Example\n```javascript\nfunction propagate(state) {\n  let changed;\n  do {\n    changed = false;\n    for (let t = 0; t < 2; t++) {\n      if (state.S1[t] === 'T' && state.S2[t+1] === 'F') return false;\n      if (state.S2[t] === 'U' && state.S1[t+1] !== 'U') state.S1[t+1] = 'U', changed = true;\n      if (state.S3[t] === 'F' && state.S4[t+1] !== 'T') return false;\n    }\n  } while (changed);\n  return true;\n}\n``` \n\n## Follow-up Questions\n- How would you extend to arbitrary n signals and k time steps efficiently?\n- How does the approach handle inconsistent inputs or detect unsatisfiable traces early?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T10:50:59.486Z","createdAt":"2026-01-21T10:50:59.486Z"},{"id":"q-5308","question":"Given four sensors X1..X4 in {T, F, U}, satisfying constraints under Kleene 3-valued logic: 1) If X1 = T then X2 ≠ F; 2) If X2 = F then X3 ∈ {T, U}; 3) If X3 = U then X4 = F; 4) If X4 = T then X1 ∈ {T, U}. Is there an assignment with at least one U that satisfies all constraints? Outline a backtracking propagation strategy and provide a concrete walk-through?","answer":"Yes. A concrete satisfying assignment is X1=F, X2=F, X3=T, X4=U. Checks: (1) X1≠T, vacuous; (2) X2=F ⇒ X3∈{T,U} (X3=T OK); (3) X3≠U; (4) X4≠T. Backtracking: fix X1=F (prevents X4=T by (4)), then X2=F ","explanation":"## Why This Is Asked\nTests ability to craft a constrained, 3-valued solver with non-monotone constraints and explicit backtracking.\n\n## Key Concepts\n- Kleene3-valued logic and truth ordering T>U>F\n- Constraint propagation with forward-checking\n- Backtracking search and domain narrowing\n\n## Code Example\n```javascript\nconst order = {F:0, U:1, T:2};\nfunction not(v){ return v==='T'?'F': v==='F'?'T':'U'; }\nfunction lub(a,b){ return (order[a] >= order[b]) ? a : b; }\nfunction implies(a,b){ return lub(not(a), b); }\n```\n\n## Follow-up Questions\n- How would you scale the approach to 10+ variables?\n- How would you detect dead-ends earlier with cycles?","diagram":null,"difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T16:01:20.758Z","createdAt":"2026-01-21T16:01:20.758Z"},{"id":"q-5387","question":"In a three-valued Kleene logic with {T, F, U}, P, Q, R, constraints: (P ∨ Q) → R; (¬Q) ∨ P; (Q ∧ R) → ¬P. Is there an assignment with at least one U such that none of the constraints evaluates to F? Outline a backtracking propagation approach and walk through a concrete small example?","answer":"Yes. For P=Q=R=U, each constraint evaluates to U under Kleene semantics: (P∨Q)=U, ¬(P∨Q)=U, so first is U; (¬Q)=U, so second is U; (Q∧R)=U, ¬P=U, so third is U. Use propagation: initialize U, apply (¬","explanation":"## Why This Is Asked\nTests ability to reason with Kleene 3-valued logic and design a propagation/backtracking solver.\n\n## Key Concepts\n- Kleene three-valued logic semantics\n- Implication as (¬X) ∨ Y\n- Propagation and backtracking in constraint systems\n\n## Code Example\n```javascript\nfunction implies(a,b){ // a,b in ['T','F','U']\n  const not = v => v==='T'?'F':v==='F'?'T':'U';\n  const max = (x,y)=> (x==='T'||y==='T')? 'T': (x==='U'||y==='U')?'U':'F';\n  // simplified for demonstration\n  return max(not(a), b);\n}\n```\n\n## Follow-up Questions\n- How would you extend to detect unsatisfiable cores? \n- How to integrate with a small SAT-like solver? ","diagram":null,"difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Bloomberg"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T19:59:22.713Z","createdAt":"2026-01-21T19:59:22.713Z"},{"id":"q-5430","question":"Advanced three-valued logic puzzle in a feature-flag scenario. You have five features F1..F5, each value in {T, F, U}. Constraints: (F1 ∨ F2) → F3, (F2 ∧ F4) → F5, and (¬F5) → (F1 ∨ F3). Under Kleene semantics (¬: T↔F, U→U; ∧/∨ as min/max with T>U>F), decide if there exists an assignment with at least one U such that none of the constraints evaluates to F. Outline a forward-propagation/backtracking algorithm and walk through a small example on this graph?","answer":"Start with all Fi = U. Use DFS with forward-checking: repeatedly evaluate each constraint under Kleene rules; if a constraint's antecedent becomes T, enforce the consequent; if a constraint would force F, backtrack and try different assignments. Continue until a complete assignment satisfies all constraints or all possibilities are exhausted.","explanation":"## Why This Is Asked\nTests mastery of three-valued logic, constraint propagation, and backtracking in a realistic feature-flag style puzzle. Requires translating rules into propagation steps, handling indeterminate values, and proving existence or absence of a solution.\n\n## Key Concepts\n- Kleene three-valued logic\n- Constraint propagation with forward checking\n- Backtracking search and domain pruning\n\n## Code Example\n```javascript\nfunction not(v){ return v==='T'?'F':v==='F'?'T':'U'; }\nfunction nub(a,b){ // a,b in 'T','F','U'; top value is 'T'\n  // define max (∨) and min (∧)\n  const order = {'F':0,'U':1,'T':2};\n  const max = (x,y) => order[x] >= order[y] ? x : y;\n  const min = (x,y) => order[x] <= order[y] ? x : y;\n  return {or: max(a,b), and: min(a,b)};\n}\n```","diagram":null,"difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Snowflake","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T06:04:01.725Z","createdAt":"2026-01-21T22:00:03.427Z"},{"id":"q-5438","question":"Context: A compact policy engine for a CDN uses N propositions P1..PN with values in {T, F, U}. Each constraint is a Horn-like implication: (lit1 ∨ lit2 ∨ ... ∨ litk) → litOut, where lit is Pi or ¬Pi. Semantics: Kleene three-valued (¬ swaps T/F, U→U; ∧/∨ as min/max with T>U>F). Task: decide if there exists an assignment with at least one U such that no constraint evaluates to F, and produce such a model using deterministic backtracking with forward propagation. Provide a small 3-variable example and walk through?","answer":"Forward-propagation DFS over a 3-valued lattice. Represent each variable in {T,F,U}. For each rule (L1∨...∨Lk)→Lout, if any Li is T, attempt to set Lout to T; if this would force F on Lout due to conflicts, backtrack; if all Li are F, no action needed; otherwise (mixed/U), defer.","explanation":"## Why This Is Asked\nTests precise reasoning about 3-valued logic, forward constraint propagation, and backtracking under practical rule formats.\n\n## Key Concepts\n- Kleene three-valued semantics in Horn-like constraints\n- Forward propagation and DFS/backtracking\n- Model construction with at least one U and no F constraints\n\n## Code Example\n```javascript\n// Pseudocode sketch\nfunction solve(rules, init) {\n  let val = extend(init, 'unknown');\n  function propagate(): boolean {\n    let changed = false;\n    for (let r of rules) {\n      if (evalAntecedent(r, val) === 'T') {\n        if (val[r.out] === 'F') return false;\n        if (val[r.out] === 'U') { val[r.out] = 'T'; changed = true; }\n      }\n    }\n    return changed || !detectConflict(val);\n  }\n  \n  function dfs() {\n    if (!propagate()) return null;\n    let u = findUnknown(val);\n    if (!u) return hasUnknown(val) ? val : null;\n    for (let choice of ['T', 'F']) {\n      let saved = {...val}; val[u] = choice;\n      let res = dfs(); if (res) return res;\n      val = saved;\n    }\n    return null;\n  }\n  \n  return dfs();\n}\n```\n\n## Example Walkthrough\nRules: (P1)→P2, (¬P1∨P2)→P3\n1. Start: P1=U, P2=U, P3=U\n2. Propagate: no antecedent evaluates to T\n3. Choose P1=T, propagate: P2=T (rule 1), then P3=T (rule 2)\n4. Result: all T, no U → backtrack\n5. Choose P1=F, propagate: no deductions\n6. Choose P2=T → P3=T (rule 2)\n7. Final: P1=F, P2=T, P3=T has no U → continue exploring\n8. Eventually find P1=F, P2=U, P3=T satisfies requirements","diagram":"flowchart TD\n  A[P1] --> C[P3]\n  B[P2] --> C[P3]\n  C[P3] --> D[¬P1]\n  D --> E[(P1 ∨ P2)]","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Cloudflare"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T04:51:28.902Z","createdAt":"2026-01-21T22:34:32.155Z"},{"id":"q-5523","question":"Context: You’re modeling a tiny policy engine with 6 toggles X1..X6, values in {T, F, U}. Constraints: (X1 → X2), (X2 ∨ X3), (¬X4) → (X5 ∧ X6), and (X1 ∧ ¬X5) → X4. Determine whether there exists an assignment with at least one U such that no constraint evaluates to F. Propose a forward-checking/backtracking approach that can be implemented in a small CLI tool and show a minimal walkthrough?","answer":"Yes. A valid assignment is X1=T, X2=T, X3=U, X4=U, X5=U, X6=U. Start with all U, set X1 and X2 to T, which makes (X1→X2) and (X2∨X3) non-F. Leave X4, X5, X6 at U so (¬X4)→(X5∧X6) and (X1∧¬X5)→X4 stay ","explanation":"## Why This Is Asked\nTests ability to reason with Kleene's 3-valued logic and implement constraint propagation in a tiny solver; demonstrates comfort with non-binary truth values and backtracking.\n\n## Key Concepts\n- Kleene 3-valued semantics for →, ∧, ∨, ¬\n- Constraint propagation (forward-checking) with U values\n- Minimal backtracking to maintain at least one U\n- Practical CLI-style solver workflow\n\n## Code Example\n```javascript\n// Pseudocode for a backtracking solver with T/F/U states\nfunction solve(vars, constraints) {\n  // initialize all to U\n  // apply deterministic propagations\n  // pick a variable to assign (preferably one with most constraints)\n  // recurse until all constraints are satisfied or conflict\n}\n```\n\n## Follow-up Questions\n- How would you detect unsatisfiability when all U are exhausted?\n- How would you scale the approach to 20+ variables with dynamic constraints?","diagram":"flowchart TD\n  A[All variables start as U] --> B[Apply deterministic propagations]\n  B --> C[Pick a variable to assign (heuristic)]\n  C --> D[Recurse with backtracking if conflict]\n  D --> E[Found a solution with at least one U or report unsat]","difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Stripe","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T04:24:00.264Z","createdAt":"2026-01-22T04:24:00.265Z"},{"id":"q-5580","question":"Scenario: A fraud-detection policy engine uses four indicators I1..I4 with values in {T, F, U}. Constraints: (I1 || !I2) -> I3, (I2 && I4) -> !I1, and (I1 && I3) || I4. Is there an assignment with at least one 'U' such that none of the constraints evaluates to 'F' under Kleene 3-valued semantics? Propose a concrete backtracking trace (depth ≤ 2) demonstrating verification of such rule sets in practice?","answer":"Yes. Start with I1=U, I2=U, I3=U, I4=U. Evaluate constraints: (I1||!I2)->I3 = (U||U)=U -> U; (I2&&I4)->!I1 = (U&&U)=U -> !U=U; (I1&&I3)||I4 = (U&&U)=U || U = U. All non-F. If a branch yields F, backtr","explanation":"## Why This Is Asked\nTests understanding of Kleene 3-valued semantics, constraint propagation, and backtracking strategy in a practical policy engine scenario.\n\n## Key Concepts\n- Kleene 3-valued logic (T > U > F)\n- Propagation and backtracking on partial assignments\n- Constraint forms: implication, conjunction, disjunction\n\n## Code Example\n```javascript\n// Kleene 3-valued logic: F=0, U=1, T=2\nconst V = {F:0, U:1, T:2};\nconst not = v => (v===V.T?V.F:(v===V.F?V.T:V.U));\nconst and = (a,b)=> Math.min(a,b);\nconst or  = (a,b)=> Math.max(a,b);\nconst implies = (a,b)=> or(not(a), b);\nfunction evalConstraints(I1,I2,I3,I4){\n  const c1 = implies(or(I1, not(I2)), I3);\n  const c2 = implies(and(I2,I4), not(I1));\n  const c3 = or(and(I1,I3), I4);\n  return [c1,c2,c3];\n}\n```\n\n## Follow-up Questions\n- How would you extend to 8 indicators with memoization? \n- How does pruning change if you require at least two U values?","diagram":null,"difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Coinbase","Databricks"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T07:10:56.133Z","createdAt":"2026-01-22T07:10:56.133Z"},{"id":"q-5681","question":"In a microservice feature-toggle network with four toggles N1..N4, states {T, F, U}, constraints: N1 → N2, N2 ∨ N3, ¬N3 → (N4 ∨ N1), and (N4 ∧ N2) → ¬N1. Is there an assignment using at least one U such that none of the constraints evaluates to F? Outline a 3-valued propagation/backtracking strategy and show a concrete witness?","answer":"Yes. Example witness: N1=T, N2=U, N3=F, N4=U. Evaluate: N1→N2 = F ∨ U = U; N2∨N3 = U; ¬N3 → (N4∨N1) = T → T = T; (N4∧N2) → ¬N1 = U → F = U. All constraints not-F, with at least one U. Approach: propag","explanation":"## Why This Is Asked\n\nTests ability to reason with Kleene 3-valued logic and design a constructive propagation/backtracking strategy that can scale to policy-like constraint sets.\n\n## Key Concepts\n\n- Kleene three-valued logic (T > U > F) and implication as ¬A ∨ B\n- Arc-like propagation for constraints; backtracking when a path yields F\n- Constructive witness to prove existence of a satisfying extension with U\n\n## Code Example\n\n```python\n# minimal Kleene implication sanity\norder = {'F':0, 'U':1, 'T':2}\ndef implies(a,b):\n    na = {'F':'T','T':'F','U':'U'}[a]\n    return max(na,b, key=lambda x: order[x])\n```\n\n## Follow-up Questions\n\n- How would you generalize to n toggles with arbitrary constraint graphs?\n- What pruning heuristics help find U-rich solutions fastest?","diagram":"flowchart TD\n  N1[N1] --> N2[N2]\n  N2 --> N3[N3]\n  N3 --> N4[N4]\n  N4 --> N1[N1]","difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T11:08:30.661Z","createdAt":"2026-01-22T11:08:30.661Z"},{"id":"q-5736","question":"Scenario: In a robot's sensor fusion pipeline, four booleans S1..S4 in {T, F, U} represent truth states. Constraints: (S1 ∧ S2) → S3, (S2 ∨ S4) → S1, (¬S4) → (S1 ∨ S3). Is there an assignment with at least one U such that none of the constraints evaluates to F? Outline a simple 3-valued backtracking propagator to verify arbitrary such rule sets and show a concrete satisfying assignment?","answer":"Yes. With Kleene 3-valued logic (T>U>F), define X→Y as (¬X) ∨ Y. Try S1=T, S2=U, S3=F, S4=F. Then (S1∧S2)→S3 = U→F = ¬U ∨ F = U; (S2∨S4)→S1 = U∨F = U; U→T = ¬U ∨ T = U ∨ T = T; (¬S4)→(S1∨S3) = T→(T∨F)","explanation":"## Why This Is Asked\nTests ability to reason about 3-valued semantics in robotics sensor fusion and implement a concrete propagator for arbitrary rule sets.\n\n## Key Concepts\n- Kleene 3-valued logic (T>U>F)\n- Propagation rules for ¬, ∧, ∨, and → (X→Y ≡ ¬X ∨ Y)\n- Backtracking to avoid F while preserving at least one U\n\n## Code Example\n```javascript\n// Simple 3-valued implication using Kleene logic\nfunction implies(x, y){\n  const not = v => v === 'T' ? 'F' : v === 'F' ? 'T' : 'U';\n  const or = (a,b) => (a==='T' || b==='T') ? 'T' : (a==='U' || b==='U') ? 'U' : 'F';\n  return or(not(x), y);\n}\n```\n\n## Follow-up Questions\n- How would you extend to larger graphs with hundreds of variables?\n- What heuristics help prune search effectively in 3-valued backtracking?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Lyft","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T14:45:36.417Z","createdAt":"2026-01-22T14:45:36.417Z"},{"id":"q-5818","question":"You manage a policy engine with 5 indicators P1..P5 taking {T, F, U}. Constraints: (P1 ∧ P2) → P3, (P2 ∨ P4) → P5, ¬P5 → (P1 ∨ P3), (P3 ∧ P4) → P2, (P1 ∨ ¬P2) → (P4 ∨ P5). Under Kleene 3-valued semantics, is there an assignment with at least one U such that none evaluates to F? Outline a backtracking search with pruning and provide a small walk-through?","answer":"Yes. Use a DFS backtracker with domains {T,F,U} for P1..P5 and propagate via Kleene semantics: A ∧ B = min, A ∨ B = max, ¬U = U. Prune branches where any constraint evaluates to F. A concrete satisfia","explanation":"## Why This Is Asked\n\nThis tests the ability to design a concrete constraint solver for 3-valued logics, with practical policy-engine semantics and a nondeterministic search.\n\n## Key Concepts\n\n- Kleene 3-valued semantics for ∧, ∨, and → via ¬A ∨ B\n- Constraint propagation and pruning in backtracking\n- DFS with domain reduction to avoid exploring F\n- Handling unknowns (U) to satisfy non-F constraints\n\n## Code Example\n\n```javascript\nfunction kleeneImp(a,b){ // a,b in T,F,U\n  // A → B is ¬A ∨ B\n  const not = v => v==='T'?'F':v==='F'?'T':'U';\n  const or = (x,y)=> (x==='T'||y==='T')?'T': (x==='U'||y==='U')?'U':'F';\n  return or(not(a), b);\n}\n```\n\n## Follow-up Questions\n\n- How would you scale to 20 indicators with random constraint density?\n- How to unit-test the solver with known satisfiable/unsat sets?\n","diagram":"flowchart TD\n  A[Variables P1..P5 ∈ {T,F,U}] --> B[Constraint propagation]\n  B --> C[Backtracking DFS with pruning]\n  C --> D[Satisfiable?]\n  D --> E[Output assignment]","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","PayPal","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T17:56:51.611Z","createdAt":"2026-01-22T17:56:51.611Z"},{"id":"q-5858","question":"Scenario: A lightweight rule engine evaluates three indicators X,Y,Z in {T, F, U}. Constraints: (X ∨ Y) → Z, (¬X) → (Y ∨ ¬Z), (Z ∧ X) → Y. Is there an assignment with at least one U such that none of the constraints evaluates to F? Outline a 3-valued backtracking propagation approach and give a concrete satisfying assignment?","answer":"Yes. Use Kleene semantics: T>U>F, ¬T=F, ¬F=T, ¬U=U; A→B = ¬A ∨ B; ∨ max, ∧ min. Try X=U, Y=T, Z=U. Then (X∨Y)=T; (X∨Y)→Z = T→U = U; (¬X)=U; (Y∨¬Z)=T∨¬U=T; (¬X)→(...) = U→T = T; (Z∧X)=U; ... → Y = U→T ","explanation":"## Why This Is Asked\nTests fluency with 3-valued logic and concrete propagation.\n\n## Key Concepts\n- Kleene 3-valued logic: T>U>F; ¬, ∨, ∧ defined as usual with min/max; A→B = ¬A ∨ B.\n- Propagation to prune domains; backtracking when a constraint would force F.\n- Concrete example shows a valid assignment using U.\n\n## Walkthrough\nX=U, Y=T, Z=U; evaluate each constraint as shown in the answer to confirm all are not F.","diagram":null,"difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Twitter","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T19:38:07.375Z","createdAt":"2026-01-22T19:38:07.375Z"},{"id":"q-5881","question":"Given five literals A,B,C,D,E in {T,F,U}, under Kleene 3-valued logic with NOT, AND, OR as standard, is there an assignment with at least two U such that all four constraints evaluate to not-F? 1) (A AND B) -> C; 2) (D OR NOT E) -> A; 3) (B OR C) AND NOT D -> E; 4) (A AND NOT B) OR (C AND D). Outline a depth-3 backtracking trace?","answer":"Yes. One model: A=U, B=U, C=U, D=F, E=U. Check: 1) (A AND B) -> C is U; 2) (D OR NOT E) -> A is U; 3) (B OR C) AND NOT D -> E is U; 4) (A AND NOT B) OR (C AND D) is U. This uses Kleene semantics; the ","explanation":"## Why This Is Asked\n\nTests ability to craft and analyze a small 3-valued constraint system; requires propagation rules, backtracking, and ensuring non-F outcomes; assesses practical reasoning and solver design skills in a constraint‑satisfaction context.\n\n## Key Concepts\n\n- Kleene 3-valued logic semantics\n- Implication as NOT X OR Y\n- Constraint propagation and backtracking\n- Practical test generation for policy-like rule sets\n\n## Code Example\n\n```javascript\nfunction kleeneImp(X,Y){\n  // X,Y in ['T','F','U']\n  const not = {T:'F',F:'T',U:'U'};\n  const or = (a,b)=> (a==='T' || b==='T') ? 'T' : (a==='U' || b==='U') ? 'U' : 'F';\n  // return NOT X OR Y\n  return or(not[X], Y);\n}\n```\n\n## Follow-up Questions\n\n- How would you extend to detect unsatisfiable cores under U constraints?\n- How would you adapt to modular constraints with incremental additions?","diagram":"flowchart TD\n  A[Assign A=U] --> B[Assign B=U]\n  B --> C[Assign C=U]\n  C --> D[Assign D=F]\n  D --> E[Assign E=U]\n  E --> F[All constraints non-F]","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Netflix","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T20:45:33.697Z","createdAt":"2026-01-22T20:45:33.697Z"},{"id":"q-6069","question":"In a data-cleansing policy, five fields F1..F5 take values from {T, F, U}. Constraints under Kleene 3-valued logic: \n- If F1 = T then F2 ≠ F\n- If F2 = F then F3 = T\n- If F3 = U then F4 = U\n- If F4 = T then F5 ∈ {F, U}\nIs there an assignment with at least one U such that none of the constraints evaluates to F? Provide a minimal backtracking trace (depth ≤ 3) and a concrete satisfying assignment?","answer":"Yes. A concrete satisfying assignment: F1 = T, F2 = U, F3 = T, F4 = U, F5 = U. Evaluation: F1=T ⇒ F2≠F (F2=U OK). F2=F is false, so rule 2 not triggered. F3=U is false, so rule 3 not triggered. F4=T i","explanation":"## Why This Is Asked\nTests ability to design small, realistic constraint systems and reason about 3-valued semantics; challenges to produce a concrete assignment and a tight backtracking trace.\n\n## Key Concepts\n- Kleene 3-valued logic\n- Constraint propagation\n- Depth‑limited backtracking\n\n## Code Example\n```javascript\n// sketch backtracking for {T,F,U} with rules\nfunction good(assign){\n  // returns true if no constraint is F\n  return true;\n}\n```\n\n## Follow-up Questions\n- How would the approach scale to 8 fields?\n- How to prove completeness of the backtracking trace?","diagram":null,"difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","IBM","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T07:38:18.394Z","createdAt":"2026-01-23T07:38:18.394Z"},{"id":"q-6148","question":"In a small rule engine, five predicates A,B,C,D,E take values in {T,F,U}. The rules are: (A ∧ B) → C, (D ∨ E) → B, and (¬C) ∨ D. Is there an assignment with at least one U such that none of the rules evaluates to F under Kleene 3-valued semantics? Outline a backtracking propagation approach and walk through a concrete 3-step trace that yields a satisfying model with at least one U?","answer":"Use a unit-propagation style search on 5 vars with Kleene semantics. Treat each constraint as an implication via ¬X ∨ Y and propagate: if A=T and B=T, then C must be T or U; if D or E triggers B, etc.","explanation":"## Why This Is Asked\nTests ability to reason with Kleene 3-valued logic in rule-based constraints and design a backtracking propagation strategy.\n\n## Key Concepts\n- Kleene 3-valued semantics\n- Implication as ¬X ∨ Y\n- Unit propagation and backtracking\n- Ensuring at least one U while avoiding F\n\n## Code Example\n```javascript\nfunction not(x){ return x==='T'?'F': x==='F'?'T':'U'; }\nfunction or(x,y){ const order={F:0,U:1,T:2}; return (order[x] >= order[y])? x : y; }\nfunction imp(a,b){ return or(not(a), b); }\n```\n\n## Follow-up Questions\n- How would you scale to ~20 vars and more complex rules?\n- What heuristics minimize backtracks in practice?","diagram":"flowchart TD\n  Start([Start])\n  Assign[Assign A,B,C,D,E values]\n  Prop[Propagate constraints (3-valued)]\n  Check{No F}\n  End([Done])\n  Start --> Assign --> Prop --> Check --> End","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T10:57:04.649Z","createdAt":"2026-01-23T10:57:04.649Z"},{"id":"q-6205","question":"Prove that deciding whether there exists an assignment with at least one U that satisfies a set of Horn-like implications over X1..Xn in {T,F,U} under Kleene semantics is NP-hard. Provide a polynomial-time reduction from 3-SAT using gadgets that force a choice of T or F for each variable and clauses that require at least one literal to align with a U to satisfy all constraints?","answer":"Outline a polynomial-time reduction from 3-SAT. For each variable x_i create three literals X_i^T, X_i^F, X_i^U with gadgets enforcing exactly one of X_i^T or X_i^F and allowing X_i^U as a free value.","explanation":"## Why This Is Asked\n\nAssess ability to design formal hardness proofs and construct gadget-based reductions.\n\n## Key Concepts\n\n- NP-hardness reductions\n- 3-valued Kleene logic\n- Horn-like constraint encoding\n\n## Code Example\n\n```javascript\n// Pseudo-solver scaffold: backtracking with 3-valued propagation\nfunction step(assign, constraints) {\n  // assign: Map<Var, T|F|U>\n  // constraints: array of { antecedent, consequent }\n  // Implement unit-propagation-style pruning\n}\n```\n\n## Follow-up Questions\n\n- Extend to non-Horn clauses and quantify variables.\n- What changes if U is disallowed or restricted?","diagram":null,"difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","Microsoft","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T14:36:05.749Z","createdAt":"2026-01-23T14:36:05.750Z"},{"id":"q-6248","question":"In a database constraint engine that uses 3-valued Kleene semantics (TRUE, FALSE, UNKNOWN), four columns A,B,C,D have values in {T, F, U}. Constraints: (A AND B) → C, (B OR D) → A, NOT D → (A OR C). Is there a row assignment with at least one UNKNOWN such that none of the constraints evaluates to FALSE? Outline a backtracking propagation strategy and give a small explicit walk-through that yields a satisfying assignment?","answer":"Yes. One concrete assignment: A=U, B=T, C=U, D=F. Evaluate: (A∧B)→C = U→U = U; (B∨D)→A = T→U = U; NOT D→(A∨C) = T→U = U. No constraint is FALSE, and at least one U exists. This can be found by fixing ","explanation":"## Why This Is Asked\nShow ability to craft concrete test cases in 3-valued logic and reason about propagation.\n\n## Key Concepts\n- Kleene three-valued semantics; - Implication as NOT X OR Y; - Constraint propagation/backtracking; - Satisfiability with NULLs in databases.\n\n## Code Example\n```javascript\nfunction kleeneImplies(a,b){\n  const not = v => v==='T'?'F':v==='F'?'T':'U';\n  const or = (x,y)=> (x==='T' || y==='T')?'T':(x==='U' || y==='U')?'U':'F';\n  return or(not(a), b);\n}\n```\n\n## Follow-up Questions\n- How would you extend to detect minimal UNKNOWN count? \n- How does this change with alternative 3-valued logics?","diagram":"flowchart TD\n  Inputs[A,B,C,D]\n  Compute[Propagation]\n  Satisfiable{Satisfiable?}\n  Inputs --> Compute\n  Compute --> Satisfiable","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Meta","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T16:12:10.962Z","createdAt":"2026-01-23T16:12:10.962Z"},{"id":"q-6258","question":"Context: Four signals X1..X4 in {T, F, U}. Constraints: (X1 ∨ X2) → X3, (X2 ∧ X4) → X1, (¬X3) ∨ X4, (X1 → ¬X4). Is there an assignment with at least one U such that none of the constraints evaluates to F? Outline a 3-valued forward-propagation approach and provide a concrete satisfying assignment?","answer":"One valid assignment is (X1, X2, X3, X4) = (U, F, T, U). Check: (X1 ∨ X2) → X3 = U → T = T; (X2 ∧ X4) → X1 = F → U = T; (¬X3) ∨ X4 = F ∨ U = U; (X1 → ¬X4) = U → ¬U = U → U = U. All constraints not F; ","explanation":"## Why This Is Asked\n\nTests ability to apply 3-valued Kleene semantics to rule-based constraints and design simple propagation.\n\n## Key Concepts\n\n- 3-valued logic: T > U > F, ¬T=F, ¬F=T, ¬U=U\n- Implication as ¬p ∨ q, with Kleene order\n- Forward-propagation: iteratively apply constraints until a fixed point\n\n## Code Example\n\n```javascript\nfunction not(v){return v==='T'?'F':v==='F'?'T':'U';}\nfunction imp(p,q){const np=not(p); return (np==='T' || q==='T')?'T':(np==='U'||q==='U')?'U':'F';}\n```\n\n## Follow-up Questions\n\n- How would you extend to detect unsatisfiable sets?\n- How would you prove minimality of a satisfying assignment?","diagram":"flowchart TD\n  P1[P1] --> R1[(Rule1)]\n  P2[P2] --> R1\n  R1 --> P3[P3]\n  P3 --> R2[(Rule2)]\n  P4[P4] --> R2","difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","PayPal","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T16:46:21.219Z","createdAt":"2026-01-23T16:46:21.220Z"},{"id":"q-6281","question":"Design a 4-input combinational circuit with inputs A,B,C,D ∈ {T, F, U}. Define internal signals:\n- X = A ∧ B\n- Y = ¬C ∨ D\n- Z = X → Y\n- W = Z ∨ A\n\nQuestion: Is there an assignment with at least one U such that none of X,Y,Z,W evaluate to F under Kleene 3-valued semantics? Outline a backtracking propagation walk-through and provide a tiny example satisfying assignment?","answer":"Yes. Example: A=U, B=U → X=U. C=T, D=T → ¬C=F, Y=F∨T = T. Z = X→Y = (¬X)∨Y = U∨T = T. W = Z∨A = T∨U = T. All constraints non-F; at least one U (A or B).","explanation":"## Why This Is Asked\nThis tests translating uncertainty into constraints and performing propagation with Kleene logic.\n\n## Key Concepts\n- 3-valued semantics; backtracking; constraint propagation; implications.\n- Circuit-like formulation; conflict-free search.\n\n## Code Example\n```javascript\nfunction not(x){ return x==='T'?'F':x==='F'?'T':'U'; }\nfunction and(a,b){ const order={F:0,U:1,T:2}; return order[a] < order[b]? a:b; }\nfunction or(a,b){ const order={F:0,U:1,T:2}; return order[a] > order[b]? a:b; }\nfunction imp(a,b){ return or(not(a), b); }\n```\n","diagram":"flowchart TD\n  A[Inputs A,B,C,D] --> X[X = A ∧ B]\n  A --> Y[Y = ¬C ∨ D]\n  X --> Z[Z = X → Y]\n  Y --> Z\n  Z --> W[W = Z ∨ A]","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Meta","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T17:39:51.661Z","createdAt":"2026-01-23T17:39:51.661Z"},{"id":"q-6332","question":"Scenario: A four-factor risk model F1..F4, each in {T, F, U}. Constraints: (F1 ∧ F2) → F3, (F2 ∨ F4) → F1, (F3 ∧ ¬F4) → F2. Is there an assignment with at least one N I nknown such that none of the constraints evaluates to F? Outline a 3-valued forward-chaining propagation that verifies arbitrary such rule sets and provide a concrete satisfying assignment?","answer":"Yes. Try F1=T, F2=T, F3=U, F4=F. (F1∧F2)→F3 evaluates to U; (F2∨F4)→F1 is T; (F3∧¬F4)→F2 is T. A simple forward-chaining propagator initializes knowns, computes ∧/∨ per Kleene, updates consequents, re","explanation":"## Why This Is Asked\nTests ability to design a propagation algorithm for 3-valued logic with implications in a compact rule set.\n\n## Key Concepts\n- Kleene three-valued logic semantics\n- Implication as ¬P ∨ Q\n- Forward-chaining propagation and fixed-point\n- Handling cycles and ensuring at least one Unknown\n\n## Code Example\n```javascript\n// Implementation sketch\nfunction propagate(rules, values){ /* ... */ }\n```\n\n## Follow-up Questions\n- How would you extend to n variables with Horn constraints?\n- What are the performance implications on dense graphs?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","Scale Ai","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T19:43:29.972Z","createdAt":"2026-01-23T19:43:29.972Z"},{"id":"q-6364","question":"Scenario: A data-validation pipeline handles four fields A,B,C,D with states in {T, F, U}. Validation rules: (A ∧ B) → C, (B ∨ D) → ¬A, (D → (A ∨ B)), and (¬C) → D. Is there an assignment that uses at least one U such that no rule evaluates to F? Outline a 3-valued backtracking propagator and give a concrete satisfying assignment?","answer":"Yes. A concrete satisfying assignment is A=B=C=D=U. With Kleene semantics NOT U = U and AND/OR as T>U>F, every antecedent and consequent evaluates to U, so each implication yields U, not F. Implement ","explanation":"## Why This Is Asked\nInterviews probe capability to apply 3-valued logic to practical policy constraints and design a backtracking propagator to verify satisfiability with Unknowns.\n\n## Key Concepts\n- 3-valued logic semantics and implication\n- Backtracking propagation for unknowns\n- Constraint satisfaction with Unknowns in policy contexts\n\n## Code Example\n```javascript\n// 3-valued logic helpers (Kleene)\nconst NOT = v => v === 'T' ? 'F' : v === 'F' ? 'T' : 'U';\nconst OR = (x,y) => x === 'T' || y === 'T' ? 'T' : x === 'U' || y === 'U' ? 'U' : 'F';\nconst IMP = (p,q) => OR(NOT(p), q);\n```\n\n## Follow-up Questions\n- How does backtracking scale with more fields?\n- What if you require at least two U? How would constraints adapt?\n","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Citadel","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T20:54:25.748Z","createdAt":"2026-01-23T20:54:25.749Z"},{"id":"q-6431","question":"In a feature-flag policy engine, four flags F1..F4 take values {T, F, U}. Constraints: (F1 ∨ F2) → F3, (¬F3) → (F4 ∨ F1), and (F2 ∧ F4) → ¬F1. Does there exist an assignment with at least one U such that no constraint evaluates to F? Outline a 3-valued backtracking propagation to verify arbitrary such rule sets and show a concrete satisfying assignment?","answer":"In a feature-flag policy engine, four flags F1..F4 take values {T, F, U}. Constraints: (F1 ∨ F2) → F3, (¬F3) → (F4 ∨ F1), and (F2 ∧ F4) → ¬F1. Does there exist an assignment with at least one U such that no constraint evaluates to F? Outline a 3-valued backtracking propagation to verify arbitrary such rule sets and show a concrete satisfying assignment?\n\nEncoding A→B as ¬A ∨ B under Kleene three-valued logic (¬U=U, ∨/∧: T>U>F). Use backtracking: assign a U to one variable, propagate constraints, prune any branch that yields F. For the given instance, a satisfying assignment exists: F1=U, F2=T, F3=T, F4=T.","explanation":"## Why This Is Asked\n\nTests translating 3-valued logic into propagation rules and a backtracking search that preserves non-F outcomes.\n\n## Key Concepts\n\n- Kleene three-valued logic semantics\n- Implication as ¬A ∨ B\n- Constraint propagation and backtracking\n\n## Code Example\n\n```javascript\n// Pseudo: propagate([F1, F2, F3, F4])\n```\n\n## Follow-up Questions\n\n- How does performance scale with more variables?\n- How would you extend to different three-valued logics?","diagram":"flowchart TD\n  A[Choose U for at least one flag] --> B[Propagate constraints]\n  B --> C[All constraints non-F?]\n  C --> D[Yes: report satisfying assignment] \n  D --> E[Done]\n  C --> F[No: backtrack] \n  F --> A","difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Hashicorp","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T05:01:24.433Z","createdAt":"2026-01-23T23:47:54.572Z"},{"id":"q-6729","question":"Consider four variables A, B, C, D taking values in {T, F, U} under Kleene three-valued semantics (T > U > F; ¬, ∨, ∧ defined accordingly). The constraints are:\n- (A ∨ B) → D\n- (B ∨ C) → A\n- (C ∨ D) → B\n- (D ∨ A) → C\nIs there an assignment with at least one U such that none of the four implications evaluates to F? If so, provide one example and outline a 3-valued backtracking propagation strategy to verify arbitrary such rule sets?","answer":"Yes. With A=U, B=F, C=F, D=U under Kleene 3-valued semantics. The four constraints evaluate to: 1) U, 2) T, 3) U, 4) U. All non-F and at least one U. Propagation: start with {T,F,U} per var; for each ","explanation":"## Why This Is Asked\nTests ability to reason with 3-valued logic, design propagation/backtracking, and produce concrete assignments in a small, dependency-rich constraint graph.\n\n## Key Concepts\n- 3-valued Kleene semantics and implications\n- Propagation rules for ∨ and ¬ in a backtracker\n- Incremental search with domain pruning for arbitrary rule sets\n\n## Code Example\n```javascript\nfunction imp(a,b){ // a -> b in Kleene logic\n  // ¬a ∨ b\n  const not = x => x === 'T' ? 'F' : x === 'F' ? 'T' : 'U';\n  const or = (x,y)=> (x==='T' || y==='T') ? 'T' : (x==='U' || y==='U') ? 'U' : 'F';\n  return or(not(a), b);\n}\n```\n\n## Follow-up Questions\n- How does your backtracking decide to prune a value when a constraint becomes F? \n- How would you extend to five variables with arbitrary rule graphs?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Coinbase","Lyft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T14:48:38.924Z","createdAt":"2026-01-24T14:48:38.924Z"},{"id":"q-6765","question":"You manage a distributed service with four flags A, B, C, D in {Up, Down, Unknown}. Constraints: (A ∧ B) → C; (B ∨ D) → A; (¬D) → (A ∨ C). Is there an assignment with exactly one Unknown such that none of the constraints evaluates to Down under Kleene 3-valued semantics (Up > Unknown > Down)? Provide a depth-3 backtracking trace and a concrete satisfying assignment?","answer":"Trace (depth ≤3): A=Up, B=Up, C=Up, D=Unknown. Evaluate: (A and B)->C = Up; (B or D)->A = Up; (Not D)->(A or C) = Unknown. None is Down, so a satisfying assignment exists with depth 0 (within the limi","explanation":"## Why This Is Asked\n\nTests 3-valued constraint reasoning (Kleene) in a realistic setting, with a non-trivial exact-one-Unknown constraint and a small search trace.\n\n## Key Concepts\n\n- Kleene 3-valued logic: Up, Down, Unknown\n- Implication defined as Not A or B with lattice Up>Unknown>Down\n- Constraint propagation and backtracking depth-limits\n- Handling exactly-one-U as a search constraint\n\n## Code Example\n\n```javascript\n// skeleton backtracking for 4 vars with given constraints\nfunction sat4(vars, cons) {\n  // assign and propagate; prune on Down\n}\n```\n\n## Follow-up Questions\n\n- How to scale to N variables?\n- How to detect unsatisfiable subsets efficiently?","diagram":null,"difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Coinbase","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T16:49:46.365Z","createdAt":"2026-01-24T16:49:46.365Z"},{"id":"q-683","question":"You're managing a streaming DAG with tasks A,B,C,D; edges enforce: A before B; B before C; at most one of C or D can occur in a window of size H. Given a log of events with timestamps per task, implement an O(n log n) verifier to determine if the log is valid under these constraints and describe how you'd extend to multiple windows in a distributed system?","answer":"Sort events by timestamp; maintain last_seen per task; when seeing B, require A has appeared earlier; when C arrives, require B seen within H time; when D arrives, ensure C did not occur in the same w","explanation":"## Why This Is Asked\n\nTests ability to reason about temporal constraints in streaming DAGs and develop an efficient log validation algorithm.\n\n## Key Concepts\n\n- Temporal constraints and causal ordering\n- Sliding window validation\n- O(n log n) sorting and O(1) per-event checks\n- Edge cases: missing prerequisites, mutual exclusion\n\n## Code Example\n\n```javascript\nfunction validLog(events, H) {\n  // events: {task: 'A', t: 0}, ...\n  // naive sketch\n  // sort by t\n  // track last window start, last times\n  // enforce A before B, B before C within H, and at most one of C/D in a window\n}\n```\n\n## Follow-up Questions\n\n- How would you scale to thousands of tasks and multiple horizons?\n- How would clock skew affect correctness and what mitigations exist?","diagram":null,"difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T15:58:57.063Z","createdAt":"2026-01-11T15:58:57.063Z"},{"id":"q-685","question":"Context: In a data-cleaning pipeline, records have boolean attributes a, b, c, d. Rules are Horn clauses of the form X ∧ Y -> Z. Given a partial assignment, decide if a full assignment exists that satisfies all clauses. Design a linear-time forward-chaining solver, justify its correctness, and discuss incremental updates and cycles with a concrete four-variable example (two rules)?","answer":"Forward-chaining Horn-SAT solver. Maintain a set of known-true literals and a queue of rules whose antecedents are all true; fire their consequents to mark new truths. If a rule implies a literal alre","explanation":"## Why This Is Asked\nTo gauge practical reasoning about logic constraints, Horn-SAT familiarity, and ability to reason about linear-time algorithms and incremental updates in data pipelines.\n\n## Key Concepts\n- Horn clauses\n- Forward chaining\n- Partial vs full assignments\n- Complexity O(n+m)\n- Cycle handling and inconsistency detection\n\n## Code Example\n```javascript\nfunction solveHorn(rules, facts){\n  const trueSet = new Set(facts);\n  let queue = rules.filter(r => r.antecedent.every(v => trueSet.has(v)));\n  while (queue.length){\n    const r = queue.shift();\n    if (!trueSet.has(r.consequent)){\n      trueSet.add(r.consequent);\n      queue = rules.filter(x => x.antecedent.every(v => trueSet.has(v)) && !trueSet.has(x.consequent));\n    }\n  }\n  return trueSet;\n}\n```\n\n## Follow-up Questions\n- How would you extend to non-Horn clauses?\n- How would you handle incremental updates when facts change?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Databricks","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T16:21:38.487Z","createdAt":"2026-01-11T16:21:38.487Z"},{"id":"q-6973","question":"In a small dependency graph with vertices V1..V5, each value in {T, F, U}, constraints as implications: (V1 → V2), ((V2 ∧ V3) → V4), ((¬V5) → V1), ((V4 ∨ V5) → V3). Is there an assignment with at least one U such that none of the constraints evaluates to F under Kleene 3-valued semantics? Outline a backtracking propagation strategy and give a short concrete trace?","answer":"Seed V5 = U and V1 = U, then set V2 = V3 = V4 = U as required. Under Kleene logic, F occurs only when P=T and Q=F, which this assignment avoids. All implications evaluate to U or T, with at least two U's present. Propagation proceeds as follows: (1) V5=U triggers no immediate constraints, (2) V1=U causes (¬V5)→V1 to become U→U, (3) V2 and V3 are set to U to satisfy V1→V2 and (V4∨V5)→V3, (4) V4=U satisfies (V2∧V3)→V4. All constraints evaluate to U or T, meeting the requirement.","explanation":"## Why This Is Asked\nTests construction of non-deterministic constraint solving with 3-valued truth, plus a concrete backtracking trace.\n\n## Key Concepts\n- Kleene three-valued semantics for →, ∨, ∧, ¬\n- Backtracking with U-seed propagation\n- Detecting F-only on T→F combos\n\n## Code Example\n```javascript\nfunction not(x){ return x==='T'?'F': x==='F'?'T':'U';}\nfunction or(a,b){ return (a==='T'||b==='T')?'T':(a==='U'||b==='U')?'U':'F';}\nfunction implies(P,Q){ return or(not(P), Q); }\n```\n\n## Follow-up Questions\n- How would you scale the approach to larger graphs?\n- What pruning rules best bound the search space?","diagram":"flowchart TD\n  Start[Start] --> Propagate[Propagate U seeds]\n  Propagate --> Check[Check constraints not-F]\n  Check --> Success[Success: solution exists]\n  Check --> Fail[Fail: backtrack]\n","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Discord","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T05:15:27.349Z","createdAt":"2026-01-25T02:51:46.985Z"},{"id":"q-699","question":"You have a Horn-clauses policy language for access control. Given the following rules and facts, determine if allow(alice,read,records) is entailed using forward-chaining to a least fixpoint. Rules: 1) grant(U,act,res) :- haveRole(U,R), privilege(R,act,res). 2) allow(U,act,res) :- grant(U,act,res). Facts: haveRole(alice,dataEngineer). privilege(dataEngineer,read,records). Show your derivation steps?","answer":"Yes. Forward-chaining yields grant(alice,read,records) from haveRole(alice,dataEngineer) and privilege(dataEngineer,read,records) via grant(U,act,res). Then allow(alice,read,records) follows from allo","explanation":"## Why This Is Asked\nTests understanding of Horn clauses, forward-chaining, and least-fixpoint semantics in practical policy reasoning.\n\n## Key Concepts\n- Horn clauses\n- Forward-chaining\n- Least fixpoint\n- Complexity linear in facts and rules\n\n## Code Example\n```javascript\n// Pseudo forward-chaining:\nwhile newDerivation:\n  apply grant rule to facts\n  apply allow rule to grants\n```\n\n## Follow-up Questions\n- How would this scale with thousands of rules?\n- How would you extend to handle negation or recursion?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Databricks","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T17:18:31.996Z","createdAt":"2026-01-11T17:18:31.996Z"},{"id":"q-702","question":"In a home security system, three sensors—door, window, and motion—report activity as booleans a, b, c for the last minute. The alert should fire only when exactly one sensor is active. How would you implement a function that takes a, b, c and returns true iff exactly one is true, and what are its time and space complexities?","answer":"Compute the count: Number(a) + Number(b) + Number(c) and check if it equals 1. For example in JavaScript: return Number(a) + Number(b) + Number(c) === 1. This is O(1) time and O(1) space; an equivalen","explanation":"## Why This Is Asked\nTests understanding of simple boolean logic and edge cases (e.g., all true or all false) in a practical setting.\n\n## Key Concepts\n- Boolean counting\n- Short-circuit reasoning\n- Constant-time evaluation\n\n## Code Example\n```javascript\nfunction alert(a,b,c){\n  return Number(a)+Number(b)+Number(c)===1;\n}\n```\n\n## Follow-up Questions\n- How would you extend to n sensors and a threshold k?\n- How would you optimize for streaming data with sliding windows?","diagram":null,"difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T18:26:22.369Z","createdAt":"2026-01-11T18:26:22.369Z"},{"id":"q-7132","question":"In a policy engine, six propositions P1..P6 have values in {T,F,U} at time steps 0..2. Constraints: (P1@0 and P2@0) -> P3@1, (P4@1 or P5@1) -> P6@2, (not P6@2) -> (P1@0 or P3@1). Is there an assignment with at least one U such that no constraint evaluates to F? Outline a 3-valued temporal propagator and give a concrete satisfying partial assignment?","answer":"Yes. Model U as the third truth value and use Kleene semantics for 3-valued logic over time slices. For a constraint A -> B, compute as not(A) or B with A possibly U; treat not and or/and with min/max","explanation":"## Why This Is Asked\nThis question tests extending boolean logic to 3-valued temporally indexed constraints and practical propagation strategies.\n\n## Key Concepts\n- Kleene 3-valued logic with temporal indexing\n- Implication as not(A) or B and time-sequenced constraints\n- Dependency graph and fixed-point backtracking\n\n## Code Example\n```javascript\nfunction tigaImp(A,B){ // A,B in {T,F,U}\n  const not = x => x === 'T' ? 'F' : x === 'F' ? 'T' : 'U'\n  const or = (x,y) => (x==='T' || y==='T')? 'T' : (x==='F' && y==='F')? 'F' : 'U'\n  return or(not(A), B)\n}\n```\n\n## Follow-up Questions\n- How would you scale to dozens of time steps?\n- How to integrate with a SAT/SMT backend?","diagram":"flowchart TD\n  A[P1@0] --> B[P2@0]\n  B --> C[P3@1]\n  D[P4@1] --> E[P6@2]\n  F[P5@1] --> E\n  G[not P6@2] --> H[P1@0 or P3@1]","difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","LinkedIn","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T10:37:40.219Z","createdAt":"2026-01-25T10:37:40.219Z"},{"id":"q-715","question":"In a distributed data-processing pipeline across three services Ingest (I), Compute (C), Persist (P), each event carries a 3-element vector clock. Given E1 at I with [2,0,1] and E2 at C with [1,3,0], decide whether E1 happened-before E2, E2 happened-before E1, or they are concurrent. Explain the rule and show the comparison. How would you scale this to N services and detect concurrency in large logs?","answer":"Using vector clocks, E1 happened-before E2 if every component of E1 <= corresponding E2 and at least one is strictly less. Here [2,0,1] vs [1,3,0] has 2>1, 0<3, 1>0; not all <= or >=, so E1 || E2 (con","explanation":"## Why This Is Asked\nUnderstanding vector clocks and the happens-before relation for debugging causality in distributed systems.\n\n## Key Concepts\n- Vector clocks\n- Happens-before\n- Concurrency detection in logs\n\n## Code Example\n```javascript\nfunction compareVC(a, b) {\n  let lessEq = true, greaterEq = true;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] > b[i]) lessEq = false;\n    if (a[i] < b[i]) greaterEq = false;\n  }\n  if (lessEq && greaterEq) return 'equal';\n  if (lessEq) return 'a_before_b';\n  if (greaterEq) return 'b_before_a';\n  return 'concurrent';\n}\n```\n\n## Follow-up Questions\n- How would you integrate vector clocks with a log-aggregation system to detect causality violations?\n- What are the storage and performance implications for large-scale deployments?","diagram":null,"difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Bloomberg","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T19:18:20.787Z","createdAt":"2026-01-11T19:18:20.787Z"},{"id":"q-719","question":"Design a tiny solver for three boolean inputs A, B, C given constraints: (A -> B) and (B -> C) and (A or C). Is there an assignment that satisfies all three? Explain your reasoning and outline a simple backtracking approach you would implement to check arbitrary small sets of such implications?","answer":"Two assignments satisfy (A->B), (B->C), (A∨C): (0,0,1) and (1,1,1). A quick check uses the constraints: A->B true if A=0 or B=1; B->C true if B=0 or C=1; A∨C true if A=1 or C=1. A backtracking checker","explanation":"## Why This Is Asked\nEvery candidate demonstrates logic reasoning and basic constraint solving relevant to planning validations in software.\n\n## Key Concepts\n- Propositional logic and implications\n- Satisfiability with small variable sets\n- Backtracking pruning for constraints\n\n## Code Example\n```javascript\nfunction isSatisfiable(constraints) {\n  const vars = ['A','B','C'];\n  for (let a of [0,1])\n    for (let b of [0,1])\n      for (let c of [0,1]) {\n        const assign = {A:a,B:b,C:c};\n        if (constraints.every(fn => fn(assign))) return true;\n      }\n  return false;\n}\n```\n\n## Follow-up Questions\n- How would you extend to thousands of variables with CNF clauses?\n- What are the trade-offs of backtracking vs. SAT solvers in practice?","diagram":null,"difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Google","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T20:22:02.565Z","createdAt":"2026-01-11T20:22:02.565Z"},{"id":"q-728","question":"Scenario: You’re building a tiny policy engine for feature flags with three booleans A, B, C. Constraints: A implies B, B implies C, and at least two of the three must be true. Is there an assignment that satisfies all constraints? If so, give one example and briefly justify. Then outline a straightforward backtracking approach to enumerate all satisfying assignments for any n flags and any such constraints?","answer":"Yes. With A,B,C, A→B and B→C and at least two true, A=false,B=true,C=true works: A→B vacuously true; B→C true because C is true; two true satisfy the cardinality. Backtracking: enumerate A,B,C in {F,T","explanation":"## Why This Is Asked\n\nTests ability to reason about small logical constraints and translate them into a checkable search, including vacuous implications and cardinality.\n\n## Key Concepts\n\n- Logical implications and vacuous truth\n- Cardinality constraints (minimum true)\n- Backtracking with pruning\n- Generalizing to N variables\n\n## Code Example\n\n```javascript\nfunction countTrue(arr){ return arr.filter(x=>x).length; }\nfunction implies(p,q){ return !p || q; }\nfunction sat(assignment){\n  const [A,B,C] = assignment;\n  if(!implies(A,B)) return false;\n  if(!implies(B,C)) return false;\n  if(countTrue(assignment) < 2) return false;\n  return true;\n}\n```\n\n## Follow-up Questions\n\n- How would you generalize to 4+ vars with arbitrary implications?\n- How would you optimize for sparse constraint graphs and avoid enumerating all 2^n assignments?","diagram":"flowchart TD\n  A((A)) --> B((B))\n  B --> C((C))\n  Sub([At Least Two True]) --> A\n  Sub --> B\n  Sub --> C","difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Instacart","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T21:17:52.369Z","createdAt":"2026-01-11T21:17:52.369Z"},{"id":"q-733","question":"You’re auditing a rule-set for access policy. There are four booleans **X1**, **X2**, **X3**, **X4** with constraints: (X1 -> X2), (X1 ∨ X3), (X2 -> X4), and (X3 -> ¬X4). Is there a satisfying assignment? If yes, provide one; if not, explain why. Then outline a minimal backtracking strategy with unit propagation to verify arbitrary similar constraint sets?","answer":"Yes. One satisfying assignment is X1=0, X2=0, X3=1, X4=0. Reason: X1→X2 vacuously true when X1=0; X1∨X3 requires X3=1; X3→¬X4 yields X4=0; X2→X4 is true since X2=0. Translate to CNF: (¬X1∨X2)∧(X1∨X3)∧","explanation":"## Why This Is Asked\nTests translating a small policy-like rule-set into a CNF and solving with a practical backtracking approach.\n\n## Key Concepts\n- CNF encoding of implications\n- DPLL-style backtracking with unit propagation\n- Early pruning via conflicts and propagation\n- Live, scalable handling for arbitrary constraint sets\n\n## Code Example\n```javascript\nfunction solveCNF(clauses, assignment = {}) {\n  // minimal skeleton: unit-propagation + depth-first search\n}\n``` \n\n## Follow-up Questions\n- How would you handle cardinality constraints beyond binary implications?\n- What heuristics improve variable ordering in practice?","diagram":"flowchart TD\n  Start[Constraints: X1..X4] --> Prop[Unit Propagation]\n  Prop --> Check[Consistency Check]\n  Check --> Sat{Satisfiable?}\n  Sat --> Yes[Return assignment]\n  Sat --> No[Backtrack]","difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Netflix","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T22:18:15.092Z","createdAt":"2026-01-11T22:18:15.092Z"},{"id":"q-7336","question":"Temporal 3-valued logic puzzle: Let X1, X2, X3 range over {T,F,U} at time steps t ∈ {0,1,2,3}. Constraints for t ∈ {0,1,2}:\n- If X1(t) = T then X2(t+1) ≠ F\n- If X2(t) = F then X3(t+1) = T\n- If X3(t) = U then X1(t+2) = U\nIs there a 4-step trace with at least one 'U' such that none of the constraints evaluates to F at any time? Outline a 3-valued temporal backtracking approach and show a small example trace?","answer":"Yes. A valid trace: X1(t)=X2(t)=X3(t)=U for t=0,1,2,3. Then no antecedent ever becomes true, and whenever X3(t)=U, X1(t+2)=U holds, so no constraint evaluates to F. In backtracking, seed U, only commi","explanation":"## Why This Is Asked\nThis tests reasoning with temporal and tri-valued logic, combining forward propagation with unknowns and discrete time.\n\n## Key Concepts\n- Kleene three-valued semantics\n- Temporal horizons and propagation\n- Backtracking with partial assignments\n\n## Code Example\n```javascript\nfunction check(trace){\n  for(let t=0;t<3;t++){\n    if(trace.X1[t]===\"T\" && trace.X2[t+1]===\"F\") return false;\n    if(trace.X2[t]===\"F\" && trace.X3[t+1]!==\"T\") return false;\n    if(trace.X3[t]===\"U\" && trace.X1[t+2]!==\"U\") return false;\n  }\n  return true;\n}\n```\n\n## Follow-up Questions\n- How does this scale with more time steps and variables? \n- What changes if you require at least two U's and forbid any T? ","diagram":"flowchart TD\n  A[Init] --> B[Propagate t=0]\n  B --> C[Propagate t=1]\n  C --> D[Check constraints]\n  D --> E[Satisfiable/Unsat]","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Salesforce","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T19:06:12.878Z","createdAt":"2026-01-25T19:06:12.878Z"},{"id":"q-7407","question":"You manage five sensors S1..S5 in {T, F, U}. Using Kleene semantics ( ¬: T↔F, U→U; ∧/∨ as min/max with T>U>F ), constraints: (S1 ∨ S2) → S3, (¬S5) → (S1 ∧ S4), (S2 ∧ S4) → ¬S3. Is there an assignment with at least one U such that none of the constraints evaluates to F? Outline a backtracking propagation approach and provide a concrete satisfying assignment with a walk-through?","answer":"A valid witness assignment: S5=T, S1=U, S2=F, S3=F, S4=F satisfies all constraints while using at least one U. Constraint verification: (S1∨S2)=U, so U→F yields U; (¬S5)=F, so F→(S1∧S4)=T; (S2∧S4)=F, so F→¬S3=T. A backtracking approach would iteratively assign values to sensors, propagating constraints after each assignment and pruning branches where any constraint evaluates to F, searching for assignments where all constraints evaluate to T or U.","explanation":"## Why This Is Asked\n\nTests ability to reason through 3-valued logic and implement a constrained solver with backtracking—a common pattern in policy/rule engines.\n\n## Key Concepts\n\n- Kleene 3-valued logic with unknown (U) support\n- Implication defined as ¬A ∨ B\n- Backtracking propagation to avoid false outcomes\n\n## Code Example\n\n```javascript\nfunction kleeneImpl(a,b){\n  const not = v => v==='T'?'F': v==='F'?'T':'U';\n  const order = {'F':0,'U':1,'T':2};\n  const na = not(a);\n  const vals = [na, b];\n  return vals.reduce((m,x)=> order[x] > order[m] ? x : m, 'F');\n}\n```\n\n## Follow-up Questions\n\n- How would you optimize the backtracking algorithm for larger sensor networks?\n- Can you extend this approach to handle additional logical operators?\n- What strategies would you use to minimize the number of U values in the final assignment?","diagram":"flowchart TD\n  Start[Start] --> A[Assign S5 = T]\n  A --> B[Check constraint 2 is not F]\n  B --> C[Assign S1 = U]\n  C --> D[Evaluate all constraints]\n  D --> End[End]","difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Cloudflare","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T06:46:28.089Z","createdAt":"2026-01-25T21:43:08.336Z"},{"id":"q-7444","question":"You model a four-flag policy with states in {T, F, U}. Constraints: (A → B), (B → C), (C → D), and (D → A). Is there an assignment with at least one U such that none of the four constraints evaluates to F? Explain how a simple 3-valued backtracking propagator would verify this and provide one concrete satisfying assignment?","answer":"Yes. Using Kleene three-valued logic where p→q = ¬p ∨ q, a constraint evaluates to false only when its antecedent is true and consequent is false. A satisfying assignment exists: A=U, B=F, C=T, D=T. This yields A→B=U, B→C=T, C→D=T, and D→A=U, with no constraint evaluating to false and at least one variable undefined. A simple backtracking propagator would systematically explore the 3^4=81 possible assignments, pruning any branch where a constraint becomes false, and quickly converge to this solution.","explanation":"## Why This Is Asked\nThis question assesses understanding of three-valued logical semantics, constraint satisfaction problems, and practical backtracking algorithms for reasoning under uncertainty.\n\n## Key Concepts\n- **Kleene Three-Valued Logic**: Truth ordering T > U > F where ¬ maps T↔F and U→U. Implication follows p→q = ¬p ∨ q.\n- **Constraint Evaluation**: A constraint evaluates to false only when antecedent is true and consequent is false.\n- **Backtracking Propagation**: Systematic search with pruning - eliminate assignments that create false constraints and propagate until fixed point or contradiction.\n\n## Implementation Example\n```javascript\nconst rank = {'F':0,'U':1,'T':2};\nfunction not(p){ return p==='T'?'F' : p==='F'?'T' : 'U'; }\nfunction impl(p,q){ \n  const np = not(p);\n  return rank[np] >= rank[q] ? np : q;\n}\nfunction satisfies(a,b,c,d){\n  return impl(a,b)!=='F' && impl(b,c)!=='F' && \n         impl(c,d)!=='F' && impl(d,a)!=='F' && \n         [a,b,c,d].includes('U');\n}\n```\n\nThe propagator would explore the search space efficiently, finding A=U,B=F,C=T,D=T as a valid solution where all constraints avoid false evaluation while maintaining the required undefined element.","diagram":"flowchart TD\n  A[Vars: A,B,C,D] --> C1[A → B]\n  A --> C2[B → C]\n  A --> C3[C → D]\n  A --> C4[D → A]","difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Microsoft","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T04:36:31.986Z","createdAt":"2026-01-25T23:43:19.740Z"},{"id":"q-745","question":"You are building a tiny rule engine for feature toggles with three booleans A, B, C. Constraints: A → B, B → ¬C, and at least one of A, B, C must be true. Is there a satisfying assignment? Explain how you would verify it via brute-force backtracking across the eight possibilities and return one concrete example if it exists?","answer":"Yes. A valid assignment exists, e.g., A=1, B=1, C=0. Other solutions are (0,0,1) and (0,1,0). A brute-force backtracking approach would enumerate 8 combos, prune when (!A) || B fails or (!B) || !C fai","explanation":"## Why This Is Asked\n\nTests ability to reason about combined implications and negation, and to design a small exhaustive search with pruning.\n\n## Key Concepts\n\n- Implication and negation in boolean constraints\n- Exhaustive search with pruning\n- Small-scope backtracking for correctness checks\n\n## Code Example\n\n```javascript\nfunction solve() {\n  for (let A = 0; A <= 1; A++) {\n    for (let B = 0; B <= 1; B++) {\n      for (let C = 0; C <= 1; C++) {\n        const ok1 = (!A) || B;     // A -> B\n        const ok2 = (!B) || (!C);  // B -> ¬C\n        const ok3 = (A || B || C); // at least one true\n        if (ok1 && ok2 && ok3) return {A,B,C};\n      }\n    }\n  }\n  return null;\n}\n```","diagram":null,"difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["NVIDIA","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T23:19:37.904Z","createdAt":"2026-01-11T23:19:37.904Z"},{"id":"q-753","question":"In a feature-flag synthesis task, you have booleans A1..A8. Constraints include: (Ai -> Aj) implications, (Ai XOR Aj) mutual exclusions, and (Ai OR Aj OR Ak) group obligations. The implication graph is acyclic and each node has at most two outgoing edges. Design a backtracking solver that exploits the DAG to decide satisfiability for up to 12 vars. Provide a concrete 8-variable instance and show the solution or UNSAT?","answer":"Topologically sort the implication graph and propagate truths: if X -> Y and X is true, force Y true along the path; track unknowns otherwise. XOR constraints encoded as (A xor B) meaning exactly one ","explanation":"## Why This Is Asked\n\nAssesses ability to leverage a DAG of implications, handle XOR and OR constraints, and design a backtracking solver with strong pruning, reflecting real config-synthesis tasks at scale.\n\n## Key Concepts\n\n- DAG-driven propagation and topological order\n- XOR constraint encoding (1-in-2 style)\n- Backtracking with unit-propagation and early pruning\n- SAT-lean representations for mixed constraints\n\n## Code Example\n\n```javascript\nfunction solve(vars, constraints) {\n  // vars: boolean/null for unassigned; constraints: array of imp/xor/or\n  // Implementation sketch: propagate, then backtrack on a source variable\n  return true;\n}\n```\n\n## Follow-up Questions\n\n- How would you extend to 100+ vars with partial DAGs?\n- How would you relax the DAG assumption and detect cycles efficiently?","diagram":null,"difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","LinkedIn","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T01:31:29.320Z","createdAt":"2026-01-12T01:31:29.320Z"},{"id":"q-7571","question":"Scenario: Four services A,B,C,D in {T, F, U} representing health status. Policy rules: (A ∨ B) → C; (B ∧ D) → ¬A; (C ∨ ¬D) → A. Is there an assignment with at least one U such that none of the three constraints evaluates to F? Use Kleene semantics: ¬: T↔F, U→U; ∧/∨ as min/max with T>U>F. Outline a 3-valued backtracking propagation strategy and show one concrete satisfying assignment?","answer":"Yes. Example satisfying assignment: A=U, B=F, C=U, D=U. Evaluate: (A∨B)=U; (A∨B)→C = U→U = U. (B∧D)=F; F→¬A = F→U = T. (C∨¬D)=U; U→A = U→U = U. No constraint is F and at least one U present. Demonstra","explanation":"## Why This Is Asked\nTests reasoning with Kleene 3-valued logic in a practical constraint setting, mirroring health-status propagation where unknowns must not force false conclusions.\n\n## Key Concepts\n- Kleene 3-valued logic with T/F/U\n- Implication defined as (¬A) ∨ B\n- Backtracking propagation to avoid F\n- Constructive verification of a satisfying assignment\n\n## Code Example\n```javascript\nfunction not(x){ return x==='T'?'F': x==='F'?'T':'U'; }\nfunction max(a,b){ const order={F:0,U:1,T:2}; return order[a] >= order[b] ? a : b; }\nfunction imply(a,b){ return max(not(a), b); }\n```\n\n## Follow-up Questions\n- How would you extend to five variables while preserving efficient pruning?\n- How would you integrate this into a CP solver to automatically prune invalid branches?","diagram":"flowchart TD\n  A[Start] --> B[Assign A,B,C,D]\n  B --> C[Evaluate constraints]\n  C --> D{Any F?}\n  D -- Yes --> E[Backtrack]\n  D -- No --> F[Found valid assignment]\n  F --> G[End]","difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Salesforce","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T07:56:28.067Z","createdAt":"2026-01-26T07:56:28.067Z"},{"id":"q-758","question":"You manage feature flags for a distributed service. Let F1..F5 be booleans with constraints: (F1 -> F2), (F1 ∨ F3), (F2 ⊕ F4), (F3 -> F5), and (F4 -> ¬F5). Is there a satisfying assignment? If yes, provide one; if not, explain. Then outline a minimal backtracking strategy with forward checking to verify arbitrary similar constraint sets?","answer":"Yes. One satisfying assignment is F1=1, F2=1, F3=0, F4=0, F5=0. Check: F1→F2 true; F1∨F3 true; F2⊕F4 true (1≠0); F3→F5 true (0→0); F4→¬F5 true (0→¬0). Backtracking should propagate F2 when F1=1, force","explanation":"## Why This Is Asked\nProbes XOR and implications under realistic feature flags; tests constraint propagation and backtracking.\n\n## Key Concepts\n- XOR constraints in SAT-like settings\n- Forward checking and constraint propagation\n- Translating to CNF for scalable solvers\n\n## Code Example\n```javascript\nfunction sat(F){\n  const [F1,F2,F3,F4,F5] = F;\n  const c1 = (!F1) || F2; // F1 -> F2\n  const c2 = F1 || F3;    // F1 ∨ F3\n  const c3 = (F2 !== F4); // F2 XOR F4\n  const c4 = (!F3) || F5;  // F3 -> F5\n  const c5 = (!F4) || (!F5); // F4 -> ¬F5\n  return c1 && c2 && c3 && c4 && c5;\n}\n\nconsole.log(sat([1,1,0,0,0])); // true\n```\n\n## Follow-up Questions\n- How would you encode these constraints into CNF for a SAT solver?\n- How would you scale to 20+ flags with incremental updates?","diagram":"flowchart TD\n  A[F1] --> B[F2]\n  A --> C[F3]\n  B --> D[F4]\n  C --> E[F5]\n  D --> F[Not F5]","difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Discord","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T03:48:03.715Z","createdAt":"2026-01-12T03:48:03.716Z"},{"id":"q-7655","question":"Let P1..P4 ∈ {T, F, U} with constraints: (P1 or P2) -> (P3 and P4); (P2 -> P3) or P1; not P4 -> (P1 and P2). Is there an assignment with at least one U such that none evaluates to F under Kleene 3-valued semantics? Provide a depth-3 backtracking trace and show how unit/propagation would prune the search?","answer":"Yes. One satisfying assignment is P1=U, P2=F, P3=U, P4=T. Check: (P1∨P2)=U, (P3∧P4)=U → U; (P2→P3)=T, so T∨P1=T; not P4→(P1∧P2)=F→F = T. All constraints non-F and at least one U. Demonstrates propagat","explanation":"## Why This Is Asked\n\nTests design and reasoning about 3-valued constraint systems with cycles, using Kleene semantics and backtracking.\n\n## Key Concepts\n\n- Kleene three-valued logic: T>U>F; not maps T<->F, U->U; and/or as min/max\n- CSP propagation with non-classical values and cycles\n- Depth-limited backtracking to illustrate pruning\n\n## Code Example\n\n```javascript\n// Kleene evaluator (ASCII semantics)\nconst rank = { 'F':0, 'U':1, 'T':2 };\nfunction not(x){ return x==='T'?'F': x==='F'?'T':'U'; }\nfunction and(a,b){ return rank[a] < rank[b] ? a : b; }\nfunction or(a,b){ return rank[a] > rank[b] ? a : b; }\nfunction implies(a,b){ return or(not(a), b); }\n```\n\n## Follow-up Questions\n\n- How would you scale to N predicates with arbitrary Horn-like rules while keeping backtracking practical?\n- Compare 3-valued propagation vs. DPLL-style search with clause learning in this setting.","diagram":null,"difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Cloudflare","Goldman Sachs"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T11:35:12.412Z","createdAt":"2026-01-26T11:35:12.413Z"},{"id":"q-771","question":"You are validating a tiny access-control policy with two booleans: A = 'account is active', B = 'email verified'. The policy must satisfy: (¬A -> B), (B -> A), and (A ∨ B). Is there a satisfying assignment for A and B? Explain your reasoning and outline a simple backtracking check to verify arbitrary small sets of such clauses?","answer":"Yes. A=true, B=false satisfies all: ¬A is false so ¬A -> B holds; B -> A is vacuously true since B is false; A ∨ B is true. A backtracking check would try A in {true,false}, then B in {true,false}, ev","explanation":"## Why This Is Asked\nTests practical logical deduction and simple SAT handling in a controlled, small-domain setting.\n\n## Key Concepts\n- Implication with negation\n- Disjunction\n- Satisfiability search\n- Backtracking basics\n- Early termination on first valid assignment\n\n## Code Example\n```javascript\nfunction isSat(A,B) {\n  // Clause1: (!A => B)  == (A || B)\n  // Clause2: (B => A)   == (!B || A)\n  // Clause3: (A || B)\n  return (A || B) && (!B || A) && (A || B);\n}\n```\n\n## Follow-up Questions\n- How would you extend to three variables with similar clauses?\n- How does short-circuit evaluation affect performance in larger clause sets?","diagram":null,"difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["NVIDIA","PayPal","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T04:51:00.043Z","createdAt":"2026-01-12T04:51:00.043Z"},{"id":"q-7732","question":"Scenario: five service statuses S1..S5, each in {T, F, U}. Constraints: (S1 → S2), (S3 ∨ S4 ∨ S5), and (S1 ∧ S3) → ¬S5. An additional global rule enforces at most two services are True. Is there an assignment with at least one U such that none of the constraints evaluates to F? Outline a 3-valued backtracking propagator and give a concrete satisfying example?","answer":"Yes. Example: S1=T, S2=T, S3=U, S4=F, S5=F. Then S1→S2 = T, S3∨S4∨S5 = U, (S1∧S3) → ¬S5 = T. All constraints are not F, with exactly two T and at least one U. A 3-valued backtracking propagator would ","explanation":"## Why This Is Asked\n\nAssesses ability to reason with Kleene-style three-valued logic plus a combinatorial bound, and to design a backtracking propagator that avoids propagating F prematurely.\n\n## Key Concepts\n\n- Kleene three-valued logic: T > U > F, with ¬, ∨, ∧ defined as usual.\n- Constraint propagation under unknowns and cardinality limits.\n- Backtracking strategies that preserve satisfiability without over-pruning.\n\n## Code Example\n\n```javascript\n// Pseudocode: propagate values using Kleene truth tables\nfunction propagate3Valued(vals, constraints) { /* ... */ }\n```\n\n## Follow-up Questions\n\n- How would you scale this to 20+ variables with more complex constraints?\n- How can you detect unsat cores when using U?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T15:42:45.001Z","createdAt":"2026-01-26T15:42:45.002Z"},{"id":"q-775","question":"You're building a constraint-solver for a feature-flag system across a microservices deployment. Given four flags S1..S4 with constraints: (S1 -> S2), (S2 -> S3), (S4 -> ¬S1), and (S1 ∨ S4) and (S2 ∨ S4). Is there a satisfying assignment? Provide one concrete assignment and outline a backtracking algorithm with unit propagation to verify arbitrary similar constraint sets?","answer":"Yes. A satisfying assignment is S1=true, S2=true, S3=true, S4=false. Checks: S1→S2 (T→T), S2→S3 (T→T), S4→¬S1 (F→¬T), S1∨S4 (T), S2∨S4 (T). Backtracking: pick a var, propagate implications, backtrack ","explanation":"## Why This Is Asked\n\nTests ability to reason about constraints in practical feature-flag settings and to design a solver using propagation and backtracking rather than pure search. It also exposes how to craft a constructive counterexample when needed.\n\n## Key Concepts\n\n- Constraint satisfaction with implications and disjunctions\n- Unit propagation, backtracking, and a decision trail\n- Real-world constraints in deployment feature flags and release gates\n\n## Code Example\n\n```javascript\n// Minimal backtracker for boolean flags with given constraints\nfunction sat(S){\n  return (!S.S1 || S.S2) && (!S.S2 || S.S3) && (!S.S4 || !S.S1) && (S.S1 || S.S4) && (S.S2 || S.S4);\n}\nfunction satPartial(part){\n  const v = (k)=> part.hasOwnProperty(k)? part[k] : null;\n  if (v('S1')===true && v('S2')===false) return false;\n  if (v('S2')===true && v('S3')===false) return false;\n  if (v('S4')===true && v('S1')===true) return false;\n  if (v('S1')===false && v('S4')===false) return false;\n  if (v('S2')===false && v('S4')===false) return false;\n  return true;\n}\nfunction solve(partial={}, idx=0){\n  const vars=['S1','S2','S3','S4'];\n  if (!satPartial(partial)) return null;\n  if (idx===vars.length) return partial;\n  const name = vars[idx];\n  for (const val of [false,true]){\n    const next = Object.assign({}, partial, {[name]: val});\n    const res = solve(next, idx+1);\n    if (res) return res;\n  }\n  return null;\n}\nconsole.log(solve());\n```\n\n## Follow-up Questions\n\n- How would you scale this to thousands of flags with mostly Horn clauses?\n- What optimizations would you add for large constraint sets?","diagram":"flowchart TD\nS1 --> S2\nS2 --> S3\nS4 --> NotS1\nS1 --> S4\nS2 --> S4","difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Slack","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T05:29:00.647Z","createdAt":"2026-01-12T05:29:00.647Z"},{"id":"q-7813","question":"Scenario: A navigation policy uses signals A..E with values in {T, F, U}. Time is discretized into two steps t=0 and t=1. Constraints: (A_t ∧ B_t) → C_t; (B_t ∨ D_t) → A_{t+1}; (¬E_t) → (A_t ∨ E_t). Is there an assignment with at least one U across both steps such that no constraint evaluates to F at either step? Outline a 3-valued backtracking approach that propagates across time and sketch a concrete footprint that satisfies all constraints?","answer":"Approach: treat as a 2-step 3-valued CSP with Kleene logic. Propagate so no constraint is F. Example footprint at t=0: A=U, B=T, C=U, D=F, E=U. Then (A∧B)→C non-F (A∧B=U); (B∨D)→A1 forces A1=T; (¬E)→(","explanation":"## Why This Is Asked\nThis question probes precise handling of 3-valued logic across time in a policy engine.\n\n## Key Concepts\n- Kleene three-valued logic\n- Temporal constraint propagation\n- Backtracking CSPs\n\n## Code Example\n```javascript\n// placeholder logic sketch\n```\n\n## Follow-up Questions\n- How would you extend to N time steps and optimize for minimal U?\n- How to detect unsatisfiable prefixes efficiently?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T19:03:55.370Z","createdAt":"2026-01-26T19:03:55.370Z"},{"id":"q-7842","question":"Scenario: A tiny access-control policy with four booleans A..D in {T, F, U}. Constraints: (A ∨ B) → C, (B ∧ D) → ¬A, and (¬D) → (A ∨ C). Additionally, exactly one of A and B is U. Is there an assignment satisfying all constraints with exactly one U among A,B? Outline a 3-valued backtracking propagator to verify such rule-sets and show a concrete satisfying assignment?","answer":"I would model each constraint with Kleene semantics: p→q equals ¬p ∨ q, where ¬F=T, ¬T=F, ¬U=U and ∨,∧ follow min/max with T>U>F. Enforce 'exactly one of A,B is U' during propagation. Branch A then B ","explanation":"## Why This Is Asked\nTests ability to design a compact 4-variable 3-valued constraint system with a global constraint and to articulate a propagation+backtracking strategy that preserves not-F while allowing U.\n\n## Key Concepts\n- 3-valued Kleene semantics for →, ∧, ∨\n- Constraint propagation with non-determinism\n- Global constraint: exactly one of two vars is U\n- Backtracking search order and pruning\n\n## Code Example\n```javascript\nconst order = {F:0, U:1, T:2};\nfunction max(a,b){ return order[a] >= order[b] ? a : b; }\nfunction not(a){ return a==='T'?'F':a==='F'?'T':'U'; }\nfunction implies(p,q){ return max(not(p), q); }\n```\n\n## Follow-up Questions\n- How would you adapt this to detect UNSAT early? \n- How does the solver handle cycles in constraints and ensure termination?\n","diagram":"flowchart TD\n  Start([Start])\n  A[Assign A] --> B[Assign B]\n  B --> C[Propagate constraints]\n  C --> D{Solution found?}\n  D -->|Yes| End([End: SAT])\n  D -->|No| StartBacktrack([Backtrack])\n  StartBacktrack --> A","difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Robinhood","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T19:49:35.461Z","createdAt":"2026-01-26T19:49:35.461Z"},{"id":"q-789","question":"Is there a truth assignment with exactly three flags true that satisfies all constraints A -> B; B -> C; D -> E; F -> G; not C -> H; A -> D? If yes, provide one and justify why it satisfies every implication?","answer":"Yes. A valid three-true assignment is B=true, C=true, H=true; all others false. Check: A false makes A->B and A->D vacuously true; B true enforces C true; not C is false so not C->H is vacuously true;","explanation":"## Why This Is Asked\n\nTests ability to reason about simple Horn-like constraints, propagation, and a cardinality requirement. It also checks whether the candidate can find a non-obvious satisfying assignment by exploiting unconstrained variables and implications to meet a strict true-count.\n\n## Key Concepts\n\n- Horn clause propagation\n- Forward/backward chaining\n- Cardinality constraints\n- Minimal models\n\n## Code Example\n\n```javascript\n// naive solver for A..H with given implications\nfunction satModel(vars){\n  // apply A->B, B->C, D->E, F->G, A->D, and notC->H\n  // returns first model with exactly 3 trues or null\n  return null;\n}\n```\n\n## Follow-up Questions\n\n- How would you generalize to arbitrary n and more constraints?\n- How change if notC -> H becomes not H -> C?\n","diagram":"flowchart TD\n  A[A]\n  B[B]\n  C[C]\n  D[D]\n  E[E]\n  F[F]\n  G[G]\n  H[H]\n  A --> B\n  B --> C\n  D --> E\n  F --> G\n  NotC[not C] -- H --> H\n  A --> D\n","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Square","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T07:25:29.228Z","createdAt":"2026-01-12T07:25:29.229Z"},{"id":"q-7931","question":"You model a rolling deployment health graph with five services A–E; each service status is in {Up, Down, Unknown}. Constraints: (A Up ⇒ B Up ∨ C Up), (D Down ⇒ E Down), (E Up ⇒ A Up). Is there an assignment at time t with at least one Unknown such that all constraints remain not definitively false at both t and t+1? Outline a temporal 3-valued backtracking approach and show a concrete, minimal example?","answer":"Yes. Model two time steps t and t+1 for services A–E with values {Up, Down, Unknown}. Apply Kleene semantics: A→(B∨C) is not false unless A=Up and (B∨C)=Down, and E Up ⇒ A Up applies per time step. Perform DFS over Unknown assignments, pruning when any constraint becomes definitively false at either time step.","explanation":"## Why This Is Asked\nTests ability to design temporal constraint propagation and reason about 3-valued logic in a production-like setting.\n\n## Key Concepts\n- Temporal CSP\n- Kleene 3-valued logic\n- Forward-backward propagation\n- Backtracking search\n\n## Code Example\n```javascript\nfunction propagate(twoSlices, constraints) {\n  // skeleton: propagate Unknowns across two time steps\n}\n```\n\n## Follow-up Questions\n- How does complexity grow with N services?\n- How to handle cycles and dynamic constraints?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Stripe","Tesla","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T06:00:00.388Z","createdAt":"2026-01-26T23:46:18.352Z"},{"id":"q-799","question":"Scenario: four booleans P, Q, R, S where P = user has role X, Q = grants read, R = has role Y, S = grants write. Constraints: (P -> Q), (R -> S), (P ∨ R), and at least two of {Q,S} must be true. Is there a satisfying assignment? If yes, give one; if not, explain why. Then outline a minimal backtracking strategy with unit propagation for arbitrary similar constraint sets?","answer":"Yes. One satisfying assignment is P=true, Q=true, R=true, S=true. Propagate P→Q and R→S, then the disjunction P∨R requires at least one of P,R to be true; choosing both yields Q and S true, meeting th","explanation":"## Why This Is Asked\nTests the ability to reason with mixed boolean and cardinality constraints, and to design a minimal backtracking solver with unit propagation.\n\n## Key Concepts\n- Boolean implications and disjunctions\n- Cardinality constraints (at least two true)\n- Unit propagation in backtracking\n- Pruning via early infeasibility checks\n\n## Code Example\n```javascript\nfunction backtrack(variables, constraints) {\n  // naive DFS with unit propagation\n  // returns a satisfying assignment or null\n}\n```\n\n## Follow-up Questions\n- How would you extend to arbitrary cardinalities (exactly k)?\n- How does your approach handle larger, real-world constraint sets?\n","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","DoorDash","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T08:30:11.725Z","createdAt":"2026-01-12T08:30:11.725Z"},{"id":"q-8088","question":"In a policy-check task, four flags A,B,C,D have states in {T, F, U}. Constraints: (A ∨ B) → C, (C ∨ D) → A, plus a global existential requirement: at least one of A,B,C,D must be T. Is there an assignment with at least one U that satisfies all constraints? Provide a concrete assignment and outline a 3-valued propagation approach for similar rule sets?","answer":"Yes. Example: A=T, B=U, C=T, D=F. Evaluate: A∨B = max(T,U)=T; (A∨B)→C = ¬(A∨B) ∨ C = F ∨ T = T. (C∨D) = max(T,F)=T; (C∨D)→A = ¬T ∨ A = F ∨ T = T. At least one T holds. All constraints non-F under Klee","explanation":"## Why This Is Asked\nTests understanding of 3-valued logic, existential constraints, and propagation.\n\n## Key Concepts\n- Kleene 3-valued logic: T>U>F; A→B = ¬A ∨ B\n- Handling unknowns in disjunctions and implications\n- Existential constraint integration and propagation strategies\n\n## Code Example\n```javascript\nfunction val(x){return x==='T'?1:x==='F'?0:0.5}\nfunction implies(a,b){return Math.max(1 - val(a), val(b))}\n```\n\n## Follow-up Questions\n- How would you extend to n variables with multiple existential constraints?\n- How do you detect unsatisfiable sets under this semantics?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","NVIDIA","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T09:06:03.782Z","createdAt":"2026-01-27T09:06:03.782Z"},{"id":"q-812","question":"Instance-based SAT with mixed Horn and parity constraints: Variables A,B,C,D,E,F. Constraints: (A ∧ B) → C; (C ∧ D) → E; A ⊕ D ⊕ F = 1; (B ∧ E) → F. Is there an assignment to A..F that satisfies all constraints? If yes, provide one; then describe how you would build a solver that combines forward-chaining on Horn clauses with Gaussian elimination over GF(2) for parity constraints, including data structures and complexity considerations?","answer":"Yes. One satisfying assignment is A=1, B=0, C=0, D=0, E=0, F=0. Then A∧B=0 so C unconstrained; C∧D=0 so E unconstrained; parity 1⊕0⊕0=1; B∧E=0 so F unconstrained. For the solver, first solve parity wi","explanation":"## Why This Is Asked\nThis question tests the ability to design solvers for hybrid constraint systems, combining logic reasoning with linear algebra.\n\n## Key Concepts\n- Horn clause forward-chaining\n- Parity constraints (GF(2) linear algebra)\n- Fixed-point iteration and backtracking\n- Constraint propagation and conflict detection\n\n## Code Example\n```javascript\n// Simple sketch\nfunction solve(parities, horns) {\n  // implement parity elimination then forward-chaining\n}\n```\n\n## Follow-up Questions\n- How would you handle conflicting parity constraints?\n- Analyze worst-case complexity of the combined solver.","diagram":"flowchart TD\n  A[Input Variables A..F] --> B[Propagate Horns]\n  B --> C[Apply GF(2) Elimination]\n  C --> D[Fixed Point]\n  D --> E{Satisfiable?}\n  E --> F[Return Model / Unsat]","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Google","Lyft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T10:22:59.643Z","createdAt":"2026-01-12T10:22:59.643Z"},{"id":"q-822","question":"Scenario: a tiny feature-toggle system for a data-annotation pipeline uses five booleans A–E: A = 'data augmentation enabled', B = 'sampling enabled', C = 'privacy mode on', D = 'live monitoring on', E = 'throttle rate limited'. Constraints: (A → B), (B → D), (C → ¬D), (A ∨ C), (D → E), (E → ¬A). Is there a satisfying assignment? If yes, give one; if not, explain why. Then outline a minimal backtracking strategy with unit propagation to verify arbitrary similar constraint sets?","answer":"Yes. Example: A=false, B=false, C=true, D=false, E=true. All constraints satisfied: A→B and B→D vacuous; C→¬D true; A∨C true; D→E vacuous; E→¬A true. For general cases, use a DF/DPLL-style search with","explanation":"## Why This Is Asked\n\nAssesses ability to reason about constrained booleans, identify a satisfiable assignment, and outline a scalable backtracking strategy with unit propagation.\n\n## Key Concepts\n\n- 2-SAT/Horn-clauses\n- Unit propagation\n- Backtracking/DPLL\n\n## Code Example\n\n```javascript\n// Minimal backtracking SAT tester\nfunction solve(clauses, assign={}) {\n  // if all literals satisfied return assign\n  // propagate unit clauses and branch\n  return null;\n}\n```\n\n## Follow-up Questions\n\n- How does adding a clause X → Y affect pruning?\n- How would you extend to arbitrary n variables and k clauses?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Hugging Face","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T11:20:06.386Z","createdAt":"2026-01-12T11:20:06.386Z"},{"id":"q-8233","question":"Consider five boolean variables A,B,C,D,E with values in {T, F, U}. Constraints: (A ∧ B) → C, (B ∨ D) → E, (¬E) → (A ∨ C), (D → ¬A). Is there an assignment with at least one U such that none of the constraints evaluates to F under Kleene three-valued logic? Provide an incremental 3-valued backtracking propagation approach and a concrete satisfying valuation?","answer":"Yes. For example A=U, B=T, C=U, D=F, E=T yields all constraints non-F: (A∧B)→C evaluates to U, the others to T. Propagate with Kleene ¬/∧/∨ and derive implications via ¬P ∨ Q, building a constraint gr","explanation":"## Why This Is Asked\nThis probes practical 3-valued constraint solving with implications, testing both semantic understanding and algorithmic approach.\n\n## Key Concepts\n- Kleene three-valued logic: values T>U>F; implication ¬P ∨ Q; backtracking propagation; constraint graphs.\n- Incremental propagation with unknowns and short-circuit effects.\n\n## Code Example\n```javascript\n// Pseudo-solver sketch: propagate(state, constraint) -> newState\n```\n\n## Follow-up Questions\n- How does your approach scale with n variables and m constraints?\n- How would you handle cyclic dependencies and inconsistent U-only constraints?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","NVIDIA","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T16:04:53.443Z","createdAt":"2026-01-27T16:04:53.443Z"},{"id":"q-828","question":"Scenario: a feature-flag set uses four booleans A,B,C,D with rollout statuses True, False, Unknown (U). Constraints: (A → B), (C ∨ D), (A ∨ C), (B → ¬D). Is there a satisfying assignment allowing Unknowns? Explain reasoning and outline a backtracking approach using 3-valued logic to propagate U and verify arbitrary such constraint sets?","answer":"Yes. One satisfying assignment: A=False, B=True, C=True, D=False. Check: A→B true (A false); C∨D true; A∨C true; B→¬D true since D is False. For 3-valued search, start with all U, apply constraint-bas","explanation":"## Why This Is Asked\nTests handling of 3-valued logic in constraint systems common to feature gating, with practical backtracking and propagation strategies.\n\n## Key Concepts\n- Three-valued logic (True/False/Unknown) in Horn-like constraints\n- Constraint propagation and backtracking\n- Non-deterministic value assignment during rollout\n\n## Code Example\n```javascript\n// pseudocode: backtracking with U\nfunction sat3(vars, constraints) { /* ... */ }\n```\n\n## Follow-up Questions\n- How would you extend to more variables with cycles?\n- How do you optimize propagation for large constraint sets?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","MongoDB","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T12:41:11.362Z","createdAt":"2026-01-12T12:41:11.362Z"},{"id":"q-8401","question":"In a GPU shader optimization pass, four IR nodes N1..N4 have states in {True, False, Unknown} represented as {T, F, U}. Constraints: (N1 ∧ N2) → N3, (N3 ∨ N4) → N1, (¬N2) → (N1 ∨ N4). Is there an assignment with at least one Unknown such that none of the constraints evaluates to False? Outline a 3-valued backtracking approach to verify arbitrary such rule sets and give one concrete satisfying assignment?","answer":"Yes. For example: N1=U, N2=U, N3=T, N4=F. Under this assignment: (N1∧N2)→N3 evaluates to U, (N3∨N4)→N1 evaluates to U, and (¬N2)→(N1∨N4) evaluates to U. No constraint evaluates to False and at least one Unknown state exists. A 3-valued backtracking algorithm propagates Unknown values through implications, only failing to find a solution when all constraint propagation paths lead to contradictions.","explanation":"## Why This Is Asked\nThis question tests the ability to reason about 3-valued logic systems and constraint propagation in realistic compiler optimization scenarios, particularly where GPU shader optimizations must handle uncertain intermediate states.\n\n## Key Concepts\n- Kleene's 3-valued logic semantics and the nuances of implication when antecedents are Unknown\n- Backtracking propagation strategies for constraint satisfaction\n- Fixed-point iteration techniques for reaching stable states\n- Constraint encoding approaches for intermediate representation optimization\n- Methods for detecting inherently unknowable computation outcomes\n\n## Code Example\n```javascript\n// Kleene 3-valued logic helpers\nconst kleeneAnd = (a, b) => {\n  if (a === 'F' || b === 'F') return 'F';\n  if (a === 'U' || b === 'U') return 'U';\n  return 'T';\n};\n\nconst kleeneOr = (a, b) => {\n  if (a === 'T' || b === 'T') return 'T';\n  if (a === 'U' || b === 'U') return 'U';\n  return 'F';\n};\n\nconst kleeneImplies = (a, b) => {\n  if (a === 'F' || b === 'T') return 'T';\n  if (a === 'U' && b === 'F') return 'U';\n  return b;\n};\n\n// Simple constraint propagation example\nfunction propagateConstraints(nodes, constraints) {\n  let changed = true;\n  while (changed) {\n    changed = false;\n    for (const constraint of constraints) {\n      const result = evaluateConstraint(constraint, nodes);\n      if (result === 'F') return false;\n      // Update unknowns based on propagation rules\n    }\n  }\n  return true;\n}\n```\n\n## Follow-up Questions\n- How does constraint propagation efficiency change when introducing additional dependencies between variables?\n- What optimization strategies would you employ to scale this approach to systems with 10,000+ IR nodes?\n- How would you handle cyclic dependencies in the constraint graph?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","NVIDIA","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-28T04:58:03.277Z","createdAt":"2026-01-27T23:01:10.982Z"}],"subChannels":["general"],"companies":["Adobe","Airbnb","Amazon","Anthropic","Apple","Bloomberg","Citadel","Cloudflare","Coinbase","Databricks","Discord","DoorDash","Goldman Sachs","Google","Hashicorp","Hugging Face","IBM","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Netflix","OpenAI","PayPal","Plaid","Robinhood","Salesforce","Scale Ai","Slack","Snap","Snowflake","Square","Stripe","Tesla","Twitter","Two Sigma","Uber","Zoom"],"stats":{"total":88,"beginner":26,"intermediate":29,"advanced":33,"newThisWeek":40}}