{"questions":[{"id":"q-1133","question":"Scenario: a constraint-satisfaction problem with four tasks A,B,C,D each can be in domains {Pending, Running, Done}. Constraints: (A = Done) → (B = Running); (B = Running) → (C = Done); (C = Pending) → (D = Running); and (A = Pending) ∨ (D = Done). Is there a feasible assignment with at least one Running? Explain reasoning and outline a backtracking algorithm with forward-checking and 3-valued propagation to decide arbitrary such constraint sets?","answer":"Yes. Example: A=Done, B=Running, C=Done, D=Done satisfies all constraints and uses at least one Running. A=Done implies B=Running; B=Running implies C=Done; C≠Pending avoids the third rule; D=Done sat","explanation":"## Why This Is Asked\nTests ability to model tri-state CSPs with implications and a simple propagation strategy.\n\n## Key Concepts\n- Tri-state domains; constraint propagation; forward-checking; simple arc-consistency.\n- Handling conditional constraints like X=Done → Y=Running.\n\n## Code Example\n```javascript\n// minimal constraint-checker and backtracker skeleton\n```\n\n## Follow-up Questions\n- How would you extend to n variables? \n- How does you handle cycles in implications?\n","diagram":"flowchart TD\n  Start((Start))\n  ChooseVar[Choose variable with smallest domain]\n  AssignVal[Assign a domain value]\n  Propagate[Propagate constraints]\n  Conf{Conflict?}\n  Backtrack[Backtrack or fail]\n  Accept[Accept solution]\n  Start --> ChooseVar\n  ChooseVar --> AssignVal\n  AssignVal --> Propagate\n  Propagate --> Conf\n  Conf -- yes --> Backtrack\n  Conf -- no --> Accept\n  Backtrack --> ChooseVar","difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Lyft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T01:24:07.311Z","createdAt":"2026-01-13T01:24:07.311Z"},{"id":"q-1253","question":"Scenario: A deployment feature-flag policy defines three booleans F1, F2, F3 with these constraints: F1 -> F2, F2 -> F3, and exactly one of F1 and F3 is true, plus at least one flag is true. Is there a satisfying assignment? If yes, give one; if not, explain why. Then outline a tiny solver that encodes such constraints into a 2-SAT instance using an implication graph and SCC, with pseudocode?","answer":"Yes. A valid assignment is F1=0, F3=1, F2=0 (or 1). Check: F1->F2 is true; F2->F3 is true since F3=1; XOR true since 0≠1; at least one flag true via F3. Encoding: CNF is (¬F1 ∨ F2) ∧ (¬F2 ∨ F3) ∧ (F1 ","explanation":"## Why This Is Asked\nTests translating a small DSL of implications and XOR constraints into a 2-SAT form, then reasoning about satisfiability and a scalable solver using implication graphs and SCC.\n\n## Key Concepts\n- 2-SAT encoding\n- Implication graph and SCC\n- XOR-to-CNF transformation\n- Tarjan/Kosaraju SCC-based solver\n\n## Code Example\n```javascript\n// Pseudocode: build clauses, then run SCC to check contradictions\n```\n\n## Follow-up Questions\n- How does this scale to n flags with arbitrary XOR constraints?\n- How would you handle dynamic updates to constraints without recomputing from scratch?","diagram":"flowchart TD\n  F1[F1] --> F2[F2]\n  F2[F2] --> F3[F3]\n  XOR[XOR(F1,F3)] --> F1\n  XOR --> F3","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Meta","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T06:46:28.035Z","createdAt":"2026-01-13T06:46:28.035Z"},{"id":"q-1915","question":"You design a tiny policy engine for network ports where each port's state is Allow, Deny, or Unknown (A, D, U). Ports: 80, 443, 22, 23, 8080. Constraints: (80 → 443), (22 ∨ 23), (80 ∨ 22), (443 → ¬23). Is there an assignment with U that does not force any constraint to be definitively false? Explain how you would implement a 3-valued backtracking propagation to verify arbitrary such rule sets?","answer":"Yes. Using Kleene three-valued logic, A→B equals ¬A ∨ B with F<U<T. Propose: set 80=T, 443=U, 22=T, 23=F, 8080=T. Evaluate: 80→443: T→U = U (not false); 22∨23: T∨F = T; 80∨22: T∨T = T; 443→¬23: U→¬F =","explanation":"## Why This Is Asked\nTests ability to reason with tri-valued logic in practical rule systems, requiring concrete evaluation and a structured backtracking plan.\n\n## Key Concepts\n- 3-valued semantics (Kleene)\n- Implication as ¬A ∨ B\n- Backtracking with propagation of U\n\n## Code Example\n```javascript\nfunction phoVal(a){ /* placeholder: tri-valued logic emulation */ }\n```\n\n## Follow-up Questions\n- How would you extend to 4-valued logic with ‘Unknown but decidable’? \n- How does short-circuiting affect propagation in large rule sets?","diagram":"flowchart TD\n  A[80] --> B[443]\n  C[22] --> D[23]\n  E[80] --> F[22]\n  G[443] --> H[23]","difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","LinkedIn","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T16:59:35.366Z","createdAt":"2026-01-14T16:59:35.366Z"},{"id":"q-1930","question":"In a policy graph with rules of the form (P ∧ Q) → R, (P ∧ R) → S, and (Q ∧ S) → T, plus a set of base facts that you may set to true as needed, is there an assignment making T true without violating any rule? Provide an algorithm to compute a minimal witness (smallest base set) and apply it to this instance to show T is derivable with base facts {P, Q}?","answer":"Yes. With base facts P and Q true, R becomes true via (P ∧ Q) → R; then S via (P ∧ R) → S; then T via (Q ∧ S) → T. A minimal witness is {P, Q}. The algorithm uses forward-chaining with a small DFS/BFS","explanation":"## Why This Is Asked\n\nTo evaluate ability to design minimal-witness solvers for Horn-like rules and detect derivability with backtracking.\n\n## Key Concepts\n\n- Horn clauses\n- Minimal witness extraction\n- Forward-chaining with backtracking\n- Cycle detection in derivations\n\n## Code Example\n\n```javascript\n// simple forward-chaining for (A∧B)→C rules\nfunction canDerive(target, base, rules){\n  const derived = new Set(base);\n  let changed = true;\n  while (changed) {\n    changed = false;\n    for (const [A,B,C] of rules){\n      if (derived.has(A) && derived.has(B) && !derived.has(C)){\n        derived.add(C);\n        changed = true;\n      }\n    }\n  }\n  return derived.has(target);\n}\n```\n\n## Follow-up Questions\n\n- How would you extend to arbitrary antecedent sizes or negative literals?\n- How would you enumerate all minimal witnesses or detect unsatisfiable cycles in large graphs?","diagram":"flowchart TD\n  P(Base: P) --> R(R derived)\n  Q(Base: Q) --> R\n  R --> S\n  S --> T","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Databricks","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T17:45:24.925Z","createdAt":"2026-01-14T17:45:24.925Z"},{"id":"q-2088","question":"You manage access flags as a directed graph with A ≤ B meaning 'A true implies B true'. Given a required set T of flags that must be true, decide if a consistent assignment exists and produce the least-true model containing T. Describe a linear-time forward-closure algorithm that propagates truth along edges until a fixpoint, and how it handles cycles. Include a concrete 6-flag example with 7 relations?","answer":"Initialize a queue with the required set T and mark all flags in T as true. While the queue is not empty, pop a flag x and for each outgoing edge x→y, if y is not yet true, mark it as true and push y onto the queue. After propagation terminates, the true set represents the least upward-closed model containing T. This algorithm runs in O(V + E) time and handles cycles naturally: when a cycle is encountered, each flag is processed at most once, and the algorithm still produces the correct fixed-point.","explanation":"## Why This Is Asked\nTests understanding of graph reachability and fixed-point semantics in logical implications, with practical applications in policy and permission systems.\n\n## Key Concepts\n- Upward-closure in partially ordered sets\n- Fixed-point computation via forward-closure\n- Linear-time graph traversal algorithms\n- Cycle handling through visited state management\n\n## Code Example\n```javascript\nfunction propagate(T, edges) {\n  const trueSet = new Set(T);\n  const queue = [...T];\n  const adjacency = new Map();\n  \n  for (const [a, b] of edges) {\n    if (!adjacency.has(a)) adjacency.set(a, []);\n    adjacency.get(a).push(b);\n  }\n  \n  while (queue.length > 0) {\n    const x = queue.shift();\n    for (const y of adjacency.get(x) || []) {\n      if (!trueSet.has(y)) {\n        trueSet.add(y);\n        queue.push(y);\n      }\n    }\n  }\n  \n  return trueSet;\n}\n```\n\n## Example\nConsider flags {A,B,C,D,E,F} with relations: A→B, B→C, C→A (cycle), A→D, D→E, E→F, B→F. If T={A}, propagation yields {A,B,C,D,E,F} as the least model containing T.","diagram":null,"difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Goldman Sachs","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T05:03:46.198Z","createdAt":"2026-01-14T23:39:30.930Z"},{"id":"q-2194","question":"Given a finite Kripke model M = (W, {R_a, R_b}, V) with W = {w1,w2,w3}, agents a,b, and a proposition p with V(p) = {w1,w2}. After a public announcement of p, compute the updated model M|p and determine which worlds satisfy K_a p and K_b p. Then describe a linear-time algorithm using product update and forward closure to handle arbitrary finite models and sequences of announcements, including a small 3-world example to illustrate the steps?","answer":"Use public announcement logic: update M to M|p by discarding worlds not in V(p) and restricting R_i to surviving worlds. Then Ki p holds in w iff every w' with w R_i w' satisfies p in M|p. In the 3-wo","explanation":"## Why This Is Asked\nTests ability to apply public announcements to epistemic models and design a practical solver that scales with model size.\n\n## Key Concepts\n- Kripke models and accessibility relations\n- Public announcements and product update\n- Knowledge operator Ki and post-update evaluation\n- Linear-time propagation and fixpoint reasoning\n\n## Code Example\n```javascript\n// Minimal representation and product update sketch\nfunction productUpdate(W, relations, V, pSet) {\n  const Wp = W.filter(w => pSet.has(w));\n  const Rp = {};\n  for (const [AG, rel] of Object.entries(relations)) {\n    Rp[AG] = new Map();\n    for (const w of Wp) {\n      Rp[AG].set(w, rel.get(w).filter(v => pSet.has(v)));\n    }\n  }\n  return { W: Wp, relations: Rp };\n}\n\nfunction knows(pSet, w, agentRel) {\n  const targets = agentRel.get(w) || [];\n  return targets.every(u => pSet.has(u));\n}\n``` \n\n## Follow-up Questions\n- How to extend to more agents or multi-modal knowledge (common knowledge)?\n- How would you optimize for many sequential announcements or large models?\n- What are potential numerical issues with non-deterministic updates in practice?","diagram":"flowchart TD\n  A[Worlds W] -->|R_a| B[W1, W2, W3]\n  A -->|R_b| C[Edges per agent]\n  D{Announce p?}\n  D -->|Yes| E[M|p: remove non-p worlds]\n  E --> F[Evaluate Ki p on M|p]\n  F --> G[Update knowledge for each w]\n  G --> H[Scales to sequences of announcements]","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Instacart","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T07:02:41.111Z","createdAt":"2026-01-15T07:02:41.111Z"},{"id":"q-2286","question":"Design a solver for booleans with two constraint types: XOR constraints (subset S XOR = b) and at-least-k constraints on subsets. How would you decide satisfiability efficiently, encode the mix for a practical solver, and handle contradictions and scalability?","answer":"Model XOR constraints as a GF(2) linear system Ax = b. Encode at-least-k by introducing slack booleans and a CNF or linear encoding. Solve with sparse Gaussian elimination, then verify at-least constr","explanation":"## Why This Is Asked\nThis question probes the candidate's ability to combine algebraic reasoning (GF(2)) with combinatorial SAT techniques, and to design a solver architecture that scales with constraints. It tests encoding decisions, data structures (sparse matrices), and how to expose contradictions early.\n\n## Key Concepts\n- GF(2) linear algebra\n- Slack-variable encodings for at-least\n- Sparse Gaussian elimination\n- Constraint propagation and unsat witnesses\n\n## Code Example\n```\n// Pseudocode: assemble matrix A, vector b; run elimination; derive x; verify constraints\n```\n\n## Follow-up Questions\n- How would you extend to dynamic constraint streams?\n- How to optimize memory for very large x?","diagram":"flowchart TD\n  S[Parse constraints] --> E[Translate XORs to GF(2) system]\n  E --> L[Extend with slack vars for at-least constraints]\n  L --> SOL[Solve with sparse Gauss + LP-like check]\n  SOL --> V[Return solution or UNSAT]","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Instacart","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T10:46:41.704Z","createdAt":"2026-01-15T10:46:41.704Z"},{"id":"q-2441","question":"In a 3-valued logic with T, F, U, build a tiny circuit: inputs A, B, C; gates: G1 = A AND B; G2 = B OR C; G3 = NOT G1; G4 = G2 AND G3. Is there an assignment to (A, B, C) using U that yields G4 = U after standard Kleene-style tables? Explain how you would implement a small propagator to verify arbitrary such circuits?","answer":"Yes. Set A=B=C=U. Then G1 = U AND U = U; G2 = U OR U = U; G3 = NOT U = U; G4 = U AND U = U. To verify arbitrary circuits, implement a fixed-point propagator: maintain a worklist of gates, apply 3-valu","explanation":"## Why This Is Asked\nTests practical understanding of Kleene three-valued logic and how to implement a propagator for arbitrary circuits, a common check in hardware simulators and policy engines.\n\n## Key Concepts\n- Three-valued logic (T, F, U) and Kleene tables\n- Propagation with fixed-point iteration\n- Handling cycles in DAG vs. cyclic graphs\n\n## Code Example\n```javascript\nfunction kleeneAnd(a,b){ if(a===false || b===false) return false; if(a===true && b===true) return true; return 'U'; }\nfunction kleeneOr(a,b){ if(a===true || b===true) return true; if(a===false && b===false) return false; return 'U'; }\nfunction kleeneNot(a){ if(a===true) return false; if(a===false) return true; return 'U'; }\n```\n\n## Follow-up Questions\n- How would you scale this to circuits with hundreds of gates?\n- How would you extend to more truth values or probabilistic states?","diagram":"flowchart TD\n  A[A] --> G1[G1 = A AND B]\n  B[B] --> G1\n  B --> G2[G2 = B OR C]\n  C[C] --> G2\n  G1 --> G3[NOT G1]\n  G2 --> G4[G4 = G2 AND G3]\n  G3 --> G4","difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","NVIDIA","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T17:58:51.134Z","createdAt":"2026-01-15T17:58:51.134Z"},{"id":"q-2496","question":"Scenario: four attributes X,Y,Z,W take values 0,1, or U. Constraints: X+Y ≥ 1, Y ≥ Z, Z+W ≥ 1, W ≤ X. Is there an assignment that uses U for at least one variable while satisfying all constraints? Outline a straightforward 3-valued propagation plus backtracking to verify arbitrary such constraint sets?","answer":"Yes. Model X,Y,Z,W ∈ {0,1,U}. Use 3-valued propagation: tighten domains per constraint (e.g., X+Y≥1 excludes X=0 and Y=0; Z+W≥1 excludes Z=0 and W=0; W≤X bans W=1 if X=0). Then backtrack on U, trying ","explanation":"## Why This Is Asked\nTests ability to design a tiny constraint solver using 3-valued logic and backtracking, with a concrete, solvable example.\n\n## Key Concepts\n- 3-valued propagation\n- Domain narrowing for inequalities\n- Backtracking search\n- Early pruning and consistency checks\n\n## Code Example\n```javascript\n// Pseudocode for propagation and backtracking\n```\n## Follow-up Questions\n- How would you extend to non-linear constraints?\n- How does propagation complexity grow with variables?","diagram":"flowchart TD\n  X[X] -->|≥1| Y[Y]\n  Y -->|≥Z| Z[Z]\n  Z -->|≥1| W[W]\n  W -->|≤| X2[X]\n","difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Meta","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T20:37:09.469Z","createdAt":"2026-01-15T20:37:09.470Z"},{"id":"q-2696","question":"Design a tiny policy-engine puzzle: There are flags F1..F5 taking values Enable (E), Disable (D), or Unknown (U). Constraints:\n- If F1 is E then F2 is E.\n- If F2 is D then F3 is D.\n- If F4 is E then F5 is E.\n- At least one of F1 or F3 must be E unless F5 is D.\n- F3 cannot be E if F4 is D.\nIs there an assignment that uses U for at least one flag and satisfies all constraints? Propose a 3-valued propagation with backtracking approach and apply it to the concrete instantiation: F1=U, F2=U, F3=U, F4=D, F5=U; determine feasibility?","answer":"Yes. Example: F1=E, F2=E, F3=D, F4=D, F5=U satisfies all constraints and uses U. F1→F2 triggers F2=E; F1=E keeps F2 consistent; F4=D forbids F3=E; F5≠D requires F1 or F3=E, with F1=E this is satisfied","explanation":"## Why This Is Asked\nEvaluates ability to reason with partial information and implement a practical 3-valued constraint propagator with backtracking for policy-like rules.\n\n## Key Concepts\n- 3-valued logic propagation (E, D, U)\n- implication and unless-style constraints\n- backtracking with pruning on Unknowns\n\n## Code Example\n```javascript\n// Pseudo-propagation skeleton for 3-valued constraints\nfunction propagate(assign, rules) {\n  // rules: [{type:'imp', if: {F1:'E'}, then:{F2:'E'}}, ...]\n  // returns whether a satisfiable extension exists and updated assign\n}\n```\n\n## Follow-up Questions\n- How to detect cycles that force contradictions?\n- How to scale the approach to thousands of flags and complex constraints?","diagram":"flowchart TD\n  F1[E] --> F2[E]\n  F2[D] --> F3[D]\n  F4[E] --> F5[E]\n  F5 -->|not D| F1\n  subgraph Constraints\n  end","difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Slack","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T07:33:07.312Z","createdAt":"2026-01-16T07:33:07.312Z"},{"id":"q-3078","question":"You model a SQL-like WHERE clause with 4 predicates A,B,C,D each taking values TRUE, FALSE, or UNKNOWN. The formula is F = (A OR NOT B) AND (C XOR D). Is there an assignment that uses at least one UNKNOWN and makes F evaluate to TRUE under Kleene three-valued logic? Outline a concrete 3-valued propagation algorithm and a backtracking strategy to verify arbitrary such constraints?","answer":"Yes. For variables A, B, C, D ∈ {TRUE, FALSE, UNKNOWN}, the formula F = (A OR NOT B) AND (C XOR D) evaluates to TRUE with the assignment A = UNKNOWN, B = FALSE, C = TRUE, D = FALSE. Under Kleene's three-valued logic: NOT B = TRUE, so A OR NOT B = TRUE; and C XOR D = TRUE XOR FALSE = TRUE. Therefore, F = TRUE ∧ TRUE = TRUE, satisfying the requirement of using at least one UNKNOWN while making the formula evaluate to TRUE.","explanation":"## Why This Is Asked\n\nThis question evaluates the candidate's understanding of three-valued logic as implemented in SQL systems, where NULL values introduce UNKNOWN states that must propagate through logical expressions according to Kleene's truth tables.\n\n## Key Concepts\n\n- **Kleene Three-Valued Logic**: Extends classical logic with UNKNOWN (U) to handle missing/NULL data\n- **Truth Table Propagation**: Systematic application of Kleene's rules to reduce variable domains\n- **Constraint Propagation**: Forward checking algorithm that prunes inconsistent value assignments\n- **Backtracking Strategy**: Search with domain reduction and early failure detection\n\n## Algorithm Implementation\n\n```javascript\n// Kleene truth table operations\nfunction kleeneNot(x) { \n  return x === 'T' ? 'F' : x === 'F' ? 'T' : 'U';\n}\n\nfunction kleeneOr(a, b) {\n  if (a === 'T' || b === 'T') return 'T';\n  if (a === 'F' && b === 'F') return 'F';\n  return 'U';\n}\n\nfunction kleeneAnd(a, b) {\n  if (a === 'F' || b === 'F') return 'F';\n  if (a === 'T' && b === 'T') return 'T';\n  return 'U';\n}\n\nfunction kleeneXor(a, b) {\n  return kleeneOr(kleeneAnd(a, kleeneNot(b)), kleeneAnd(kleeneNot(a), b));\n}\n\n// Constraint propagation with backtracking\nfunction propagate(variables, targetValue) {\n  const domains = Object.keys(variables).reduce((acc, key) => {\n    acc[key] = ['T', 'F', 'U'];\n    return acc;\n  }, {});\n  \n  function backtrack() {\n    const unassigned = Object.keys(domains).filter(k => domains[k].length > 1);\n    if (!unassigned.length) {\n      const result = evaluateFormula(domains);\n      return result === targetValue;\n    }\n    \n    const varName = unassigned[0];\n    for (const value of domains[varName]) {\n      const savedDomains = JSON.parse(JSON.stringify(domains));\n      domains[varName] = [value];\n      \n      if (forwardCheck() && backtrack()) return true;\n      \n      Object.assign(domains, savedDomains);\n    }\n    return false;\n  }\n  \n  function forwardCheck() {\n    // Apply Kleene constraints to reduce inconsistent domains\n    return true; // Implement domain reduction logic\n  }\n  \n  function evaluateFormula(domains) {\n    const A = domains.A[0], B = domains.B[0];\n    const C = domains.C[0], D = domains.D[0];\n    const left = kleeneOr(A, kleeneNot(B));\n    const right = kleeneXor(C, D);\n    return kleeneAnd(left, right);\n  }\n  \n  return backtrack();\n}\n```\n\nThis approach systematically explores the search space while leveraging Kleene's logical rules to prune inconsistent assignments early, ensuring efficient constraint satisfaction in three-valued logic contexts.","diagram":"flowchart TD\n  Q[Query model] --> P[Propagate with Kleene tables]\n  P --> C[Prune domains]\n  C --> A[Accept / Backtrack]\n  A --> Q","difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Goldman Sachs","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T05:12:32.066Z","createdAt":"2026-01-16T23:46:48.399Z"},{"id":"q-3166","question":"You maintain a tiny 3-valued data-validation rule engine. Variables X, Y, Z, W take values True, False, Unknown. Constraints: (X OR Y) AND (X AND Z) -> W AND (W OR Z) is True. Is there an assignment with at least one Unknown that makes the whole formula True? Provide a concrete assignment and concise justification?","answer":"Yes. Example: X = U, Y = T, Z = F, W = T. Evaluate: X OR Y = T; X AND Z = U AND F = F; (X AND Z) -> W = T; W OR Z = T. All subexpressions evaluate to True, and X remains Unknown, satisfying the condit","explanation":"## Why This Is Asked\nTests ability to reason with Kleene-style 3-valued logic and design tiny propagators for constraint sets.\n\n## Key Concepts\n- 3-valued logic (True, False, Unknown)\n- Kleene-style truth tables\n- Satisfiability with Unknowns and propagation\n\n## Code Example\n```javascript\n// simple evaluator sketch\nfunction not3(v){ return v=== 'T' ? 'F' : v==='F' ? 'T' : 'U'; }\nfunction or3(a,b){ if(a==='T' || b==='T') return 'T'; if(a==='F' && b==='F') return 'F'; return 'U'; }\nfunction and3(a,b){ if(a==='F' || b==='F') return 'F'; if(a==='T' && b==='T') return 'T'; return 'U'; }\nfunction imp3(a,b){ // a -> b  is (!a) OR b\n  const na = not3(a); if(na==='T' && b==='F') return 'F'; if(na==='T') return b; if(na==='F') return 'T'; return 'U'; }\n```\n\n## Follow-up Questions\n- How would you implement a propagator to handle larger rule sets?\n- How does short-circuiting affect unknown propagation in practice?","diagram":null,"difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T05:31:36.212Z","createdAt":"2026-01-17T05:31:36.212Z"},{"id":"q-3247","question":"Given a directed graph where each node i has a threshold t_i (0 ≤ t_i ≤ indeg(i)) and a node is true iff at least t_i of its in-neighbors are true, does there exist a fixed point S containing a specified T? If yes, compute the least such fixed point. Outline a linear-time propagation algorithm that handles cycles and illustrate with a concrete 6-node, 7-edge example?","answer":"Start with S = T. Maintain count[v] = number of in-neighbors of v in S. Initialize with T, queue them. When you pop u, for each v in succ(u), increment count[v]; if count[v] ≥ t_v and v ∉ S, add v to ","explanation":"## Why This Is Asked\nTests understanding of least fixed-point computation in monotone boolean networks with thresholds and how to implement an efficient propagation algorithm that converges even with cycles.\n\n## Key Concepts\n- Monotone operators and least fixed points\n- Threshold-based activation with in-neighbor counting\n- Queue-driven BFS-like propagation\n- Handling cycles via convergence to a fixpoint\n\n## Code Example\n```javascript\n// Pseudo-implementation of the propagation\nfunction leastFixedPoint(T, edges, thresh) {\n  const n = thresh.length;\n  const succ = Array.from({length: n}, () => []);\n  for (const [u,v] of edges) succ[u].push(v);\n  const count = Array(n).fill(0);\n  const inSet = Array(n).fill(false);\n  const q = [];\n  for (const i of T) { inSet[i] = true; q.push(i); }\n  while (q.length) {\n    const u = q.shift();\n    for (const v of succ[u]) {\n      count[v]++;\n      if (!inSet[v] && count[v] >= thresh[v]) {\n        inSet[v] = true;\n        q.push(v);\n      }\n    }\n  }\n  return Array.from({length: n}, (_,i) => i).filter(i => inSet[i]);\n}\n```\n\n## Follow-up Questions\n- How would you adapt for weighted thresholds or non-monotone edges?\n- How would you prove the result is the least fixed point containing T?","diagram":"flowchart TD\n  A[Nodes A-F] --> B[Edge A->B]\n  A --> C[Edge A->C]\n  B --> D[D node]\n  C --> D\n  D --> E\n  E --> F\n  F --> D","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T08:42:43.337Z","createdAt":"2026-01-17T08:42:43.337Z"},{"id":"q-3329","question":"Given N boolean flags X1..XN and constraints Xi XOR Xj = c (c in {0,1}) and optional fixed Xi = di, determine if the system is consistent and output a model with the minimum number of true flags. Describe a linear-time algorithm to check consistency, derive per-component solutions, and pick root values to minimize total true bits. For a concrete 5-flag example with 6 constraints, what is the minimum-weight solution?","answer":"Build a graph with edges i-j labeled c for Xi XOR Xj = c and mark fixed nodes Xi = di. For each connected component, compute dist[i] by DFS: Xi = Xroot XOR dist[i]. If a cycle yields inconsistent dist","explanation":"## Why This Is Asked\n\nTests ability to model XOR constraints as graph edges, detect cycle inconsistencies, and design a linear-time minimization of a solution under free roots. Combines graph algorithms with a small amount of linear algebra over GF(2) and a practical optimization goal.\n\n## Key Concepts\n\n- XOR constraints on pairs -> edge-labeled graph\n- Cycle parity consistency\n- Component-wise root assignment and fixed-node propagation\n- Minimizing Hamming weight under linear constraints\n\n## Code Example\n\n```javascript\n// Pseudo-implementation sketch (not complete)\nfunction minWeightXor(n, edges, fixed){\n  // build graph, DFS to compute dist and check consistency\n  // if fixed, deduce root; else pick root to minimize weight\n}\n```\n\n## Follow-up Questions\n\n- How would you handle additional constraints Xi = NOT Xj?\n- How to extend to handle weighted costs or non-binary states?","diagram":"flowchart TD\n  A[Build constraint graph: edges Xi XOR Xj = c, optional Xi = di]\n  B[Check cycle consistency by dist parity]\n  C[Apply fixed-node constraints to deduce root]\n  D[If no fixed root, compute weights for root 0/1]\n  E[Assemble final minimum-weight solution]\n  F[Return infeasible if inconsistency]\n\n  A --> B\n  B --> C\n  C --> D\n  D --> E\n  E --> F","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Discord","LinkedIn"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T11:36:45.152Z","createdAt":"2026-01-17T11:36:45.152Z"},{"id":"q-3355","question":"In a tiny 3-valued dataflow analysis with values {T, F, U}, given SSA vars B, C, E (inputs) and derived A = B AND C; D = NOT E; F = D OR A. Is there a choice of B, C, E from {T, F, U} such that after Kleene-style propagation to a fixpoint, F evaluates to U? Explain the propagation steps and a succinct algorithm to verify arbitrary such sets?","answer":"Yes. Take B=U, C=T, E=U. Then A=U∧T=U; D=¬U=U; F=U∨U=U. A worklist-based fixpoint with Kleene truth tables (NOT, AND, OR) propagates until no change. This demonstrates existence and provides a scalabl","explanation":"## Why This Is Asked\nTests 3-valued dataflow reasoning, fixpoint propagation, and translating logic into a workable algorithm.\n\n## Key Concepts\n- Kleene three-valued logic (T, F, U)\n- Worklist/fixpoint propagation\n- Dataflow dependency graphs\n- Handling cycles and convergence\n\n## Code Example\n```javascript\n// Kleene 3-valued logic\nconst T = true, F = false, U = 'U';\nfunction not(x){ if (x===T) return F; if (x===F) return T; return U; }\nfunction and(a,b){ if (a===F || b===F) return F; if (a===T && b===T) return T; return U; }\nfunction or(a,b){ if (a===T || b===T) return T; if (a===F && b===F) return F; return U; }\n\n// program: A = B AND C; D = NOT E; F = D OR A\nlet B = U, C = T, E = U;\nlet A = and(B, C);\nlet D = not(E);\nlet F = or(D, A);\n```\n\n## Follow-up Questions\n- How would you extend to cycles and determine worst-case iterations?\n- How would you optimize for sparse graphs and pruning impossible combinations?","diagram":"flowchart TD\n  B[Input: B] --> A[A = B AND C]\n  C[Input: C] --> A\n  E[Input: E] --> D[D = NOT E]\n  A --> F[F = D OR A]\n  D --> F","difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Scale Ai","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T13:12:10.843Z","createdAt":"2026-01-17T13:12:10.843Z"},{"id":"q-3607","question":"Design a tiny policy engine for a microservice access rule set in 3-valued logic (T, F, U). Variables A,B,C,D ∈ {T,F,U}. Constraints: (A ∧ B) → D; (¬A ∨ C) → D; (D ∧ ¬C) → A. Is there an assignment to (A,B,C,D) using U that does not force any constraint to be definitively false? Explain propagation steps and outline an algorithm to verify arbitrary such rule sets?","answer":"Yes. One valid assignment is A=U, B=F, C=U, D=U. Under Kleene's three-valued logic (¬U=U, F∧x=F, T∧x=x, etc.), the constraints evaluate as follows: 1) A∧B = F, and F→D = T; 2) ¬A∨C = U, and U→D = U; 3) D∧¬C = U, and U→A = U. None of the constraints evaluates to false. A tri-valued propagator iteratively applies constraint rules until reaching a fixpoint, using Kleene semantics to handle unknown values.","explanation":"## Why This Is Asked\nThis question tests the ability to reason with three-valued semantics in policy rule evaluation and to design a generic propagator for real-world constraints.\n\n## Key Concepts\n- Kleene three-valued logic semantics\n- Implication evaluation under unknown values\n- Constraint propagation mechanisms\n- Fixpoint iteration algorithms\n- Practical design patterns for policy engines\n\n## Code Example\n```javascript\n// Kleene three-valued logic implementation\nfunction not(x) { \n  if (x === 'T') return 'F'; \n  if (x === 'F') return 'T'; \n  return 'U'; \n}\n\nfunction and(x, y) { \n  if (x === 'F' || y === 'F') return 'F'; \n  if (x === 'U' || y === 'U') return 'U'; \n  return 'T'; \n}\n\nfunction or(x, y) { \n  if (x === 'T' || y === 'T') return 'T'; \n  if (x === 'U' || y === 'U') return 'U'; \n  return 'F'; \n}\n\nfunction implies(x, y) { \n  if (x === 'F') return 'T'; \n  if (x === 'U') return y === 'T' ? 'T' : 'U'; \n  return y; \n}\n\n// Constraint propagator\nfunction propagate(constraints, variables) {\n  let changed = true;\n  while (changed) {\n    changed = false;\n    for (const constraint of constraints) {\n      const result = evaluate(constraint, variables);\n      if (result === 'F') return false;\n      // Update variables based on constraint results\n      // Implementation depends on constraint type\n    }\n  }\n  return true;\n}\n```\n\n## Algorithm Outline\n1. Initialize variables with given values\n2. Iteratively apply constraints using Kleene semantics\n3. Track variable changes until fixpoint reached\n4. Return false if any constraint evaluates to false\n5. Return true with final variable assignment otherwise","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T05:28:47.370Z","createdAt":"2026-01-17T23:33:17.256Z"},{"id":"q-3685","question":"Let V be a set of boolean variables. We have Horn clauses of the form (A1 ∧ ... ∧ Ap) -> B. Each variable v has a nonnegative cost c(v) for setting it true. Given a required set T ⊆ V that must be true and a budget K, decide if there exists a model with T true and total cost ≤ K, and produce the minimum-cost model if possible. Explain a forward-chaining approach to minimize cost, handle cycles, and illustrate with a small 5-variable example showing two feasible models with different costs?","answer":"Use a forward-chaining closure over Horn clauses with costs. Start from T, maintain a min-cost true-set S; only trigger a clause (A1 ∧ ... ∧ Ap) -> B when all antecedents are in S, then add B if its c","explanation":"## Why This Is Asked\nTests ability to design a cost-aware Horn-solver, handling cycles, and producing a minimal-cost solution while respecting a budget.\n\n## Key Concepts\n- Horn clauses; forward-chaining; fixpoint\n- Cost-weighted model; budget-constrained search\n- Strongly connected components to manage cycles\n\n## Code Example\n```javascript\n// sketch of forward-chaining with costs\n```\n\n## Follow-up Questions\n- How would you prove correctness of your approach?\n- How would you extend to non-Horn clauses or multiple budgets per user?","diagram":"flowchart TD\n  Start[Start] --> Fire[Rule firing]\n  Fire --> Add[Add var to S]\n  Add --> Budget{Budget OK?}\n  Budget -- Yes --> Finish[Finish]\n  Budget -- No --> Stop[Stop]\n  Fire --> Cycle[Handle cycles]\\nvia SCC condensation","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Netflix","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T05:36:35.982Z","createdAt":"2026-01-18T05:36:35.982Z"},{"id":"q-3801","question":"Scenario: Build a tiny constraint solver for four gates Ship1..Ship4 in 3-valued logic (T, F, U). Constraints: (Ship1 ∧ Ship2) → Ship3; Ship2 ∨ Ship4; Ship1 ∨ ¬Ship3; Ship4 → ¬Ship1. Is there an assignment using U that does not force any constraint to be false? Propose a 3-valued backtracking propagation approach to verify arbitrary such rule sets?","answer":"Yes. A safe assignment: Ship1=U, Ship2=T, Ship3=U, Ship4=U. Evaluate: (Ship1∧Ship2)→Ship3 = U→U; Ship2∨Ship4 = T; Ship1∨¬Ship3 = U; Ship4→¬Ship1 = U. No constraint is false. Propagate by fixed-point: ","explanation":"## Why This Is Asked\nA practical test of applying 3-valued logic to constraint propagation in a tiny engine, with cycles and mixed truths.\n\n## Key Concepts\n- 3-valued logic (T, F, U)\n- Kleene semantics for NOT/AND/OR\n- Constraint propagation and fixpoint\n- Backtracking verification for arbitrary sets\n\n## Code Example\n```javascript\nfunction not(v){ return v===\"T\"?\"F\": v===\"F\"?\"T\":\"U\"; }\nfunction and(a,b){ if(a===\"F\"||b===\"F\") return \"F\"; if(a===\"T\"&&b===\"T\") return \"T\"; return \"U\"; }\n```\n\n## Follow-up Questions\n- How to scale to dozens of vars?\n- What optimizations for convergence? \n- How to detect inevitable F under inconsistent constraints?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","DoorDash","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T10:30:22.338Z","createdAt":"2026-01-18T10:30:22.338Z"},{"id":"q-3850","question":"Scenario: A tiny policy engine uses four predicates P,Q,R,S ∈ {T, F, U} with Kleene three-valued logic. Constraints: P ∨ Q = T; R ∧ S = F; P → R = T; Q → S = F. Is there an assignment that includes at least one U and that makes all constraints evaluate as required? Explain a simple 3-valued propagation approach to verify arbitrary such rule sets?","answer":"Yes. Example: P=U, Q=T, R=T, S=F. Then P ∨ Q = T due to Q; R ∧ S = F since S=F; P → R = T because ¬P ∨ R yields U ∨ T = T; Q → S = F since T → F = F. A 3-valued propagator uses Kleene truth tables, pr","explanation":"## Why This Is Asked\n\nTests understanding of Kleene three-valued logic through small, concrete constraints and requires applying a propagation-based approach to tri-valued SAT problems.\n\n## Key Concepts\n\n- Kleene three-valued logic (T, F, U)\n- Implication with U\n- 3-valued constraint propagation\n\n## Code Example\n\n```javascript\nfunction not(x){ return x=== 'T' ? 'F' : x==='F' ? 'T' : 'U'; }\nfunction or(a,b){ if(a==='T' || b==='T') return 'T'; if(a==='F' && b==='F') return 'F'; return 'U'; }\n```\n\n## Follow-up Questions\n\n- How would you extend to 5 predicates with cycles?\n- How would you implement a fixed-point propagator for arbitrary constraints?","diagram":null,"difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Discord","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T12:56:36.892Z","createdAt":"2026-01-18T12:56:36.893Z"},{"id":"q-683","question":"You're managing a streaming DAG with tasks A,B,C,D; edges enforce: A before B; B before C; at most one of C or D can occur in a window of size H. Given a log of events with timestamps per task, implement an O(n log n) verifier to determine if the log is valid under these constraints and describe how you'd extend to multiple windows in a distributed system?","answer":"Sort events by timestamp; maintain last_seen per task; when seeing B, require A has appeared earlier; when C arrives, require B seen within H time; when D arrives, ensure C did not occur in the same w","explanation":"## Why This Is Asked\n\nTests ability to reason about temporal constraints in streaming DAGs and develop an efficient log validation algorithm.\n\n## Key Concepts\n\n- Temporal constraints and causal ordering\n- Sliding window validation\n- O(n log n) sorting and O(1) per-event checks\n- Edge cases: missing prerequisites, mutual exclusion\n\n## Code Example\n\n```javascript\nfunction validLog(events, H) {\n  // events: {task: 'A', t: 0}, ...\n  // naive sketch\n  // sort by t\n  // track last window start, last times\n  // enforce A before B, B before C within H, and at most one of C/D in a window\n}\n```\n\n## Follow-up Questions\n\n- How would you scale to thousands of tasks and multiple horizons?\n- How would clock skew affect correctness and what mitigations exist?","diagram":null,"difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-11T15:58:57.063Z","createdAt":"2026-01-11T15:58:57.063Z"},{"id":"q-685","question":"Context: In a data-cleaning pipeline, records have boolean attributes a, b, c, d. Rules are Horn clauses of the form X ∧ Y -> Z. Given a partial assignment, decide if a full assignment exists that satisfies all clauses. Design a linear-time forward-chaining solver, justify its correctness, and discuss incremental updates and cycles with a concrete four-variable example (two rules)?","answer":"Forward-chaining Horn-SAT solver. Maintain a set of known-true literals and a queue of rules whose antecedents are all true; fire their consequents to mark new truths. If a rule implies a literal alre","explanation":"## Why This Is Asked\nTo gauge practical reasoning about logic constraints, Horn-SAT familiarity, and ability to reason about linear-time algorithms and incremental updates in data pipelines.\n\n## Key Concepts\n- Horn clauses\n- Forward chaining\n- Partial vs full assignments\n- Complexity O(n+m)\n- Cycle handling and inconsistency detection\n\n## Code Example\n```javascript\nfunction solveHorn(rules, facts){\n  const trueSet = new Set(facts);\n  let queue = rules.filter(r => r.antecedent.every(v => trueSet.has(v)));\n  while (queue.length){\n    const r = queue.shift();\n    if (!trueSet.has(r.consequent)){\n      trueSet.add(r.consequent);\n      queue = rules.filter(x => x.antecedent.every(v => trueSet.has(v)) && !trueSet.has(x.consequent));\n    }\n  }\n  return trueSet;\n}\n```\n\n## Follow-up Questions\n- How would you extend to non-Horn clauses?\n- How would you handle incremental updates when facts change?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Databricks","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-11T16:21:38.487Z","createdAt":"2026-01-11T16:21:38.487Z"},{"id":"q-699","question":"You have a Horn-clauses policy language for access control. Given the following rules and facts, determine if allow(alice,read,records) is entailed using forward-chaining to a least fixpoint. Rules: 1) grant(U,act,res) :- haveRole(U,R), privilege(R,act,res). 2) allow(U,act,res) :- grant(U,act,res). Facts: haveRole(alice,dataEngineer). privilege(dataEngineer,read,records). Show your derivation steps?","answer":"Yes. Forward-chaining yields grant(alice,read,records) from haveRole(alice,dataEngineer) and privilege(dataEngineer,read,records) via grant(U,act,res). Then allow(alice,read,records) follows from allo","explanation":"## Why This Is Asked\nTests understanding of Horn clauses, forward-chaining, and least-fixpoint semantics in practical policy reasoning.\n\n## Key Concepts\n- Horn clauses\n- Forward-chaining\n- Least fixpoint\n- Complexity linear in facts and rules\n\n## Code Example\n```javascript\n// Pseudo forward-chaining:\nwhile newDerivation:\n  apply grant rule to facts\n  apply allow rule to grants\n```\n\n## Follow-up Questions\n- How would this scale with thousands of rules?\n- How would you extend to handle negation or recursion?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Databricks","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-11T17:18:31.996Z","createdAt":"2026-01-11T17:18:31.996Z"},{"id":"q-702","question":"In a home security system, three sensors—door, window, and motion—report activity as booleans a, b, c for the last minute. The alert should fire only when exactly one sensor is active. How would you implement a function that takes a, b, c and returns true iff exactly one is true, and what are its time and space complexities?","answer":"Compute the count: Number(a) + Number(b) + Number(c) and check if it equals 1. For example in JavaScript: return Number(a) + Number(b) + Number(c) === 1. This is O(1) time and O(1) space; an equivalen","explanation":"## Why This Is Asked\nTests understanding of simple boolean logic and edge cases (e.g., all true or all false) in a practical setting.\n\n## Key Concepts\n- Boolean counting\n- Short-circuit reasoning\n- Constant-time evaluation\n\n## Code Example\n```javascript\nfunction alert(a,b,c){\n  return Number(a)+Number(b)+Number(c)===1;\n}\n```\n\n## Follow-up Questions\n- How would you extend to n sensors and a threshold k?\n- How would you optimize for streaming data with sliding windows?","diagram":null,"difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-11T18:26:22.369Z","createdAt":"2026-01-11T18:26:22.369Z"},{"id":"q-715","question":"In a distributed data-processing pipeline across three services Ingest (I), Compute (C), Persist (P), each event carries a 3-element vector clock. Given E1 at I with [2,0,1] and E2 at C with [1,3,0], decide whether E1 happened-before E2, E2 happened-before E1, or they are concurrent. Explain the rule and show the comparison. How would you scale this to N services and detect concurrency in large logs?","answer":"Using vector clocks, E1 happened-before E2 if every component of E1 <= corresponding E2 and at least one is strictly less. Here [2,0,1] vs [1,3,0] has 2>1, 0<3, 1>0; not all <= or >=, so E1 || E2 (con","explanation":"## Why This Is Asked\nUnderstanding vector clocks and the happens-before relation for debugging causality in distributed systems.\n\n## Key Concepts\n- Vector clocks\n- Happens-before\n- Concurrency detection in logs\n\n## Code Example\n```javascript\nfunction compareVC(a, b) {\n  let lessEq = true, greaterEq = true;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] > b[i]) lessEq = false;\n    if (a[i] < b[i]) greaterEq = false;\n  }\n  if (lessEq && greaterEq) return 'equal';\n  if (lessEq) return 'a_before_b';\n  if (greaterEq) return 'b_before_a';\n  return 'concurrent';\n}\n```\n\n## Follow-up Questions\n- How would you integrate vector clocks with a log-aggregation system to detect causality violations?\n- What are the storage and performance implications for large-scale deployments?","diagram":null,"difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Bloomberg","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-11T19:18:20.787Z","createdAt":"2026-01-11T19:18:20.787Z"},{"id":"q-719","question":"Design a tiny solver for three boolean inputs A, B, C given constraints: (A -> B) and (B -> C) and (A or C). Is there an assignment that satisfies all three? Explain your reasoning and outline a simple backtracking approach you would implement to check arbitrary small sets of such implications?","answer":"Two assignments satisfy (A->B), (B->C), (A∨C): (0,0,1) and (1,1,1). A quick check uses the constraints: A->B true if A=0 or B=1; B->C true if B=0 or C=1; A∨C true if A=1 or C=1. A backtracking checker","explanation":"## Why This Is Asked\nEvery candidate demonstrates logic reasoning and basic constraint solving relevant to planning validations in software.\n\n## Key Concepts\n- Propositional logic and implications\n- Satisfiability with small variable sets\n- Backtracking pruning for constraints\n\n## Code Example\n```javascript\nfunction isSatisfiable(constraints) {\n  const vars = ['A','B','C'];\n  for (let a of [0,1])\n    for (let b of [0,1])\n      for (let c of [0,1]) {\n        const assign = {A:a,B:b,C:c};\n        if (constraints.every(fn => fn(assign))) return true;\n      }\n  return false;\n}\n```\n\n## Follow-up Questions\n- How would you extend to thousands of variables with CNF clauses?\n- What are the trade-offs of backtracking vs. SAT solvers in practice?","diagram":null,"difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Google","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-11T20:22:02.565Z","createdAt":"2026-01-11T20:22:02.565Z"},{"id":"q-728","question":"Scenario: You’re building a tiny policy engine for feature flags with three booleans A, B, C. Constraints: A implies B, B implies C, and at least two of the three must be true. Is there an assignment that satisfies all constraints? If so, give one example and briefly justify. Then outline a straightforward backtracking approach to enumerate all satisfying assignments for any n flags and any such constraints?","answer":"Yes. With A,B,C, A→B and B→C and at least two true, A=false,B=true,C=true works: A→B vacuously true; B→C true because C is true; two true satisfy the cardinality. Backtracking: enumerate A,B,C in {F,T","explanation":"## Why This Is Asked\n\nTests ability to reason about small logical constraints and translate them into a checkable search, including vacuous implications and cardinality.\n\n## Key Concepts\n\n- Logical implications and vacuous truth\n- Cardinality constraints (minimum true)\n- Backtracking with pruning\n- Generalizing to N variables\n\n## Code Example\n\n```javascript\nfunction countTrue(arr){ return arr.filter(x=>x).length; }\nfunction implies(p,q){ return !p || q; }\nfunction sat(assignment){\n  const [A,B,C] = assignment;\n  if(!implies(A,B)) return false;\n  if(!implies(B,C)) return false;\n  if(countTrue(assignment) < 2) return false;\n  return true;\n}\n```\n\n## Follow-up Questions\n\n- How would you generalize to 4+ vars with arbitrary implications?\n- How would you optimize for sparse constraint graphs and avoid enumerating all 2^n assignments?","diagram":"flowchart TD\n  A((A)) --> B((B))\n  B --> C((C))\n  Sub([At Least Two True]) --> A\n  Sub --> B\n  Sub --> C","difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Instacart","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-11T21:17:52.369Z","createdAt":"2026-01-11T21:17:52.369Z"},{"id":"q-733","question":"You’re auditing a rule-set for access policy. There are four booleans **X1**, **X2**, **X3**, **X4** with constraints: (X1 -> X2), (X1 ∨ X3), (X2 -> X4), and (X3 -> ¬X4). Is there a satisfying assignment? If yes, provide one; if not, explain why. Then outline a minimal backtracking strategy with unit propagation to verify arbitrary similar constraint sets?","answer":"Yes. One satisfying assignment is X1=0, X2=0, X3=1, X4=0. Reason: X1→X2 vacuously true when X1=0; X1∨X3 requires X3=1; X3→¬X4 yields X4=0; X2→X4 is true since X2=0. Translate to CNF: (¬X1∨X2)∧(X1∨X3)∧","explanation":"## Why This Is Asked\nTests translating a small policy-like rule-set into a CNF and solving with a practical backtracking approach.\n\n## Key Concepts\n- CNF encoding of implications\n- DPLL-style backtracking with unit propagation\n- Early pruning via conflicts and propagation\n- Live, scalable handling for arbitrary constraint sets\n\n## Code Example\n```javascript\nfunction solveCNF(clauses, assignment = {}) {\n  // minimal skeleton: unit-propagation + depth-first search\n}\n``` \n\n## Follow-up Questions\n- How would you handle cardinality constraints beyond binary implications?\n- What heuristics improve variable ordering in practice?","diagram":"flowchart TD\n  Start[Constraints: X1..X4] --> Prop[Unit Propagation]\n  Prop --> Check[Consistency Check]\n  Check --> Sat{Satisfiable?}\n  Sat --> Yes[Return assignment]\n  Sat --> No[Backtrack]","difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Netflix","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-11T22:18:15.092Z","createdAt":"2026-01-11T22:18:15.092Z"},{"id":"q-745","question":"You are building a tiny rule engine for feature toggles with three booleans A, B, C. Constraints: A → B, B → ¬C, and at least one of A, B, C must be true. Is there a satisfying assignment? Explain how you would verify it via brute-force backtracking across the eight possibilities and return one concrete example if it exists?","answer":"Yes. A valid assignment exists, e.g., A=1, B=1, C=0. Other solutions are (0,0,1) and (0,1,0). A brute-force backtracking approach would enumerate 8 combos, prune when (!A) || B fails or (!B) || !C fai","explanation":"## Why This Is Asked\n\nTests ability to reason about combined implications and negation, and to design a small exhaustive search with pruning.\n\n## Key Concepts\n\n- Implication and negation in boolean constraints\n- Exhaustive search with pruning\n- Small-scope backtracking for correctness checks\n\n## Code Example\n\n```javascript\nfunction solve() {\n  for (let A = 0; A <= 1; A++) {\n    for (let B = 0; B <= 1; B++) {\n      for (let C = 0; C <= 1; C++) {\n        const ok1 = (!A) || B;     // A -> B\n        const ok2 = (!B) || (!C);  // B -> ¬C\n        const ok3 = (A || B || C); // at least one true\n        if (ok1 && ok2 && ok3) return {A,B,C};\n      }\n    }\n  }\n  return null;\n}\n```","diagram":null,"difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["NVIDIA","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-11T23:19:37.904Z","createdAt":"2026-01-11T23:19:37.904Z"},{"id":"q-753","question":"In a feature-flag synthesis task, you have booleans A1..A8. Constraints include: (Ai -> Aj) implications, (Ai XOR Aj) mutual exclusions, and (Ai OR Aj OR Ak) group obligations. The implication graph is acyclic and each node has at most two outgoing edges. Design a backtracking solver that exploits the DAG to decide satisfiability for up to 12 vars. Provide a concrete 8-variable instance and show the solution or UNSAT?","answer":"Topologically sort the implication graph and propagate truths: if X -> Y and X is true, force Y true along the path; track unknowns otherwise. XOR constraints encoded as (A xor B) meaning exactly one ","explanation":"## Why This Is Asked\n\nAssesses ability to leverage a DAG of implications, handle XOR and OR constraints, and design a backtracking solver with strong pruning, reflecting real config-synthesis tasks at scale.\n\n## Key Concepts\n\n- DAG-driven propagation and topological order\n- XOR constraint encoding (1-in-2 style)\n- Backtracking with unit-propagation and early pruning\n- SAT-lean representations for mixed constraints\n\n## Code Example\n\n```javascript\nfunction solve(vars, constraints) {\n  // vars: boolean/null for unassigned; constraints: array of imp/xor/or\n  // Implementation sketch: propagate, then backtrack on a source variable\n  return true;\n}\n```\n\n## Follow-up Questions\n\n- How would you extend to 100+ vars with partial DAGs?\n- How would you relax the DAG assumption and detect cycles efficiently?","diagram":null,"difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","LinkedIn","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T01:31:29.320Z","createdAt":"2026-01-12T01:31:29.320Z"},{"id":"q-758","question":"You manage feature flags for a distributed service. Let F1..F5 be booleans with constraints: (F1 -> F2), (F1 ∨ F3), (F2 ⊕ F4), (F3 -> F5), and (F4 -> ¬F5). Is there a satisfying assignment? If yes, provide one; if not, explain. Then outline a minimal backtracking strategy with forward checking to verify arbitrary similar constraint sets?","answer":"Yes. One satisfying assignment is F1=1, F2=1, F3=0, F4=0, F5=0. Check: F1→F2 true; F1∨F3 true; F2⊕F4 true (1≠0); F3→F5 true (0→0); F4→¬F5 true (0→¬0). Backtracking should propagate F2 when F1=1, force","explanation":"## Why This Is Asked\nProbes XOR and implications under realistic feature flags; tests constraint propagation and backtracking.\n\n## Key Concepts\n- XOR constraints in SAT-like settings\n- Forward checking and constraint propagation\n- Translating to CNF for scalable solvers\n\n## Code Example\n```javascript\nfunction sat(F){\n  const [F1,F2,F3,F4,F5] = F;\n  const c1 = (!F1) || F2; // F1 -> F2\n  const c2 = F1 || F3;    // F1 ∨ F3\n  const c3 = (F2 !== F4); // F2 XOR F4\n  const c4 = (!F3) || F5;  // F3 -> F5\n  const c5 = (!F4) || (!F5); // F4 -> ¬F5\n  return c1 && c2 && c3 && c4 && c5;\n}\n\nconsole.log(sat([1,1,0,0,0])); // true\n```\n\n## Follow-up Questions\n- How would you encode these constraints into CNF for a SAT solver?\n- How would you scale to 20+ flags with incremental updates?","diagram":"flowchart TD\n  A[F1] --> B[F2]\n  A --> C[F3]\n  B --> D[F4]\n  C --> E[F5]\n  D --> F[Not F5]","difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Discord","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T03:48:03.715Z","createdAt":"2026-01-12T03:48:03.716Z"},{"id":"q-771","question":"You are validating a tiny access-control policy with two booleans: A = 'account is active', B = 'email verified'. The policy must satisfy: (¬A -> B), (B -> A), and (A ∨ B). Is there a satisfying assignment for A and B? Explain your reasoning and outline a simple backtracking check to verify arbitrary small sets of such clauses?","answer":"Yes. A=true, B=false satisfies all: ¬A is false so ¬A -> B holds; B -> A is vacuously true since B is false; A ∨ B is true. A backtracking check would try A in {true,false}, then B in {true,false}, ev","explanation":"## Why This Is Asked\nTests practical logical deduction and simple SAT handling in a controlled, small-domain setting.\n\n## Key Concepts\n- Implication with negation\n- Disjunction\n- Satisfiability search\n- Backtracking basics\n- Early termination on first valid assignment\n\n## Code Example\n```javascript\nfunction isSat(A,B) {\n  // Clause1: (!A => B)  == (A || B)\n  // Clause2: (B => A)   == (!B || A)\n  // Clause3: (A || B)\n  return (A || B) && (!B || A) && (A || B);\n}\n```\n\n## Follow-up Questions\n- How would you extend to three variables with similar clauses?\n- How does short-circuit evaluation affect performance in larger clause sets?","diagram":null,"difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["NVIDIA","PayPal","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T04:51:00.043Z","createdAt":"2026-01-12T04:51:00.043Z"},{"id":"q-775","question":"You're building a constraint-solver for a feature-flag system across a microservices deployment. Given four flags S1..S4 with constraints: (S1 -> S2), (S2 -> S3), (S4 -> ¬S1), and (S1 ∨ S4) and (S2 ∨ S4). Is there a satisfying assignment? Provide one concrete assignment and outline a backtracking algorithm with unit propagation to verify arbitrary similar constraint sets?","answer":"Yes. A satisfying assignment is S1=true, S2=true, S3=true, S4=false. Checks: S1→S2 (T→T), S2→S3 (T→T), S4→¬S1 (F→¬T), S1∨S4 (T), S2∨S4 (T). Backtracking: pick a var, propagate implications, backtrack ","explanation":"## Why This Is Asked\n\nTests ability to reason about constraints in practical feature-flag settings and to design a solver using propagation and backtracking rather than pure search. It also exposes how to craft a constructive counterexample when needed.\n\n## Key Concepts\n\n- Constraint satisfaction with implications and disjunctions\n- Unit propagation, backtracking, and a decision trail\n- Real-world constraints in deployment feature flags and release gates\n\n## Code Example\n\n```javascript\n// Minimal backtracker for boolean flags with given constraints\nfunction sat(S){\n  return (!S.S1 || S.S2) && (!S.S2 || S.S3) && (!S.S4 || !S.S1) && (S.S1 || S.S4) && (S.S2 || S.S4);\n}\nfunction satPartial(part){\n  const v = (k)=> part.hasOwnProperty(k)? part[k] : null;\n  if (v('S1')===true && v('S2')===false) return false;\n  if (v('S2')===true && v('S3')===false) return false;\n  if (v('S4')===true && v('S1')===true) return false;\n  if (v('S1')===false && v('S4')===false) return false;\n  if (v('S2')===false && v('S4')===false) return false;\n  return true;\n}\nfunction solve(partial={}, idx=0){\n  const vars=['S1','S2','S3','S4'];\n  if (!satPartial(partial)) return null;\n  if (idx===vars.length) return partial;\n  const name = vars[idx];\n  for (const val of [false,true]){\n    const next = Object.assign({}, partial, {[name]: val});\n    const res = solve(next, idx+1);\n    if (res) return res;\n  }\n  return null;\n}\nconsole.log(solve());\n```\n\n## Follow-up Questions\n\n- How would you scale this to thousands of flags with mostly Horn clauses?\n- What optimizations would you add for large constraint sets?","diagram":"flowchart TD\nS1 --> S2\nS2 --> S3\nS4 --> NotS1\nS1 --> S4\nS2 --> S4","difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Slack","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T05:29:00.647Z","createdAt":"2026-01-12T05:29:00.647Z"},{"id":"q-789","question":"Is there a truth assignment with exactly three flags true that satisfies all constraints A -> B; B -> C; D -> E; F -> G; not C -> H; A -> D? If yes, provide one and justify why it satisfies every implication?","answer":"Yes. A valid three-true assignment is B=true, C=true, H=true; all others false. Check: A false makes A->B and A->D vacuously true; B true enforces C true; not C is false so not C->H is vacuously true;","explanation":"## Why This Is Asked\n\nTests ability to reason about simple Horn-like constraints, propagation, and a cardinality requirement. It also checks whether the candidate can find a non-obvious satisfying assignment by exploiting unconstrained variables and implications to meet a strict true-count.\n\n## Key Concepts\n\n- Horn clause propagation\n- Forward/backward chaining\n- Cardinality constraints\n- Minimal models\n\n## Code Example\n\n```javascript\n// naive solver for A..H with given implications\nfunction satModel(vars){\n  // apply A->B, B->C, D->E, F->G, A->D, and notC->H\n  // returns first model with exactly 3 trues or null\n  return null;\n}\n```\n\n## Follow-up Questions\n\n- How would you generalize to arbitrary n and more constraints?\n- How change if notC -> H becomes not H -> C?\n","diagram":"flowchart TD\n  A[A]\n  B[B]\n  C[C]\n  D[D]\n  E[E]\n  F[F]\n  G[G]\n  H[H]\n  A --> B\n  B --> C\n  D --> E\n  F --> G\n  NotC[not C] -- H --> H\n  A --> D\n","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Square","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T07:25:29.228Z","createdAt":"2026-01-12T07:25:29.229Z"},{"id":"q-799","question":"Scenario: four booleans P, Q, R, S where P = user has role X, Q = grants read, R = has role Y, S = grants write. Constraints: (P -> Q), (R -> S), (P ∨ R), and at least two of {Q,S} must be true. Is there a satisfying assignment? If yes, give one; if not, explain why. Then outline a minimal backtracking strategy with unit propagation for arbitrary similar constraint sets?","answer":"Yes. One satisfying assignment is P=true, Q=true, R=true, S=true. Propagate P→Q and R→S, then the disjunction P∨R requires at least one of P,R to be true; choosing both yields Q and S true, meeting th","explanation":"## Why This Is Asked\nTests the ability to reason with mixed boolean and cardinality constraints, and to design a minimal backtracking solver with unit propagation.\n\n## Key Concepts\n- Boolean implications and disjunctions\n- Cardinality constraints (at least two true)\n- Unit propagation in backtracking\n- Pruning via early infeasibility checks\n\n## Code Example\n```javascript\nfunction backtrack(variables, constraints) {\n  // naive DFS with unit propagation\n  // returns a satisfying assignment or null\n}\n```\n\n## Follow-up Questions\n- How would you extend to arbitrary cardinalities (exactly k)?\n- How does your approach handle larger, real-world constraint sets?\n","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","DoorDash","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T08:30:11.725Z","createdAt":"2026-01-12T08:30:11.725Z"},{"id":"q-812","question":"Instance-based SAT with mixed Horn and parity constraints: Variables A,B,C,D,E,F. Constraints: (A ∧ B) → C; (C ∧ D) → E; A ⊕ D ⊕ F = 1; (B ∧ E) → F. Is there an assignment to A..F that satisfies all constraints? If yes, provide one; then describe how you would build a solver that combines forward-chaining on Horn clauses with Gaussian elimination over GF(2) for parity constraints, including data structures and complexity considerations?","answer":"Yes. One satisfying assignment is A=1, B=0, C=0, D=0, E=0, F=0. Then A∧B=0 so C unconstrained; C∧D=0 so E unconstrained; parity 1⊕0⊕0=1; B∧E=0 so F unconstrained. For the solver, first solve parity wi","explanation":"## Why This Is Asked\nThis question tests the ability to design solvers for hybrid constraint systems, combining logic reasoning with linear algebra.\n\n## Key Concepts\n- Horn clause forward-chaining\n- Parity constraints (GF(2) linear algebra)\n- Fixed-point iteration and backtracking\n- Constraint propagation and conflict detection\n\n## Code Example\n```javascript\n// Simple sketch\nfunction solve(parities, horns) {\n  // implement parity elimination then forward-chaining\n}\n```\n\n## Follow-up Questions\n- How would you handle conflicting parity constraints?\n- Analyze worst-case complexity of the combined solver.","diagram":"flowchart TD\n  A[Input Variables A..F] --> B[Propagate Horns]\n  B --> C[Apply GF(2) Elimination]\n  C --> D[Fixed Point]\n  D --> E{Satisfiable?}\n  E --> F[Return Model / Unsat]","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Google","Lyft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T10:22:59.643Z","createdAt":"2026-01-12T10:22:59.643Z"},{"id":"q-822","question":"Scenario: a tiny feature-toggle system for a data-annotation pipeline uses five booleans A–E: A = 'data augmentation enabled', B = 'sampling enabled', C = 'privacy mode on', D = 'live monitoring on', E = 'throttle rate limited'. Constraints: (A → B), (B → D), (C → ¬D), (A ∨ C), (D → E), (E → ¬A). Is there a satisfying assignment? If yes, give one; if not, explain why. Then outline a minimal backtracking strategy with unit propagation to verify arbitrary similar constraint sets?","answer":"Yes. Example: A=false, B=false, C=true, D=false, E=true. All constraints satisfied: A→B and B→D vacuous; C→¬D true; A∨C true; D→E vacuous; E→¬A true. For general cases, use a DF/DPLL-style search with","explanation":"## Why This Is Asked\n\nAssesses ability to reason about constrained booleans, identify a satisfiable assignment, and outline a scalable backtracking strategy with unit propagation.\n\n## Key Concepts\n\n- 2-SAT/Horn-clauses\n- Unit propagation\n- Backtracking/DPLL\n\n## Code Example\n\n```javascript\n// Minimal backtracking SAT tester\nfunction solve(clauses, assign={}) {\n  // if all literals satisfied return assign\n  // propagate unit clauses and branch\n  return null;\n}\n```\n\n## Follow-up Questions\n\n- How does adding a clause X → Y affect pruning?\n- How would you extend to arbitrary n variables and k clauses?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Hugging Face","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T11:20:06.386Z","createdAt":"2026-01-12T11:20:06.386Z"},{"id":"q-828","question":"Scenario: a feature-flag set uses four booleans A,B,C,D with rollout statuses True, False, Unknown (U). Constraints: (A → B), (C ∨ D), (A ∨ C), (B → ¬D). Is there a satisfying assignment allowing Unknowns? Explain reasoning and outline a backtracking approach using 3-valued logic to propagate U and verify arbitrary such constraint sets?","answer":"Yes. One satisfying assignment: A=False, B=True, C=True, D=False. Check: A→B true (A false); C∨D true; A∨C true; B→¬D true since D is False. For 3-valued search, start with all U, apply constraint-bas","explanation":"## Why This Is Asked\nTests handling of 3-valued logic in constraint systems common to feature gating, with practical backtracking and propagation strategies.\n\n## Key Concepts\n- Three-valued logic (True/False/Unknown) in Horn-like constraints\n- Constraint propagation and backtracking\n- Non-deterministic value assignment during rollout\n\n## Code Example\n```javascript\n// pseudocode: backtracking with U\nfunction sat3(vars, constraints) { /* ... */ }\n```\n\n## Follow-up Questions\n- How would you extend to more variables with cycles?\n- How do you optimize propagation for large constraint sets?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","MongoDB","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T12:41:11.362Z","createdAt":"2026-01-12T12:41:11.362Z"}],"subChannels":["general"],"companies":["Adobe","Airbnb","Amazon","Anthropic","Apple","Bloomberg","Citadel","Cloudflare","Databricks","Discord","DoorDash","Goldman Sachs","Google","Hashicorp","Hugging Face","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Netflix","PayPal","Plaid","Robinhood","Salesforce","Scale Ai","Slack","Snap","Snowflake","Square","Tesla","Twitter","Two Sigma"],"stats":{"total":37,"beginner":10,"intermediate":14,"advanced":13,"newThisWeek":37}}