{"questions":[{"id":"q-683","question":"You're managing a streaming DAG with tasks A,B,C,D; edges enforce: A before B; B before C; at most one of C or D can occur in a window of size H. Given a log of events with timestamps per task, implement an O(n log n) verifier to determine if the log is valid under these constraints and describe how you'd extend to multiple windows in a distributed system?","answer":"Sort events by timestamp; maintain last_seen per task; when seeing B, require A has appeared earlier; when C arrives, require B seen within H time; when D arrives, ensure C did not occur in the same w","explanation":"## Why This Is Asked\n\nTests ability to reason about temporal constraints in streaming DAGs and develop an efficient log validation algorithm.\n\n## Key Concepts\n\n- Temporal constraints and causal ordering\n- Sliding window validation\n- O(n log n) sorting and O(1) per-event checks\n- Edge cases: missing prerequisites, mutual exclusion\n\n## Code Example\n\n```javascript\nfunction validLog(events, H) {\n  // events: {task: 'A', t: 0}, ...\n  // naive sketch\n  // sort by t\n  // track last window start, last times\n  // enforce A before B, B before C within H, and at most one of C/D in a window\n}\n```\n\n## Follow-up Questions\n\n- How would you scale to thousands of tasks and multiple horizons?\n- How would clock skew affect correctness and what mitigations exist?","diagram":null,"difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T15:58:57.063Z","createdAt":"2026-01-11T15:58:57.063Z"},{"id":"q-685","question":"Context: In a data-cleaning pipeline, records have boolean attributes a, b, c, d. Rules are Horn clauses of the form X ∧ Y -> Z. Given a partial assignment, decide if a full assignment exists that satisfies all clauses. Design a linear-time forward-chaining solver, justify its correctness, and discuss incremental updates and cycles with a concrete four-variable example (two rules)?","answer":"Forward-chaining Horn-SAT solver. Maintain a set of known-true literals and a queue of rules whose antecedents are all true; fire their consequents to mark new truths. If a rule implies a literal alre","explanation":"## Why This Is Asked\nTo gauge practical reasoning about logic constraints, Horn-SAT familiarity, and ability to reason about linear-time algorithms and incremental updates in data pipelines.\n\n## Key Concepts\n- Horn clauses\n- Forward chaining\n- Partial vs full assignments\n- Complexity O(n+m)\n- Cycle handling and inconsistency detection\n\n## Code Example\n```javascript\nfunction solveHorn(rules, facts){\n  const trueSet = new Set(facts);\n  let queue = rules.filter(r => r.antecedent.every(v => trueSet.has(v)));\n  while (queue.length){\n    const r = queue.shift();\n    if (!trueSet.has(r.consequent)){\n      trueSet.add(r.consequent);\n      queue = rules.filter(x => x.antecedent.every(v => trueSet.has(v)) && !trueSet.has(x.consequent));\n    }\n  }\n  return trueSet;\n}\n```\n\n## Follow-up Questions\n- How would you extend to non-Horn clauses?\n- How would you handle incremental updates when facts change?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Databricks","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T16:21:38.487Z","createdAt":"2026-01-11T16:21:38.487Z"},{"id":"q-699","question":"You have a Horn-clauses policy language for access control. Given the following rules and facts, determine if allow(alice,read,records) is entailed using forward-chaining to a least fixpoint. Rules: 1) grant(U,act,res) :- haveRole(U,R), privilege(R,act,res). 2) allow(U,act,res) :- grant(U,act,res). Facts: haveRole(alice,dataEngineer). privilege(dataEngineer,read,records). Show your derivation steps?","answer":"Yes. Forward-chaining yields grant(alice,read,records) from haveRole(alice,dataEngineer) and privilege(dataEngineer,read,records) via grant(U,act,res). Then allow(alice,read,records) follows from allo","explanation":"## Why This Is Asked\nTests understanding of Horn clauses, forward-chaining, and least-fixpoint semantics in practical policy reasoning.\n\n## Key Concepts\n- Horn clauses\n- Forward-chaining\n- Least fixpoint\n- Complexity linear in facts and rules\n\n## Code Example\n```javascript\n// Pseudo forward-chaining:\nwhile newDerivation:\n  apply grant rule to facts\n  apply allow rule to grants\n```\n\n## Follow-up Questions\n- How would this scale with thousands of rules?\n- How would you extend to handle negation or recursion?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Databricks","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T17:18:31.996Z","createdAt":"2026-01-11T17:18:31.996Z"},{"id":"q-702","question":"In a home security system, three sensors—door, window, and motion—report activity as booleans a, b, c for the last minute. The alert should fire only when exactly one sensor is active. How would you implement a function that takes a, b, c and returns true iff exactly one is true, and what are its time and space complexities?","answer":"Compute the count: Number(a) + Number(b) + Number(c) and check if it equals 1. For example in JavaScript: return Number(a) + Number(b) + Number(c) === 1. This is O(1) time and O(1) space; an equivalen","explanation":"## Why This Is Asked\nTests understanding of simple boolean logic and edge cases (e.g., all true or all false) in a practical setting.\n\n## Key Concepts\n- Boolean counting\n- Short-circuit reasoning\n- Constant-time evaluation\n\n## Code Example\n```javascript\nfunction alert(a,b,c){\n  return Number(a)+Number(b)+Number(c)===1;\n}\n```\n\n## Follow-up Questions\n- How would you extend to n sensors and a threshold k?\n- How would you optimize for streaming data with sliding windows?","diagram":null,"difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T18:26:22.369Z","createdAt":"2026-01-11T18:26:22.369Z"},{"id":"q-715","question":"In a distributed data-processing pipeline across three services Ingest (I), Compute (C), Persist (P), each event carries a 3-element vector clock. Given E1 at I with [2,0,1] and E2 at C with [1,3,0], decide whether E1 happened-before E2, E2 happened-before E1, or they are concurrent. Explain the rule and show the comparison. How would you scale this to N services and detect concurrency in large logs?","answer":"Using vector clocks, E1 happened-before E2 if every component of E1 <= corresponding E2 and at least one is strictly less. Here [2,0,1] vs [1,3,0] has 2>1, 0<3, 1>0; not all <= or >=, so E1 || E2 (con","explanation":"## Why This Is Asked\nUnderstanding vector clocks and the happens-before relation for debugging causality in distributed systems.\n\n## Key Concepts\n- Vector clocks\n- Happens-before\n- Concurrency detection in logs\n\n## Code Example\n```javascript\nfunction compareVC(a, b) {\n  let lessEq = true, greaterEq = true;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] > b[i]) lessEq = false;\n    if (a[i] < b[i]) greaterEq = false;\n  }\n  if (lessEq && greaterEq) return 'equal';\n  if (lessEq) return 'a_before_b';\n  if (greaterEq) return 'b_before_a';\n  return 'concurrent';\n}\n```\n\n## Follow-up Questions\n- How would you integrate vector clocks with a log-aggregation system to detect causality violations?\n- What are the storage and performance implications for large-scale deployments?","diagram":null,"difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Bloomberg","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T19:18:20.787Z","createdAt":"2026-01-11T19:18:20.787Z"},{"id":"q-719","question":"Design a tiny solver for three boolean inputs A, B, C given constraints: (A -> B) and (B -> C) and (A or C). Is there an assignment that satisfies all three? Explain your reasoning and outline a simple backtracking approach you would implement to check arbitrary small sets of such implications?","answer":"Two assignments satisfy (A->B), (B->C), (A∨C): (0,0,1) and (1,1,1). A quick check uses the constraints: A->B true if A=0 or B=1; B->C true if B=0 or C=1; A∨C true if A=1 or C=1. A backtracking checker","explanation":"## Why This Is Asked\nEvery candidate demonstrates logic reasoning and basic constraint solving relevant to planning validations in software.\n\n## Key Concepts\n- Propositional logic and implications\n- Satisfiability with small variable sets\n- Backtracking pruning for constraints\n\n## Code Example\n```javascript\nfunction isSatisfiable(constraints) {\n  const vars = ['A','B','C'];\n  for (let a of [0,1])\n    for (let b of [0,1])\n      for (let c of [0,1]) {\n        const assign = {A:a,B:b,C:c};\n        if (constraints.every(fn => fn(assign))) return true;\n      }\n  return false;\n}\n```\n\n## Follow-up Questions\n- How would you extend to thousands of variables with CNF clauses?\n- What are the trade-offs of backtracking vs. SAT solvers in practice?","diagram":null,"difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Google","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T20:22:02.565Z","createdAt":"2026-01-11T20:22:02.565Z"},{"id":"q-728","question":"Scenario: You’re building a tiny policy engine for feature flags with three booleans A, B, C. Constraints: A implies B, B implies C, and at least two of the three must be true. Is there an assignment that satisfies all constraints? If so, give one example and briefly justify. Then outline a straightforward backtracking approach to enumerate all satisfying assignments for any n flags and any such constraints?","answer":"Yes. With A,B,C, A→B and B→C and at least two true, A=false,B=true,C=true works: A→B vacuously true; B→C true because C is true; two true satisfy the cardinality. Backtracking: enumerate A,B,C in {F,T","explanation":"## Why This Is Asked\n\nTests ability to reason about small logical constraints and translate them into a checkable search, including vacuous implications and cardinality.\n\n## Key Concepts\n\n- Logical implications and vacuous truth\n- Cardinality constraints (minimum true)\n- Backtracking with pruning\n- Generalizing to N variables\n\n## Code Example\n\n```javascript\nfunction countTrue(arr){ return arr.filter(x=>x).length; }\nfunction implies(p,q){ return !p || q; }\nfunction sat(assignment){\n  const [A,B,C] = assignment;\n  if(!implies(A,B)) return false;\n  if(!implies(B,C)) return false;\n  if(countTrue(assignment) < 2) return false;\n  return true;\n}\n```\n\n## Follow-up Questions\n\n- How would you generalize to 4+ vars with arbitrary implications?\n- How would you optimize for sparse constraint graphs and avoid enumerating all 2^n assignments?","diagram":"flowchart TD\n  A((A)) --> B((B))\n  B --> C((C))\n  Sub([At Least Two True]) --> A\n  Sub --> B\n  Sub --> C","difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Instacart","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T21:17:52.369Z","createdAt":"2026-01-11T21:17:52.369Z"},{"id":"q-733","question":"You’re auditing a rule-set for access policy. There are four booleans **X1**, **X2**, **X3**, **X4** with constraints: (X1 -> X2), (X1 ∨ X3), (X2 -> X4), and (X3 -> ¬X4). Is there a satisfying assignment? If yes, provide one; if not, explain why. Then outline a minimal backtracking strategy with unit propagation to verify arbitrary similar constraint sets?","answer":"Yes. One satisfying assignment is X1=0, X2=0, X3=1, X4=0. Reason: X1→X2 vacuously true when X1=0; X1∨X3 requires X3=1; X3→¬X4 yields X4=0; X2→X4 is true since X2=0. Translate to CNF: (¬X1∨X2)∧(X1∨X3)∧","explanation":"## Why This Is Asked\nTests translating a small policy-like rule-set into a CNF and solving with a practical backtracking approach.\n\n## Key Concepts\n- CNF encoding of implications\n- DPLL-style backtracking with unit propagation\n- Early pruning via conflicts and propagation\n- Live, scalable handling for arbitrary constraint sets\n\n## Code Example\n```javascript\nfunction solveCNF(clauses, assignment = {}) {\n  // minimal skeleton: unit-propagation + depth-first search\n}\n``` \n\n## Follow-up Questions\n- How would you handle cardinality constraints beyond binary implications?\n- What heuristics improve variable ordering in practice?","diagram":"flowchart TD\n  Start[Constraints: X1..X4] --> Prop[Unit Propagation]\n  Prop --> Check[Consistency Check]\n  Check --> Sat{Satisfiable?}\n  Sat --> Yes[Return assignment]\n  Sat --> No[Backtrack]","difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Netflix","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T22:18:15.092Z","createdAt":"2026-01-11T22:18:15.092Z"},{"id":"q-745","question":"You are building a tiny rule engine for feature toggles with three booleans A, B, C. Constraints: A → B, B → ¬C, and at least one of A, B, C must be true. Is there a satisfying assignment? Explain how you would verify it via brute-force backtracking across the eight possibilities and return one concrete example if it exists?","answer":"Yes. A valid assignment exists, e.g., A=1, B=1, C=0. Other solutions are (0,0,1) and (0,1,0). A brute-force backtracking approach would enumerate 8 combos, prune when (!A) || B fails or (!B) || !C fai","explanation":"## Why This Is Asked\n\nTests ability to reason about combined implications and negation, and to design a small exhaustive search with pruning.\n\n## Key Concepts\n\n- Implication and negation in boolean constraints\n- Exhaustive search with pruning\n- Small-scope backtracking for correctness checks\n\n## Code Example\n\n```javascript\nfunction solve() {\n  for (let A = 0; A <= 1; A++) {\n    for (let B = 0; B <= 1; B++) {\n      for (let C = 0; C <= 1; C++) {\n        const ok1 = (!A) || B;     // A -> B\n        const ok2 = (!B) || (!C);  // B -> ¬C\n        const ok3 = (A || B || C); // at least one true\n        if (ok1 && ok2 && ok3) return {A,B,C};\n      }\n    }\n  }\n  return null;\n}\n```","diagram":null,"difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["NVIDIA","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T23:19:37.904Z","createdAt":"2026-01-11T23:19:37.904Z"},{"id":"q-753","question":"In a feature-flag synthesis task, you have booleans A1..A8. Constraints include: (Ai -> Aj) implications, (Ai XOR Aj) mutual exclusions, and (Ai OR Aj OR Ak) group obligations. The implication graph is acyclic and each node has at most two outgoing edges. Design a backtracking solver that exploits the DAG to decide satisfiability for up to 12 vars. Provide a concrete 8-variable instance and show the solution or UNSAT?","answer":"Topologically sort the implication graph and propagate truths: if X -> Y and X is true, force Y true along the path; track unknowns otherwise. XOR constraints encoded as (A xor B) meaning exactly one ","explanation":"## Why This Is Asked\n\nAssesses ability to leverage a DAG of implications, handle XOR and OR constraints, and design a backtracking solver with strong pruning, reflecting real config-synthesis tasks at scale.\n\n## Key Concepts\n\n- DAG-driven propagation and topological order\n- XOR constraint encoding (1-in-2 style)\n- Backtracking with unit-propagation and early pruning\n- SAT-lean representations for mixed constraints\n\n## Code Example\n\n```javascript\nfunction solve(vars, constraints) {\n  // vars: boolean/null for unassigned; constraints: array of imp/xor/or\n  // Implementation sketch: propagate, then backtrack on a source variable\n  return true;\n}\n```\n\n## Follow-up Questions\n\n- How would you extend to 100+ vars with partial DAGs?\n- How would you relax the DAG assumption and detect cycles efficiently?","diagram":null,"difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","LinkedIn","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T01:31:29.320Z","createdAt":"2026-01-12T01:31:29.320Z"},{"id":"q-758","question":"You manage feature flags for a distributed service. Let F1..F5 be booleans with constraints: (F1 -> F2), (F1 ∨ F3), (F2 ⊕ F4), (F3 -> F5), and (F4 -> ¬F5). Is there a satisfying assignment? If yes, provide one; if not, explain. Then outline a minimal backtracking strategy with forward checking to verify arbitrary similar constraint sets?","answer":"Yes. One satisfying assignment is F1=1, F2=1, F3=0, F4=0, F5=0. Check: F1→F2 true; F1∨F3 true; F2⊕F4 true (1≠0); F3→F5 true (0→0); F4→¬F5 true (0→¬0). Backtracking should propagate F2 when F1=1, force","explanation":"## Why This Is Asked\nProbes XOR and implications under realistic feature flags; tests constraint propagation and backtracking.\n\n## Key Concepts\n- XOR constraints in SAT-like settings\n- Forward checking and constraint propagation\n- Translating to CNF for scalable solvers\n\n## Code Example\n```javascript\nfunction sat(F){\n  const [F1,F2,F3,F4,F5] = F;\n  const c1 = (!F1) || F2; // F1 -> F2\n  const c2 = F1 || F3;    // F1 ∨ F3\n  const c3 = (F2 !== F4); // F2 XOR F4\n  const c4 = (!F3) || F5;  // F3 -> F5\n  const c5 = (!F4) || (!F5); // F4 -> ¬F5\n  return c1 && c2 && c3 && c4 && c5;\n}\n\nconsole.log(sat([1,1,0,0,0])); // true\n```\n\n## Follow-up Questions\n- How would you encode these constraints into CNF for a SAT solver?\n- How would you scale to 20+ flags with incremental updates?","diagram":"flowchart TD\n  A[F1] --> B[F2]\n  A --> C[F3]\n  B --> D[F4]\n  C --> E[F5]\n  D --> F[Not F5]","difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Discord","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T03:48:03.715Z","createdAt":"2026-01-12T03:48:03.716Z"},{"id":"q-771","question":"You are validating a tiny access-control policy with two booleans: A = 'account is active', B = 'email verified'. The policy must satisfy: (¬A -> B), (B -> A), and (A ∨ B). Is there a satisfying assignment for A and B? Explain your reasoning and outline a simple backtracking check to verify arbitrary small sets of such clauses?","answer":"Yes. A=true, B=false satisfies all: ¬A is false so ¬A -> B holds; B -> A is vacuously true since B is false; A ∨ B is true. A backtracking check would try A in {true,false}, then B in {true,false}, ev","explanation":"## Why This Is Asked\nTests practical logical deduction and simple SAT handling in a controlled, small-domain setting.\n\n## Key Concepts\n- Implication with negation\n- Disjunction\n- Satisfiability search\n- Backtracking basics\n- Early termination on first valid assignment\n\n## Code Example\n```javascript\nfunction isSat(A,B) {\n  // Clause1: (!A => B)  == (A || B)\n  // Clause2: (B => A)   == (!B || A)\n  // Clause3: (A || B)\n  return (A || B) && (!B || A) && (A || B);\n}\n```\n\n## Follow-up Questions\n- How would you extend to three variables with similar clauses?\n- How does short-circuit evaluation affect performance in larger clause sets?","diagram":null,"difficulty":"beginner","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["NVIDIA","PayPal","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T04:51:00.043Z","createdAt":"2026-01-12T04:51:00.043Z"},{"id":"q-775","question":"You're building a constraint-solver for a feature-flag system across a microservices deployment. Given four flags S1..S4 with constraints: (S1 -> S2), (S2 -> S3), (S4 -> ¬S1), and (S1 ∨ S4) and (S2 ∨ S4). Is there a satisfying assignment? Provide one concrete assignment and outline a backtracking algorithm with unit propagation to verify arbitrary similar constraint sets?","answer":"Yes. A satisfying assignment is S1=true, S2=true, S3=true, S4=false. Checks: S1→S2 (T→T), S2→S3 (T→T), S4→¬S1 (F→¬T), S1∨S4 (T), S2∨S4 (T). Backtracking: pick a var, propagate implications, backtrack ","explanation":"## Why This Is Asked\n\nTests ability to reason about constraints in practical feature-flag settings and to design a solver using propagation and backtracking rather than pure search. It also exposes how to craft a constructive counterexample when needed.\n\n## Key Concepts\n\n- Constraint satisfaction with implications and disjunctions\n- Unit propagation, backtracking, and a decision trail\n- Real-world constraints in deployment feature flags and release gates\n\n## Code Example\n\n```javascript\n// Minimal backtracker for boolean flags with given constraints\nfunction sat(S){\n  return (!S.S1 || S.S2) && (!S.S2 || S.S3) && (!S.S4 || !S.S1) && (S.S1 || S.S4) && (S.S2 || S.S4);\n}\nfunction satPartial(part){\n  const v = (k)=> part.hasOwnProperty(k)? part[k] : null;\n  if (v('S1')===true && v('S2')===false) return false;\n  if (v('S2')===true && v('S3')===false) return false;\n  if (v('S4')===true && v('S1')===true) return false;\n  if (v('S1')===false && v('S4')===false) return false;\n  if (v('S2')===false && v('S4')===false) return false;\n  return true;\n}\nfunction solve(partial={}, idx=0){\n  const vars=['S1','S2','S3','S4'];\n  if (!satPartial(partial)) return null;\n  if (idx===vars.length) return partial;\n  const name = vars[idx];\n  for (const val of [false,true]){\n    const next = Object.assign({}, partial, {[name]: val});\n    const res = solve(next, idx+1);\n    if (res) return res;\n  }\n  return null;\n}\nconsole.log(solve());\n```\n\n## Follow-up Questions\n\n- How would you scale this to thousands of flags with mostly Horn clauses?\n- What optimizations would you add for large constraint sets?","diagram":"flowchart TD\nS1 --> S2\nS2 --> S3\nS4 --> NotS1\nS1 --> S4\nS2 --> S4","difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Slack","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T05:29:00.647Z","createdAt":"2026-01-12T05:29:00.647Z"},{"id":"q-789","question":"Is there a truth assignment with exactly three flags true that satisfies all constraints A -> B; B -> C; D -> E; F -> G; not C -> H; A -> D? If yes, provide one and justify why it satisfies every implication?","answer":"Yes. A valid three-true assignment is B=true, C=true, H=true; all others false. Check: A false makes A->B and A->D vacuously true; B true enforces C true; not C is false so not C->H is vacuously true;","explanation":"## Why This Is Asked\n\nTests ability to reason about simple Horn-like constraints, propagation, and a cardinality requirement. It also checks whether the candidate can find a non-obvious satisfying assignment by exploiting unconstrained variables and implications to meet a strict true-count.\n\n## Key Concepts\n\n- Horn clause propagation\n- Forward/backward chaining\n- Cardinality constraints\n- Minimal models\n\n## Code Example\n\n```javascript\n// naive solver for A..H with given implications\nfunction satModel(vars){\n  // apply A->B, B->C, D->E, F->G, A->D, and notC->H\n  // returns first model with exactly 3 trues or null\n  return null;\n}\n```\n\n## Follow-up Questions\n\n- How would you generalize to arbitrary n and more constraints?\n- How change if notC -> H becomes not H -> C?\n","diagram":"flowchart TD\n  A[A]\n  B[B]\n  C[C]\n  D[D]\n  E[E]\n  F[F]\n  G[G]\n  H[H]\n  A --> B\n  B --> C\n  D --> E\n  F --> G\n  NotC[not C] -- H --> H\n  A --> D\n","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Square","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T07:25:29.228Z","createdAt":"2026-01-12T07:25:29.229Z"},{"id":"q-799","question":"Scenario: four booleans P, Q, R, S where P = user has role X, Q = grants read, R = has role Y, S = grants write. Constraints: (P -> Q), (R -> S), (P ∨ R), and at least two of {Q,S} must be true. Is there a satisfying assignment? If yes, give one; if not, explain why. Then outline a minimal backtracking strategy with unit propagation for arbitrary similar constraint sets?","answer":"Yes. One satisfying assignment is P=true, Q=true, R=true, S=true. Propagate P→Q and R→S, then the disjunction P∨R requires at least one of P,R to be true; choosing both yields Q and S true, meeting th","explanation":"## Why This Is Asked\nTests the ability to reason with mixed boolean and cardinality constraints, and to design a minimal backtracking solver with unit propagation.\n\n## Key Concepts\n- Boolean implications and disjunctions\n- Cardinality constraints (at least two true)\n- Unit propagation in backtracking\n- Pruning via early infeasibility checks\n\n## Code Example\n```javascript\nfunction backtrack(variables, constraints) {\n  // naive DFS with unit propagation\n  // returns a satisfying assignment or null\n}\n```\n\n## Follow-up Questions\n- How would you extend to arbitrary cardinalities (exactly k)?\n- How does your approach handle larger, real-world constraint sets?\n","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","DoorDash","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T08:30:11.725Z","createdAt":"2026-01-12T08:30:11.725Z"},{"id":"q-812","question":"Instance-based SAT with mixed Horn and parity constraints: Variables A,B,C,D,E,F. Constraints: (A ∧ B) → C; (C ∧ D) → E; A ⊕ D ⊕ F = 1; (B ∧ E) → F. Is there an assignment to A..F that satisfies all constraints? If yes, provide one; then describe how you would build a solver that combines forward-chaining on Horn clauses with Gaussian elimination over GF(2) for parity constraints, including data structures and complexity considerations?","answer":"Yes. One satisfying assignment is A=1, B=0, C=0, D=0, E=0, F=0. Then A∧B=0 so C unconstrained; C∧D=0 so E unconstrained; parity 1⊕0⊕0=1; B∧E=0 so F unconstrained. For the solver, first solve parity wi","explanation":"## Why This Is Asked\nThis question tests the ability to design solvers for hybrid constraint systems, combining logic reasoning with linear algebra.\n\n## Key Concepts\n- Horn clause forward-chaining\n- Parity constraints (GF(2) linear algebra)\n- Fixed-point iteration and backtracking\n- Constraint propagation and conflict detection\n\n## Code Example\n```javascript\n// Simple sketch\nfunction solve(parities, horns) {\n  // implement parity elimination then forward-chaining\n}\n```\n\n## Follow-up Questions\n- How would you handle conflicting parity constraints?\n- Analyze worst-case complexity of the combined solver.","diagram":"flowchart TD\n  A[Input Variables A..F] --> B[Propagate Horns]\n  B --> C[Apply GF(2) Elimination]\n  C --> D[Fixed Point]\n  D --> E{Satisfiable?}\n  E --> F[Return Model / Unsat]","difficulty":"advanced","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Google","Lyft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T10:22:59.643Z","createdAt":"2026-01-12T10:22:59.643Z"},{"id":"q-822","question":"Scenario: a tiny feature-toggle system for a data-annotation pipeline uses five booleans A–E: A = 'data augmentation enabled', B = 'sampling enabled', C = 'privacy mode on', D = 'live monitoring on', E = 'throttle rate limited'. Constraints: (A → B), (B → D), (C → ¬D), (A ∨ C), (D → E), (E → ¬A). Is there a satisfying assignment? If yes, give one; if not, explain why. Then outline a minimal backtracking strategy with unit propagation to verify arbitrary similar constraint sets?","answer":"Yes. Example: A=false, B=false, C=true, D=false, E=true. All constraints satisfied: A→B and B→D vacuous; C→¬D true; A∨C true; D→E vacuous; E→¬A true. For general cases, use a DF/DPLL-style search with","explanation":"## Why This Is Asked\n\nAssesses ability to reason about constrained booleans, identify a satisfiable assignment, and outline a scalable backtracking strategy with unit propagation.\n\n## Key Concepts\n\n- 2-SAT/Horn-clauses\n- Unit propagation\n- Backtracking/DPLL\n\n## Code Example\n\n```javascript\n// Minimal backtracking SAT tester\nfunction solve(clauses, assign={}) {\n  // if all literals satisfied return assign\n  // propagate unit clauses and branch\n  return null;\n}\n```\n\n## Follow-up Questions\n\n- How does adding a clause X → Y affect pruning?\n- How would you extend to arbitrary n variables and k clauses?","diagram":null,"difficulty":"intermediate","tags":["math-logic"],"channel":"math-logic","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Hugging Face","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T11:20:06.386Z","createdAt":"2026-01-12T11:20:06.386Z"}],"subChannels":["general"],"companies":["Adobe","Amazon","Apple","Bloomberg","Citadel","Cloudflare","Databricks","Discord","DoorDash","Google","Hugging Face","Instacart","LinkedIn","Lyft","Microsoft","MongoDB","NVIDIA","Netflix","PayPal","Plaid","Salesforce","Scale Ai","Slack","Snowflake","Square","Twitter","Two Sigma"],"stats":{"total":17,"beginner":5,"intermediate":7,"advanced":5,"newThisWeek":17}}