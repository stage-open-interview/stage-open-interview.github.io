{"questions":[{"id":"azure-developer-develop-compute-1768162939034-0","question":"You are designing a high-throughput event-driven API on Azure Functions that must connect to a third-party service requiring a fixed outbound IP. Which compute option best meets latency, scale, and IP allow-list requirements?","answer":"[{\"id\":\"a\",\"text\":\"Azure Functions Consumption plan with dynamic outbound IP\",\"isCorrect\":false},{\"id\":\"b\",\"text\":\"Azure Functions Premium plan with pre-warmed instances and VNET integration\",\"isCorrect\":true},{\"id\":\"c\",\"text\":\"Azure App Service on Standard plan\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Azure Container Instances with a single container\",\"isCorrect\":false}]","explanation":"## Correct Answer\nOption B. Azure Functions Premium plan with pre-warmed instances and VNET integration reduces cold starts and provides secure, controllable egress when connecting to external services, which helps meet latency and network-security requirements. For strict fixed outbound IPs, additional egress controls (such as a NAT or dedicated egress) may be used, but Premium still offers the best balance of latency, scale, and network control for this scenario.\n\n## Why Other Options Are Wrong\n- Option A: Consumption plan experiences cold starts under load and outbound IPs can change, which worsens latency and IP allow-list reliability.\n- Option C: App Service on Standard does not guarantee pre-warmed instances and has less flexible networking options for controlled egress.\n- Option D: ACI with a single container does not provide the auto-scaling, pacing, or integrated networking features needed for high-throughput, multi-tenant workloads.\n\n## Key Concepts\n- Serverless compute options: Consumption vs Premium plans\n- VNET integration for Azure Functions\n- Egress control and outbound IP considerations\n- When to apply NAT or dedicated egress patterns\n\n## Real-World Application\nUsed when building a serverless integration that must call partner APIs with IP allow-list constraints and predictable latency, enabling reliable scaling without cold starts.","diagram":null,"difficulty":"intermediate","tags":["Azure","Kubernetes","AWS","Terraform","AKS","certification-mcq","domain-weight-25"],"channel":"azure-developer","subChannel":"develop-compute","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T20:22:19.035Z","createdAt":"2026-01-11 20:22:19"},{"id":"azure-developer-develop-compute-1768162939034-1","question":"During a migration of a microservices app to AKS, your team requires zero-downtime deployments, per-service autoscaling, and straightforward routing. Which approach best satisfies these needs in AKS?","answer":"[{\"id\":\"a\",\"text\":\"Deploy each service as a Kubernetes Deployment using RollingUpdate with readiness probes and per-service HorizontalPodAutoscaler\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"Use VM Scale Sets behind a load balancer\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"Move all services to Azure Functions for event-driven processing\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Use App Service Environment with slot swapping\",\"isCorrect\":false}]","explanation":"## Correct Answer\nOption A. Deploying each microservice as a Kubernetes Deployment with a RollingUpdate strategy, plus readiness probes and per-service HorizontalPodAutoscalers (HPA), enables zero-downtime deployments and automatic scaling. While canary/blue-green patterns can be added with service mesh tooling, the core AKS pattern for safe updates and scalable services is rolling updates combined with readiness probes and per-service HPAs.\n\n## Why Other Options Are Wrong\n- Option B: VM Scale Sets can offer scale but do not provide native per-service rolling updates with Kubernetes-level health checks and routing complexity.\n- Option C: Azure Functions is not a direct substitute for a distributed microservices architecture on AKS and does not address zero-downtime rolling updates across multiple services.\n- Option D: Slot swapping is an App Service concept and does not apply to AKS traffic routing and rolling deployments.\n\n## Key Concepts\n- Kubernetes Deployment rolling updates\n- Readiness probes and liveness checks\n- HorizontalPodAutoscaler per service\n- AKS deployment strategies for zero-downtime upgrades\n\n## Real-World Application\nApplies when migrating microservices to AKS and you need smooth, automatic updates across many services without traffic disruption, while preserving scalable capacity per service.","diagram":null,"difficulty":"intermediate","tags":["Azure","Kubernetes","AWS","Terraform","AKS","certification-mcq","domain-weight-25"],"channel":"azure-developer","subChannel":"develop-compute","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T20:22:19.617Z","createdAt":"2026-01-11 20:22:20"},{"id":"azure-developer-develop-compute-1768162939034-2","question":"In an event-driven Azure architecture, you want to guarantee exactly-once processing of messages from a queue into a downstream store. Which pattern best achieves this?","answer":"[{\"id\":\"a\",\"text\":\"Azure Service Bus with sessions and content-based deduplication and an idempotent consumer\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"Azure Storage Queues with DeleteMessage after processing\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"Azure Event Grid with automatic retries until success\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Cosmos DB change feed with eventual consistency handling\",\"isCorrect\":false}]","explanation":"## Correct Answer\nOption A. Azure Service Bus supports per-message deduplication and sessions for ordered processing, and when combined with an idempotent consumer (the downstream store logic is designed to handle duplicates gracefully), you can approach exactly-once semantics. Other options either rely on at-least-once processing guarantees (Storage Queues, Event Grid retries) or require complex idempotency handling beyond what change feeds provide by default.\n\n## Why Other Options Are Wrong\n- Option B: Storage Queues can deliver messages at-least-once; duplicates are possible without additional dedup logic.\n- Option C: Event Grid retries do not guarantee exactly-once delivery semantics for each event across all handlers.\n- Option D: Cosmos DB change feed provides strong ordering and consistency models for data changes but does not inherently enforce exactly-once processing for external downstream writes.\n\n## Key Concepts\n- Exactly-once processing patterns\n- Service Bus deduplication and sessions\n- Idempotent consumer design\n- Event-driven architecture trade-offs\n\n## Real-World Application\nUseful when integrating microservices that ingest events from a message broker and must avoid duplicate writes to a downstream data store, such as financial or inventory systems where duplicates have real consequences.","diagram":null,"difficulty":"intermediate","tags":["Azure","Kubernetes","Terraform","AWS","Service Bus","certification-mcq","domain-weight-25"],"channel":"azure-developer","subChannel":"develop-compute","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T20:22:20.149Z","createdAt":"2026-01-11 20:22:20"},{"id":"azure-developer-implement-security-1768202831629-0","question":"A web application runs in Azure App Service. To securely manage a credential used to call a third-party service, you want centralized storage, automatic rotation, and minimal exposure in code. Which approach best achieves this?","answer":"[{\"id\":\"a\",\"text\":\"Store the key in App Service Settings as a plain text value and rotate manually in the portal\",\"isCorrect\":false},{\"id\":\"b\",\"text\":\"Store the key in an Azure Key Vault and grant the app's managed identity read access to secrets; retrieve the key at runtime; enable versioned secrets for rotation\",\"isCorrect\":true},{\"id\":\"c\",\"text\":\"Store the key as a secret in a Kubernetes Secret used by the App Service container\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Embed the key in code and load it from a configuration file at runtime\",\"isCorrect\":false}]","explanation":"## Correct Answer\nOption B is correct because using Azure Key Vault with a managed identity provides centralized secret management, runtime retrieval, and secret versioning for rotation without embedding credentials in code or configuration. \n\n## Why Other Options Are Wrong\n- A: Storing in App Service settings exposes secrets in the portal and requires manual rotation, increasing risk. \n- C: Kubernetes Secrets are not appropriate for App Service deployments and can leak if not carefully managed. \n- D: Embedding secrets in code or config files ties rotation to code changes and risks exposure. \n\n## Key Concepts\n- Managed identities for Azure resources\n- Azure Key Vault secret management and versioning \n- Secret rotation without code changes \n\n## Real-World Application\nImplement a Key Vault, grant the App Service's identity Get/List on secrets, retrieve the secret at startup or per-call, and rotate the secret by creating a new version in Key Vault without touching the application code.","diagram":null,"difficulty":"intermediate","tags":["AzureSecurity","KeyVault","ManagedIdentity","Kubernetes","Terraform","AWS IAM","certification-mcq","domain-weight-20"],"channel":"azure-developer","subChannel":"implement-security","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T07:27:11.631Z","createdAt":"2026-01-12 07:27:12"},{"id":"azure-developer-implement-security-1768202831629-1","question":"To enforce that all new Storage Accounts use customer-managed keys (CMK) for encryption at rest, and to prevent non-compliant configurations, which approach provides the least friction while ensuring enforcement?","answer":"[{\"id\":\"a\",\"text\":\"Rely on Microsoft-managed keys for encryption by default and monitor for CMK usage\",\"isCorrect\":false},{\"id\":\"b\",\"text\":\"Create an Azure Policy that requires encryption with customer-managed keys and denies creation of storage accounts without a CMK\",\"isCorrect\":true},{\"id\":\"c\",\"text\":\"Audit storage accounts quarterly and remediate non-compliant ones manually\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Store CMKs in Key Vault and rotate them manually; apply changes after resource creation\",\"isCorrect\":false}]","explanation":"## Correct Answer\nOption B is correct because an Azure Policy can enforce CMK usage at creation time and deny non-compliant storage accounts, providing automatic, scalable enforcement across the subscription. \n\n## Why Other Options Are Wrong\n- A: Microsoft-managed keys do not enforce CMK usage and do not prevent non-compliant configurations. \n- C: Auditing without enforcement allows non-compliant resources to exist. \n- D: Manual rotation/remediation is error-prone and lacks scalable enforcement. \n\n## Key Concepts\n- Azure Policy for enforcement\n- Customer-managed keys in Key Vault for encryption at rest\n- Deny assignments to prevent non-compliant resource creation\n\n## Real-World Application\nDefine a policy initiative that requires CMK for storage accounts and assign it at the subscription level; configure remediation tasks to address non-compliant resources when detected.","diagram":null,"difficulty":"intermediate","tags":["AzureSecurity","KeyVault","AzurePolicy","Terraform","Kubernetes","AWS IAM","certification-mcq","domain-weight-20"],"channel":"azure-developer","subChannel":"implement-security","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T07:27:12.158Z","createdAt":"2026-01-12 07:27:12"},{"id":"azure-developer-implement-security-1768202831629-2","question":"In an AKS cluster, you need pods to access Azure Key Vault secrets without embedding credentials in Kubernetes manifests. Which approach best enables fine-grained, workload-scoped access from specific pods while avoiding secret leakage?","answer":"[{\"id\":\"a\",\"text\":\"Create a Kubernetes Secret containing a service principal and mount it to the pods\",\"isCorrect\":false},{\"id\":\"b\",\"text\":\"Use Azure AD Workload Identity Federation to map a Kubernetes service account to an Azure AD identity and grant it access to Key Vault\",\"isCorrect\":true},{\"id\":\"c\",\"text\":\"Attach a managed identity to the AKS node pool and share it across all pods to access Key Vault\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Embed the key in the application code and fetch it from Key Vault using a client secret\",\"isCorrect\":false}]","explanation":"## Correct Answer\nOption B is correct because Azure AD Workload Identity Federations (or Azure AD Pod Identity) enable Kubernetes service accounts to obtain short-lived tokens that grant pods scoped access to Key Vault, eliminating per-pod secret management. \n\n## Why Other Options Are Wrong\n- A: Kubernetes Secrets can be leaked or exposed in pod specs and are not ideal for dynamic workloads. \n- C: Node-scoped identities do not provide fine-grained, workload-level access control and are not principle-of-least-privilege. \n- D: Embedding secrets in code is insecure and breaks rotation guarantees. \n\n## Key Concepts\n- Azure AD Workload Identity Federation / Pod Identity\n- Fine-grained access control to Key Vault\n- Short-lived tokens and avoiding embedded secrets\n\n## Real-World Application\nConfigure a Kubernetes service account bound to an Azure identity, grant that identity a Key Vault access policy (or RBAC), and modify the pod deployment to use the bound service account so secrets are retrieved securely at runtime.","diagram":null,"difficulty":"intermediate","tags":["AzureSecurity","AKS","KeyVault","Kubernetes","Terraform","AWS IAM","certification-mcq","domain-weight-20"],"channel":"azure-developer","subChannel":"implement-security","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T07:27:12.672Z","createdAt":"2026-01-12 07:27:12"}],"subChannels":["develop-compute","implement-security"],"companies":[],"stats":{"total":6,"beginner":0,"intermediate":6,"advanced":0,"newThisWeek":6}}