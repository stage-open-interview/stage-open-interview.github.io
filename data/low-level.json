{"questions":[{"id":"q-684","question":"Design a fixed-size ring buffer in C that stores bytes. Capacity N is a power of two (e.g., 1024). Show how to compute the next index using a mask (idx & (N-1)), and explain full vs empty detection using only head and tail counters. Provide enqueue and dequeue logic for a single-producer/single-consumer scenario?","answer":"Use two indices: head and tail. Let mask = N-1. Enqueue: if ((head - tail) == N) return 0; data[head & mask] = value; head++; Dequeue: if (head == tail) return 0; *out = data[tail & mask]; tail++; Thi","explanation":"## Why This Is Asked\n\nTests understanding of a practical, low-level data structure and its wrap-around behavior, plus efficient empty/full checks in a simple producer/consumer path.\n\n## Key Concepts\n\n- Ring buffers\n- Power-of-two masking\n- Empty/full checks with head/tail without extra state\n- SPSC memory ordering\n\n## Code Example\n\n```c\ntypedef struct {\n  size_t head, tail;\n  unsigned char data[N];\n} Ring;\n\nint enqueue(Ring *r, unsigned char value) {\n  if ((r->head - r->tail) == N) return 0; // full\n  r->data[r->head & (N - 1)] = value;\n  r->head++;\n  return 1;\n}\nint dequeue(Ring *r, unsigned char *out) {\n  if (r->head == r->tail) return 0; // empty\n  *out = r->data[r->tail & (N - 1)];\n  r->tail++;\n  return 1;\n}\n```\n\n## Follow-up Questions\n\n- How would you modify for multi-producer/multi-consumer?\n- What memory-ordering considerations arise on weakly-ordered architectures?","diagram":"flowchart TD\n  A[Head/Tail] --> B[Mask: (N-1)]\n  B --> C[Enqueue path]\n  B --> D[Dequeue path]\n  C --> E[Increment Head]\n  D --> F[Increment Tail]\n  E --> G{Full?}\n  F --> H{Empty?}","difficulty":"beginner","tags":["low-level"],"channel":"low-level","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Hugging Face","Instacart"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T15:59:22.270Z","createdAt":"2026-01-11T15:59:22.270Z"},{"id":"q-692","question":"Design a lock-free ring buffer that supports multiple producers and multiple consumers with bounded capacity. Provide enqueue/dequeue pseudo-code, explain how you avoid ABA, how memory reclamation is handled (hazard pointers or epochs), and why it scales under high contention. Include caveats on cache lines and false sharing. How would you validate under stress?","answer":"Use a power-of-two ring buffer with per-slot sequence numbers, atomic head/tail, and CAS-based reservations. Producers CAS tail to claim a slot, consumers CAS head to advance. ABA avoided by sequence ","explanation":"## Why This Is Asked\n\nTests understanding of low-level concurrency, lock-free design under real contention.\n\n## Key Concepts\n\n- MPMC queue design\n- ABA protection\n- Memory reclamation (hazard pointers, epochs)\n- Cache friendliness\n\n## Code Example\n\n```javascript\n// Pseudo-code\nlet enqueue = (item) => {/* atomic reserve tail; write; commit */};\nlet dequeue = () => {/* atomic advance head; read; retire slot */};\n```\n\n## Follow-up Questions\n\n- How would you detect and recover from stalls under hot paths?\n- Compare hazard pointers vs epochs for this use-case.","diagram":null,"difficulty":"advanced","tags":["low-level"],"channel":"low-level","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Databricks","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T16:24:48.553Z","createdAt":"2026-01-11T16:24:48.553Z"}],"subChannels":["general"],"companies":["Anthropic","Databricks","Discord","Hugging Face","Instacart","Stripe"],"stats":{"total":2,"beginner":1,"intermediate":0,"advanced":1,"newThisWeek":2}}