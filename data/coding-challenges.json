[{"id":"cc39","title":"Missing Number Finder","description":"Given an array containing n distinct numbers from 0 to n, find the missing number. The array is unsorted and may contain any order of numbers. Exactly one number from the range 0 to n will be missing.","difficulty":"easy","category":"arrays","tags":["arrays","math"],"companies":["Databricks","Pinterest","Tesla","Snowflake"],"starterCode":{"javascript":"function findMissingNumber(nums) {\n  // Your code here\n}","python":"def find_missing_number(nums):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[3,0,1]","expectedOutput":"2","description":"Missing middle number"},{"id":"2","input":"[0]","expectedOutput":"1","description":"Single element array"},{"id":"3","input":"[9,6,4,2,3,5,7,0,1]","expectedOutput":"8","description":"Large array missing last number"},{"id":"4","input":"[]","expectedOutput":"0","description":"Empty array missing 0"}],"hints":["Use the mathematical formula for sum of first n natural numbers: n*(n+1)/2","Calculate expected sum minus actual sum to find missing number"],"solution":{"javascript":"function findMissingNumber(nums) {\n  const n = nums.length;\n  const expectedSum = n * (n + 1) / 2;\n  const actualSum = nums.reduce((sum, num) => sum + num, 0);\n  return expectedSum - actualSum;\n}","python":"def find_missing_number(nums):\n    n = len(nums)\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We traverse the array once to calculate the actual sum, giving O(n) time. We only use a few variables regardless of input size, giving O(1) space."},"timeLimit":15,"createdAt":"2025-12-22T04:54:05.366Z"},{"id":"cc50","title":"Array Alternating Sum","description":"Given an array of integers, calculate the alternating sum where you add elements at even indices and subtract elements at odd indices. Return the final result.","difficulty":"easy","category":"arrays","tags":["arrays","alternating-sum"],"companies":["Dropbox","PayPal"],"starterCode":{"javascript":"function alternatingSum(arr) {\n  // Your code here\n}","python":"def alternating_sum(arr):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1, 2, 3, 4, 5]","expectedOutput":"3","description":"Basic alternating sum: 1 - 2 + 3 - 4 + 5 = 3"},{"id":"2","input":"[10, -5, 8, -2]","expectedOutput":"25","description":"With negative numbers: 10 - (-5) + 8 - (-2) = 21"},{"id":"3","input":"[7]","expectedOutput":"7","description":"Single element at even index"},{"id":"4","input":"[]","expectedOutput":"0","description":"Empty array returns 0"}],"hints":["Iterate through the array and check if the index is even or odd","Use the modulo operator (%) to determine if an index is even or odd"],"solution":{"javascript":"function alternatingSum(arr) {\n  let result = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0) {\n      result += arr[i];\n    } else {\n      result -= arr[i];\n    }\n  }\n  return result;\n}","python":"def alternating_sum(arr):\n    result = 0\n    for i in range(len(arr)):\n        if i % 2 == 0:\n            result += arr[i]\n        else:\n            result -= arr[i]\n    return result"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We iterate through the array once, performing constant time operations for each element."},"timeLimit":15,"createdAt":"2025-12-22T06:32:33.573Z"},{"id":"cc55","title":"Merge Two Sorted Arrays In-Place","description":"Given two sorted integer arrays nums1 and nums2, where nums1 has enough space to hold all elements from nums2, merge nums2 into nums1 as a sorted array. The extra space in nums1 is filled with zeros. You must do this in O(1) extra space.\n\nConstraints:\n- 1 ≤ m, n ≤ 200\n- nums1.length = m + n\n- nums2.length = n\n- 0 ≤ nums1[i], nums2[j] ≤ 1000\n- Both arrays are initially sorted in non-decreasing order","difficulty":"easy","category":"arrays","tags":["arrays","two-pointers"],"companies":["Google","Uber","Airbnb"],"starterCode":{"javascript":"function mergeSorted(nums1, m, nums2, n) {\n  // Your code here\n}","python":"def merge_sorted(nums1, m, nums2, n):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[[1,2,3,0,0,0], 3, [2,5,6], 3]","expectedOutput":"[1,2,2,3,5,6]","description":"Basic merge"},{"id":"2","input":"[[1,0], 1, [2], 1]","expectedOutput":"[1,2]","description":"Single element each"},{"id":"3","input":"[[0], 0, [1], 1]","expectedOutput":"[1]","description":"Empty first array"},{"id":"4","input":"[[4,5,6,0,0,0], 3, [1,2,3], 3]","expectedOutput":"[1,2,3,4,5,6]","description":"All nums2 elements smaller"}],"hints":["Start merging from the end of both arrays to avoid overwriting elements","Use three pointers: one for the end of nums1's valid elements, one for nums2, and one for the final position"],"solution":{"javascript":"function mergeSorted(nums1, m, nums2, n) {\n  let i = m - 1;\n  let j = n - 1;\n  let k = m + n - 1;\n  \n  while (j >= 0) {\n    if (i >= 0 && nums1[i] > nums2[j]) {\n      nums1[k] = nums1[i];\n      i--;\n    } else {\n      nums1[k] = nums2[j];\n      j--;\n    }\n    k--;\n  }\n  \n  return nums1;\n}","python":"def merge_sorted(nums1, m, nums2, n):\n    i = m - 1\n    j = n - 1\n    k = m + n - 1\n    \n    while j >= 0:\n        if i >= 0 and nums1[i] > nums2[j]:\n            nums1[k] = nums1[i]\n            i -= 1\n        else:\n            nums1[k] = nums2[j]\n            j -= 1\n        k -= 1\n    \n    return nums1"},"complexity":{"time":"O(m + n)","space":"O(1)","explanation":"We traverse each array once with two pointers, using only constant extra space for the pointers."},"timeLimit":15,"createdAt":"2025-12-22T06:33:19.235Z"},{"id":"cc60","title":"Container With Most Water","description":"Given an array of positive integers representing heights of vertical lines drawn at each index position, find two lines that together with the x-axis form a container that holds the most water. Return the maximum amount of water the container can store.\n\nConstraints:\n- Array length is between 2 and 10^5\n- Each height is between 1 and 10^4\n- The distance between lines is the difference in their indices","difficulty":"easy","category":"arrays","tags":["arrays","two-pointers"],"companies":["Goldman Sachs","Coinbase","Google","SpaceX"],"starterCode":{"javascript":"function maxArea(heights) {\n  // Your code here\n}","python":"def max_area(heights):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1,8,6,2,5,4,8,3,7]","expectedOutput":"49","description":"Standard case with multiple peaks"},{"id":"2","input":"[1,1]","expectedOutput":"1","description":"Minimum array size"},{"id":"3","input":"[4,3,2,1,4]","expectedOutput":"16","description":"Symmetric heights"},{"id":"4","input":"[1,2,1]","expectedOutput":"2","description":"Small array with valley"}],"hints":["Use two pointers starting at the ends of the array","Move the pointer pointing to the shorter line inward","The area is calculated as: min(height[left], height[right]) * (right - left)"],"solution":{"javascript":"function maxArea(heights) {\n  let left = 0;\n  let right = heights.length - 1;\n  let maxWater = 0;\n  \n  while (left < right) {\n    const width = right - left;\n    const currentHeight = Math.min(heights[left], heights[right]);\n    maxWater = Math.max(maxWater, width * currentHeight);\n    \n    if (heights[left] < heights[right]) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n  \n  return maxWater;\n}","python":"def max_area(heights):\n    left = 0\n    right = len(heights) - 1\n    max_water = 0\n    \n    while left < right:\n        width = right - left\n        current_height = min(heights[left], heights[right])\n        max_water = max(max_water, width * current_height)\n        \n        if heights[left] < heights[right]:\n            left += 1\n        else:\n            right -= 1\n    \n    return max_water"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We traverse the array once with two pointers, using constant extra space."},"timeLimit":15,"createdAt":"2025-12-25T06:29:41.583Z"},{"id":"cc67","title":"Array Peak Finder","description":"Given an array of integers, find the number of peak elements. A peak element is an element that is greater than its immediate neighbors. The first and last elements have only one neighbor. Return the count of peak elements.\n\nConstraints:\n- Array length: 0 to 1000\n- Element values: -1000 to 1000\n- Time complexity: O(n)","difficulty":"easy","category":"arrays","tags":["arrays","peak-finding"],"companies":["Dropbox","Twitter","Two Sigma","Lyft"],"starterCode":{"javascript":"function countPeaks(arr) {\n  // Your code here\n}","python":"def count_peaks(arr):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1, 3, 2, 4, 1]","expectedOutput":"2","description":"Multiple peaks"},{"id":"2","input":"[5, 4, 3, 2, 1]","expectedOutput":"1","description":"Descending array"},{"id":"3","input":"[1, 2, 3, 4, 5]","expectedOutput":"1","description":"Ascending array"},{"id":"4","input":"[]","expectedOutput":"0","description":"Empty array"}],"hints":["Check first and last elements separately since they have only one neighbor","For middle elements, compare with both left and right neighbors"],"solution":{"javascript":"function countPeaks(arr) {\n  if (arr.length === 0) return 0;\n  let count = 0;\n  \n  // Check first element\n  if (arr.length === 1 || arr[0] > arr[1]) count++;\n  \n  // Check middle elements\n  for (let i = 1; i < arr.length - 1; i++) {\n    if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) count++;\n  }\n  \n  // Check last element\n  if (arr.length > 1 && arr[arr.length - 1] > arr[arr.length - 2]) count++;\n  \n  return count;\n}","python":"def count_peaks(arr):\n    if not arr:\n        return 0\n    \n    count = 0\n    \n    # Check first element\n    if len(arr) == 1 or arr[0] > arr[1]:\n        count += 1\n    \n    # Check middle elements\n    for i in range(1, len(arr) - 1):\n        if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:\n            count += 1\n    \n    # Check last element\n    if len(arr) > 1 and arr[-1] > arr[-2]:\n        count += 1\n    \n    return count"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We iterate through the array once, checking each element against its neighbors. No additional data structures are used."},"timeLimit":15,"createdAt":"2025-12-25T06:30:48.421Z"},{"id":"cc71","title":"Array Even Odd Separator","description":"Given an array of integers, separate them into two arrays: one containing all even numbers and one containing all odd numbers, while preserving the original order within each group. Return an object with 'even' and 'odd' keys containing the respective arrays.","difficulty":"easy","category":"arrays","tags":["arrays","separation"],"companies":["Anthropic","Goldman Sachs","Two Sigma","Lyft"],"starterCode":{"javascript":"function separateEvenOdd(arr) {\n  // Your code here\n}","python":"def separate_even_odd(arr):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1, 2, 3, 4, 5, 6]","expectedOutput":"{\"even\": [2, 4, 6], \"odd\": [1, 3, 5]}","description":"Mixed numbers"},{"id":"2","input":"[]","expectedOutput":"{\"even\": [], \"odd\": []}","description":"Empty array"},{"id":"3","input":"[2, 4, 6, 8]","expectedOutput":"{\"even\": [2, 4, 6, 8], \"odd\": []}","description":"All even"},{"id":"4","input":"[1, 3, 5, 7]","expectedOutput":"{\"even\": [], \"odd\": [1, 3, 5, 7]}","description":"All odd"}],"hints":["Iterate through the array once, checking each number's parity","Use modulo operator (%) to determine if a number is even or odd"],"solution":{"javascript":"function separateEvenOdd(arr) {\n  const result = { even: [], odd: [] };\n  for (const num of arr) {\n    if (num % 2 === 0) {\n      result.even.push(num);\n    } else {\n      result.odd.push(num);\n    }\n  }\n  return result;\n}","python":"def separate_even_odd(arr):\n    result = {'even': [], 'odd': []}\n    for num in arr:\n        if num % 2 == 0:\n            result['even'].append(num)\n        else:\n            result['odd'].append(num)\n    return result"},"complexity":{"time":"O(n)","space":"O(n)","explanation":"We iterate through the array once and store elements in separate arrays"},"timeLimit":15,"createdAt":"2025-12-25T06:31:16.804Z"},{"id":"cc73","title":"Array Adjacent Difference Calculator","description":"Given an array of integers, calculate the sum of absolute differences between all adjacent elements. For an array with less than 2 elements, return 0. Constraints: 1 ≤ array length ≤ 10^5, -10^9 ≤ element ≤ 10^9.","difficulty":"easy","category":"arrays","tags":["arrays","math"],"companies":["Pinterest","Coinbase","Google"],"starterCode":{"javascript":"function solve(arr) {\n  // Your code here\n}","python":"def solve(arr):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1, 3, 2, 5]","expectedOutput":"6","description":"Normal case"},{"id":"2","input":"[10]","expectedOutput":"0","description":"Single element"},{"id":"3","input":"[]","expectedOutput":"0","description":"Empty array"},{"id":"4","input":"[-5, 0, 5, -10]","expectedOutput":"25","description":"Negative numbers"}],"hints":["Iterate through the array once, calculating absolute difference between each pair of adjacent elements","Use Math.abs() in JavaScript or abs() in Python for absolute values"],"solution":{"javascript":"function solve(arr) {\n  let sum = 0;\n  for (let i = 1; i < arr.length; i++) {\n    sum += Math.abs(arr[i] - arr[i - 1]);\n  }\n  return sum;\n}","python":"def solve(arr):\n    total = 0\n    for i in range(1, len(arr)):\n        total += abs(arr[i] - arr[i - 1])\n    return total"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"Single pass through array with constant extra space"},"timeLimit":15,"createdAt":"2025-12-25T14:58:48.788Z"},{"id":"cc15","title":"Maximum Subarray Sum with One Deletion","description":"Given an array of integers, you can delete exactly one element from the array. Return the maximum possible sum of a non-empty subarray after deleting at most one element. A subarray is a contiguous sequence of elements.\n\nConstraints:\n- 1 <= arr.length <= 10^5\n- -10^4 <= arr[i] <= 10^4\n- The array contains at least one positive number","difficulty":"medium","category":"arrays","tags":["arrays","dynamic programming","subarray"],"companies":["Databricks","Twitter","Two Sigma"],"starterCode":{"javascript":"function maxSumWithOneDeletion(arr) {\n  // Your code here\n  \n}","python":"def max_sum_with_one_deletion(arr):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1,2,3,4,5]","expectedOutput":"15","description":"All positive numbers - no deletion needed"},{"id":"2","input":"[1,-2,0,3]","expectedOutput":"4","description":"Delete -2 to maximize sum"},{"id":"3","input":"[-1,-1,-1,-1]","expectedOutput":"-1","description":"All negative numbers - delete one element"},{"id":"4","input":"[1,-1,5,-2,3]","expectedOutput":"8","description":"Delete -2 to get max subarray [1,-1,5,3]"}],"hints":["Use dynamic programming to track max sums ending at each position","Consider two states: max sum without deletion and max sum with one deletion","The answer is the maximum of both states across all positions"],"solution":{"javascript":"function maxSumWithOneDeletion(arr) {\n  const n = arr.length;\n  const dpNoDelete = new Array(n);\n  const dpOneDelete = new Array(n);\n  \n  dpNoDelete[0] = arr[0];\n  dpOneDelete[0] = -Infinity;\n  \n  let result = arr[0];\n  \n  for (let i = 1; i < n; i++) {\n    dpNoDelete[i] = Math.max(arr[i], dpNoDelete[i-1] + arr[i]);\n    dpOneDelete[i] = Math.max(dpNoDelete[i-1], dpOneDelete[i-1] + arr[i]);\n    result = Math.max(result, dpNoDelete[i], dpOneDelete[i]);\n  }\n  \n  return result;\n}","python":"def max_sum_with_one_deletion(arr):\n    n = len(arr)\n    dp_no_delete = [0] * n\n    dp_one_delete = [0] * n\n    \n    dp_no_delete[0] = arr[0]\n    dp_one_delete[0] = float('-inf')\n    \n    result = arr[0]\n    \n    for i in range(1, n):\n        dp_no_delete[i] = max(arr[i], dp_no_delete[i-1] + arr[i])\n        dp_one_delete[i] = max(dp_no_delete[i-1], dp_one_delete[i-1] + arr[i])\n        result = max(result, dp_no_delete[i], dp_one_delete[i])\n    \n    return result"},"complexity":{"time":"O(n)","space":"O(n)","explanation":"We iterate through the array once, maintaining two DP arrays for states with and without deletion"},"timeLimit":15,"createdAt":"2025-12-20T09:45:57.338Z"},{"id":"cc45","title":"Array Partition Maximum Sum","description":"Given an array of integers, partition it into pairs such that the sum of the minimum of each pair is maximized. Return the maximum possible sum.\n\nConstraints:\n- Array length is even (2 ≤ n ≤ 10^5)\n- -10^4 ≤ arr[i] ≤ 10^4\n- Must partition all elements into pairs","difficulty":"medium","category":"arrays","tags":["arrays","sorting","greedy"],"companies":["Snap","Meta"],"starterCode":{"javascript":"function maxPairSum(arr) {\n  // Your code here\n}","python":"def max_pair_sum(arr):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1,4,3,2]","expectedOutput":"4","description":"Basic case"},{"id":"2","input":"[6,2,6,5,1,2]","expectedOutput":"9","description":"Mixed values"},{"id":"3","input":"[-1,-2,-3,-4]","expectedOutput":"-6","description":"All negative"},{"id":"4","input":"[100,100,1,1]","expectedOutput":"101","description":"Large difference"}],"hints":["Sort the array first to optimize pair formation","Consider pairing adjacent elements after sorting"],"solution":{"javascript":"function maxPairSum(arr) {\n  arr.sort((a,b) => a - b);\n  let sum = 0;\n  for (let i = 0; i < arr.length; i += 2) {\n    sum += arr[i];\n  }\n  return sum;\n}","python":"def max_pair_sum(arr):\n    arr.sort()\n    return sum(arr[i] for i in range(0, len(arr), 2))"},"complexity":{"time":"O(n log n)","space":"O(1)","explanation":"Sorting dominates time complexity, we use constant extra space"},"timeLimit":15,"createdAt":"2025-12-22T06:31:51.771Z"},{"id":"cc59","title":"Array Zigzag Maximum Sum","description":"Given an array of integers, find the maximum sum of a subsequence where elements alternate between increasing and decreasing. The subsequence must follow the pattern: arr[i1] < arr[i2] > arr[i3] < arr[i4] > arr[i5]... or arr[i1] > arr[i2] < arr[i3] > arr[i4] < arr[i5]... Return the maximum possible sum of such a zigzag subsequence. If no valid zigzag subsequence exists (array has fewer than 2 elements), return 0.","difficulty":"medium","category":"arrays","tags":["arrays","dynamic-programming","subsequence"],"companies":["Google","SpaceX"],"starterCode":{"javascript":"function zigzagMaxSum(arr) {\n  // Your code here\n}","python":"def zigzag_max_sum(arr):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1, 7, 4, 9, 2, 5]","expectedOutput":"27","description":"Perfect zigzag sequence"},{"id":"2","input":"[1, 2, 3, 4, 5]","expectedOutput":"5","description":"Monotonic increasing array"},{"id":"3","input":"[5, 4, 3, 2, 1]","expectedOutput":"4","description":"Monotonic decreasing array"},{"id":"4","input":"[1]","expectedOutput":"0","description":"Single element"},{"id":"5","input":"[]","expectedOutput":"0","description":"Empty array"}],"hints":["Use dynamic programming with two states: up[i] and down[i] representing maximum zigzag sum ending at index i with last movement being up or down.","For each element, consider all previous elements to build the zigzag pattern based on comparison.","The answer is the maximum value from both up and down arrays."],"solution":{"javascript":"function zigzagMaxSum(arr) {\n  const n = arr.length;\n  if (n < 2) return 0;\n  \n  const up = new Array(n).fill(0);\n  const down = new Array(n).fill(0);\n  \n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < i; j++) {\n      if (arr[i] > arr[j]) {\n        up[i] = Math.max(up[i], down[j] + arr[i]);\n      } else if (arr[i] < arr[j]) {\n        down[i] = Math.max(down[i], up[j] + arr[i]);\n      }\n    }\n  }\n  \n  return Math.max(...up, ...down);\n}","python":"def zigzag_max_sum(arr):\n    n = len(arr)\n    if n < 2:\n        return 0\n    \n    up = [0] * n\n    down = [0] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                up[i] = max(up[i], down[j] + arr[i])\n            elif arr[i] < arr[j]:\n                down[i] = max(down[i], up[j] + arr[i])\n    \n    return max(max(up), max(down))"},"complexity":{"time":"O(n²)","space":"O(n)","explanation":"We use nested loops to compare each element with all previous elements, and maintain two DP arrays of size n."},"timeLimit":15,"createdAt":"2025-12-25T06:29:34.828Z"},{"id":"cc63","title":"Array Element Frequency Counter","description":"Given an array of integers, find the element that appears most frequently. If there's a tie, return the smallest element. If the array is empty, return null.\n\nConstraints:\n- Array length: 0 to 10^5\n- Element values: -10^9 to 10^9\n- Must handle ties by returning the smallest value","difficulty":"medium","category":"arrays","tags":["arrays","hashing","frequency"],"companies":["Twitter","Anthropic","Bloomberg"],"starterCode":{"javascript":"function findMostFrequent(arr) {\n  // Your code here\n}","python":"def find_most_frequent(arr):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1,2,2,3,3,3,4]","expectedOutput":"3","description":"Basic frequency"},{"id":"2","input":"[5,5,6,6,7,7]","expectedOutput":"5","description":"Tie - return smallest"},{"id":"3","input":"[]","expectedOutput":"null","description":"Empty array"},{"id":"4","input":"[-1,-1,0,1,2,2,2]","expectedOutput":"2","description":"Negative numbers and tie"}],"hints":["Use a hash map/dictionary to count frequencies","Track both max frequency and smallest element during iteration"],"solution":{"javascript":"function findMostFrequent(arr) {\n  if (arr.length === 0) return null;\n  \n  const freq = new Map();\n  let maxFreq = 0;\n  let result = Infinity;\n  \n  for (const num of arr) {\n    const count = (freq.get(num) || 0) + 1;\n    freq.set(num, count);\n    \n    if (count > maxFreq || (count === maxFreq && num < result)) {\n      maxFreq = count;\n      result = num;\n    }\n  }\n  \n  return result;\n}","python":"def find_most_frequent(arr):\n    if not arr:\n        return None\n    \n    freq = {}\n    max_freq = 0\n    result = float('inf')\n    \n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n        \n        if freq[num] > max_freq or (freq[num] == max_freq and num < result):\n            max_freq = freq[num]\n            result = num\n    \n    return result"},"complexity":{"time":"O(n)","space":"O(n)","explanation":"We iterate through the array once, using a hash map to store frequencies. The hash map stores at most n unique elements."},"timeLimit":15,"createdAt":"2025-12-25T06:30:00.879Z"},{"id":"cc72","title":"Array Balance Point Finder","description":"Given an array of integers, find an index where the sum of elements to the left equals the sum of elements to the right. Return the smallest such index, or -1 if none exists. The element at the balance point is not included in either sum.","difficulty":"medium","category":"arrays","tags":["arrays","prefix-sum"],"companies":["Databricks","Netflix"],"starterCode":{"javascript":"function findBalanceIndex(arr) {\n  // Your code here\n}","python":"def find_balance_index(arr):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1, 2, 3, 4, 6]","expectedOutput":"3","description":"Balance at index 3 (1+2+3 = 6)"},{"id":"2","input":"[1, 2, 3]","expectedOutput":"-1","description":"No balance point exists"},{"id":"3","input":"[0, 0, 0, 0]","expectedOutput":"0","description":"Multiple balance points, return smallest"},{"id":"4","input":"[10]","expectedOutput":"0","description":"Single element is balanced"}],"hints":["Use prefix sums to calculate left and right sums efficiently","Total sum minus current element minus left sum gives right sum"],"solution":{"javascript":"function findBalanceIndex(arr) {\n  const totalSum = arr.reduce((sum, num) => sum + num, 0);\n  let leftSum = 0;\n  \n  for (let i = 0; i < arr.length; i++) {\n    const rightSum = totalSum - leftSum - arr[i];\n    if (leftSum === rightSum) {\n      return i;\n    }\n    leftSum += arr[i];\n  }\n  return -1;\n}","python":"def find_balance_index(arr):\n    total_sum = sum(arr)\n    left_sum = 0\n    \n    for i in range(len(arr)):\n        right_sum = total_sum - left_sum - arr[i]\n        if left_sum == right_sum:\n            return i\n        left_sum += arr[i]\n    return -1"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"Single pass with constant extra space using prefix sum technique"},"timeLimit":15,"createdAt":"2025-12-25T06:31:29.943Z"},{"id":"cc28","title":"Fibonacci Steps","description":"You are climbing a staircase that has n steps. You can take either 1 step or 2 steps at a time. Return the number of distinct ways to reach the top of the staircase.\n\nConstraints:\n- 0 <= n <= 45\n- The answer should fit in a 32-bit integer","difficulty":"easy","category":"dynamic-programming","tags":["dynamic-programming","math","recursion"],"companies":["Anthropic","Twitter"],"starterCode":{"javascript":"function climbStairs(n) {\n  // Your code here\n}","python":"def climb_stairs(n):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"2","expectedOutput":"2","description":"Two steps - can take 1+1 or 2"},{"id":"2","input":"3","expectedOutput":"3","description":"Three steps - 1+1+1, 1+2, or 2+1"},{"id":"3","input":"0","expectedOutput":"1","description":"Zero steps - one way (stay at bottom)"},{"id":"4","input":"1","expectedOutput":"1","description":"One step - only one way"}],"hints":["Think about the relationship between ways(n) and ways(n-1) and ways(n-2)","This follows the Fibonacci pattern where each step builds on previous results"],"solution":{"javascript":"function climbStairs(n) {\n  if (n <= 1) return 1;\n  let prev = 1, curr = 1;\n  for (let i = 2; i <= n; i++) {\n    let next = prev + curr;\n    prev = curr;\n    curr = next;\n  }\n  return curr;\n}","python":"def climb_stairs(n):\n    if n <= 1:\n        return 1\n    prev, curr = 1, 1\n    for i in range(2, n + 1):\n        prev, curr = curr, prev + curr\n    return curr"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We iterate through each step once, using constant space to track only the previous two values"},"timeLimit":10,"createdAt":"2025-12-21T09:16:14.723Z"},{"id":"cc38","title":"House Robber Path","description":"You are a robber planning to rob houses along a street. Each house has a certain amount of money stashed. However, adjacent houses have security systems connected and you cannot rob two adjacent houses. Given an array of non-negative integers representing the amount of money in each house, return the maximum amount of money you can rob tonight.\n\nConstraints:\n- 0 <= nums.length <= 10^4\n- 0 <= nums[i] <= 10^3","difficulty":"easy","category":"dynamic-programming","tags":["dynamic-programming","array"],"companies":["Lyft","Tesla","Pinterest","Robinhood"],"starterCode":{"javascript":"function rob(nums) {\n  // Your code here\n}","python":"def rob(nums):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1,2,3,1]","expectedOutput":"4","description":"Basic case"},{"id":"2","input":"[2,7,9,3,1]","expectedOutput":"12","description":"Longer array"},{"id":"3","input":"[]","expectedOutput":"0","description":"Empty array"},{"id":"4","input":"[5]","expectedOutput":"5","description":"Single house"}],"hints":["Use dynamic programming: dp[i] = max(dp[i-1], dp[i-2] + nums[i])","You only need the previous two values, not the entire array"],"solution":{"javascript":"function rob(nums) {\n  if (nums.length === 0) return 0;\n  if (nums.length === 1) return nums[0];\n  \n  let prev2 = 0;\n  let prev1 = nums[0];\n  \n  for (let i = 1; i < nums.length; i++) {\n    const current = Math.max(prev1, prev2 + nums[i]);\n    prev2 = prev1;\n    prev1 = current;\n  }\n  \n  return prev1;\n}","python":"def rob(nums):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    prev2 = 0\n    prev1 = nums[0]\n    \n    for i in range(1, len(nums)):\n        current = max(prev1, prev2 + nums[i])\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We iterate through the array once, maintaining only two previous values"},"timeLimit":10,"createdAt":"2025-12-21T09:22:15.954Z"},{"id":"cc5","title":"Climbing Stairs","description":"You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Constraints: 1 <= n <= 45.","difficulty":"easy","category":"dynamic-programming","tags":["dynamic-programming","fibonacci","math"],"companies":["Pinterest","Morgan Stanley","Palantir","Amazon"],"starterCode":{"javascript":"function climbStairs(n) {\n  // Your code here\n  \n}","python":"def climb_stairs(n):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"2","expectedOutput":"2","description":"Two steps: 1+1 or 2"},{"id":"2","input":"3","expectedOutput":"3","description":"Three steps: 1+1+1, 1+2, or 2+1"},{"id":"3","input":"1","expectedOutput":"1","description":"Single step: only one way"},{"id":"4","input":"5","expectedOutput":"8","description":"Five steps: fibonacci sequence"}],"hints":["Think about the relationship between ways(n) and ways(n-1), ways(n-2)","This follows the Fibonacci pattern","You can solve it iteratively with O(1) space"],"solution":{"javascript":"function climbStairs(n) {\n  if (n <= 2) return n;\n  \n  let prev1 = 1;\n  let prev2 = 2;\n  \n  for (let i = 3; i <= n; i++) {\n    const current = prev1 + prev2;\n    prev1 = prev2;\n    prev2 = current;\n  }\n  \n  return prev2;\n}","python":"def climb_stairs(n):\n    if n <= 2:\n        return n\n    \n    prev1, prev2 = 1, 2\n    \n    for i in range(3, n + 1):\n        current = prev1 + prev2\n        prev1, prev2 = prev2, current\n    \n    return prev2"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We iterate through each step once, storing only the previous two values"},"timeLimit":10,"createdAt":"2025-12-20T09:39:58.780Z"},{"id":"cc61","title":"Jump Game Minimum Energy","description":"You are given an array where each element represents the maximum jump length from that position. You need to find the minimum total energy required to reach the end of the array. The energy cost for each jump is equal to the distance jumped. Return the minimum total energy needed to reach the last index, or -1 if it's impossible.\n\nConstraints:\n- 1 ≤ nums.length ≤ 1000\n- 0 ≤ nums[i] ≤ 100\n- If you're already at the last index, return 0\n- If you can't reach the end, return -1","difficulty":"easy","category":"dynamic-programming","tags":["dynamic-programming","greedy","arrays"],"companies":["LinkedIn","Anthropic"],"starterCode":{"javascript":"function minJumpEnergy(nums) {\n  // Your code here\n}","python":"def min_jump_energy(nums):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[2,3,1,1,4]","expectedOutput":"4","description":"Basic reachable case"},{"id":"2","input":"[3,2,1,0,4]","expectedOutput":"-1","description":"Unreachable case"},{"id":"3","input":"[1,1,1,1]","expectedOutput":"3","description":"Single step jumps"},{"id":"4","input":"[0]","expectedOutput":"0","description":"Single element"}],"hints":["Use dynamic programming to track minimum energy to reach each position","For each position, consider all possible jumps from previous positions","If a position remains unreachable (infinity), the end is impossible"],"solution":{"javascript":"function minJumpEnergy(nums) {\n  const n = nums.length;\n  if (n === 1) return 0;\n  \n  const dp = new Array(n).fill(Infinity);\n  dp[0] = 0;\n  \n  for (let i = 0; i < n; i++) {\n    if (dp[i] === Infinity) continue;\n    \n    const maxJump = nums[i];\n    for (let j = 1; j <= maxJump && i + j < n; j++) {\n      dp[i + j] = Math.min(dp[i + j], dp[i] + j);\n    }\n  }\n  \n  return dp[n - 1] === Infinity ? -1 : dp[n - 1];\n}","python":"def min_jump_energy(nums):\n    n = len(nums)\n    if n == 1:\n        return 0\n    \n    dp = [float('inf')] * n\n    dp[0] = 0\n    \n    for i in range(n):\n        if dp[i] == float('inf'):\n            continue\n            \n        max_jump = nums[i]\n        for j in range(1, min(max_jump + 1, n - i)):\n            dp[i + j] = min(dp[i + j], dp[i] + j)\n    \n    return -1 if dp[-1] == float('inf') else dp[-1]"},"complexity":{"time":"O(n²)","space":"O(n)","explanation":"We use nested loops where the outer loop runs n times and the inner loop runs at most n times in the worst case. The DP array uses O(n) space."},"timeLimit":15,"createdAt":"2025-12-25T06:29:49.075Z"},{"id":"cc1","title":"Maximum Sum Subsequence","description":"Given an array of integers, find the maximum sum of a subsequence such that no two elements in the subsequence are adjacent in the original array. A subsequence is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.\n\nConstraints:\n- 1 ≤ nums.length ≤ 10^5\n- -10^4 ≤ nums[i] ≤ 10^4\n- The array may contain negative numbers","difficulty":"medium","category":"dynamic-programming","tags":["dynamic-programming","array","subsequence"],"companies":["Lyft","LinkedIn"],"starterCode":{"javascript":"function maxSumSubsequence(nums) {\n  // Your code here\n  \n}","python":"def max_sum_subsequence(nums):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[3,2,5,10,7]","expectedOutput":"15","description":"Basic case with positive numbers"},{"id":"2","input":"[3,2,7,10]","expectedOutput":"13","description":"Choose non-adjacent elements"},{"id":"3","input":"[-1,-2,-3,-4]","expectedOutput":"0","description":"All negative numbers - choose empty subsequence"},{"id":"4","input":"[5,5,10,100,10,5]","expectedOutput":"110","description":"Mixed values with optimal non-adjacent selection"}],"hints":["Consider the maximum sum up to each position","Think about whether to include or exclude the current element","Use two variables to track previous states"],"solution":{"javascript":"function maxSumSubsequence(nums) {\n  if (nums.length === 0) return 0;\n  \n  let include = Math.max(0, nums[0]);\n  let exclude = 0;\n  \n  for (let i = 1; i < nums.length; i++) {\n    const newInclude = exclude + Math.max(0, nums[i]);\n    const newExclude = Math.max(include, exclude);\n    \n    include = newInclude;\n    exclude = newExclude;\n  }\n  \n  return Math.max(include, exclude);\n}","python":"def max_sum_subsequence(nums):\n    if not nums:\n        return 0\n    \n    include = max(0, nums[0])\n    exclude = 0\n    \n    for i in range(1, len(nums)):\n        new_include = exclude + max(0, nums[i])\n        new_exclude = max(include, exclude)\n        \n        include = new_include\n        exclude = new_exclude\n    \n    return max(include, exclude)"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We iterate through the array once, using constant space to track the maximum sums when including or excluding each element."},"timeLimit":15,"createdAt":"2025-12-20T09:39:31.993Z"},{"id":"cc16","title":"Maximum Sum of Non-Adjacent Elements","description":"Given an array of integers, return the maximum sum of non-adjacent elements. You cannot pick two elements that are next to each other in the array. If all numbers are negative, return 0 (empty subarray). Constraints: 1 ≤ nums.length ≤ 10^4, -10^3 ≤ nums[i] ≤ 10^3.","difficulty":"medium","category":"dynamic-programming","tags":["dynamic-programming","array","greedy"],"companies":["Microsoft","MongoDB","Amazon"],"starterCode":{"javascript":"function maxNonAdjacentSum(nums) {\n  // Your code here\n  \n}","python":"def max_non_adjacent_sum(nums):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[2,7,9,3,1]","expectedOutput":"12","description":"Basic case with positive numbers"},{"id":"2","input":"[-1,-2,-3]","expectedOutput":"0","description":"All negative numbers"},{"id":"3","input":"[5]","expectedOutput":"5","description":"Single element"},{"id":"4","input":"[3,2,5,10,7]","expectedOutput":"15","description":"Mixed positive numbers"}],"hints":["Think about the maximum sum you can get up to each position","Consider using two variables to track previous states","The optimal solution uses dynamic programming with O(1) space"],"solution":{"javascript":"function maxNonAdjacentSum(nums) {\n  if (nums.length === 0) return 0;\n  \n  let prev1 = 0; // max sum up to i-1\n  let prev2 = 0; // max sum up to i-2\n  \n  for (let num of nums) {\n    const current = Math.max(prev1, prev2 + Math.max(0, num));\n    prev2 = prev1;\n    prev1 = current;\n  }\n  \n  return prev1;\n}","python":"def max_non_adjacent_sum(nums):\n    if not nums:\n        return 0\n    \n    prev1 = 0  # max sum up to i-1\n    prev2 = 0  # max sum up to i-2\n    \n    for num in nums:\n        current = max(prev1, prev2 + max(0, num))\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We iterate through the array once, using constant space to track previous states"},"timeLimit":15,"createdAt":"2025-12-20T09:46:04.273Z"},{"id":"cc56","title":"Energy Grid Optimization","description":"Given an array representing energy production values at different time intervals, find the maximum total energy that can be collected while never collecting from two consecutive intervals. This simulates optimizing energy collection in a smart grid where maintenance periods are required between collection periods.\n\nConstraints: 1 ≤ n ≤ 10^5, 0 ≤ energy[i] ≤ 10^3","difficulty":"medium","category":"dynamic-programming","tags":["dynamic-programming","arrays","optimization"],"companies":["Tesla","Dropbox"],"starterCode":{"javascript":"function maxEnergyCollection(energy) {\n  // Your code here\n}","python":"def max_energy_collection(energy):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[3, 2, 5, 10, 7]","expectedOutput":"15","description":"Basic case - choose 3, 5, 7"},{"id":"2","input":"[3, 2, 7, 10]","expectedOutput":"13","description":"Choose 3, 10"},{"id":"3","input":"[5, 5, 10, 100, 10, 5]","expectedOutput":"110","description":"Choose 5, 100, 5"},{"id":"4","input":"[]","expectedOutput":"0","description":"Empty array"}],"hints":["Use dynamic programming: dp[i] represents max energy up to index i","At each position, you can either take current value + dp[i-2] or skip and take dp[i-1]"],"solution":{"javascript":"function maxEnergyCollection(energy) {\n  if (energy.length === 0) return 0;\n  if (energy.length === 1) return energy[0];\n  \n  let prev2 = energy[0];\n  let prev1 = Math.max(energy[0], energy[1]);\n  \n  for (let i = 2; i < energy.length; i++) {\n    let current = Math.max(prev1, prev2 + energy[i]);\n    prev2 = prev1;\n    prev1 = current;\n  }\n  \n  return prev1;\n}","python":"def max_energy_collection(energy):\n    if not energy:\n        return 0\n    if len(energy) == 1:\n        return energy[0]\n    \n    prev2 = energy[0]\n    prev1 = max(energy[0], energy[1])\n    \n    for i in range(2, len(energy)):\n        current = max(prev1, prev2 + energy[i])\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"Single pass through array with constant space for DP state"},"timeLimit":15,"createdAt":"2025-12-23T15:23:43.860Z"},{"id":"cc3","title":"First Unique Character","description":"Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1. The string contains only lowercase English letters. Length of s is between 1 and 10^5.","difficulty":"easy","category":"hash-maps","tags":["hash-maps","string","counting"],"companies":["Amazon","Dropbox"],"starterCode":{"javascript":"function firstUniqueChar(s) {\n  // Your code here\n  \n}","python":"def first_unique_char(s):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"\"leetcode\"","expectedOutput":"0","description":"First character is unique"},{"id":"2","input":"\"loveleetcode\"","expectedOutput":"2","description":"Unique character in middle"},{"id":"3","input":"\"aabb\"","expectedOutput":"-1","description":"No unique characters"},{"id":"4","input":"\"z\"","expectedOutput":"0","description":"Single character"}],"hints":["Count the frequency of each character first","Use a hash map to store character counts","Iterate through the string again to find the first character with count 1"],"solution":{"javascript":"function firstUniqueChar(s) {\n  const count = {};\n  \n  // Count frequency of each character\n  for (let char of s) {\n    count[char] = (count[char] || 0) + 1;\n  }\n  \n  // Find first character with count 1\n  for (let i = 0; i < s.length; i++) {\n    if (count[s[i]] === 1) {\n      return i;\n    }\n  }\n  \n  return -1;\n}","python":"def first_unique_char(s):\n    count = {}\n    \n    # Count frequency of each character\n    for char in s:\n        count[char] = count.get(char, 0) + 1\n    \n    # Find first character with count 1\n    for i, char in enumerate(s):\n        if count[char] == 1:\n            return i\n    \n    return -1"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We make two passes through the string. The hash map stores at most 26 lowercase letters, so space is constant."},"timeLimit":10,"createdAt":"2025-12-20T09:39:44.814Z"},{"id":"cc49","title":"Find Most Frequent Element","description":"Given an array of integers, find the element that appears most frequently. If there are multiple elements with the same highest frequency, return the smallest one. The array will contain at least one element.","difficulty":"easy","category":"hash-maps","tags":["hash-maps","frequency-counting"],"companies":["Two Sigma","Amazon","Lyft"],"starterCode":{"javascript":"function mostFrequent(arr) {\n  // Your code here\n}","python":"def most_frequent(arr):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1,2,2,3,3,3]","expectedOutput":"3","description":"Basic case with clear winner"},{"id":"2","input":"[4,4,5,5]","expectedOutput":"4","description":"Tie case - return smaller element"},{"id":"3","input":"[7]","expectedOutput":"7","description":"Single element"},{"id":"4","input":"[-1,-1,0,1,1]","expectedOutput":"-1","description":"Negative numbers with tie"}],"hints":["Use a hash map to count frequencies of each element","Track the most frequent element and its count while iterating","When frequencies tie, compare the actual values"],"solution":{"javascript":"function mostFrequent(arr) {\n  const freq = {};\n  let maxCount = 0;\n  let result = arr[0];\n  \n  for (const num of arr) {\n    freq[num] = (freq[num] || 0) + 1;\n    \n    if (freq[num] > maxCount || \n        (freq[num] === maxCount && num < result)) {\n      maxCount = freq[num];\n      result = num;\n    }\n  }\n  \n  return result;\n}","python":"def most_frequent(arr):\n    freq = {}\n    max_count = 0\n    result = arr[0]\n    \n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n        \n        if freq[num] > max_count or (freq[num] == max_count and num < result):\n            max_count = freq[num]\n            result = num\n    \n    return result"},"complexity":{"time":"O(n)","space":"O(n)","explanation":"We iterate through the array once, using a hash map to store frequencies. The hash map size is proportional to the number of unique elements."},"timeLimit":15,"createdAt":"2025-12-22T06:32:26.639Z"},{"id":"cc57","title":"Find Pair Sum","description":"Given an array of integers and a target sum, find two distinct numbers that add up to the target. Return their indices as an array. If no such pair exists, return an empty array. Each input has exactly one solution or none.\n\nConstraints:\n- Array length: 2 to 10^4\n- Values: -10^9 to 10^9\n- Target: -10^9 to 10^9\n- Use same element only once","difficulty":"easy","category":"hash-maps","tags":["hash-maps","arrays","two-sum"],"companies":["Apple","Meta"],"starterCode":{"javascript":"function findPairSum(nums, target) {\n  // Your code here\n}","python":"def find_pair_sum(nums, target):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[2,7,11,15], 9","expectedOutput":"[0, 1]","description":"Basic positive numbers"},{"id":"2","input":"[3,2,4], 6","expectedOutput":"[1, 2]","description":"Middle elements"},{"id":"3","input":"[3,3], 6","expectedOutput":"[0, 1]","description":"Duplicate values"},{"id":"4","input":"[1,2,3,4,5], 10","expectedOutput":"[]","description":"No solution"}],"hints":["Use a hash map to store numbers and their indices","For each number, check if target - current exists in the map"],"solution":{"javascript":"function findPairSum(nums, target) {\n  const map = new Map();\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    if (map.has(complement)) {\n      return [map.get(complement), i];\n    }\n    map.set(nums[i], i);\n  }\n  return [];\n}","python":"def find_pair_sum(nums, target):\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []"},"complexity":{"time":"O(n)","space":"O(n)","explanation":"Single pass through array with hash map lookups"},"timeLimit":15,"createdAt":"2025-12-25T06:29:17.458Z"},{"id":"cc62","title":"Find First Repeating Character","description":"Given a string, find the first character that appears more than once. Return the character or null if no character repeats. The search should be case-sensitive and consider the order of first occurrence.","difficulty":"easy","category":"hash-maps","tags":["hash-maps","strings","iteration"],"companies":["Meta","Twitter"],"starterCode":{"javascript":"function findFirstRepeating(s) {\n  // Your code here\n}","python":"def find_first_repeating(s):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"\"abca\"","expectedOutput":"\"a\"","description":"Basic case with repeating character"},{"id":"2","input":"\"abcdef\"","expectedOutput":"null","description":"No repeating characters"},{"id":"3","input":"\"abcbda\"","expectedOutput":"\"a\"","description":"Multiple repeats, find first by position"},{"id":"4","input":"\"\"","expectedOutput":"null","description":"Empty string"}],"hints":["Use a hash map to track character counts","Iterate through the string to build counts, then find first character with count > 1"],"solution":{"javascript":"function findFirstRepeating(s) {\n  const counts = {};\n  for (const char of s) {\n    counts[char] = (counts[char] || 0) + 1;\n  }\n  for (const char of s) {\n    if (counts[char] > 1) return char;\n  }\n  return null;\n}","python":"def find_first_repeating(s):\n    counts = {}\n    for char in s:\n        counts[char] = counts.get(char, 0) + 1\n    for char in s:\n        if counts[char] > 1:\n            return char\n    return None"},"complexity":{"time":"O(n)","space":"O(k)","explanation":"Two passes through the string, where k is the number of unique characters"},"timeLimit":15,"createdAt":"2025-12-25T06:29:54.591Z"},{"id":"cc12","title":"Find Middle Node","description":"Given the head of a singly linked list, return the middle node. If the list has an even number of nodes, return the second middle node. The linked list is represented as an array of values where you need to construct the list first. Constraints: 1 <= number of nodes <= 100, 1 <= node values <= 1000.","difficulty":"easy","category":"linked-lists","tags":["linked-lists","two-pointers","slow-fast"],"companies":["Goldman Sachs","Uber"],"starterCode":{"javascript":"function findMiddleNode(values) {\n  // Your code here\n  \n}","python":"def find_middle_node(values):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1,2,3,4,5]","expectedOutput":"3","description":"Odd length list"},{"id":"2","input":"[1,2,3,4,5,6]","expectedOutput":"4","description":"Even length list - return second middle"},{"id":"3","input":"[42]","expectedOutput":"42","description":"Single node"},{"id":"4","input":"[10,20]","expectedOutput":"20","description":"Two nodes - return second"}],"hints":["Use the slow and fast pointer technique","Fast pointer moves 2 steps while slow moves 1 step","When fast reaches the end, slow will be at the middle"],"solution":{"javascript":"function findMiddleNode(values) {\n  if (values.length === 0) return null;\n  \n  // Use slow and fast pointers on array indices\n  let slow = 0;\n  let fast = 0;\n  \n  while (fast < values.length - 1) {\n    slow++;\n    fast += 2;\n  }\n  \n  return values[slow];\n}","python":"def find_middle_node(values):\n    if not values:\n        return None\n    \n    # Use slow and fast pointers on array indices\n    slow = 0\n    fast = 0\n    \n    while fast < len(values) - 1:\n        slow += 1\n        fast += 2\n    \n    return values[slow]"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"Two pointers traverse the list once, using constant extra space"},"timeLimit":10,"createdAt":"2025-12-20T09:41:39.925Z"},{"id":"cc34","title":"Find Last Even Node","description":"Given the head of a singly linked list, return the value of the last node that contains an even number. If there are no even numbers in the list, return -1. The list nodes contain integers from -1000 to 1000. The list length is between 0 and 1000 nodes.","difficulty":"easy","category":"linked-lists","tags":["linked-lists","traversal"],"companies":["Anthropic","Snap","Stripe"],"starterCode":{"javascript":"function findLastEvenNode(head) {\n  // Your code here\n}","python":"def find_last_even_node(head):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1,2,3,4,5]","expectedOutput":"4","description":"Multiple even numbers"},{"id":"2","input":"[1,3,5,7]","expectedOutput":"-1","description":"No even numbers"},{"id":"3","input":"[2,4,6,8]","expectedOutput":"8","description":"All even numbers"},{"id":"4","input":"[]","expectedOutput":"-1","description":"Empty list"}],"hints":["Traverse the list once, keeping track of the last even value found","Return -1 if no even numbers were encountered"],"solution":{"javascript":"function findLastEvenNode(head) {\n  let lastEven = -1;\n  let current = head;\n  while (current) {\n    if (current.val % 2 === 0) {\n      lastEven = current.val;\n    }\n    current = current.next;\n  }\n  return lastEven;\n}","python":"def find_last_even_node(head):\n    last_even = -1\n    current = head\n    while current:\n        if current.val % 2 == 0:\n            last_even = current.val\n        current = current.next\n    return last_even"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We traverse the list once, using constant extra space to track the last even value"},"timeLimit":10,"createdAt":"2025-12-21T09:21:38.651Z"},{"id":"cc35","title":"Find Second to Last Node","description":"Given the head of a singly linked list, return the value of the second to last node. If the list has fewer than 2 nodes, return -1.\n\nConstraints:\n- The number of nodes in the list is between 0 and 1000.\n- Node values are integers between -1000 and 1000.\n- Each node has a 'val' and 'next' property.","difficulty":"easy","category":"linked-lists","tags":["linked-lists","pointers"],"companies":["OpenAI","Dropbox","Snap","Palantir"],"starterCode":{"javascript":"function secondToLast(head) {\n  // Your code here\n}","python":"def second_to_last(head):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1,2,3,4,5]","expectedOutput":"4","description":"Normal case with multiple nodes"},{"id":"2","input":"[10,20]","expectedOutput":"10","description":"Exactly two nodes"},{"id":"3","input":"[42]","expectedOutput":"-1","description":"Single node"},{"id":"4","input":"[]","expectedOutput":"-1","description":"Empty list"}],"hints":["Use two pointers: one moves ahead of the other","Handle edge cases where list has < 2 nodes"],"solution":{"javascript":"function secondToLast(head) {\n  if (!head || !head.next) return -1;\n  let slow = head;\n  let fast = head.next;\n  while (fast.next) {\n    slow = slow.next;\n    fast = fast.next;\n  }\n  return slow.val;\n}","python":"def second_to_last(head):\n    if not head or not head.next:\n        return -1\n    slow = head\n    fast = head.next\n    while fast.next:\n        slow = slow.next\n        fast = fast.next\n    return slow.val"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We traverse the list once with two pointers, using constant extra space."},"timeLimit":10,"createdAt":"2025-12-21T09:21:45.500Z"},{"id":"cc47","title":"Find Node with Maximum Value in Linked List","description":"Given the head of a singly linked list, find the node with the maximum value and return that value. If the list is empty, return null. The linked list nodes contain integer values that can be positive, negative, or zero.","difficulty":"easy","category":"linked-lists","tags":["linked-lists","traversal","maximum"],"companies":["Google","Microsoft"],"starterCode":{"javascript":"function findMaxValue(head) {\n  // Your code here\n}","python":"def find_max_value(head):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"{\"val\": 5, \"next\": {\"val\": 3, \"next\": {\"val\": 9, \"next\": {\"val\": 1, \"next\": null}}}}","expectedOutput":"9","description":"Basic case with positive numbers"},{"id":"2","input":"null","expectedOutput":"null","description":"Empty list"},{"id":"3","input":"{\"val\": -2, \"next\": {\"val\": -8, \"next\": {\"val\": -1, \"next\": null}}}","expectedOutput":"-1","description":"All negative numbers"},{"id":"4","input":"{\"val\": 0, \"next\": null}","expectedOutput":"0","description":"Single node with zero"}],"hints":["Traverse the linked list while keeping track of the maximum value seen so far","Handle the edge case of an empty list by returning null"],"solution":{"javascript":"function findMaxValue(head) {\n  if (!head) return null;\n  \n  let maxVal = head.val;\n  let current = head.next;\n  \n  while (current) {\n    if (current.val > maxVal) {\n      maxVal = current.val;\n    }\n    current = current.next;\n  }\n  \n  return maxVal;\n}","python":"def find_max_value(head):\n    if not head:\n        return None\n    \n    max_val = head.val\n    current = head.next\n    \n    while current:\n        if current.val > max_val:\n            max_val = current.val\n        current = current.next\n    \n    return max_val"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We traverse the linked list once, visiting each node exactly once. We only use a constant amount of extra space to store the maximum value and current pointer."},"timeLimit":15,"createdAt":"2025-12-22T06:32:11.195Z"},{"id":"cc52","title":"Find Node with Minimum Value in Linked List","description":"Given the head of a singly linked list, find the node with the minimum value and return that value. If the list is empty, return null. The linked list nodes contain integer values that can be positive, negative, or zero.","difficulty":"easy","category":"linked-lists","tags":["linked-lists","traversal","minimum"],"companies":["Apple","Robinhood","Meta"],"starterCode":{"javascript":"function findMinValue(head) {\n  // Your code here\n}","python":"def find_min_value(head):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[5,3,8,1,4]","expectedOutput":"1","description":"Normal case with positive numbers"},{"id":"2","input":"[-2,-8,-1,-5]","expectedOutput":"-8","description":"All negative numbers"},{"id":"3","input":"[7]","expectedOutput":"7","description":"Single node"},{"id":"4","input":"[]","expectedOutput":"null","description":"Empty list"}],"hints":["Traverse the list once while keeping track of the minimum value seen so far","Handle the empty list case before starting traversal"],"solution":{"javascript":"function findMinValue(head) {\n  if (!head) return null;\n  let min = head.val;\n  let current = head.next;\n  while (current) {\n    if (current.val < min) {\n      min = current.val;\n    }\n    current = current.next;\n  }\n  return min;\n}","python":"def find_min_value(head):\n    if not head:\n        return None\n    min_val = head.val\n    current = head.next\n    while current:\n        if current.val < min_val:\n            min_val = current.val\n        current = current.next\n    return min_val"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We traverse the linked list once, visiting each node exactly once. We only use a constant amount of extra space to store the minimum value."},"timeLimit":15,"createdAt":"2025-12-22T06:32:56.342Z"},{"id":"cc53","title":"Find Node at Kth Position from Start","description":"Given the head of a singly linked list and an integer k, return the value of the node at the kth position (1-indexed) from the start. If k is out of bounds, return -1.\n\nConstraints:\n- The number of nodes in the list is between 0 and 1000\n- k is a positive integer\n- Node values are integers\n- Do not use extra space beyond O(1)","difficulty":"easy","category":"linked-lists","tags":["linked-lists","traversal"],"companies":["SpaceX","Twitter"],"starterCode":{"javascript":"function findKthFromStart(head, k) {\n  // Your code here\n}","python":"def find_kth_from_start(head, k):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"{\"head\": [1,2,3,4,5], \"k\": 3}","expectedOutput":"3","description":"Basic case - middle element"},{"id":"2","input":"{\"head\": [10,20,30], \"k\": 1}","expectedOutput":"10","description":"First element"},{"id":"3","input":"{\"head\": [5,15,25,35], \"k\": 4}","expectedOutput":"35","description":"Last element"},{"id":"4","input":"{\"head\": [1,2,3], \"k\": 5}","expectedOutput":"-1","description":"k out of bounds"},{"id":"5","input":"{\"head\": [], \"k\": 1}","expectedOutput":"-1","description":"Empty list"}],"hints":["Traverse the list while counting nodes until you reach position k","Handle edge cases where k is larger than the list length or list is empty"],"solution":{"javascript":"function findKthFromStart(head, k) {\n  let current = head;\n  let count = 1;\n  \n  while (current !== null && count < k) {\n    current = current.next;\n    count++;\n  }\n  \n  return current !== null && count === k ? current.val : -1;\n}","python":"def find_kth_from_start(head, k):\n    current = head\n    count = 1\n    \n    while current is not None and count < k:\n        current = current.next\n        count += 1\n    \n    return current.val if current is not None and count == k else -1"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We traverse at most k nodes in the worst case, using only constant extra space for pointers and counters."},"timeLimit":15,"createdAt":"2025-12-22T06:33:05.123Z"},{"id":"cc64","title":"Find Length of Linked List","description":"Given the head of a singly linked list, return the number of nodes in the list. The list may be empty (null).","difficulty":"easy","category":"linked-lists","tags":["linked-lists","traversal"],"companies":["Google","LinkedIn","Amazon"],"starterCode":{"javascript":"function solve(head) {\n  // Your code here\n}","python":"def solve(head):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1,2,3,4,5]","expectedOutput":"5","description":"Normal list with multiple nodes"},{"id":"2","input":"[]","expectedOutput":"0","description":"Empty list"},{"id":"3","input":"[42]","expectedOutput":"1","description":"Single node list"},{"id":"4","input":"[1,1,1,1]","expectedOutput":"4","description":"List with duplicate values"}],"hints":["Traverse the list from head to null, counting each node","Use a counter variable that increments for each node visited"],"solution":{"javascript":"function solve(head) {\n  let count = 0;\n  let current = head;\n  while (current !== null) {\n    count++;\n    current = current.next;\n  }\n  return count;\n}","python":"def solve(head):\n    count = 0\n    current = head\n    while current is not None:\n        count += 1\n        current = current.next\n    return count"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We visit each node exactly once, using only a constant amount of extra space for the counter and pointer."},"timeLimit":15,"createdAt":"2025-12-25T06:30:06.214Z"},{"id":"cc70","title":"Find First Odd Node","description":"Given a linked list, find the first node with an odd value. Return the value of the first odd node, or -1 if no odd values exist. The linked list is represented as an array of integers.","difficulty":"easy","category":"linked-lists","tags":["linked-lists","traversal","searching"],"companies":["Meta","Square","PayPal","Snap"],"starterCode":{"javascript":"function findFirstOddNode(head) {\n  // Your code here\n}","python":"def find_first_odd_node(head):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[2, 4, 6, 8, 10]","expectedOutput":"-1","description":"No odd values"},{"id":"2","input":"[2, 3, 4, 5, 6]","expectedOutput":"3","description":"First odd at position 2"},{"id":"3","input":"[1, 2, 4, 6]","expectedOutput":"1","description":"First odd at head"},{"id":"4","input":"[]","expectedOutput":"-1","description":"Empty list"}],"hints":["Traverse the linked list from the beginning","Check each node's value for oddness using modulo operator","Return the first odd value found or -1 if none exist"],"solution":{"javascript":"function findFirstOddNode(head) {\n  for (let val of head) {\n    if (val % 2 !== 0) {\n      return val;\n    }\n  }\n  return -1;\n}","python":"def find_first_odd_node(head):\n    for val in head:\n        if val % 2 != 0:\n            return val\n    return -1"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We traverse the list once, checking each node. No additional space is used beyond variables."},"timeLimit":15,"createdAt":"2025-12-25T06:31:09.937Z"},{"id":"cc11","title":"Remove Nth Node From End of List","description":"Given the head of a linked list, remove the nth node from the end of the list and return its head. Follow up: Could you do this in one pass? Constraints: The number of nodes in the list is sz. 1 <= sz <= 30. 0 <= Node.val <= 100. 1 <= n <= sz.","difficulty":"medium","category":"linked-lists","tags":["linked-lists","two-pointers","node-deletion"],"companies":["LinkedIn","DoorDash","Databricks"],"starterCode":{"javascript":"function removeNthFromEnd(head, n) {\n  // Your code here\n  \n}","python":"def remove_nth_from_end(head, n):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1,2,3,4,5],2","expectedOutput":"[1,2,3,5]","description":"Remove second from end"},{"id":"2","input":"[1],1","expectedOutput":"[]","description":"Single node removal"},{"id":"3","input":"[1,2],1","expectedOutput":"[1]","description":"Remove last node"},{"id":"4","input":"[1,2,3,4],4","expectedOutput":"[2,3,4]","description":"Remove head node"}],"hints":["Use two pointers with a gap of n nodes between them","When the fast pointer reaches the end, slow pointer is at the node to remove","Consider using a dummy node to handle edge cases"],"solution":{"javascript":"function removeNthFromEnd(head, n) {\n  let dummy = new ListNode(0);\n  dummy.next = head;\n  let fast = dummy;\n  let slow = dummy;\n  \n  for (let i = 0; i <= n; i++) {\n    fast = fast.next;\n  }\n  \n  while (fast !== null) {\n    slow = slow.next;\n    fast = fast.next;\n  }\n  \n  slow.next = slow.next.next;\n  return dummy.next;\n}","python":"def remove_nth_from_end(head, n):\n    dummy = ListNode(0)\n    dummy.next = head\n    fast = dummy\n    slow = dummy\n    \n    for _ in range(n + 1):\n        fast = fast.next\n    \n    while fast:\n        slow = slow.next\n        fast = fast.next\n    \n    slow.next = slow.next.next\n    return dummy.next"},"complexity":{"time":"O(L)","space":"O(1)","explanation":"One pass through the list using two pointers, constant extra space"},"timeLimit":15,"createdAt":"2025-12-20T09:41:05.389Z"},{"id":"cc27","title":"Swap Nodes in Pairs","description":"Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n\nConstraints:\n- The number of nodes in the list is in the range [0, 100].\n- 0 <= Node.val <= 100","difficulty":"medium","category":"linked-lists","tags":["linked-lists","pointers"],"companies":["Netflix","Adobe","Coinbase","Morgan Stanley"],"starterCode":{"javascript":"function swapPairs(head) {\n  // Your code here\n}","python":"def swap_pairs(head):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1,2,3,4]","expectedOutput":"[2,1,4,3]","description":"Even number of nodes"},{"id":"2","input":"[1,2,3]","expectedOutput":"[2,1,3]","description":"Odd number of nodes"},{"id":"3","input":"[]","expectedOutput":"[]","description":"Empty list"},{"id":"4","input":"[1]","expectedOutput":"[1]","description":"Single node"}],"hints":["Use a dummy node to handle the head case easily","Think about swapping the next pointers of three nodes: prev, current, and next"],"solution":{"javascript":"function swapPairs(head) {\n  let dummy = new ListNode(0);\n  dummy.next = head;\n  let prev = dummy;\n  \n  while (prev.next && prev.next.next) {\n    let first = prev.next;\n    let second = prev.next.next;\n    \n    first.next = second.next;\n    second.next = first;\n    prev.next = second;\n    \n    prev = first;\n  }\n  \n  return dummy.next;\n}","python":"def swap_pairs(head):\n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n    \n    while prev.next and prev.next.next:\n        first = prev.next\n        second = prev.next.next\n        \n        first.next = second.next\n        second.next = first\n        prev.next = second\n        \n        prev = first\n    \n    return dummy.next"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We traverse the list once, swapping pairs of nodes. Only constant extra space is used for pointers."},"timeLimit":15,"createdAt":"2025-12-21T09:16:04.735Z"},{"id":"cc30","title":"Rotate Linked List by K","description":"Given the head of a singly linked list and an integer k, rotate the list to the right by k positions. Return the new head of the rotated list. A rotation by k means moving the last k nodes to the front while maintaining their order. If k is greater than the list length, use k % length. If the list is empty or has one node, return it unchanged.","difficulty":"medium","category":"linked-lists","tags":["linked-lists","rotation","two-pointers"],"companies":["Twitter","Tesla","Airbnb"],"starterCode":{"javascript":"function rotateRight(head, k) {\n  // Your code here\n}","python":"def rotate_right(head, k):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"{\"head\": [1,2,3,4,5], \"k\": 2}","expectedOutput":"[4,5,1,2,3]","description":"Normal rotation"},{"id":"2","input":"{\"head\": [1,2], \"k\": 3}","expectedOutput":"[2,1]","description":"K greater than length"},{"id":"3","input":"{\"head\": [], \"k\": 5}","expectedOutput":"[]","description":"Empty list"},{"id":"4","input":"{\"head\": [7], \"k\": 100}","expectedOutput":"[7]","description":"Single node"}],"hints":["Find the length of the list first","Connect the tail to head to make it circular","Break the circle at the new tail position"],"solution":{"javascript":"function rotateRight(head, k) {\n  if (!head || !head.next || k === 0) return head;\n  \n  let length = 1;\n  let tail = head;\n  while (tail.next) {\n    tail = tail.next;\n    length++;\n  }\n  \n  k = k % length;\n  if (k === 0) return head;\n  \n  tail.next = head;\n  let stepsToNewTail = length - k;\n  let newTail = tail;\n  \n  for (let i = 0; i < stepsToNewTail; i++) {\n    newTail = newTail.next;\n  }\n  \n  let newHead = newTail.next;\n  newTail.next = null;\n  \n  return newHead;\n}","python":"def rotate_right(head, k):\n    if not head or not head.next or k == 0:\n        return head\n    \n    length = 1\n    tail = head\n    while tail.next:\n        tail = tail.next\n        length += 1\n    \n    k = k % length\n    if k == 0:\n        return head\n    \n    tail.next = head\n    steps_to_new_tail = length - k\n    new_tail = tail\n    \n    for _ in range(steps_to_new_tail):\n        new_tail = new_tail.next\n    \n    new_head = new_tail.next\n    new_tail.next = None\n    \n    return new_head"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We traverse the list once to find length and tail, then once more to find the new tail position. No extra space is used beyond pointers."},"timeLimit":15,"createdAt":"2025-12-21T09:16:44.482Z"},{"id":"cc20","title":"Sum of Array Elements","description":"Given an array of integers, return the sum of all elements. If the array is empty, return 0. Constraints: 0 ≤ array length ≤ 1000, -1000 ≤ each element ≤ 1000.","difficulty":"easy","category":"math","tags":["math","array","iteration"],"companies":["Airbnb","Shopify","Snap"],"starterCode":{"javascript":"function sumArray(arr) {\n  // Your code here\n  \n}","python":"def sum_array(arr):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1,2,3]","expectedOutput":"6","description":"Basic positive numbers"},{"id":"2","input":"[]","expectedOutput":"0","description":"Empty array"},{"id":"3","input":"[5]","expectedOutput":"5","description":"Single element"},{"id":"4","input":"[-1,2,-3,4]","expectedOutput":"2","description":"Mixed positive and negative"}],"hints":["Iterate through the array and accumulate the sum","Consider using a simple loop or built-in reduce method","Handle the edge case of empty array explicitly"],"solution":{"javascript":"function sumArray(arr) {\n  let sum = 0;\n  for (let num of arr) {\n    sum += num;\n  }\n  return sum;\n}","python":"def sum_array(arr):\n    total = 0\n    for num in arr:\n        total += num\n    return total"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We visit each element once and use constant extra space for the accumulator."},"timeLimit":10,"createdAt":"2025-12-20T09:47:00.728Z"},{"id":"cc33","title":"Digit Product Calculator","description":"Given an integer array, calculate the product of all digits in the array. If the array is empty, return 0. If any number is 0, the product becomes 0. Handle negative numbers by using their absolute values for the calculation.\n\nConstraints:\n- Array length: 0 to 1000\n- Each number: -1000 to 1000\n- Product fits in 32-bit integer","difficulty":"easy","category":"math","tags":["math","array","product"],"companies":["PayPal","Morgan Stanley"],"starterCode":{"javascript":"function digitProduct(nums) {\n  // Your code here\n}","python":"def digit_product(nums):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[2,3,4]","expectedOutput":"24","description":"Basic positive numbers"},{"id":"2","input":"[]","expectedOutput":"0","description":"Empty array"},{"id":"3","input":"[5,0,7]","expectedOutput":"0","description":"Contains zero"},{"id":"4","input":"[-2,3,-4]","expectedOutput":"24","description":"Negative numbers"}],"hints":["Use absolute value for negative numbers","Check for empty array first","Early return if you encounter zero"],"solution":{"javascript":"function digitProduct(nums) {\n  if (nums.length === 0) return 0;\n  let product = 1;\n  for (let num of nums) {\n    if (num === 0) return 0;\n    product *= Math.abs(num);\n  }\n  return product;\n}","python":"def digit_product(nums):\n    if not nums:\n        return 0\n    product = 1\n    for num in nums:\n        if num == 0:\n            return 0\n        product *= abs(num)\n    return product"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"Single pass through array, constant extra space"},"timeLimit":10,"createdAt":"2025-12-21T09:21:32.036Z"},{"id":"cc51","title":"Digital Root Calculator","description":"Calculate the digital root of a positive integer by repeatedly summing its digits until a single digit remains. The digital root of n is n if n < 10, otherwise it's the digital root of the sum of its digits. Input: positive integer n (1 ≤ n ≤ 10^18). Output: single digit representing the digital root.","difficulty":"easy","category":"math","tags":["math","digits"],"companies":["Snowflake","Snap"],"starterCode":{"javascript":"function digitalRoot(n) {\n  // Your code here\n}","python":"def digital_root(n):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"38","expectedOutput":"2","description":"Two digit number"},{"id":"2","input":"12345","expectedOutput":"6","description":"Multi-digit number"},{"id":"3","input":"9","expectedOutput":"9","description":"Single digit"},{"id":"4","input":"1000000000000000000","expectedOutput":"1","description":"Large number"}],"hints":["You can either repeatedly sum the digits or use the mathematical formula: digital root = 1 + (n - 1) % 9 for n > 0","For n = 0, the digital root is 0, but this problem guarantees n ≥ 1"],"solution":{"javascript":"function digitalRoot(n) {\n  if (n < 10) return n;\n  return 1 + (n - 1) % 9;\n}","python":"def digital_root(n):\n    if n < 10:\n        return n\n    return 1 + (n - 1) % 9"},"complexity":{"time":"O(1)","space":"O(1)","explanation":"Using the mathematical formula, we can compute the digital root in constant time without iterating through digits."},"timeLimit":15,"createdAt":"2025-12-22T06:32:48.509Z"},{"id":"cc36","title":"Prime Factor Sum","description":"Given an integer n, find the sum of all prime factors of n. If n is 1, return 0. If n is prime, return n itself. A prime factor should be counted only once even if it appears multiple times in the factorization.\n\nConstraints:\n- 1 ≤ n ≤ 10^9\n- n is a positive integer\n\nExample: For n = 12, prime factors are 2 and 3, so sum is 5.","difficulty":"medium","category":"math","tags":["math","prime-factors","factorization"],"companies":["LinkedIn","Microsoft","Elastic"],"starterCode":{"javascript":"function primeFactorSum(n) {\n  // Your code here\n}","python":"def prime_factor_sum(n):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"12","expectedOutput":"5","description":"Basic case with multiple prime factors"},{"id":"2","input":"1","expectedOutput":"0","description":"Edge case with n=1"},{"id":"3","input":"17","expectedOutput":"17","description":"Prime number case"},{"id":"4","input":"72","expectedOutput":"5","description":"Number with repeated prime factors"}],"hints":["Use trial division up to sqrt(n) to find prime factors","Remember to add the remaining n if it's greater than 1 after division"],"solution":{"javascript":"function primeFactorSum(n) {\n  if (n === 1) return 0;\n  let sum = 0;\n  \n  // Check for factor 2\n  if (n % 2 === 0) {\n    sum += 2;\n    while (n % 2 === 0) n /= 2;\n  }\n  \n  // Check for odd factors\n  for (let i = 3; i <= Math.sqrt(n); i += 2) {\n    if (n % i === 0) {\n      sum += i;\n      while (n % i === 0) n /= i;\n    }\n  }\n  \n  // If remaining n is prime\n  if (n > 1) sum += n;\n  \n  return sum;\n}","python":"def prime_factor_sum(n):\n    if n == 1:\n        return 0\n    \n    total = 0\n    \n    # Check for factor 2\n    if n % 2 == 0:\n        total += 2\n        while n % 2 == 0:\n            n //= 2\n    \n    # Check for odd factors\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            total += i\n            while n % i == 0:\n                n //= i\n        i += 2\n    \n    # If remaining n is prime\n    if n > 1:\n        total += n\n    \n    return total"},"complexity":{"time":"O(√n)","space":"O(1)","explanation":"We iterate up to sqrt(n) to find all prime factors, using constant extra space."},"timeLimit":15,"createdAt":"2025-12-21T09:21:52.394Z"},{"id":"cc42","title":"Geometric Mean Calculator","description":"Calculate the geometric mean of an array of positive numbers. The geometric mean is the nth root of the product of all numbers, where n is the array length. Return 0 for empty arrays. Handle floating point precision appropriately.","difficulty":"medium","category":"math","tags":["math","floating-point","exponents"],"companies":["Microsoft","Stripe","Netflix","Tesla"],"starterCode":{"javascript":"function geometricMean(numbers) {\n  // Your code here\n}","python":"def geometric_mean(numbers):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1,4,9]","expectedOutput":"3.3019272488946263","description":"Perfect squares"},{"id":"2","input":"[2,8,32]","expectedOutput":"7.999999999999998","description":"Powers of 2"},{"id":"3","input":"[1.5,2.5,3.5]","expectedOutput":"2.358846990158267","description":"Floating point numbers"},{"id":"4","input":"[]","expectedOutput":"0","description":"Empty array"}],"hints":["Use logarithms to avoid overflow: log(product) = sum(log(each))","Geometric mean = exp(sum(log(each)) / n)","Handle the empty array case separately"],"solution":{"javascript":"function geometricMean(numbers) {\n  if (numbers.length === 0) return 0;\n  const logSum = numbers.reduce((sum, num) => sum + Math.log(num), 0);\n  return Math.exp(logSum / numbers.length);\n}","python":"def geometric_mean(numbers):\n    if not numbers:\n        return 0\n    import math\n    log_sum = sum(math.log(num) for num in numbers)\n    return math.exp(log_sum / len(numbers))"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"Single pass through array, constant extra space"},"timeLimit":15,"createdAt":"2025-12-22T06:31:29.553Z"},{"id":"cc65","title":"Modular Arithmetic Sequence","description":"Given an array of integers, find the length of the longest contiguous subarray where the sum of elements is divisible by the array length. If no such subarray exists, return 0. Constraints: 1 ≤ array.length ≤ 10^4, -10^4 ≤ elements ≤ 10^4.","difficulty":"medium","category":"math","tags":["math","arrays","modular-arithmetic"],"companies":["LinkedIn","Google"],"starterCode":{"javascript":"function longestModularSubarray(arr) {\n  // Your code here\n}","python":"def longest_modular_subarray(arr):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[3, 1, 4, 2, 2]","expectedOutput":"2","description":"Entire array works (sum=12, length=5, 12%5=2)"},{"id":"2","input":"[1, 2, 3, 6]","expectedOutput":"4","description":"Subarray [1,2,3] works (sum=6, length=3, 6%3=0)"},{"id":"3","input":"[5, 7, 11]","expectedOutput":"2","description":"No valid subarray exists"},{"id":"4","input":"[-2, 4, -1, 3]","expectedOutput":"4","description":"Entire array works with negative numbers (sum=4, length=4, 4%4=0)"}],"hints":["Use prefix sums to efficiently calculate subarray sums","For each subarray length, check if sum % length === 0","Consider all possible subarray starting points"],"solution":{"javascript":"function longestModularSubarray(arr) {\n  let maxLen = 0;\n  const n = arr.length;\n  \n  for (let start = 0; start < n; start++) {\n    let sum = 0;\n    for (let end = start; end < n; end++) {\n      sum += arr[end];\n      const length = end - start + 1;\n      if (sum % length === 0) {\n        maxLen = Math.max(maxLen, length);\n      }\n    }\n  }\n  \n  return maxLen;\n}","python":"def longest_modular_subarray(arr):\n    max_len = 0\n    n = len(arr)\n    \n    for start in range(n):\n        total = 0\n        for end in range(start, n):\n            total += arr[end]\n            length = end - start + 1\n            if total % length == 0:\n                max_len = max(max_len, length)\n    \n    return max_len"},"complexity":{"time":"O(n²)","space":"O(1)","explanation":"We check all possible subarrays using nested loops, calculating sums in O(1) with running totals."},"timeLimit":15,"createdAt":"2025-12-25T06:30:31.484Z"},{"id":"cc7","title":"Perfect Square Sum","description":"Given an array of integers, return the sum of all perfect square numbers in the array. A perfect square is an integer that is the square of another integer (e.g., 1, 4, 9, 16, 25, etc.). If no perfect squares are found, return 0.\n\nConstraints:\n- Input array length: 0 to 1000\n- Each integer: -1000 to 1000\n- Only positive perfect squares should be summed (ignore negative numbers)","difficulty":"medium","category":"math","tags":["math","array","perfect-square"],"companies":["Uber","Google","MongoDB","Dropbox"],"starterCode":{"javascript":"function perfectSquareSum(arr) {\n  // Your code here\n  \n}","python":"def perfect_square_sum(arr):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1,2,3,4,5,6,7,8,9,10]","expectedOutput":"14","description":"Mixed array with multiple perfect squares"},{"id":"2","input":"[-4,-1,0,1,4,9,16]","expectedOutput":"30","description":"Array with negative numbers and zero"},{"id":"3","input":"[2,3,5,7,11,13]","expectedOutput":"0","description":"No perfect squares"},{"id":"4","input":"[100,81,64,49,36,25,16,9,4,1]","expectedOutput":"385","description":"All perfect squares"}],"hints":["To check if a number is a perfect square, take its square root and see if it's an integer","Be careful with negative numbers - they can't be perfect squares","Consider using Math.sqrt() in JavaScript or math.sqrt() in Python"],"solution":{"javascript":"function perfectSquareSum(arr) {\n  let sum = 0;\n  for (const num of arr) {\n    if (num > 0) {\n      const sqrt = Math.sqrt(num);\n      if (sqrt === Math.floor(sqrt)) {\n        sum += num;\n      }\n    }\n  }\n  return sum;\n}","python":"def perfect_square_sum(arr):\n    total = 0\n    for num in arr:\n        if num > 0:\n            sqrt = int(num ** 0.5)\n            if sqrt * sqrt == num:\n                total += num\n    return total"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We iterate through the array once, performing O(1) operations for each element"},"timeLimit":15,"createdAt":"2025-12-20T09:40:15.823Z"},{"id":"cc14","title":"Linear Search in Rotated Array","description":"Given a rotated sorted array and a target value, return the index of the target if it exists, otherwise return -1. A rotated sorted array is an array that was originally sorted in ascending order but then rotated at some pivot point. The array contains distinct integers.\n\nConstraints:\n- 1 ≤ nums.length ≤ 1000\n- -10^4 ≤ nums[i] ≤ 10^4\n- -10^4 ≤ target ≤ 10^4\n- All values in nums are distinct","difficulty":"easy","category":"searching","tags":["searching","array","linear-search"],"companies":["Dropbox","Uber","Stripe","Twitter"],"starterCode":{"javascript":"function linearSearchRotated(nums, target) {\n  // Your code here\n  \n}","python":"def linear_search_rotated(nums, target):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[[4,5,6,7,0,1,2], 0]","expectedOutput":"4","description":"Target found in rotated array"},{"id":"2","input":"[[4,5,6,7,0,1,2], 3]","expectedOutput":"-1","description":"Target not found"},{"id":"3","input":"[[1], 1]","expectedOutput":"0","description":"Single element array, target found"},{"id":"4","input":"[[1], 2]","expectedOutput":"-1","description":"Single element array, target not found"}],"hints":["Since this is an easy problem, try the simplest approach first","A linear scan through the array will work fine for the given constraints","Just check each element and return its index if it matches the target"],"solution":{"javascript":"function linearSearchRotated(nums, target) {\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === target) {\n      return i;\n    }\n  }\n  return -1;\n}","python":"def linear_search_rotated(nums, target):\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n    return -1"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We scan through the array once, checking each element. No extra space is used beyond variables."},"timeLimit":10,"createdAt":"2025-12-20T09:45:49.336Z"},{"id":"cc17","title":"Find First Occurrence in Sorted Array","description":"Given a sorted array of integers and a target value, find the first index where the target appears. If the target is not found, return -1. The array is sorted in non-decreasing order and may contain duplicate elements.","difficulty":"easy","category":"searching","tags":["searching","binary search","arrays"],"companies":["Pinterest","Morgan Stanley"],"starterCode":{"javascript":"function findFirstOccurrence(nums, target) {\n  // Your code here\n  \n}","python":"def find_first_occurrence(nums, target):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[[1,2,2,2,3,4,5],2]","expectedOutput":"1","description":"Multiple occurrences, return first"},{"id":"2","input":"[[1,3,5,7,9],4]","expectedOutput":"-1","description":"Target not found"},{"id":"3","input":"[[2,2,2,2,2],2]","expectedOutput":"0","description":"All elements are target"},{"id":"4","input":"[[],5]","expectedOutput":"-1","description":"Empty array"}],"hints":["Since the array is sorted, binary search is more efficient than linear search","When you find the target, continue searching the left half to find the first occurrence","Keep track of the answer and update it when you find a smaller index"],"solution":{"javascript":"function findFirstOccurrence(nums, target) {\n  let left = 0;\n  let right = nums.length - 1;\n  let result = -1;\n  \n  while (left <= right) {\n    let mid = Math.floor((left + right) / 2);\n    \n    if (nums[mid] === target) {\n      result = mid;\n      right = mid - 1; // Continue searching left\n    } else if (nums[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  \n  return result;\n}","python":"def find_first_occurrence(nums, target):\n    left, right = 0, len(nums) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            result = mid\n            right = mid - 1  # Continue searching left\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result"},"complexity":{"time":"O(log n)","space":"O(1)","explanation":"Binary search reduces the search space by half each iteration, giving logarithmic time complexity. Only constant extra space is used."},"timeLimit":10,"createdAt":"2025-12-20T09:46:20.858Z"},{"id":"cc26","title":"Find Closest Number in Array","description":"Given a sorted array of integers and a target value, find the number in the array that is closest to the target. If there are two numbers equally close, return the smaller one. The array is guaranteed to have at least one element.","difficulty":"easy","category":"searching","tags":["searching","binary-search","array"],"companies":["Apple","Citadel","Twitter"],"starterCode":{"javascript":"function findClosest(arr, target) {\n  // Your code here\n}","python":"def find_closest(arr, target):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[[1,3,5,7,9], 6]","expectedOutput":"5","description":"Target between two elements"},{"id":"2","input":"[[2,4,6,8,10], 1]","expectedOutput":"2","description":"Target smaller than all elements"},{"id":"3","input":"[[1,4,7,10], 11]","expectedOutput":"10","description":"Target larger than all elements"},{"id":"4","input":"[[1,5,9], 7]","expectedOutput":"5","description":"Equal distance, return smaller"}],"hints":["Use binary search to find the insertion point","Compare the target with the element at insertion point and its previous element"],"solution":{"javascript":"function findClosest(arr, target) {\n  let left = 0, right = arr.length - 1;\n  \n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) return arr[mid];\n    if (arr[mid] < target) left = mid + 1;\n    else right = mid - 1;\n  }\n  \n  if (left >= arr.length) return arr[arr.length - 1];\n  if (right < 0) return arr[0];\n  \n  const diffLeft = Math.abs(target - arr[right]);\n  const diffRight = Math.abs(arr[left] - target);\n  \n  if (diffLeft === diffRight) return arr[right];\n  return diffLeft < diffRight ? arr[right] : arr[left];\n}","python":"def find_closest(arr, target):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return arr[mid]\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    if left >= len(arr):\n        return arr[-1]\n    if right < 0:\n        return arr[0]\n    \n    diff_left = abs(target - arr[right])\n    diff_right = abs(arr[left] - target)\n    \n    if diff_left == diff_right:\n        return arr[right]\n    return arr[right] if diff_left < diff_right else arr[left]"},"complexity":{"time":"O(log n)","space":"O(1)","explanation":"Binary search reduces the search space by half each iteration"},"timeLimit":10,"createdAt":"2025-12-21T08:18:39.282Z"},{"id":"cc29","title":"Find Element in Nearly Sorted Array","description":"Given a nearly sorted array where each element is at most 1 position away from its correct sorted position, find the index of a target element. If the element is not found, return -1.\n\nConstraints:\n- 1 ≤ array.length ≤ 10^4\n- -10^9 ≤ array[i] ≤ 10^9\n- -10^9 ≤ target ≤ 10^9\n- Each element is at most 1 position away from its sorted position","difficulty":"easy","category":"searching","tags":["searching","binary-search","array"],"companies":["Coinbase","Stripe"],"starterCode":{"javascript":"function findInNearlySorted(arr, target) {\n  // Your code here\n}","python":"def find_in_nearly_sorted(arr, target):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[[4,5,6,7,0,1,2],0]","expectedOutput":"4","description":"Target found in middle"},{"id":"2","input":"[[4,5,6,7,0,1,2],3]","expectedOutput":"-1","description":"Target not found"},{"id":"3","input":"[[1,2,3],2]","expectedOutput":"1","description":"Small array"},{"id":"4","input":"[[2,1],1]","expectedOutput":"1","description":"Two element array"}],"hints":["Since each element is at most 1 position away, check current, previous, and next positions during binary search","Modify standard binary search to compare with neighbors when target doesn't match current position"],"solution":{"javascript":"function findInNearlySorted(arr, target) {\n  let left = 0, right = arr.length - 1;\n  while (left <= right) {\n    let mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) return mid;\n    if (mid > left && arr[mid - 1] === target) return mid - 1;\n    if (mid < right && arr[mid + 1] === target) return mid + 1;\n    if (arr[mid] < target) left = mid + 2;\n    else right = mid - 2;\n  }\n  return -1;\n}","python":"def find_in_nearly_sorted(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        if mid > left and arr[mid - 1] == target:\n            return mid - 1\n        if mid < right and arr[mid + 1] == target:\n            return mid + 1\n        if arr[mid] < target:\n            left = mid + 2\n        else:\n            right = mid - 2\n    return -1"},"complexity":{"time":"O(log n)","space":"O(1)","explanation":"Modified binary search that checks up to 3 positions per iteration, maintaining logarithmic time complexity"},"timeLimit":10,"createdAt":"2025-12-21T09:16:32.254Z"},{"id":"cc31","title":"Find Missing Number in Range","description":"Given an array of distinct integers that contains numbers from 1 to n with exactly one number missing, find the missing number. The array may not be sorted.\n\nConstraints:\n- 1 ≤ array length ≤ 10^4\n- 1 ≤ array elements ≤ 10^6\n- Exactly one number from 1 to n is missing\n- Array contains distinct integers","difficulty":"easy","category":"searching","tags":["searching","math","array"],"companies":["Microsoft","Airbnb","Instacart","DoorDash"],"starterCode":{"javascript":"function findMissingNumber(nums) {\n  // Your code here\n}","python":"def find_missing_number(nums):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1,2,4,5]","expectedOutput":"3","description":"Basic missing in middle"},{"id":"2","input":"[2,3,4,5]","expectedOutput":"1","description":"Missing first element"},{"id":"3","input":"[1,2,3,4]","expectedOutput":"5","description":"Missing last element"},{"id":"4","input":"[1]","expectedOutput":"2","description":"Single element array"}],"hints":["Use the formula for sum of first n natural numbers: n*(n+1)/2","The missing number is the difference between expected sum and actual sum"],"solution":{"javascript":"function findMissingNumber(nums) {\n  const n = nums.length + 1;\n  const expectedSum = n * (n + 1) / 2;\n  const actualSum = nums.reduce((sum, num) => sum + num, 0);\n  return expectedSum - actualSum;\n}","python":"def find_missing_number(nums):\n    n = len(nums) + 1\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We iterate through the array once to calculate the sum, using constant extra space."},"timeLimit":10,"createdAt":"2025-12-21T09:21:13.885Z"},{"id":"cc19","title":"Find Peak Element in Mountain Array","description":"Given a mountain array (strictly increasing then strictly decreasing), find the peak element using binary search. A mountain array is defined as an array where there exists some index i such that arr[0] < arr[1] < ... < arr[i] > arr[i+1] > ... > arr[n-1]. Return the index of the peak element. If the array is not a valid mountain array, return -1.","difficulty":"medium","category":"searching","tags":["searching","binary search","array"],"companies":["Tesla","Apple"],"starterCode":{"javascript":"function findPeakIndex(arr) {\n  // Your code here\n  \n}","python":"def find_peak_index(arr):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1,3,5,4,2]","expectedOutput":"2","description":"Basic mountain array"},{"id":"2","input":"[0,2,4,3,1]","expectedOutput":"2","description":"Mountain array starting from 0"},{"id":"3","input":"[1,2,3,4,5]","expectedOutput":"-1","description":"Strictly increasing array (not mountain)"},{"id":"4","input":"[5,4,3,2,1]","expectedOutput":"-1","description":"Strictly decreasing array (not mountain)"},{"id":"5","input":"[1,2,3,2,1,0,-1]","expectedOutput":"2","description":"Longer mountain array"}],"hints":["Use binary search to efficiently find the peak","Compare middle element with its neighbors to determine direction","If arr[mid] < arr[mid + 1], the peak is to the right","If arr[mid] > arr[mid + 1], the peak is to the left or at mid"],"solution":{"javascript":"function findPeakIndex(arr) {\n  if (arr.length < 3) return -1;\n  \n  let left = 0;\n  let right = arr.length - 1;\n  \n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    \n    if (arr[mid] < arr[mid + 1]) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n  \n  // Verify it's a valid mountain array\n  if (left === 0 || left === arr.length - 1) return -1;\n  if (arr[left - 1] >= arr[left] || arr[left] <= arr[left + 1]) return -1;\n  \n  return left;\n}","python":"def find_peak_index(arr):\n    if len(arr) < 3:\n        return -1\n    \n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        if arr[mid] < arr[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    \n    # Verify it's a valid mountain array\n    if left == 0 or left == len(arr) - 1:\n        return -1\n    if arr[left - 1] >= arr[left] or arr[left] <= arr[left + 1]:\n        return -1\n    \n    return left"},"complexity":{"time":"O(log n)","space":"O(1)","explanation":"Binary search reduces the search space by half each iteration, giving logarithmic time complexity. Only constant extra space is used for pointers."},"timeLimit":15,"createdAt":"2025-12-20T09:46:36.752Z"},{"id":"cc2","title":"Search in Rotated Sorted Array","description":"Given a rotated sorted array of distinct integers and a target value, return the index of the target if it exists, otherwise return -1. The array was originally sorted in ascending order and then rotated at an unknown pivot. Constraints: 1 <= nums.length <= 10^4, -10^4 <= nums[i] <= 10^4, -10^4 <= target <= 10^4, All values are distinct.","difficulty":"medium","category":"searching","tags":["searching","binary-search","array"],"companies":["Elastic","Uber","Microsoft"],"starterCode":{"javascript":"function searchRotated(nums, target) {\n  // Your code here\n  \n}","python":"def search_rotated(nums, target):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[4,5,6,7,0,1,2],0","expectedOutput":"4","description":"Target in right half"},{"id":"2","input":"[4,5,6,7,0,1,2],3","expectedOutput":"-1","description":"Target not found"},{"id":"3","input":"[1],0","expectedOutput":"-1","description":"Single element, not found"},{"id":"4","input":"[1],1","expectedOutput":"0","description":"Single element, found"}],"hints":["Use modified binary search to handle rotation","Determine which half is sorted at each step","Compare target with the sorted half boundaries"],"solution":{"javascript":"function searchRotated(nums, target) {\n  let left = 0, right = nums.length - 1;\n  \n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    \n    if (nums[mid] === target) return mid;\n    \n    if (nums[left] <= nums[mid]) {\n      if (nums[left] <= target && target < nums[mid]) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    } else {\n      if (nums[mid] < target && target <= nums[right]) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n  }\n  \n  return -1;\n}","python":"def search_rotated(nums, target):\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        \n        if nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    return -1"},"complexity":{"time":"O(log n)","space":"O(1)","explanation":"Binary search eliminates half the search space each iteration"},"timeLimit":15,"createdAt":"2025-12-20T09:39:39.098Z"},{"id":"cc23","title":"Find First and Last Position of Element in Sorted Array","description":"Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity.","difficulty":"medium","category":"searching","tags":["searching","binary-search","array"],"companies":["Salesforce","Lyft"],"starterCode":{"javascript":"function searchRange(nums, target) {\n  // Your code here\n  \n}","python":"def search_range(nums, target):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[[5,7,7,8,8,10],8]","expectedOutput":"[3,4]","description":"Target appears multiple times"},{"id":"2","input":"[[5,7,7,8,8,10],6]","expectedOutput":"[-1,-1]","description":"Target not found"},{"id":"3","input":"[[],0]","expectedOutput":"[-1,-1]","description":"Empty array"},{"id":"4","input":"[[2,2],2]","expectedOutput":"[0,1]","description":"All elements are target"}],"hints":["Use binary search to find the leftmost and rightmost positions","Write a helper function that finds the first occurrence","Write another helper function that finds the last occurrence"],"solution":{"javascript":"function searchRange(nums, target) {\n  const findFirst = () => {\n    let left = 0, right = nums.length - 1;\n    let result = -1;\n    while (left <= right) {\n      const mid = Math.floor((left + right) / 2);\n      if (nums[mid] === target) {\n        result = mid;\n        right = mid - 1;\n      } else if (nums[mid] < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    return result;\n  };\n  \n  const findLast = () => {\n    let left = 0, right = nums.length - 1;\n    let result = -1;\n    while (left <= right) {\n      const mid = Math.floor((left + right) / 2);\n      if (nums[mid] === target) {\n        result = mid;\n        left = mid + 1;\n      } else if (nums[mid] < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    return result;\n  };\n  \n  return [findFirst(), findLast()];\n}","python":"def search_range(nums, target):\n    def find_first():\n        left, right = 0, len(nums) - 1\n        result = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                result = mid\n                right = mid - 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return result\n    \n    def find_last():\n        left, right = 0, len(nums) - 1\n        result = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                result = mid\n                left = mid + 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return result\n    \n    return [find_first(), find_last()]"},"complexity":{"time":"O(log n)","space":"O(1)","explanation":"Two binary searches each take O(log n) time, using constant extra space"},"timeLimit":15,"createdAt":"2025-12-20T09:47:28.875Z"},{"id":"cc25","title":"Find Peak Element in Rotated Sorted Array","description":"Given a rotated sorted array that may contain duplicates, find the index of any peak element. A peak element is an element that is greater than or equal to its neighbors. For the first and last elements, only one neighbor needs to be considered. If there are multiple peaks, return any one of them. If the array is empty, return -1.","difficulty":"medium","category":"searching","tags":["searching","binary-search","array"],"companies":["Robinhood","Apple"],"starterCode":{"javascript":"function findPeakInRotated(nums) {\n  // Your code here\n  \n}","python":"def find_peak_in_rotated(nums):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[4,5,6,7,0,1,2]","expectedOutput":"3","description":"Standard rotated array with peak at 7"},{"id":"2","input":"[2,2,2,3,2,2,2]","expectedOutput":"3","description":"Array with duplicates and peak at 3"},{"id":"3","input":"[1,2,3,4,5]","expectedOutput":"4","description":"Non-rotated array, peak at end"},{"id":"4","input":"[]","expectedOutput":"-1","description":"Empty array edge case"}],"hints":["Use binary search to efficiently locate a peak","Compare middle element with its neighbors to determine search direction","Handle duplicates by moving pointers inward when equal","Consider boundary conditions for first and last elements"],"solution":{"javascript":"function findPeakInRotated(nums) {\n  if (nums.length === 0) return -1;\n  \n  let left = 0;\n  let right = nums.length - 1;\n  \n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    \n    if (mid > 0 && nums[mid] < nums[mid - 1]) {\n      right = mid - 1;\n    } else if (mid < nums.length - 1 && nums[mid] < nums[mid + 1]) {\n      left = mid + 1;\n    } else {\n      return mid;\n    }\n  }\n  \n  return left;\n}","python":"def find_peak_in_rotated(nums):\n    if not nums:\n        return -1\n    \n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        if mid > 0 and nums[mid] < nums[mid - 1]:\n            right = mid - 1\n        elif mid < len(nums) - 1 and nums[mid] < nums[mid + 1]:\n            left = mid + 1\n        else:\n            return mid\n    \n    return left"},"complexity":{"time":"O(log n)","space":"O(1)","explanation":"Binary search reduces the search space by half each iteration, achieving logarithmic time complexity with constant extra space."},"timeLimit":15,"createdAt":"2025-12-20T09:47:59.852Z"},{"id":"cc32","title":"Find Kth Closest Element to Target","description":"Given a sorted array of distinct integers and a target value, find the k-th closest element to the target. If there are multiple elements at the same distance, return the element with the smaller value first. The array is sorted in ascending order and contains no duplicates.","difficulty":"medium","category":"searching","tags":["searching","binary-search","two-pointers"],"companies":["Amazon","Confluent","Airbnb","Goldman Sachs"],"starterCode":{"javascript":"function findKthClosest(arr, target, k) {\n  // Your code here\n}","python":"def find_kth_closest(arr, target, k):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1,2,3,4,5],3,2","expectedOutput":"2","description":"Target in middle, k=2"},{"id":"2","input":"[1,4,6,8,10],3,1","expectedOutput":"4","description":"Target outside range, closest is first"},{"id":"3","input":"[1,2,4,6,8,10],7,3","expectedOutput":"4","description":"Target between elements, k=3"},{"id":"4","input":"[1,3,5,7,9],10,4","expectedOutput":"3","description":"Target beyond last element"}],"hints":["Use binary search to find the insertion point of the target","Use two pointers expanding from the insertion point to find the k-th closest"],"solution":{"javascript":"function findKthClosest(arr, target, k) {\n  let left = 0, right = arr.length - 1;\n  \n  // Binary search to find insertion point\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) {\n      left = mid;\n      break;\n    } else if (arr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  \n  let i = left - 1, j = left;\n  let count = 0;\n  \n  while (count < k && (i >= 0 || j < arr.length)) {\n    if (i >= 0 && j < arr.length) {\n      const leftDist = Math.abs(arr[i] - target);\n      const rightDist = Math.abs(arr[j] - target);\n      \n      if (leftDist < rightDist || (leftDist === rightDist && arr[i] < arr[j])) {\n        i--;\n      } else {\n        j++;\n      }\n    } else if (i >= 0) {\n      i--;\n    } else {\n      j++;\n    }\n    count++;\n  }\n  \n  return count === k ? (i >= 0 ? arr[i + 1] : arr[j - 1]) : -1;\n}","python":"def find_kth_closest(arr, target, k):\n    left, right = 0, len(arr) - 1\n    \n    # Binary search to find insertion point\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            left = mid\n            break\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    i, j = left - 1, left\n    count = 0\n    \n    while count < k and (i >= 0 or j < len(arr)):\n        if i >= 0 and j < len(arr):\n            left_dist = abs(arr[i] - target)\n            right_dist = abs(arr[j] - target)\n            \n            if left_dist < right_dist or (left_dist == right_dist and arr[i] < arr[j]):\n                i -= 1\n            else:\n                j += 1\n        elif i >= 0:\n            i -= 1\n        else:\n            j += 1\n        count += 1\n    \n    if count == k:\n        return arr[i + 1] if i >= 0 else arr[j - 1]\n    return -1"},"complexity":{"time":"O(log n + k)","space":"O(1)","explanation":"Binary search takes O(log n) to find insertion point, then O(k) to find k-th closest element"},"timeLimit":15,"createdAt":"2025-12-21T09:21:23.163Z"},{"id":"cc4","title":"Find First Missing Positive","description":"Given an unsorted integer array, find the smallest missing positive integer. You must implement an algorithm that runs in O(n) time and uses O(1) extra space.\n\nConstraints:\n- 1 ≤ nums.length ≤ 10^5\n- -10^6 ≤ nums[i] ≤ 10^6\n- The array may contain duplicates, negative numbers, and zeros","difficulty":"medium","category":"searching","tags":["searching","array","in-place"],"companies":["Lyft","Palantir","Google"],"starterCode":{"javascript":"function firstMissingPositive(nums) {\n  // Your code here\n  \n}","python":"def first_missing_positive(nums):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1,2,0]","expectedOutput":"3","description":"Basic case with missing at end"},{"id":"2","input":"[3,4,-1,1]","expectedOutput":"2","description":"Missing in middle with negatives"},{"id":"3","input":"[7,8,9,11,12]","expectedOutput":"1","description":"All numbers > 1"},{"id":"4","input":"[1,1,2,2]","expectedOutput":"3","description":"Duplicates case"}],"hints":["Think about placing each number in its correct index position","Consider using the array itself as a hash map","The optimal solution uses cyclic sort technique"],"solution":{"javascript":"function firstMissingPositive(nums) {\n  const n = nums.length;\n  \n  // Place each number in its correct position\n  for (let i = 0; i < n; i++) {\n    while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] !== nums[i]) {\n      [nums[nums[i] - 1], nums[i]] = [nums[i], nums[nums[i] - 1]];\n    }\n  }\n  \n  // Find the first position where number doesn't match index\n  for (let i = 0; i < n; i++) {\n    if (nums[i] !== i + 1) {\n      return i + 1;\n    }\n  }\n  \n  return n + 1;\n}","python":"def first_missing_positive(nums):\n    n = len(nums)\n    \n    # Place each number in its correct position\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n    \n    # Find the first position where number doesn't match index\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    \n    return n + 1"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We use cyclic sort to place each element in its correct position, then scan to find the first mismatch."},"timeLimit":15,"createdAt":"2025-12-20T09:39:51.977Z"},{"id":"cc6","title":"Find First and Last Position of Target in Rotated Sorted Array","description":"Given a rotated sorted array that may contain duplicates, find the first and last position of a target value. If the target is not found, return [-1, -1]. A rotated sorted array is an array that was originally sorted in ascending order but then rotated at some pivot point. The array may contain duplicates.\n\nConstraints:\n- 1 <= nums.length <= 10^5\n- -10^4 <= nums[i] <= 10^4\n- -10^4 <= target <= 10^4\n- Time complexity should be better than O(n)","difficulty":"medium","category":"searching","tags":["searching","binary-search","array"],"companies":["Databricks","Palantir"],"starterCode":{"javascript":"function findFirstAndLast(nums, target) {\n  // Your code here\n  \n}","python":"def find_first_and_last(nums, target):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[[4,5,6,7,0,1,2],0]","expectedOutput":"[4,4]","description":"Target in rotated position"},{"id":"2","input":"[[1,1,1,2,2,3,3,4,4,4,4,5,5,5],4]","expectedOutput":"[7,11]","description":"Multiple duplicates of target"},{"id":"3","input":"[[6,7,0,1,2,4,5],3]","expectedOutput":"[-1,-1]","description":"Target not found"},{"id":"4","input":"[[1],1]","expectedOutput":"[0,0]","description":"Single element array"}],"hints":["First find the rotation point using binary search","Then perform binary search on the appropriate subarray","For finding first and last positions, use modified binary search","Handle duplicates carefully when finding the rotation point"],"solution":{"javascript":"function findFirstAndLast(nums, target) {\n  if (nums.length === 0) return [-1, -1];\n  \n  // Find rotation point\n  let left = 0, right = nums.length - 1;\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    if (nums[mid] > nums[right]) {\n      left = mid + 1;\n    } else if (nums[mid] < nums[right]) {\n      right = mid;\n    } else {\n      right--;\n    }\n  }\n  \n  const rotation = left;\n  \n  // Helper function for binary search with range\n  const binarySearch = (start, end, findFirst) => {\n    let result = -1;\n    let l = start, r = end;\n    \n    while (l <= r) {\n      const mid = Math.floor((l + r) / 2);\n      if (nums[mid] === target) {\n        result = mid;\n        if (findFirst) {\n          r = mid - 1;\n        } else {\n          l = mid + 1;\n        }\n      } else if (nums[mid] < target) {\n        l = mid + 1;\n      } else {\n        r = mid - 1;\n      }\n    }\n    \n    return result;\n  };\n  \n  // Determine which subarray to search\n  let firstPos, lastPos;\n  \n  if (rotation === 0 || target >= nums[rotation] && target <= nums[nums.length - 1]) {\n    firstPos = binarySearch(rotation, nums.length - 1, true);\n    lastPos = binarySearch(rotation, nums.length - 1, false);\n  } else {\n    firstPos = binarySearch(0, rotation - 1, true);\n    lastPos = binarySearch(0, rotation - 1, false);\n  }\n  \n  if (firstPos === -1) return [-1, -1];\n  return [firstPos, lastPos];\n}","python":"def find_first_and_last(nums, target):\n    if not nums:\n        return [-1, -1]\n    \n    # Find rotation point\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        elif nums[mid] < nums[right]:\n            right = mid\n        else:\n            right -= 1\n    \n    rotation = left\n    \n    # Helper function for binary search with range\n    def binary_search(start, end, find_first):\n        result = -1\n        l, r = start, end\n        \n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                result = mid\n                if find_first:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            elif nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        \n        return result\n    \n    # Determine which subarray to search\n    if rotation == 0 or target >= nums[rotation] and target <= nums[-1]:\n        first_pos = binary_search(rotation, len(nums) - 1, True)\n        last_pos = binary_search(rotation, len(nums) - 1, False)\n    else:\n        first_pos = binary_search(0, rotation - 1, True)\n        last_pos = binary_search(0, rotation - 1, False)\n    \n    if first_pos == -1:\n        return [-1, -1]\n    return [first_pos, last_pos]"},"complexity":{"time":"O(log n)","space":"O(1)","explanation":"Binary search to find rotation point (O(log n)), then binary search for first and last positions (O(log n))"},"timeLimit":15,"createdAt":"2025-12-20T09:40:09.193Z"},{"id":"cc24","title":"Sort Array by Parity","description":"Given an integer array nums, sort the array so that all even elements come before odd elements. Return the sorted array. The relative order of even and odd elements does not matter.","difficulty":"easy","category":"sorting","tags":["sorting","array","two-pointers"],"companies":["Robinhood","Uber","Elastic"],"starterCode":{"javascript":"function sortByParity(nums) {\n  // Your code here\n  \n}","python":"def sort_by_parity(nums):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[3,1,2,4]","expectedOutput":"[4, 2, 1, 3]","description":"Mixed even and odd numbers"},{"id":"2","input":"[0]","expectedOutput":"[0]","description":"Single even number"},{"id":"3","input":"[1,3,5]","expectedOutput":"[1, 3, 5]","description":"All odd numbers"},{"id":"4","input":"[]","expectedOutput":"[]","description":"Empty array"}],"hints":["Use two pointers starting from both ends of the array","Swap when you find an odd number at the front and even number at the back","This can be done in-place with O(1) extra space"],"solution":{"javascript":"function sortByParity(nums) {\n  let left = 0;\n  let right = nums.length - 1;\n  \n  while (left < right) {\n    if (nums[left] % 2 === 0) {\n      left++;\n    } else if (nums[right] % 2 === 1) {\n      right--;\n    } else {\n      [nums[left], nums[right]] = [nums[right], nums[left]];\n      left++;\n      right--;\n    }\n  }\n  \n  return nums;\n}","python":"def sort_by_parity(nums):\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        if nums[left] % 2 == 0:\n            left += 1\n        elif nums[right] % 2 == 1:\n            right -= 1\n        else:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n    \n    return nums"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"Two-pointer approach makes one pass through the array, swapping in-place"},"timeLimit":10,"createdAt":"2025-12-20T09:47:44.094Z"},{"id":"cc21","title":"Sort Colors","description":"Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent red, white, and blue, respectively. You must solve this problem without using the library's sort function.","difficulty":"medium","category":"sorting","tags":["sorting","two-pointers","array"],"companies":["Tesla","Twitter"],"starterCode":{"javascript":"function sortColors(nums) {\n  // Your code here\n  \n}","python":"def sort_colors(nums):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[2,0,2,1,1,0]","expectedOutput":"[0, 0, 1, 1, 2, 2]","description":"Basic case with mixed colors"},{"id":"2","input":"[2,0,1]","expectedOutput":"[0, 1, 2]","description":"Small array"},{"id":"3","input":"[0]","expectedOutput":"[0]","description":"Single element"},{"id":"4","input":"[1,1,1]","expectedOutput":"[1, 1, 1]","description":"All same color"}],"hints":["Use three pointers to track the position of each color","The Dutch National Flag algorithm solves this in one pass","Think about how to maintain the relative order while swapping"],"solution":{"javascript":"function sortColors(nums) {\n  let low = 0, mid = 0, high = nums.length - 1;\n  \n  while (mid <= high) {\n    if (nums[mid] === 0) {\n      [nums[low], nums[mid]] = [nums[mid], nums[low]];\n      low++;\n      mid++;\n    } else if (nums[mid] === 1) {\n      mid++;\n    } else {\n      [nums[mid], nums[high]] = [nums[high], nums[mid]];\n      high--;\n    }\n  }\n  return nums;\n}","python":"def sort_colors(nums):\n    low, mid, high = 0, 0, len(nums) - 1\n    \n    while mid <= high:\n        if nums[mid] == 0:\n            nums[low], nums[mid] = nums[mid], nums[low]\n            low += 1\n            mid += 1\n        elif nums[mid] == 1:\n            mid += 1\n        else:\n            nums[mid], nums[high] = nums[high], nums[mid]\n            high -= 1\n    return nums"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"Single pass through the array with constant extra space using three pointers"},"timeLimit":15,"createdAt":"2025-12-20T09:47:09.309Z"},{"id":"cc37","title":"Sort by Frequency and Value","description":"Given an array of integers, sort them first by frequency (descending), then by value (ascending). If two numbers have the same frequency, the smaller number comes first. Return the sorted array.\n\nConstraints:\n- 1 <= nums.length <= 10^5\n- -10^9 <= nums[i] <= 10^9\n- Multiple occurrences of the same number are allowed","difficulty":"medium","category":"sorting","tags":["sorting","hash map","frequency"],"companies":["Palantir","Lyft","Morgan Stanley","Salesforce"],"starterCode":{"javascript":"function sortByFrequency(nums) {\n  // Your code here\n}","python":"def sort_by_frequency(nums):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[2,3,1,3,2]","expectedOutput":"[2, 2, 3, 3, 1]","description":"Mixed frequencies"},{"id":"2","input":"[1,1,2,2,2,3]","expectedOutput":"[2, 2, 2, 1, 1, 3]","description":"Different frequencies"},{"id":"3","input":"[5,5,5,5]","expectedOutput":"[5, 5, 5, 5]","description":"All same"},{"id":"4","input":"[-1,2,-1,2,3]","expectedOutput":"[-1, -1, 2, 2, 3]","description":"With negatives"}],"hints":["Use a hash map to count frequencies of each number","Sort using custom comparator: frequency descending, then value ascending"],"solution":{"javascript":"function sortByFrequency(nums) {\n  const freq = {};\n  for (const num of nums) {\n    freq[num] = (freq[num] || 0) + 1;\n  }\n  \n  return nums.sort((a, b) => {\n    if (freq[a] !== freq[b]) {\n      return freq[b] - freq[a];\n    }\n    return a - b;\n  });\n}","python":"def sort_by_frequency(nums):\n    from collections import Counter\n    freq = Counter(nums)\n    \n    return sorted(nums, key=lambda x: (-freq[x], x))"},"complexity":{"time":"O(n log n)","space":"O(n)","explanation":"Counting frequencies takes O(n), sorting takes O(n log n), extra space for frequency map O(n)"},"timeLimit":15,"createdAt":"2025-12-21T09:22:09.254Z"},{"id":"cc41","title":"Sort by Absolute Difference","description":"Given an array of integers and a target value, sort the array based on the absolute difference between each element and the target. If two elements have the same absolute difference, the smaller element should come first. Return the sorted array.\n\nConstraints:\n- 1 ≤ array length ≤ 10^4\n- -10^4 ≤ array elements ≤ 10^4\n- -10^4 ≤ target ≤ 10^4","difficulty":"medium","category":"sorting","tags":["sorting","arrays"],"companies":["Databricks","Uber"],"starterCode":{"javascript":"function sortByAbsoluteDifference(arr, target) {\n  // Your code here\n}","python":"def sort_by_absolute_difference(arr, target):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[[5, 3, 8, 1, 9], 4]","expectedOutput":"[3, 5, 1, 8, 9]","description":"Basic case with mixed differences"},{"id":"2","input":"[[2, 6, 4, 8], 5]","expectedOutput":"[4, 6, 2, 8]","description":"Same difference, tie-break by value"},{"id":"3","input":"[[-3, -1, 2, 4], 0]","expectedOutput":"[-1, -3, 2, 4]","description":"Negative numbers with zero target"},{"id":"4","input":"[[7], 10]","expectedOutput":"[7]","description":"Single element"}],"hints":["Use a custom comparator that compares absolute differences first, then values","Most languages have built-in sort functions that accept custom comparison logic"],"solution":{"javascript":"function sortByAbsoluteDifference(arr, target) {\n  return arr.sort((a, b) => {\n    const diffA = Math.abs(a - target);\n    const diffB = Math.abs(b - target);\n    if (diffA !== diffB) {\n      return diffA - diffB;\n    }\n    return a - b;\n  });\n}","python":"def sort_by_absolute_difference(arr, target):\n    return sorted(arr, key=lambda x: (abs(x - target), x))"},"complexity":{"time":"O(n log n)","space":"O(n)","explanation":"Sorting dominates the time complexity. The space is O(n) for the sorted array (or O(1) for in-place sorting depending on language)."},"timeLimit":15,"createdAt":"2025-12-22T06:31:18.663Z"},{"id":"cc43","title":"Sort by Binary Ones Count","description":"Given an array of integers, sort them in ascending order based on the number of 1s in their binary representation. If two numbers have the same count of 1s, the smaller number should come first.\n\nConstraints:\n- 1 <= nums.length <= 10^4\n- 0 <= nums[i] <= 10^9\n- Return the sorted array","difficulty":"medium","category":"sorting","tags":["sorting","binary","bit-manipulation"],"companies":["Lyft","Tesla","Pinterest","Bloomberg"],"starterCode":{"javascript":"function sortByBinaryOnes(nums) {\n  // Your code here\n}","python":"def sort_by_binary_ones(nums):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[5,3,7,10]","expectedOutput":"[3, 5, 10, 7]","description":"Basic case with different binary counts"},{"id":"2","input":"[0,1,2,3,4,5,6,7,8]","expectedOutput":"[0, 1, 2, 4, 8, 3, 5, 6, 7]","description":"Sequential numbers with varying binary counts"},{"id":"3","input":"[15,7,3,1]","expectedOutput":"[1, 3, 7, 15]","description":"All numbers have same binary count, sort by value"},{"id":"4","input":"[1023,511,255,127,63,31,15,7,3,1]","expectedOutput":"[1, 3, 7, 15, 31, 63, 127, 255, 511, 1023]","description":"Large numbers with different binary counts"}],"hints":["Use built-in bit counting or count 1s manually for each number","Create a custom comparator that first compares by binary count, then by value","Consider using a stable sort to maintain relative order for equal counts"],"solution":{"javascript":"function sortByBinaryOnes(nums) {\n  const countOnes = (num) => {\n    let count = 0;\n    while (num > 0) {\n      count += num & 1;\n      num >>= 1;\n    }\n    return count;\n  };\n  \n  return nums.sort((a, b) => {\n    const countA = countOnes(a);\n    const countB = countOnes(b);\n    if (countA !== countB) {\n      return countA - countB;\n    }\n    return a - b;\n  });\n}","python":"def sort_by_binary_ones(nums):\n    def count_ones(num):\n        count = 0\n        while num > 0:\n            count += num & 1\n            num >>= 1\n        return count\n    \n    return sorted(nums, key=lambda x: (count_ones(x), x))"},"complexity":{"time":"O(n log n * k)","space":"O(1)","explanation":"Sorting takes O(n log n), counting 1s takes O(k) where k is max bit length (up to 30 for given constraints). Overall O(n log n * k) time, O(1) extra space."},"timeLimit":15,"createdAt":"2025-12-22T06:31:38.455Z"},{"id":"cc68","title":"Sort by Custom Priority","description":"Given an array of integers and a priority array, sort the integers based on their priority in the priority array. Numbers with lower index in priority array come first. If a number is not in priority array, it should appear at the end in ascending order.\n\nConstraints:\n- 1 ≤ nums.length ≤ 10^4\n- 1 ≤ priority.length ≤ 10^2\n- 0 ≤ nums[i] ≤ 10^3\n- All numbers in priority array are unique","difficulty":"medium","category":"sorting","tags":["sorting","arrays","custom-comparator"],"companies":["Microsoft","Airbnb"],"starterCode":{"javascript":"function sortByPriority(nums, priority) {\n  // Your code here\n}","python":"def sort_by_priority(nums, priority):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[[5,3,1,2,4],[1,3,5]]","expectedOutput":"[1,3,5,2,4]","description":"Basic priority sorting"},{"id":"2","input":"[[8,2,6,4,1,3,7,5],[5,1,3]]","expectedOutput":"[5,1,3,2,4,6,7,8]","description":"Mixed priority and non-priority"},{"id":"3","input":"[[10,20,30],[1,2,3]]","expectedOutput":"[10,20,30]","description":"No matching priorities"},{"id":"4","input":"[[],[1,2,3]]","expectedOutput":"[]","description":"Empty array"}],"hints":["Create a map from priority values to their indices for O(1) lookup","Use a custom comparator that considers priority index first, then value for non-priority items"],"solution":{"javascript":"function sortByPriority(nums, priority) {\n  const priorityMap = new Map();\n  priority.forEach((val, idx) => priorityMap.set(val, idx));\n  \n  return nums.sort((a, b) => {\n    const aHasPriority = priorityMap.has(a);\n    const bHasPriority = priorityMap.has(b);\n    \n    if (aHasPriority && bHasPriority) {\n      return priorityMap.get(a) - priorityMap.get(b);\n    } else if (aHasPriority) {\n      return -1;\n    } else if (bHasPriority) {\n      return 1;\n    } else {\n      return a - b;\n    }\n  });\n}","python":"def sort_by_priority(nums, priority):\n    priority_map = {val: idx for idx, val in enumerate(priority)}\n    \n    def comparator(x):\n        if x in priority_map:\n            return (0, priority_map[x])\n        else:\n            return (1, x)\n    \n    return sorted(nums, key=comparator)"},"complexity":{"time":"O(n log n)","space":"O(m)","explanation":"Sorting takes O(n log n) time. Priority map uses O(m) space where m is priority length."},"timeLimit":15,"createdAt":"2025-12-25T06:30:56.867Z"},{"id":"cc9","title":"Merge Sorted Arrays","description":"Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. The array nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has n elements. Return the merged sorted array.\n\nConstraints:\n- 0 ≤ m, n ≤ 200\n- 1 ≤ m + n ≤ 200\n- -10^9 ≤ nums1[i], nums2[i] ≤ 10^9\n- Both input arrays are already sorted in non-decreasing order","difficulty":"medium","category":"sorting","tags":["sorting","arrays","two-pointers","merge"],"companies":["Salesforce","Nvidia","Coinbase"],"starterCode":{"javascript":"function mergeSortedArrays(nums1, m, nums2, n) {\n  // Your code here\n  \n}","python":"def merge_sorted_arrays(nums1, m, nums2, n):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[[1,2,3,0,0,0],3,[2,5,6],3]","expectedOutput":"[1,2,2,3,5,6]","description":"Basic merge case"},{"id":"2","input":"[[1],1,[],0]","expectedOutput":"[1]","description":"Second array empty"},{"id":"3","input":"[[0],0,[1],1]","expectedOutput":"[1]","description":"First array empty"},{"id":"4","input":"[[4,5,6,0,0,0],3,[1,2,3],3]","expectedOutput":"[1,2,3,4,5,6]","description":"Reverse order merge"}],"hints":["Start merging from the end of both arrays to avoid overwriting elements","Use three pointers: one for nums1, one for nums2, and one for the result position","The optimal solution works in-place without extra space"],"solution":{"javascript":"function mergeSortedArrays(nums1, m, nums2, n) {\n  let i = m - 1;\n  let j = n - 1;\n  let k = m + n - 1;\n  \n  while (j >= 0) {\n    if (i >= 0 && nums1[i] > nums2[j]) {\n      nums1[k] = nums1[i];\n      i--;\n    } else {\n      nums1[k] = nums2[j];\n      j--;\n    }\n    k--;\n  }\n  \n  return nums1;\n}","python":"def merge_sorted_arrays(nums1, m, nums2, n):\n    i = m - 1\n    j = n - 1\n    k = m + n - 1\n    \n    while j >= 0:\n        if i >= 0 and nums1[i] > nums2[j]:\n            nums1[k] = nums1[i]\n            i -= 1\n        else:\n            nums1[k] = nums2[j]\n            j -= 1\n        k -= 1\n    \n    return nums1"},"complexity":{"time":"O(m + n)","space":"O(1)","explanation":"We traverse both arrays once using two pointers, and the merge is done in-place"},"timeLimit":15,"createdAt":"2025-12-20T09:40:33.651Z"},{"id":"cc8","title":"Valid Parentheses","description":"Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. A string is valid if: 1) Open brackets are closed by the same type of brackets. 2) Open brackets are closed in the correct order. 3) Every close bracket has a corresponding open bracket of the same type.","difficulty":"easy","category":"stacks","tags":["stacks","string","validation"],"companies":["Tesla","Intel","Adobe","Palantir"],"starterCode":{"javascript":"function isValidParentheses(s) {\n  // Your code here\n  \n}","python":"def is_valid_parentheses(s):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"\"()\"","expectedOutput":"true","description":"Simple valid case"},{"id":"2","input":"\"()[]{}\"","expectedOutput":"true","description":"Multiple valid pairs"},{"id":"3","input":"\"(]\"","expectedOutput":"false","description":"Mismatched brackets"},{"id":"4","input":"\"\"","expectedOutput":"true","description":"Empty string is valid"}],"hints":["Use a stack to keep track of opening brackets","When you see a closing bracket, check if it matches the top of the stack","The string is valid if the stack is empty at the end"],"solution":{"javascript":"function isValidParentheses(s) {\n  const stack = [];\n  const pairs = { '(': ')', '[': ']', '{': '}' };\n  \n  for (let char of s) {\n    if (pairs[char]) {\n      stack.push(char);\n    } else {\n      const last = stack.pop();\n      if (!last || pairs[last] !== char) {\n        return false;\n      }\n    }\n  }\n  \n  return stack.length === 0;\n}","python":"def is_valid_parentheses(s):\n    stack = []\n    pairs = {'(': ')', '[': ']', '{': '}'}\n    \n    for char in s:\n        if char in pairs:\n            stack.append(char)\n        else:\n            if not stack or pairs[stack.pop()] != char:\n                return False\n    \n    return len(stack) == 0"},"complexity":{"time":"O(n)","space":"O(n)","explanation":"We iterate through the string once, pushing/popping from stack. In worst case, all characters are opening brackets, so stack size is O(n)."},"timeLimit":10,"createdAt":"2025-12-20T09:40:23.368Z"},{"id":"cc18","title":"Valid Parentheses with Minimum Removals","description":"Given a string containing only '(', ')', '{', '}', '[' and ']', determine the minimum number of characters to remove to make the string valid. A string is valid if every opening bracket has a corresponding closing bracket of the same type and they are properly nested. Return the minimum number of removals needed.\n\nConstraints:\n- 1 <= s.length <= 10^5\n- s consists only of '(', ')', '{', '}', '[' and ']'\n- The input string may contain any combination of valid and invalid bracket sequences","difficulty":"medium","category":"stacks","tags":["stacks","string","greedy"],"companies":["Pinterest","Elastic","Google"],"starterCode":{"javascript":"function minRemovalsToValid(s) {\n  // Your code here\n  \n}","python":"def min_removals_to_valid(s):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"\"()\"","expectedOutput":"0","description":"Already valid string"},{"id":"2","input":"\"(())\"","expectedOutput":"0","description":"Nested valid string"},{"id":"3","input":"\"(()\"","expectedOutput":"1","description":"Missing closing bracket"},{"id":"4","input":"\"())\"","expectedOutput":"1","description":"Extra closing bracket"},{"id":"5","input":"\"([)]\"","expectedOutput":"2","description":"Mismatched brackets"},{"id":"6","input":"\"((({{{[[[)))}}]])))\"","expectedOutput":"15","description":"Complex invalid string"},{"id":"7","input":"\"\"","expectedOutput":"0","description":"Empty string"}],"hints":["Use a stack to track opening brackets and their positions","When you find a mismatch, you need to remove either the opening or closing bracket","Count unmatched opening brackets left in the stack at the end","The answer is the sum of unmatched closing and opening brackets"],"solution":{"javascript":"function minRemovalsToValid(s) {\n  const stack = [];\n  let removals = 0;\n  \n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    \n    if (char === '(' || char === '[' || char === '{') {\n      stack.push(char);\n    } else {\n      if (stack.length === 0) {\n        removals++; // Unmatched closing bracket\n      } else {\n        const top = stack[stack.length - 1];\n        if ((char === ')' && top === '(') ||\n            (char === ']' && top === '[') ||\n            (char === '}' && top === '{')) {\n          stack.pop(); // Valid pair\n        } else {\n          removals++; // Mismatched closing bracket\n        }\n      }\n    }\n  }\n  \n  // Add unmatched opening brackets\n  removals += stack.length;\n  \n  return removals;\n}","python":"def min_removals_to_valid(s):\n    stack = []\n    removals = 0\n    \n    for char in s:\n        if char in '([{':\n            stack.append(char)\n        else:\n            if not stack:\n                removals += 1  # Unmatched closing bracket\n            else:\n                top = stack[-1]\n                if (char == ')' and top == '(') or \\\n                   (char == ']' and top == '[') or \\\n                   (char == '}' and top == '{'):\n                    stack.pop()  # Valid pair\n                else:\n                    removals += 1  # Mismatched closing bracket\n    \n    # Add unmatched opening brackets\n    removals += len(stack)\n    \n    return removals"},"complexity":{"time":"O(n)","space":"O(n)","explanation":"We process each character once using a stack to track opening brackets. The stack can grow up to size n in the worst case."},"timeLimit":15,"createdAt":"2025-12-20T09:46:28.248Z"},{"id":"cc58","title":"Next Greater Element in Circular Array","description":"Given a circular array of integers, find the next greater element for each element. The next greater element of an element x is the first greater element to its right in the circular array. If such an element doesn't exist, return -1 for that position.\n\nConstraints:\n- 1 ≤ nums.length ≤ 10^4\n- -10^9 ≤ nums[i] ≤ 10^9\n- The array is circular, meaning we wrap around to the beginning when reaching the end.","difficulty":"medium","category":"stacks","tags":["stacks","arrays","circular"],"companies":["Square","LinkedIn","Uber","Pinterest"],"starterCode":{"javascript":"function nextGreaterElements(nums) {\n  // Your code here\n}","python":"def next_greater_elements(nums):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1,2,1]","expectedOutput":"[2, -1, 2]","description":"Basic circular case"},{"id":"2","input":"[1,2,3,4,3]","expectedOutput":"[2, 3, 4, -1, 4]","description":"Mixed increasing and decreasing"},{"id":"3","input":"[5,4,3,2,1]","expectedOutput":"[-1, 5, 5, 5, 5]","description":"Strictly decreasing"},{"id":"4","input":"[2]","expectedOutput":"[-1]","description":"Single element"}],"hints":["Use a monotonic decreasing stack to keep track of indices whose next greater element hasn't been found yet.","Process the array twice (2n iterations) to handle the circular nature, but only populate results for the first pass."],"solution":{"javascript":"function nextGreaterElements(nums) {\n  const n = nums.length;\n  const result = new Array(n).fill(-1);\n  const stack = [];\n  \n  for (let i = 0; i < 2 * n; i++) {\n    const idx = i % n;\n    while (stack.length > 0 && nums[stack[stack.length - 1]] < nums[idx]) {\n      const prevIdx = stack.pop();\n      result[prevIdx] = nums[idx];\n    }\n    if (i < n) {\n      stack.push(idx);\n    }\n  }\n  \n  return result;\n}","python":"def next_greater_elements(nums):\n    n = len(nums)\n    result = [-1] * n\n    stack = []\n    \n    for i in range(2 * n):\n        idx = i % n\n        while stack and nums[stack[-1]] < nums[idx]:\n            prev_idx = stack.pop()\n            result[prev_idx] = nums[idx]\n        if i < n:\n            stack.append(idx)\n    \n    return result"},"complexity":{"time":"O(n)","space":"O(n)","explanation":"We process each element at most twice (2n iterations) and each element is pushed/popped from the stack at most once."},"timeLimit":15,"createdAt":"2025-12-25T06:29:26.730Z"},{"id":"cc66","title":"Decode String with Nested Patterns","description":"Given an encoded string with patterns like '3[a]2[bc]', decode it by expanding the bracketed sections. The string may contain nested patterns like '3[a2[c]]'. Return the fully decoded string.\n\nConstraints:\n- 1 <= s.length <= 100\n- s consists of digits, letters, and square brackets\n- Digits represent the number of repetitions\n- All brackets are properly matched","difficulty":"medium","category":"stacks","tags":["stacks","strings","parsing"],"companies":["Pinterest","Databricks"],"starterCode":{"javascript":"function decodeString(s) {\n  // Your code here\n}","python":"def decode_string(s):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"\"3[a]2[bc]\"","expectedOutput":"\"aaabcbc\"","description":"Basic patterns"},{"id":"2","input":"\"3[a2[c]]\"","expectedOutput":"\"accaccacc\"","description":"Nested patterns"},{"id":"3","input":"\"2[abc]3[cd]ef\"","expectedOutput":"\"abcabccdcdcdef\"","description":"Multiple patterns"},{"id":"4","input":"\"10[a]\"","expectedOutput":"\"aaaaaaaaaa\"","description":"Multi-digit repetition"}],"hints":["Use two stacks: one for numbers and one for strings","When you see '[', push current string and number to stacks","When you see ']', pop from stacks and build the repeated string"],"solution":{"javascript":"function decodeString(s) {\n  const numStack = [];\n  const strStack = [];\n  let currentNum = 0;\n  let currentStr = '';\n  \n  for (let char of s) {\n    if (char >= '0' && char <= '9') {\n      currentNum = currentNum * 10 + parseInt(char);\n    } else if (char === '[') {\n      numStack.push(currentNum);\n      strStack.push(currentStr);\n      currentNum = 0;\n      currentStr = '';\n    } else if (char === ']') {\n      const repeatTimes = numStack.pop();\n      const prevStr = strStack.pop();\n      currentStr = prevStr + currentStr.repeat(repeatTimes);\n    } else {\n      currentStr += char;\n    }\n  }\n  \n  return currentStr;\n}","python":"def decode_string(s):\n    num_stack = []\n    str_stack = []\n    current_num = 0\n    current_str = ''\n    \n    for char in s:\n        if char.isdigit():\n            current_num = current_num * 10 + int(char)\n        elif char == '[':\n            num_stack.append(current_num)\n            str_stack.append(current_str)\n            current_num = 0\n            current_str = ''\n        elif char == ']':\n            repeat_times = num_stack.pop()\n            prev_str = str_stack.pop()\n            current_str = prev_str + current_str * repeat_times\n        else:\n            current_str += char\n    \n    return current_str"},"complexity":{"time":"O(n)","space":"O(n)","explanation":"We process each character once. The stacks store at most O(n) elements in the worst case of deeply nested brackets."},"timeLimit":15,"createdAt":"2025-12-25T06:30:39.431Z"},{"id":"cc22","title":"Reverse Vowels","description":"Given a string s, reverse only the vowels in it. All other characters should remain in their original positions. Vowels are 'a', 'e', 'i', 'o', 'u' (both lowercase and uppercase). Return the resulting string after reversing the vowels.","difficulty":"easy","category":"strings","tags":["strings","two-pointers","vowels"],"companies":["PayPal","Pinterest"],"starterCode":{"javascript":"function reverseVowels(s) {\n  // Your code here\n  \n}","python":"def reverse_vowels(s):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"\"hello\"","expectedOutput":"\"holle\"","description":"Basic case with vowels"},{"id":"2","input":"\"leetcode\"","expectedOutput":"\"leotcede\"","description":"Multiple vowels"},{"id":"3","input":"\"aA\"","expectedOutput":"\"Aa\"","description":"Case sensitivity test"},{"id":"4","input":"\"bcdfg\"","expectedOutput":"\"bcdfg\"","description":"No vowels"}],"hints":["Use two pointers starting from both ends of the string","Collect vowels first or swap as you find them","Remember to check both lowercase and uppercase vowels"],"solution":{"javascript":"function reverseVowels(s) {\n  const vowels = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']);\n  const chars = s.split('');\n  let left = 0, right = chars.length - 1;\n  \n  while (left < right) {\n    if (!vowels.has(chars[left])) {\n      left++;\n    } else if (!vowels.has(chars[right])) {\n      right--;\n    } else {\n      [chars[left], chars[right]] = [chars[right], chars[left]];\n      left++;\n      right--;\n    }\n  }\n  \n  return chars.join('');\n}","python":"def reverse_vowels(s):\n    vowels = set('aeiouAEIOU')\n    chars = list(s)\n    left, right = 0, len(chars) - 1\n    \n    while left < right:\n        if chars[left] not in vowels:\n            left += 1\n        elif chars[right] not in vowels:\n            right -= 1\n        else:\n            chars[left], chars[right] = chars[right], chars[left]\n            left += 1\n            right -= 1\n    \n    return ''.join(chars)"},"complexity":{"time":"O(n)","space":"O(n)","explanation":"Two-pointer approach visits each character once, converting string to array for in-place swaps"},"timeLimit":10,"createdAt":"2025-12-20T09:47:18.498Z"},{"id":"cc44","title":"String Character Frequency Sort","description":"Given a string, sort its characters in descending order based on their frequency. If two characters have the same frequency, they should maintain their original order of appearance. Return the sorted string.","difficulty":"easy","category":"strings","tags":["strings","sorting","frequency"],"companies":["Robinhood","Coinbase","Google","Uber"],"starterCode":{"javascript":"function frequencySort(s) {\n  // Your code here\n}","python":"def frequency_sort(s):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"\"tree\"","expectedOutput":"\"eetr\"","description":"Basic case with repeated characters"},{"id":"2","input":"\"cccaaa\"","expectedOutput":"\"cccaaa\"","description":"Same frequency, maintain original order"},{"id":"3","input":"\"a\"","expectedOutput":"\"a\"","description":"Single character"},{"id":"4","input":"\"\"","expectedOutput":"\"\"","description":"Empty string"}],"hints":["Count character frequencies using a hash map or dictionary","Sort characters by frequency (descending) while preserving original order for ties"],"solution":{"javascript":"function frequencySort(s) {\n  const freq = {};\n  const order = [];\n  \n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (!freq[char]) {\n      freq[char] = 1;\n      order.push(char);\n    } else {\n      freq[char]++;\n    }\n  }\n  \n  const sorted = order.sort((a, b) => freq[b] - freq[a]);\n  \n  let result = '';\n  for (const char of sorted) {\n    result += char.repeat(freq[char]);\n  }\n  \n  return result;\n}","python":"def frequency_sort(s):\n    freq = {}\n    order = []\n    \n    for char in s:\n        if char not in freq:\n            freq[char] = 1\n            order.append(char)\n        else:\n            freq[char] += 1\n    \n    sorted_chars = sorted(order, key=lambda x: freq[x], reverse=True)\n    \n    result = ''\n    for char in sorted_chars:\n        result += char * freq[char]\n    \n    return result"},"complexity":{"time":"O(n log n)","space":"O(n)","explanation":"We count frequencies in O(n), then sort unique characters in O(k log k) where k ≤ n, and build the result in O(n)."},"timeLimit":15,"createdAt":"2025-12-22T06:31:45.580Z"},{"id":"cc48","title":"String Character Distance Calculator","description":"Given a string and two characters, calculate the minimum distance between any occurrence of the first character and any occurrence of the second character. If either character doesn't exist in the string, return -1. The distance is the absolute difference between their indices (0-based).","difficulty":"easy","category":"strings","tags":["strings","two-pointers"],"companies":["Meta","LinkedIn","Microsoft","Stripe"],"starterCode":{"javascript":"function minCharacterDistance(s, char1, char2) {\n  // Your code here\n}","python":"def min_character_distance(s, char1, char2):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[\"abacaba\", \"a\", \"b\"]","expectedOutput":"1","description":"Basic case with multiple occurrences"},{"id":"2","input":"[\"hello world\", \"h\", \"w\"]","expectedOutput":"5","description":"Characters at different positions"},{"id":"3","input":"[\"abcde\", \"x\", \"y\"]","expectedOutput":"-1","description":"Both characters missing"},{"id":"4","input":"[\"aaaaa\", \"a\", \"a\"]","expectedOutput":"0","description":"Same character"}],"hints":["Track the last seen position of each character while iterating through the string","Update the minimum distance whenever you find both characters"],"solution":{"javascript":"function minCharacterDistance(s, char1, char2) {\n  let last1 = -1, last2 = -1, minDist = Infinity;\n  \n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === char1) {\n      last1 = i;\n      if (last2 !== -1) minDist = Math.min(minDist, Math.abs(last1 - last2));\n    }\n    if (s[i] === char2) {\n      last2 = i;\n      if (last1 !== -1) minDist = Math.min(minDist, Math.abs(last1 - last2));\n    }\n  }\n  \n  return minDist === Infinity ? -1 : minDist;\n}","python":"def min_character_distance(s, char1, char2):\n    last1, last2 = -1, -1\n    min_dist = float('inf')\n    \n    for i, char in enumerate(s):\n        if char == char1:\n            last1 = i\n            if last2 != -1:\n                min_dist = min(min_dist, abs(last1 - last2))\n        if char == char2:\n            last2 = i\n            if last1 != -1:\n                min_dist = min(min_dist, abs(last1 - last2))\n    \n    return -1 if min_dist == float('inf') else min_dist"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"Single pass through the string with constant extra space for tracking positions"},"timeLimit":15,"createdAt":"2025-12-22T06:32:18.987Z"},{"id":"cc54","title":"String Word Reverser","description":"Given a string, reverse the order of words while maintaining the original character order within each word. Words are separated by spaces. Handle multiple spaces and leading/trailing spaces.","difficulty":"easy","category":"strings","tags":["strings","manipulation"],"companies":["Airbnb","Robinhood","Google"],"starterCode":{"javascript":"function reverseWords(s) {\n  // Your code here\n}","python":"def reverse_words(s):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"\"hello world\"","expectedOutput":"\"world hello\"","description":"Basic two words"},{"id":"2","input":"\"  the sky  is blue  \"","expectedOutput":"\"blue is sky the\"","description":"Multiple spaces and trimming"},{"id":"3","input":"\"single\"","expectedOutput":"\"single\"","description":"Single word"},{"id":"4","input":"\"\"","expectedOutput":"\"\"","description":"Empty string"}],"hints":["Split the string by spaces and filter out empty strings","Reverse the array of words and join with single spaces"],"solution":{"javascript":"function reverseWords(s) {\n  return s.trim().split(/\\s+/).reverse().join(' ');\n}","python":"def reverse_words(s):\n    words = s.strip().split()\n    return ' '.join(reversed(words))"},"complexity":{"time":"O(n)","space":"O(n)","explanation":"We split the string into words (O(n) time, O(n) space), reverse the array (O(n) time), and join back (O(n) time)."},"timeLimit":15,"createdAt":"2025-12-22T06:33:11.332Z"},{"id":"cc10","title":"Longest Substring Without Repeating Characters","description":"Given a string s, return the length of the longest substring without repeating characters. A substring is a contiguous sequence of characters within the string. Constraints: 0 <= s.length <= 10^5, s consists of ASCII characters.","difficulty":"medium","category":"strings","tags":["strings","sliding-window","hash-map"],"companies":["Square","Databricks"],"starterCode":{"javascript":"function lengthOfLongestSubstring(s) {\n  // Your code here\n  \n}","python":"def length_of_longest_substring(s):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"\"abcabcbb\"","expectedOutput":"3","description":"Basic case with repeating characters"},{"id":"2","input":"\"bbbbb\"","expectedOutput":"1","description":"All same characters"},{"id":"3","input":"\"pwwkew\"","expectedOutput":"3","description":"Non-repeating substring in middle"},{"id":"4","input":"\"\"","expectedOutput":"0","description":"Empty string"}],"hints":["Use a sliding window approach with two pointers","Keep track of characters seen using a hash map","Move the left pointer when you encounter a duplicate character"],"solution":{"javascript":"function lengthOfLongestSubstring(s) {\n  const charMap = new Map();\n  let left = 0;\n  let maxLength = 0;\n  \n  for (let right = 0; right < s.length; right++) {\n    const char = s[right];\n    if (charMap.has(char) && charMap.get(char) >= left) {\n      left = charMap.get(char) + 1;\n    }\n    charMap.set(char, right);\n    maxLength = Math.max(maxLength, right - left + 1);\n  }\n  \n  return maxLength;\n}","python":"def length_of_longest_substring(s):\n    char_map = {}\n    left = 0\n    max_length = 0\n    \n    for right, char in enumerate(s):\n        if char in char_map and char_map[char] >= left:\n            left = char_map[char] + 1\n        char_map[char] = right\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length"},"complexity":{"time":"O(n)","space":"O(min(n, 128))","explanation":"We traverse the string once with sliding window, storing at most 128 ASCII characters in the hash map"},"timeLimit":15,"createdAt":"2025-12-20T09:40:58.615Z"},{"id":"cc13","title":"String Compression","description":"Given a string of lowercase letters, compress it by replacing consecutive identical characters with the character followed by the count of consecutive occurrences. If the compressed string is not shorter than the original, return the original string. Constraints: 1 ≤ string length ≤ 10^4, string contains only lowercase letters.","difficulty":"medium","category":"strings","tags":["strings","compression","iteration"],"companies":["SpaceX","Amazon","Microsoft","Snap"],"starterCode":{"javascript":"function compressString(s) {\n  // Your code here\n  \n}","python":"def compress_string(s):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"\"aaabcccccaaa\"","expectedOutput":"\"a3b1c5a3\"","description":"Normal case with multiple groups"},{"id":"2","input":"\"abcdef\"","expectedOutput":"\"abcdef\"","description":"No compression needed (all unique)"},{"id":"3","input":"\"a\"","expectedOutput":"\"a\"","description":"Single character"},{"id":"4","input":"\"aaaaaaaaaa\"","expectedOutput":"\"a10\"","description":"Long run of same character"}],"hints":["Iterate through the string while tracking the current character and its count","Build the compressed string as you go, but only return it if it's shorter","Be careful with the last group of characters when the loop ends"],"solution":{"javascript":"function compressString(s) {\n  if (s.length === 0) return s;\n  \n  let compressed = '';\n  let count = 1;\n  \n  for (let i = 1; i < s.length; i++) {\n    if (s[i] === s[i - 1]) {\n      count++;\n    } else {\n      compressed += s[i - 1] + count;\n      count = 1;\n    }\n  }\n  \n  compressed += s[s.length - 1] + count;\n  \n  return compressed.length < s.length ? compressed : s;\n}","python":"def compress_string(s):\n    if not s:\n        return s\n    \n    compressed = []\n    count = 1\n    \n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            compressed.append(s[i - 1] + str(count))\n            count = 1\n    \n    compressed.append(s[-1] + str(count))\n    \n    result = ''.join(compressed)\n    return result if len(result) < len(s) else s"},"complexity":{"time":"O(n)","space":"O(n)","explanation":"We iterate through the string once, and the compressed string can be up to 2n characters in worst case"},"timeLimit":15,"createdAt":"2025-12-20T09:41:49.033Z"},{"id":"cc46","title":"String Pattern Decoder","description":"Given an encoded string where letters are followed by numbers representing how many times to repeat the previous letter, decode the string. For example, 'a2b3c1' becomes 'aabbbcc'. The pattern always alternates between letter and number. Handle edge cases where numbers can be multiple digits.","difficulty":"medium","category":"strings","tags":["strings","parsing","pattern-matching"],"companies":["Coinbase","Airbnb","Bloomberg","Snap"],"starterCode":{"javascript":"function decodePattern(encoded) {\n  // Your code here\n}","python":"def decode_pattern(encoded):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"\"a2b3c1\"","expectedOutput":"\"aabbbc\"","description":"Basic pattern with single digits"},{"id":"2","input":"\"x10y2z1\"","expectedOutput":"\"xxxxxxxxxxyyz\"","description":"Multi-digit numbers"},{"id":"3","input":"\"m1n12o3\"","expectedOutput":"\"mnnnnnnnnnnnnooo\"","description":"Mixed single and multi-digit"},{"id":"4","input":"\"\"","expectedOutput":"\"\"","description":"Empty string"}],"hints":["Iterate through the string, collecting letters and parsing the following numbers","Use two pointers: one for letters, one to find where numbers end","Build the result by repeating each letter the parsed number of times"],"solution":{"javascript":"function decodePattern(encoded) {\n  let result = '';\n  let i = 0;\n  \n  while (i < encoded.length) {\n    const letter = encoded[i];\n    i++;\n    \n    let numStr = '';\n    while (i < encoded.length && encoded[i] >= '0' && encoded[i] <= '9') {\n      numStr += encoded[i];\n      i++;\n    }\n    \n    const count = parseInt(numStr);\n    result += letter.repeat(count);\n  }\n  \n  return result;\n}","python":"def decode_pattern(encoded):\n    result = ''\n    i = 0\n    \n    while i < len(encoded):\n        letter = encoded[i]\n        i += 1\n        \n        num_str = ''\n        while i < len(encoded) and encoded[i].isdigit():\n            num_str += encoded[i]\n            i += 1\n        \n        count = int(num_str)\n        result += letter * count\n    \n    return result"},"complexity":{"time":"O(n)","space":"O(n)","explanation":"We traverse the string once, and the result string size is proportional to the total output length"},"timeLimit":15,"createdAt":"2025-12-22T06:31:59.001Z"},{"id":"cc69","title":"String Transaction Parser","description":"Parse a string of financial transactions and calculate the final balance. Each transaction starts with '+' (credit) or '-' (debit) followed by an amount. The string contains transactions separated by commas with no spaces. Handle invalid formats by ignoring malformed transactions.","difficulty":"medium","category":"strings","tags":["strings","parsing","finance"],"companies":["Square","PayPal"],"starterCode":{"javascript":"function parseTransactions(transactions) {\n  // Your code here\n}","python":"def parse_transactions(transactions):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"\"+100,-50,+25\"","expectedOutput":"75","description":"Basic transactions"},{"id":"2","input":"\"+200,-100,-50,+25\"","expectedOutput":"75","description":"Multiple debits and credits"},{"id":"3","input":"\"+100,abc,-50,+25x,+75\"","expectedOutput":"125","description":"Invalid formats mixed with valid"},{"id":"4","input":"\"\"","expectedOutput":"0","description":"Empty string"}],"hints":["Split the string by commas and validate each transaction format","Use parseInt or parseFloat to convert amounts, checking for valid numbers"],"solution":{"javascript":"function parseTransactions(transactions) {\n  if (!transactions) return 0;\n  \n  const parts = transactions.split(',');\n  let balance = 0;\n  \n  for (const part of parts) {\n    if (part.length < 2) continue;\n    \n    const sign = part[0];\n    const amountStr = part.slice(1);\n    const amount = parseInt(amountStr, 10);\n    \n    if (isNaN(amount)) continue;\n    \n    if (sign === '+') {\n      balance += amount;\n    } else if (sign === '-') {\n      balance -= amount;\n    }\n  }\n  \n  return balance;\n}","python":"def parse_transactions(transactions):\n    if not transactions:\n        return 0\n    \n    parts = transactions.split(',')\n    balance = 0\n    \n    for part in parts:\n        if len(part) < 2:\n            continue\n        \n        sign = part[0]\n        amount_str = part[1:]\n        \n        try:\n            amount = int(amount_str)\n        except ValueError:\n            continue\n        \n        if sign == '+':\n            balance += amount\n        elif sign == '-':\n            balance -= amount\n    \n    return balance"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"We process each transaction once with constant extra space"},"timeLimit":15,"createdAt":"2025-12-25T06:31:03.787Z"},{"id":"cc40","title":"Longest Subarray with Sum at Most K","description":"Given an array of positive integers and a target sum K, find the length of the longest contiguous subarray whose sum is at most K. Return 0 if no such subarray exists.\n\nConstraints:\n- 1 ≤ nums.length ≤ 10^5\n- 1 ≤ nums[i] ≤ 10^4\n- 1 ≤ K ≤ 10^9","difficulty":"medium","category":"two-pointers","tags":["two-pointers","sliding-window","arrays"],"companies":["Airbnb","Twitter"],"starterCode":{"javascript":"function longestSubarray(nums, k) {\n  // Your code here\n}","python":"def longest_subarray(nums, k):\n    # Your code here\n    pass"},"testCases":[{"id":"1","input":"[1,2,3,4,5], 11","expectedOutput":"4","description":"Normal case - subarray [1,2,3,4] sums to 10"},{"id":"2","input":"[5,1,2,3,4], 6","expectedOutput":"3","description":"Subarray starting from index 1 - [1,2,3]"},{"id":"3","input":"[10,20,30], 5","expectedOutput":"0","description":"No subarray fits the constraint"},{"id":"4","input":"[1,1,1,1,1], 3","expectedOutput":"3","description":"All elements equal - longest prefix"}],"hints":["Use a sliding window with two pointers to maintain the current sum","When the sum exceeds K, move the left pointer to shrink the window","Track the maximum window size seen during the process"],"solution":{"javascript":"function longestSubarray(nums, k) {\n  let left = 0, sum = 0, maxLen = 0;\n  \n  for (let right = 0; right < nums.length; right++) {\n    sum += nums[right];\n    \n    while (sum > k && left <= right) {\n      sum -= nums[left];\n      left++;\n    }\n    \n    if (sum <= k) {\n      maxLen = Math.max(maxLen, right - left + 1);\n    }\n  }\n  \n  return maxLen;\n}","python":"def longest_subarray(nums, k):\n    left = 0\n    current_sum = 0\n    max_len = 0\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        \n        while current_sum > k and left <= right:\n            current_sum -= nums[left]\n            left += 1\n        \n        if current_sum <= k:\n            max_len = max(max_len, right - left + 1)\n    \n    return max_len"},"complexity":{"time":"O(n)","space":"O(1)","explanation":"Each element is visited at most twice - once when expanding the window and once when shrinking it"},"timeLimit":15,"createdAt":"2025-12-22T06:31:01.719Z"}]