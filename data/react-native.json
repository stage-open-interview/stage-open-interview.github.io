{"questions":[{"id":"q-1048","question":"You're building a React Native field-ops app with intermittent connectivity that must display offline-first tasks with images and support incremental sync across devices. Describe architecture and provide a small implementation sketch using a local DB (WatermelonDB or Realm), a sync service, and conflict resolution. What edge cases and tests would you include?","answer":"Adopt offline-first strategy using WatermelonDB or Realm to store tasks and media locally. Implement a background SyncWorker that batches local changes, fetches remote deltas, and merges conflicts wit","explanation":"## Why This Is Asked\n\nTests ability to design offline-first systems, conflict resolution, and background sync in React Native.\n\n## Key Concepts\n\n- offline-first DB in RN (WatermelonDB/Realm)\n- delta-based incremental sync\n- conflict resolution strategy (LWW, per-field merges)\n- background tasks (Headless JS/WorkManager)\n\n## Code Example\n\n```javascript\n// Pseudo-code sketch for SyncWorker\nasync function processBatch(batch) {\n  // apply local changes, fetch remote deltas, merge conflicts\n}\n```\n\n## Follow-up Questions\n\n- How would you handle large binary media in offline cache?\n- How would you test race conditions across devices?","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Hugging Face","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T20:33:19.081Z","createdAt":"2026-01-12T20:33:19.081Z"},{"id":"q-1065","question":"You're building a React Native app for live collaboration that streams up to 4 simultaneous camera feeds using WebRTC. Describe end-to-end architecture for capture, encoding, and transport, how you'd implement backpressure and frame pacing to sustain ~30fps per feed, and provide a small implementation sketch (camera hook + simple backpressure queue) in code?","answer":"Use four RN camera streams via WebRTC with separate RTCPeerConnections and tracks. Capture frames with VisionCamera, encode in a native module using hardware encoders, and push to the correct WebRTC t","explanation":"## Why This Is Asked\nTests real-world RN streaming with WebRTC, multi-sensor coordination, and performance under backpressure.\n\n## Key Concepts\n- WebRTC integration in React Native\n- Camera capture pipelines and encoders\n- Backpressure, frame pacing, queue management\n- Resource constraints on mobile devices and cross-platform differences\n\n## Code Example\n```javascript\nfunction createBackpressureQueue(limit){\n  const q = [];\n  return {\n    enqueue(f){ if (q.length < limit){ q.push(f); return true } return false; },\n    dequeue(){ return q.shift(); },\n    size(){ return q.length; }\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test backpressure behavior under network jitter?\n- What are the trade-offs between software vs. native encoding paths in RN?","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Google","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T21:24:56.893Z","createdAt":"2026-01-12T21:24:56.893Z"},{"id":"q-1098","question":"You're building a React Native app for field technicians that must collect GPS and sensor data in the background every 15 minutes, even when the app is suspended. Describe a cross‑platform architecture using Android WorkManager and iOS BGTaskScheduler, a minimal RN bridge, and a small code sketch of a BackgroundTaskManager that schedules tasks, persists deadlines, and handles results. Include edge cases like battery saver, app termination, and user-initiated cancel?","answer":"Adopt a cross‑platform BackgroundTaskManager bridged to native: Android WorkManager (PeriodicWorkRequest, 15m, network/battery constraints) and iOS BGTaskScheduler (BGAppRefreshTask with earliestBegin","explanation":"## Why This Is Asked\nTests cross‑platform background execution, RN bridge design, and resilience under OS quotas.\n\n## Key Concepts\n- RN bridge to native modules (TurboModules/JSI)\n- Android WorkManager and iOS BGTaskScheduler\n- Headless JS tasks and data persistence\n- Backoff/retry, quotas, cancellation\n\n## Code Example\n```javascript\nclass BackgroundTaskManager {\n  static register() { /* native register */ }\n  static schedule() { /* schedule task via bridge */ }\n  static cancel() { /* cancel */ }\n}\nexport default BackgroundTaskManager;\n```\n\n## Follow-up Questions\n- How would you test for battery-saver constraints and app-termination scenarios?","diagram":"flowchart TD\nA[RN App] --> B[BackgroundTaskManager]\nB --> C[Android: WorkManager]\nB --> D[iOS: BGTaskScheduler]\nC --> E[Headless JS Task]\nD --> E\nE --> F[Local Persist]\nF --> G[Backoff/Retry]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T22:29:56.902Z","createdAt":"2026-01-12T22:29:56.902Z"},{"id":"q-1265","question":"You're building a real-time collaborative whiteboard in React Native that must support up to 1,000 participants with low latency and offline fallback. Describe an end-to-end architecture using WebRTC data channels for deltas, WebSocket signaling, and a CRDT for merging concurrent strokes. Include data model (stroke encoding, timestamps), backpressure handling, and a small code sketch implementing a delta encoder and an in-app delta queue that feeds an RN Canvas/Skia surface, with clear acceptance criteria?","answer":"Approach: peer-to-peer deltas via WebRTC data channels, signaling via WebSocket. Encode each stroke as compact deltas (move coordinate, pressure, color, width) with varint. Use a CRDT like RGA for ord","explanation":"## Why This Is Asked\n\nTests real-time collaboration design, data encoding efficiency, and RN-CRDT integration.\n\n## Key Concepts\n\n- WebRTC data channels for low-latency deltas\n- WebSocket signaling and fallback\n- CRDTs vs OT for merges\n- Delta encoding and backpressure\n- Fluid rendering on RN Canvas/Skia\n\n## Code Example\n\n```javascript\nfunction encodeStroke(stroke){\n  // delta-encode a stroke segment\n  // return compact object\n}\nfunction applyDelta(state, delta){\n  // patch canvas state with delta\n}\n```\n\n## Follow-up Questions\n\n- How would you scale the signaling and data channels to 1,000 participants?\n- How would you ensure idempotence and replay on reconnect?","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T07:32:10.415Z","createdAt":"2026-01-13T07:32:10.415Z"},{"id":"q-1537","question":"You're building a React Native app for field engineers in regulated environments. It collects GPS and accelerometer telemetry, signs each record with a device key, and batches uploads to a backend with offline-first guarantees and tamper-evident auditing. Describe the architecture, data flow, and provide a small code sketch: a LocalAuditLog module backed by SQLite and TweetNaCl for Ed25519 signing, plus a transport adapter with exponential backoff and key-rotation handling. Include edge cases around tenant isolation, data retention, and replay protection?","answer":"Use a LocalAuditLog backed by SQLite to store signed records. Sign each entry with Ed25519 (TweetNaCl) using a per-tenant device key, include a timestamp and previous hash for chaining. Batch 50–100 r","explanation":"## Why This Is Asked\nThis probes end-to-end data integrity in offline-first mobile apps, with regulatory considerations and tenant isolation.\n\n## Key Concepts\n- Local SQLite storage for durable offline data\n- Ed25519 signing (TweetNaCl) for tamper-evident logs\n- Batch transmission with exponential backoff and idempotent retries\n- Tenant isolation and per-tenant key rotation\n- Replay protection via nonces and chained hashes\n- Data-retention and auditability guarantees\n\n## Code Example\n```javascript\n// LocalAuditLog.ts (sketch)\nimport { open } from 'sqlite';\nimport sqlite3 from 'sqlite3';\nimport nacl from 'tweetnacl';\nimport naclUtil from 'tweetnacl-util';\n\ntype AuditRecord = {\n  id: string;\n  tenantId: string;\n  timestamp: number;\n  nonce: string;\n  payload: string;\n  hash?: string;\n  signature?: string;\n};\n\nexport class LocalAuditLog {\n  private db: any;\n  private keyPair: { publicKey: string; secretKey: string };\n\n  private constructor(db: any, keyPair: { publicKey: string; secretKey: string }) {\n    this.db = db; this.keyPair = keyPair;\n  }\n\n  static async create(dbPath: string): Promise<LocalAuditLog> {\n    const db = await open({ filename: dbPath, driver: sqlite3.Database });\n    await db.exec(`CREATE TABLE IF NOT EXISTS audits (\n      id TEXT PRIMARY KEY, tenantId TEXT, timestamp INTEGER, nonce TEXT,\n      payload TEXT, hash TEXT, signature TEXT, sent INTEGER DEFAULT 0\n    )`);\n    // placeholder keypair; in practice load from secure storage and rotate as needed\n    const keyPair = nacl.sign.keyPair();\n    return new LocalAuditLog(db, {\n      publicKey: naclUtil.encodeBase64(keyPair.publicKey),\n      secretKey: naclUtil.encodeBase64(keyPair.secretKey)\n    });\n  }\n\n  async append(tenantId: string, payload: string, nonce: string): Promise<void> {\n    const record: AuditRecord = {\n      id: crypto.randomUUID(), tenantId, timestamp: Date.now(), nonce, payload\n    };\n    const data = `${record.tenantId}|${record.timestamp}|${record.nonce}|${record.payload}`;\n    const sig = nacl.sign.detached(naclUtil.decodeBase64(this.keyPair.secretKey), naclUtil.decodeUTF8(data));\n    record.hash = this.hashRecord(record);\n    record.signature = naclUtil.encodeBase64(sig);\n    await this.db.run(`INSERT INTO audits (id, tenantId, timestamp, nonce, payload, hash, signature) VALUES (?, ?, ?, ?, ?, ?, ?)`,\n      record.id, record.tenantId, record.timestamp, record.nonce, record.payload, record.hash, record.signature);\n  }\n\n  async getBatch(limit: number): Promise<AuditRecord[]> {\n    const rows = await this.db.all(`SELECT * FROM audits WHERE sent = 0 ORDER BY timestamp ASC LIMIT ?`, limit);\n    return rows as AuditRecord[];\n  }\n\n  async markSent(ids: string[]): Promise<void> {\n    const placeholders = ids.map(() => '?').join(',');\n    await this.db.run(`UPDATE audits SET sent = 1 WHERE id IN (${placeholders})`, ids);\n  }\n\n  private hashRecord(r: AuditRecord): string {\n    return naclUtil.crypto_hash(`${r.tenantId}|${r.timestamp}|${r.nonce}|${r.payload}`);\n  }\n}\n```\n\n## Follow-up Questions\n- How would you securely store and rotate keys on device across app updates?\n- How would you migrate existing records during a key rotation without data loss?\n- How would you verify server integrity and prevent replay attacks in case of network replayed requests?","diagram":"flowchart TD\n  A[Mobile App] --> B[LocalAuditLog (SQLite)]\n  B --> C[Signer (TweetNaCl Ed25519)]\n  C --> D[Batcher]\n  D --> E[Transport with Retry]\n  E --> F[Backend]","difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Goldman Sachs","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T20:53:27.037Z","createdAt":"2026-01-13T20:53:27.038Z"},{"id":"q-1790","question":"You're building a cross-platform React Native app for field technicians that must display a map with thousands of POIs, support offline caching of tiles and markers, and perform incremental sync of POI updates when online. Design a data layer and UI flow to support offline-first maps, marker clustering, and conflict resolution. Provide a small code sketch for a WatermelonDB/Realm model and a MarkerLayer component, plus test ideas?","answer":"Adopt an offline-first data layer (WatermelonDB or Realm) for POIs and a disk tile cache. Implement incremental sync: push local POI deltas, pull server updates, and resolve conflicts using server-tim","explanation":"## Why This Is Asked\n\nEvaluates ability to design an offline-first map data model, incremental sync, and scalable UI rendering with clustering in a real RN app.\n\n## Key Concepts\n\n- Offline-first data model using WatermelonDB or Realm\n- Disk tile cache for maps\n- Incremental sync with delta PUSH and server updates\n- Conflict resolution via server-timestamp precedence or last-writer-wins with logs\n- Marker clustering with geohash or grid\n- Testing: offline edits, conflict scenarios, clustering accuracy, cache eviction\n\n## Code Example\n\n```javascript\n// WatermelonDB POI schema sketch\nconst poisSchema = tableSchema({\n  name: 'pois',\n  columns: [\n    { name: 'name', type: 'string' },\n    { name: 'lat', type: 'number' },\n    { name: 'lon', type: 'number' },\n    { name: 'last_modified', type: 'number' },\n  ],\n});\n\n// MarkerLayer sketch (conceptual)\nfunction MarkerLayer({ pois }) {\n  const clusters = clusterPoints(pois, 60); // 60px radius\n  return clusters.map((c) => (\n    <Marker key={c.id} coordinate={c.center} onPress={() => openPOI(c.pois[0].id)}>\n      <Callout>{c.count} POIs</Callout>\n    </Marker>\n  ));\n}\n```\n\n## Follow-up Questions\n\n- How would you test sync conflict resolution in a CI pipeline?\n- What metrics would you monitor to detect tile cache memory pressure?\n- How would you handle real-time map tile updates in online mode without blocking UI?","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Meta","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T10:51:03.589Z","createdAt":"2026-01-14T10:51:03.589Z"},{"id":"q-2072","question":"You’re building a beginner-friendly React Native gallery that shows a 2x2 grid of images loaded from a remote JSON endpoint. Describe how you would implement offline-first caching with AsyncStorage, automatic data refresh on reconnect, and a small hook sketch to fetch and cache the image list (including error handling and a simple retry strategy)?","answer":"Use a hook useImageList that first loads cached results from AsyncStorage, falling back to fetch on miss or stale timestamp; on success, cache data with timestamp. Subscribe to NetInfo to refresh when","explanation":"## Why This Is Asked\nTests ability to design a resilient, beginner-friendly offline-first feature using core RN APIs, with practicalCaching and reconnect handling.\n\n## Key Concepts\n- AsyncStorage for caching\n- NetInfo for connectivity events\n- FlatList with numColumns=2 for a grid\n- Simple retry/backoff and error handling\n- Stale data strategy (timestamp checks)\n\n## Code Example\n```javascript\nimport {useEffect, useState, useCallback} from 'react';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport NetInfo from '@react-native-community/netinfo';\n\nexport function useImageList(endpoint) {\n  const [images, setImages] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  const load = useCallback(async (force = false) => {\n    if (!force) {\n      const cached = await AsyncStorage.getItem('images_cache');\n      if (cached) {\n        setImages(JSON.parse(cached));\n        setLoading(false);\n        return;\n      }\n    }\n    try {\n      const res = await fetch(endpoint);\n      const data = await res.json();\n      setImages(data);\n      await AsyncStorage.setItem('images_cache', JSON.stringify(data));\n      await AsyncStorage.setItem('images_cache_ts', Date.now().toString());\n      setError(null);\n    } catch (e) {\n      setError(e);\n    } finally {\n      setLoading(false);\n    }\n  }, [endpoint]);\n\n  useEffect(() => {\n    load();\n    const unsubscribe = NetInfo.addEventListener(state => {\n      if (state.isConnected) load(true);\n    });\n    return () => unsubscribe();\n  }, [load]);\n\n  return { images, loading, error, retry: () => load(true) };\n}\n```\n\n## Follow-up Questions\n- How would you test the offline cache invalidation strategy?\n- How would you adapt this for paginated loading with large datasets?","diagram":"flowchart TD\n  A[Open Gallery] --> B{Cached data?}\n  B -- Yes --> C[Show cached]\n  B -- No --> D[Fetch JSON]\n  D --> E[Cache results]\n  E --> C","difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T23:25:37.824Z","createdAt":"2026-01-14T23:25:37.824Z"},{"id":"q-2292","question":"In a React Native app for real-time dashboards, you must render up to 16 live charts and 8 image tiles refreshed via WebSocket without UI jank. How would you implement a cross-platform image tile pipeline using TurboModules (JSI) that decodes, caches, and delivers tiles on a background thread, while using a virtualization list to keep 60fps? Include a concise native interface sketch and a JS wrapper?","answer":"Use a TurboModule with a native tile decoder running on a dedicated worker thread; expose decodeTile and evictOldTiles. Implement a bounded LRU cache in JS and feed imgs to a FlatList. Backpressure vi","explanation":"## Why This Is Asked\nTests understanding of cross-platform RN bridges, background work, and memory-aware UI performance for dashboards.\n\n## Key Concepts\n- TurboModules/JSI bridging\n- background decoding threads\n- LRU caching and eviction\n- list virtualization for 60fps\n- memory pressure handling and backpressure\n\n## Code Example\n\n```javascript\n// Native module interface (TS-like)\nexport interface TileDecoderModule {\n  decodeTile(tileId: string, data: Uint8Array): Promise<ImageSource>;\n  evictOldTiles(limit: number): void;\n}\n```\n\n```javascript\n// JS wrapper sketch\ntype TileInfo = { id: string; bytes: Uint8Array; };\nclass TileDecoder {\n  private mod = (require('react-native')).NativeTileDecoder as TileDecoderModule;\n  async ensureTile(info: TileInfo) { return this.mod.decodeTile(info.id, info.bytes); }\n}\n```\n\n## Follow-up Questions\n- How would you test backpressure handling and eviction strategies?\n- How would you measure decode latency and frame drop under memory pressure?","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Databricks"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T10:51:59.033Z","createdAt":"2026-01-15T10:51:59.033Z"},{"id":"q-2436","question":"In a DoorDash-style React Native app with intermittent connectivity, how would you implement offline-first order placement using an AsyncStorage-backed Outbox queue, a background worker that processes queued actions when online, and idempotent retry semantics? Provide a minimal enqueueOrder and processQueue sketch?","answer":"Use an AsyncStorage-backed Outbox with fields like id, type, payload, retryCount, and status. On placeOrder, enqueue. A background worker runs when online (via NetInfo), iterates pending items, calls ","explanation":"## Why This Is Asked\n\nAssess offline-first data integrity, background processing, and idempotent retries in a real-world order flow.\n\n## Key Concepts\n\n- Outbox pattern\n- AsyncStorage persistence\n- Background processing lifecycle\n- Idempotency and exponential backoff\n- Conflict resolution\n\n## Code Example\n\n```javascript\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\n// enqueue an order for later processing\nasync function enqueueOrder(order) {\n  const item = { id: order.id, type: 'order', payload: order, retryCount: 0, status: 'pending' };\n  const qRaw = await AsyncStorage.getItem('orderOutbox');\n  const queue = qRaw ? JSON.parse(qRaw) : [];\n  queue.push(item);\n  await AsyncStorage.setItem('orderOutbox', JSON.stringify(queue));\n}\n\n// process queue\nasync function processQueue() {\n  const qRaw = await AsyncStorage.getItem('orderOutbox');\n  const queue = qRaw ? JSON.parse(qRaw) : [];\n  for (const it of queue.filter(i => i.status === 'pending')) {\n    try {\n      await api.placeOrder(it.payload, { idempotencyKey: it.id });\n      it.status = 'completed';\n    } catch (e) {\n      it.retryCount = (it.retryCount || 0) + 1;\n      // optional: computeBackoff(it.retryCount)\n    }\n  }\n  await AsyncStorage.setItem('orderOutbox', JSON.stringify(queue));\n}\n``` \n\n## Follow-up Questions\n\n- How would you test offline recovery and ensure no duplicate orders occur?\n- How would you integrate with a true background task runner to survive app suspends?\n","diagram":"flowchart TD\n  Offline(Offline/No Network) --> Queue[Outbox Queue]\n  Queue -->|Process| Server[Server API]\n  Server -->|Success| Remove[Remove from Queue]\n  Server -->|Failure| Backoff[Backoff & Retry]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T17:53:56.829Z","createdAt":"2026-01-15T17:53:56.829Z"},{"id":"q-2459","question":"You're building a cross-platform React Native app that requires a native module 'TileCache' to prefetch and cache map tiles for offline use. Outline the architecture, how the JavaScript bridge would interact with the iOS and Android implementations, memory management and eviction strategy, and a minimal code sketch showing the JS API and a native bridge interface to fetch a tile by z/x/y within a viewport. Include testing considerations?","answer":"TileCache is a TurboModule exposing preloadTiles(bounds, zoom), getTile(x,y,z), and clearCache. iOS (Swift) and Android (Kotlin) back the cache with a disk LRU, synchronized with a background task que","explanation":"## Why This Is Asked\n\nInterfacing JS with native modules across platforms is error-prone; this tests depth in native modules, memory, and caching.\n\n## Key Concepts\n\n- React Native bridges (JSI/TurboModules)\n- Cross-platform native modules (iOS/Android)\n- Disk + in-memory LRU cache and eviction\n- Background work and synchronization\n- Robust testing: misses, eviction, corruption, offline paths\n\n## Code Example\n\n```javascript\nexport type TileKey = { x: number; y: number; z: number; viewportId?: string };\nexport interface TileCacheApi {\n  preloadTiles(bounds: { ne: { lat: number; lng: number }; sw: { lat: number; lng: number } }, zoom: number): void;\n  getTile(x: number, y: number, z: number): Promise<string | null>;\n  clearCache(): void;\n}\n```\n\n## Follow-up Questions\n\n- How would you expose progress events and error codes to JS?\n- How would you test cache eviction under rapid viewport changes?\n","diagram":"flowchart TD\n  A[React Native JS] --> B[TileCache TurboModule]\n  B --> C[iOS Swift Native]\n  B --> D[Android Kotlin Native]\n  C --> E[Disk Cache]\n  D --> E\n  A --> F[App UI uses getTile()]\n","difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","IBM","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T19:01:04.355Z","createdAt":"2026-01-15T19:01:04.355Z"},{"id":"q-2501","question":"You're building a beginner-friendly React Native field-data app for solar installations that allows technicians to submit a checklist and attach photos while offline. Describe an offline-first submission queue design: data model, how to store locally, how to detect connectivity, batching strategy, and a small hook sketch that enqueues items with a retry/backoff policy using AsyncStorage. Include a minimal example snippet for the hook?","answer":"Store a local offline queue in AsyncStorage as JSON: {id, payload, timestamp, retries}. On submit, push to queue and mark pending. Use NetInfo to detect online; when online, batch up to 10 items and P","explanation":"## Why This Is Asked\n\nTests offline-first data capture patterns, local persistence, network awareness, and retry/backoff in a React Native context.\n\n## Key Concepts\n\n- AsyncStorage for persistent queue\n- NetInfo to detect connectivity\n- Batch submission and idempotency\n- Exponential backoff with max cap\n- Test strategies for offline scenarios\n\n## Code Example\n\n```javascript\nimport { useEffect, useState } from 'react';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport NetInfo from '@react-native-community/netinfo';\n\nexport const useOfflineQueue = (storageKey = 'offline_submissions') => {\n  const [queue, setQueue] = useState([]);\n  useEffect(() => {\n    (async () => {\n      const raw = await AsyncStorage.getItem(storageKey);\n      setQueue(raw ? JSON.parse(raw) : []);\n    })();\n  }, [storageKey]);\n\n  const enqueue = async (payload) => {\n    const item = { id: `${Date.now()}-${Math.random()}`, payload, timestamp: Date.now(), retries: 0 };\n    const next = [...queue, item];\n    setQueue(next);\n    await AsyncStorage.setItem(storageKey, JSON.stringify(next));\n  };\n\n  const flush = async () => {\n    if (!queue.length) return;\n    const toSend = queue.map(i => i.payload);\n    try {\n      const res = await fetch('https://example.com/api/submissions', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(toSend),\n      });\n      if (res.ok) {\n        await AsyncStorage.setItem(storageKey, JSON.stringify([]));\n        setQueue([]);\n      } else {\n        throw new Error('server-error');\n      }\n    } catch (e) {\n      const advanced = queue.map(i => ({ ...i, retries: i.retries + 1 }));\n      setQueue(advanced);\n      await AsyncStorage.setItem(storageKey, JSON.stringify(advanced));\n    }\n  };\n\n  return { queue, enqueue, flush };\n};\n```\n\n## Follow-up Questions\n\n- How would you test offline queue behavior on a real device? \n- How would you adapt the approach for large payloads or binary attachments (photos)?","diagram":null,"difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T20:43:56.876Z","createdAt":"2026-01-15T20:43:56.876Z"},{"id":"q-2615","question":"You're building a field-service React Native app that must perform a background data refresh every 15 minutes to fetch location-tagged asset metadata, even when the app is terminated on both Android and iOS. Design a cross-platform background task broker using Android WorkManager and iOS BGTaskScheduler. Specify data models, scheduling constraints (network/battery), how to handle token refresh, and provide a minimal React hook sketch (useBackgroundSync) to start/stop the background work and expose status?","answer":"Design a cross-platform background broker with Android WorkManager using PeriodicWorkRequest configured for 15-minute intervals, network connectivity, and battery optimization constraints, and iOS BGTaskScheduler using BGProcessingTask with earliestBeginDate, network connectivity, and external power requirements. Implement secure token refresh with persistent storage, handle app termination scenarios, and provide React Native bridge integration for real-time status updates.","explanation":"## Why This Is Asked\nTests ability to design cross-platform background work with proper lifecycle handling, constraint management, and security considerations for field-service applications requiring continuous data synchronization.\n\n## Key Concepts\n- Cross-platform native module development bridging React Native to Android and iOS\n- WorkManager vs BGTaskScheduler architecture, constraint-based scheduling, and termination handling\n- Secure persistent storage for authentication tokens and pending operations\n- Token refresh flow management and error recovery mechanisms\n- React hook patterns for background task lifecycle management","diagram":"flowchart TD\n  A[User action] --> B[Schedule task via NativeBridge]\n  B --> C[Android WorkManager / iOS BGTaskScheduler]\n  C --> D[Fetch data]\n  D --> E[Store results locally and sync to server]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Microsoft","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T05:00:33.061Z","createdAt":"2026-01-16T02:44:48.041Z"},{"id":"q-2631","question":"You're building a React Native field map app that shows a live route panel with up to 500 waypoints delivered over a WebSocket. Design a component architecture that minimizes re-renders, handles backpressure when bursts occur, and keeps the map smooth at 60fps. Provide a concise implementation sketch for a useLiveWaypoints hook (buffering and a render queue) and a minimal native bridge sketch if needed. What tests would you add to verify performance and correctness?","answer":"Adopt a data path that decouples ingestion from rendering: a ring buffer accepts WebSocket messages, a RAF-tied render queue drains a fixed batch per frame, and a memoized selector updates a capped po","explanation":"## Why This Is Asked\nTests practical RN performance patterns: streaming data, backpressure, and rendering at 60fps. The candidate must show how to separate data ingestion from rendering and explain trade-offs.\n\n## Key Concepts\n- WebSocket streaming and buffering\n- Render queue driven by requestAnimationFrame\n- Immutable data updates and memoization\n- Map overlay with a capped, debounced point set\n- Memory profiling and cross-device testing\n\n## Code Example\n```javascript\nimport { useEffect, useRef, useState } from 'react';\n\nexport function useLiveWaypoints(wsUrl) {\n  const [points, setPoints] = useState([]);\n  const buffer = useRef([]);\n  const raf = useRef<number | null>(null);\n\n  useEffect(() => {\n    const ws = new WebSocket(wsUrl);\n    ws.onmessage = (ev) => {\n      const p = JSON.parse(ev.data); // {lat, lng, ts, id}\n      buffer.current.push(p);\n    };\n    return () => ws.close();\n  }, [wsUrl]);\n\n  useEffect(() => {\n    const loop = () => {\n      const b = buffer.current;\n      if (b.length) {\n        const batchSize = Math.min(b.length, 30);\n        const batch = b.splice(0, batchSize);\n        setPoints((prev) => {\n          const merged = prev.concat(batch);\n          return merged.slice(-500);\n        });\n      }\n      raf.current = requestAnimationFrame(loop);\n    };\n    raf.current = requestAnimationFrame(loop);\n    return () => {\n      if (raf.current) cancelAnimationFrame(raf.current);\n    };\n  }, []);\n\n  return points;\n}\n```\n\n## Follow-up Questions\n- How would you test backpressure behavior under bursty data?\n- How would you adapt this for offline caching and replay after reconnect?","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Instacart","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T04:14:40.962Z","createdAt":"2026-01-16T04:14:40.962Z"},{"id":"q-2841","question":"You're building a React Native feed that displays images from a CDN with three size variants (thumb, medium, large). Implement an adaptive image loader that selects the best variant based current network speed, device pixel density, and battery saver mode, with graceful fallbacks on flaky networks. Describe data models, caching (SQLite/Realm) strategy, and provide a minimal hook useAdaptiveImage that returns {uri, loading, error} and triggers prefetches. Provide a small code sketch?","answer":"Use NetInfo to estimate bandwidth and battery mode, and PixelRatio to pick a variant (thumb/medium/large). Prefetch non-selected variants and cache the chosen URI with TTL in Realm/SQLite. The hook us","explanation":"## Why This Is Asked\nTests ability to design a responsive image loading strategy that balances UX and data usage, incorporating network state, device capabilities, and offline caching in React Native.\n\n## Key Concepts\n- Variant selection logic using NetInfo, PixelRatio, and battery saver state\n- Local caching strategy (Realm/SQLite) with TTL and cache busting\n- Image loading lifecycle and prefetching to minimize jank\n\n## Code Example\n```javascript\nimport { useEffect, useState, useCallback } from 'react'\nimport NetInfo from '@react-native-community/netinfo'\nimport { PixelRatio } from 'react-native'\n\nfunction useAdaptiveImage(sizes, baseUri) {\n  const [uri, setUri] = useState(sizes.medium)\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState(null)\n\n  const resolveVariant = useCallback((info) => {\n    const bandwidth = info.type === 'wifi' ? 1000 : info.details?.speed ?? 500\n    const dpr = PixelRatio.get()\n    const batterySaver = info.batterySaverEnabled\n    let chosen = sizes.medium\n    if (!batterySaver && bandwidth > 800 && dpr >= 2) chosen = sizes.large\n    else if (bandwidth < 400) chosen = sizes.thumb\n    return chosen\n  }, [sizes])\n\n  useEffect(() => {\n    let mounted = true\n    NetInfo.fetch().then(info => {\n      if (!mounted) return\n      const variant = resolveVariant(info)\n      setUri(variant)\n      // pretend fetch/cache logic here\n      setLoading(false)\n    }).catch(err => {\n      if (mounted) { setError(err); setLoading(false) }\n    })\n    return () => { mounted = false }\n  }, [resolveVariant])\n\n  const refresh = useCallback(() => {\n    setLoading(true)\n    NetInfo.fetch().then(info => {\n      const variant = resolveVariant(info)\n      setUri(variant)\n      setLoading(false)\n    }).catch(err => setError(err))\n  }, [resolveVariant])\n\n  return { uri, loading, error, refresh }\n}\n```\n\n## Follow-up Questions\n- How would you validate cache invalidation and handle remote URL changes?\n- How would you test behavior under intermittent connectivity and battery saver toggling?","diagram":"flowchart TD\n  NetState[Network State] --> Variant[Variant Selection]\n  Variant --> Cache[Cache Store (Realm/SQLite)]\n  NetState --> Prefetch[Prefetch Other Variants]\n  DPRBattery[DPR & Battery] --> Variant","difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T14:35:34.825Z","createdAt":"2026-01-16T14:35:34.825Z"},{"id":"q-2883","question":"You're building an offline-first React Native field-inspection app where technicians submit checklists with photos while offline. Describe end-to-end sync: data model (Checklists, Items, Attachments, Revisions), local storage choice (Realm vs SQLite), sync engine (queueing, retry/backoff, push vs pull), and conflict resolution strategy (vector clocks vs server revisions or CRDT). Include a small hook sketch that enqueues updates with backoff using a background task?","answer":"Use Realm for offline data graph (Checklist, Items, Attachments) with a per-record revision. Local SyncQueue holds pending mutations. Detect connectivity via NetInfo; a background worker batches and a","explanation":"## Why This Is Asked\nThis question probes practical offline-sync engineering, conflict handling at scale, and RN background work.\n\n## Key Concepts\n- Offline-first data modeling and synchronization\n- Conflict resolution strategies (vector clocks, last-writer-wins, CRDTs)\n- Background tasks in React Native and storage choices\n\n## Code Example\n```javascript\n// Hook sketch: enqueue mutations for sync\nimport { useCallback } from 'react'\nconst useEnqueueMutation = (store) => {\n  return useCallback((mut) => {\n    // push to SyncQueue in Realm/SQLite\n  }, [store])\n}\n```\n\n## Follow-up Questions\n- How would you test conflict scenarios across devices?\n- How would you ensure media uploads (photos) are reliably retried?\n","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","MongoDB","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T15:53:57.439Z","createdAt":"2026-01-16T15:53:57.439Z"},{"id":"q-2964","question":"You're building a React Native app for field technicians that must upload short audio notes recorded in-app while the app is in the background on both Android and iOS. The design should ensure battery and network constraints are respected, handle token refresh, and tolerate app termination. Design a cross-platform background upload pipeline: Android (WorkManager/ForegroundService) and iOS (BGProcessingTask), define data models (AudioNote, UploadState), scheduling constraints, retry strategy, and provide a minimal React hook sketch (useAudioUpload) to enqueue notes, start/stop background tasks, and expose progress?","answer":"Architect a cross-platform background upload pipeline via a native module (TurboModules/JSI). Android uses a ForegroundService with WorkManager for uploads under network and battery constraints; iOS u","explanation":"## Why This Is Asked\n\nThis question tests designing robust cross‑platform background tasks with native modules and a JS bridge, including scheduling, constraints, and error handling.\n\n## Key Concepts\n\n- React Native bridging (JSI/TurboModules)\n- Android ForegroundService + WorkManager\n- iOS BGProcessingTask\n- Data models and state machines (AudioNote, UploadState)\n- Backoff strategies and token refresh\n\n## Code Example\n\n```javascript\n// Minimal hook sketch\nexport function useAudioUpload() {\n  // enqueue, start, stop, and progress subscription\n}\n```\n\n## Follow-up Questions\n\n- How would you test across lifecycle events (app kill/restart, device reboot)?\n- How would you handle offline queueing and idempotent retries?\n","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Google","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T19:27:03.829Z","createdAt":"2026-01-16T19:27:03.829Z"},{"id":"q-3096","question":"You have a React Native dashboard app that renders a FlatList of 1,000+ items with images; data arrives in bursts and causes frame drops on both iOS and Android. Design a performance strategy to keep scroll smooth: virtualization tweaks, memoization, and batched updates. Implement a minimal hook useLiveList that subscribes to a native update channel, batches updates, and flushes periodically. Provide a concise sketch of usage in a component?","answer":"To maintain smooth scrolling with 1,000+ items, leverage FlatList's virtualization features: getItemLayout for predictable heights, initialNumToRender to control initial load, maxToRenderPerBatch to limit concurrent renders, windowSize to manage offscreen items, removeClippedSubviews for Android optimization, and a stable keyExtractor for efficient re-renders. Memoize list items using React.memo and wrap render functions in useCallback to prevent unnecessary re-renders. For bursty data scenarios, implement a custom hook useLiveList that batches updates using a buffer and flushes periodically via requestAnimationFrame or setInterval. The hook subscribes to a native event emitter, accumulates updates in a ref buffer, and applies them in controlled batches to prevent frame drops.","explanation":"## Why This Is Asked\nReal-world rendering challenges with large lists and bursty updates.\n\n## Key Concepts\n- FlatList virtualization\n- Memoization and stable keys\n- Batched updates and interval flushing\n- Native event emitters and bridging\n\n## Code Example\n```javascript\nimport { useEffect, useRef, useState } from 'react';\nimport { NativeEventEmitter, NativeModules } from 'react-native';\n\nexport function useLiveList(channel) {\n  const [updates, setUpdates] = useState([]);\n  const buf = useRef([]);\n  \n  useEffect(() => {\n    const emitter = new NativeEventEmitter(NativeModules[channel]);\n    const subscription = emitter.addListener('dataUpdate', (data) => {\n      buf.current.push(data);\n    });\n    \n    const flushInterval = setInterval(() => {\n      if (buf.current.length > 0) {\n        setUpdates(prev => [...prev, ...buf.current]);\n        buf.current = [];\n      }\n    }, 16); // ~60fps\n    \n    return () => {\n      subscription.remove();\n      clearInterval(flushInterval);\n    };\n  }, [channel]);\n  \n  return updates;\n}\n\n// Usage in component\nfunction LiveDashboard() {\n  const data = useLiveList('LiveDataSource');\n  \n  const renderItem = useCallback(({ item }) => (\n    <MemoizedListItem item={item} />\n  ), []);\n  \n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem}\n      getItemLayout={(data, index) => ({ length: 80, offset: 80 * index, index })}\n      initialNumToRender={10}\n      maxToRenderPerBatch={5}\n      windowSize={10}\n      removeClippedSubviews\n      keyExtractor={(item, index) => `item-${item.id || index}`}\n    />\n  );\n}\n```","diagram":"flowchart TD\n  DataSource[Data Source] --> FlatList[FlatList]\n  FlatList --> Renderer[Item Renderer]\n  NativeUpdates[Native Updates] --> Buffer[Batcher]\n  Buffer --> FlatList","difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Salesforce","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T05:00:07.377Z","createdAt":"2026-01-17T02:18:01.243Z"},{"id":"q-3113","question":"You're building a React Native product catalog for a large retailer. The catalog has 5,000 SKUs with high-res thumbnails and stock status updates via a streaming WebSocket. Implement a concrete plan: a useLiveCatalog hook to batch updates, and a 3-column FlatList with progressive images to keep scroll smooth. Include a minimal usage sketch and trade-offs?","answer":"Use a useLiveCatalog hook that buffers WebSocket updates in 16ms frames, merges into an immutable Map SKU->item, and exposes getVisibleItems. Render a 3-column FlatList with a ProgressiveImage compone","explanation":"## Why This Is Asked\n\nTests ability to design a streaming data pipeline in RN and keep UI responsive with large catalogs.\n\n## Key Concepts\n\n- Batched, time-bounded updates from WebSocket\n- Immutable data maps for O(1) updates and predictable renders\n- Progressive image loading and memoized row renders\n- FlatList optimizations: getItemLayout, keyExtractor, numColumns\n\n## Code Example\n\n```javascript\n// Minimal sketch: useLiveCatalog hook\nimport { useEffect, useRef, useState } from 'react';\nfunction useLiveCatalog(url) {\n  const [items, setItems] = useState(new Map());\n  const batch = useRef([]);\n  useEffect(() => {\n    const ws = new WebSocket(url);\n    ws.onmessage = (ev) => {\n      batch.current.push(JSON.parse(ev.data));\n    };\n    const t = setInterval(() => {\n      if (!batch.current.length) return;\n      const next = new Map(items);\n      for (const it of batch.current) next.set(it.id, it);\n      setItems(next);\n      batch.current = [];\n    }, 16);\n    return () => clearInterval(t);\n  }, [url]);\n  return Array.from(items.values());\n}\n```\n\n## Follow-up Questions\n\n- How would you test memory footprint and frame rate on mid-range devices?\n- How would you adapt to offline rehydration after app restart?","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Instacart","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T03:59:01.090Z","createdAt":"2026-01-17T03:59:01.092Z"},{"id":"q-3520","question":"Design a cross-platform ML inference bridge for React Native that loads models from the bundle or remote storage, runs inference on a dedicated worker thread (Android: TensorFlow Lite, iOS: Core ML), enforces a memory budget, and exposes a hook useMLInference(modelName, inputs) that queues inputs with backpressure and returns predictions asynchronously. Include architecture, data flow, error handling, and a minimal hook + native module outline?","answer":"Implement a cross-platform NativeModule that loads models from bundle or remote, runs inference on a worker thread via TFLite/Core ML, enforces a memory budget, and exposes useMLInference(modelName, i","explanation":"## Why This Is Asked\nTests ability to design a scalable, cross‑platform ML bridge, handle memory budgets, dynamic model loading, and a React hook API that cleanly abstracts native work.\n\n## Key Concepts\n- React Native bridging and native modules\n- Cross‑platform ML inference (TFLite/Core ML)\n- Dynamic model loading and versioning\n- Concurrency, worker threads, and input backpressure\n- Memory budgeting and lifecycle management\n\n## Code Example\n```javascript\n// Minimal hook sketch (conceptual)\nimport { useEffect, useRef, useState } from 'react';\nimport { NativeModules } from 'react-native';\nconst { MLBridge } = NativeModules;\n\nexport function useMLInference(modelName, inputs) {\n  const [pred, setPred] = useState(null);\n  const queue = useRef([]);\n\n  useEffect(() => {\n    if (!inputs) return;\n    queue.current.push(inputs);\n    MLBridge.enqueue(modelName, inputs)\n      .then(result => setPred(result))\n      .catch(() => {});\n  }, [modelName, inputs]);\n\n  return pred;\n}\n```\n\n## Follow-up Questions\n- How would you implement model versioning and cache invalidation?\n- How would you test latency, throughput, and memory across devices?","diagram":"flowchart TD\n  JS Layer --> NativeBridge\n  NativeBridge --> WorkerThread\n  WorkerThread --> Model\n  Model --> Predictions","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Hugging Face"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T19:34:20.215Z","createdAt":"2026-01-17T19:34:20.215Z"},{"id":"q-3579","question":"You're building a React Native app used offline by technicians that stores sensitive data locally (checklists, photos). Propose a secure offline storage design that preserves data-at-rest encryption with per-user keys, biometric unlock, and key rotation. Include data model considerations, library choices (Realm vs SQLite), a key-wrapping strategy, and a minimal hook sketch for encrypting on save and decrypting on read?","answer":"Implement envelope encryption with per-record AES-256-GCM keys wrapped by user-specific master keys stored in platform-backed keystores, protected by biometric authentication for secure offline data storage.","explanation":"## Why This Is Asked\n\nThis question evaluates your understanding of secure offline persistence, key management, and platform integration within React Native applications.\n\n## Key Concepts\n\n- Client-side encryption using AES-256-GCM\n- Envelope encryption with key wrapping strategies\n- Biometric authentication via iOS Keychain and Android Keystore\n- Key rotation and data re-wrapping processes\n- Offline storage architecture: Realm vs SQLCipher trade-offs\n\n## Code Example\n\n```javascript\nimport { encrypt, decrypt } from 'crypto-lib';\n\nfunction useEncryptedStore() {\n  const saveRecord = async (record) => {\n    // Generate per-record key, wrap with master key, store encrypted fields\n  };\n  const loadRecord = async (id) => {\n    // Decrypt wrapped key, decrypt and return record\n  };\n  \n  return { saveRecord, loadRecord };\n}\n```","diagram":"flowchart TD\n  A[User Data] --> B[Encryption Layer]\n  B --> C[Encrypted Store]\n  C --> D[Biometric Unlock]\n  D --> E[Decrypt on Read]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T05:36:43.495Z","createdAt":"2026-01-17T22:30:23.810Z"},{"id":"q-3620","question":"You're building a field-work React Native app that must remind technicians of their daily checklist. Design a cross-platform local notification flow: request permission, schedule a daily reminder at a configurable time, handle foreground/background taps, and provide a small hook useDailyReminder(hour, minute, message) to schedule and cancel reminders. Include edge cases like time zone changes and app restarts?","answer":"I would implement a cross-platform hook that requests notification permissions on initialization, uses native modules to schedule a daily UNNotificationRequest on iOS and a NotificationCompat channel on Android, persists reminder configuration in AsyncStorage for app restart durability, handles time zone changes by rescheduling when the device's time zone shifts, and provides a clean useDailyReminder(hour, minute, message) interface with methods to schedule and cancel reminders.","explanation":"## Why This Is Asked\n\nThis question tests knowledge of cross-platform local notifications, permission handling, and lifecycle management in React Native, along with the ability to create a clean, reusable hook interface.\n\n## Key Concepts\n- Cross-platform local notifications (iOS/Android)\n- Permission flow and user prompts\n- Scheduling recurring notifications at specific times\n- Foreground, background, and notification tap handling\n- State persistence and idempotent rescheduling (time zones, app restarts)\n\n## Code Example\n```javascript\n// useDailyReminder hook sketch\nimport { useEffect } from 'react'\nimport { Platform } from 'react-na","diagram":"flowchart TD\n  A[User configures reminder] --> B[Request permissions]\n  B --> C{Permission granted?}\n  C -->|Yes| D[Schedule daily notification]\n  C -->|No| E[Abort with fallback]\n  D --> F[Handle foreground]\n  D --> G[Handle background]\n  F & G --> H[On notification opened -> navigate to Tasks]\n  H --> I[App continues]\n","difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Meta","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T05:14:01.554Z","createdAt":"2026-01-17T23:42:07.492Z"},{"id":"q-3746","question":"You're shipping a React Native app that streams live location updates for 1,000 devices on a map. How would you design a scalable data pipeline and UI to render pins with 60fps panning, prioritizing tiles in the visible region, using a native spatial index (R-tree) and a JS dataflow with observable streams? Include batching, backpressure, and a hook sketch to enqueue updates?","answer":"Use a native spatial index (R-tree) to bucket 1k devices by lat/lon and expose updates through a TurboModule. On JS, implement a backpressure-enabled queue that batches updates by map tiles and thrott","explanation":"## Why This Is Asked\nTests ability to design cross‑platform, high‑throughput UI with native modules and JS streams. Evaluates decisions around spatial indexing, dataflow, backpressure, and region‑aware rendering.\n\n## Key Concepts\n- React Native bridging (TurboModules/JSI)\n- Native spatial indexing (R-tree)\n- Backpressure and batching patterns\n- Region-based rendering and virtualization\n- Production performance profiling for 1k pins at 60fps\n\n## Code Example\n```javascript\n// Hook sketch\nfunction useRegionUpdates(mapRef, { throttleMs = 100, tileSize = 256 } = {}) {\n  const [updates, setUpdates] = useState([]);\n  useEffect(() => {\n    const sub = regionProvider.subscribe(({ region, data }) => {\n      if (region.visible) enqueue(data);\n    });\n    return () => sub.unsubscribe();\n  }, [mapRef]);\n  function enqueue(item) {\n    // simple backpressure queue logic here\n  }\n  return updates;\n}\n```\n\n## Follow-up Questions\n- How would you test the backpressure behavior under bursty updates?\n- How would you handle device rotation and tile re-tiling to maintain stability?","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Meta","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T07:42:56.185Z","createdAt":"2026-01-18T07:42:56.185Z"},{"id":"q-3820","question":"You're building a React Native shopping app for an enterprise with 1,000+ product images per category and flaky connectivity. Design a cross-platform image prefetching system that preloads images for the currently visible category plus the next two categories, runs on app foreground and background (Android WorkManager + iOS BGTaskScheduler), uses an LRU disk cache, handles cache invalidation when images update, and provides an RN hook usePrefetchImages(categories, maxConcurrent). Provide a minimal usage sketch with FlatList integration?","answer":"Use a disk-based LRU cache (category folders + metadata.json). Expose usePrefetchImages(categories, {concurrency}) that fetches current category and next two, dedup in-flight, and saves with a version","explanation":"## Why This Is Asked\n\nThis question tests practical offline caching and cross-platform background work integration in React Native, focusing on image-heavy workloads and fluctuating network quality.\n\n## Key Concepts\n\n- Disk-based cache with metadata\n- LRU eviction and size caps\n- Background tasks (WorkManager/BGTaskScheduler)\n- Concurrency control and de-duplication\n- React Native hook integration with FlatList\n\n## Code Example\n\n```javascript\nimport { useEffect, useRef } from 'react';\n\nexport function usePrefetchImages(categories, maxConcurrent = 4) {\n  // skeleton: maintain in-flight set, queue, and cache lookup\n}\n```\n\n## Follow-up Questions\n\n- How would you test eviction and update handling?\n- How would you invalidate cached items when image versions update?\n","diagram":"flowchart TD\nA[Categories] --> B[Prefetch queue]\nB --> C{Cache hit?}\nC -->|yes| D[Serve from cache]\nC -->|no| E[Fetch & store]","difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Tesla","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T10:44:05.366Z","createdAt":"2026-01-18T10:44:05.367Z"},{"id":"q-3860","question":"Design a real-time, cross-asset heatmap dashboard in React Native that renders 1,000+ cells updating at 60fps. Data arrives via WebSocket; explain data modeling, a high-throughput renderer (Canvas or GL), and how you would offload updates to a native module/worker (JSI/TurboModule) to avoid UI thread jank. Include a hook sketch for backpressure batching?","answer":"Leverage a batched data model: a flat array of 1k cells, each with value, color, ts. WebSocket feeds deltas into a native ring buffer; a TurboModule/JSI bridge exposes a getLatestFrame() that returns ","explanation":"## Why This Is Asked\nTests ability to design a high-throughput, cross-thread data path and render path in RN.\n\n## Key Concepts\n- Real-time data pipelines; native modules; JSI/TurboModules\n- Efficient rendering of 1000+ cells; Canvas/GL\n- Backpressure, ring buffers, memory reuse\n\n## Code Example\n```javascript\nfunction useHeatmapFeed(url: string) {\n  // sketch: set up WebSocket, a bounded queue, and frame-driven drain\n}\n```\n\n## Follow-up Questions\n- How would you test the rendering path under memory pressure?\n- How would you handle dropped frames and consistency guarantees?","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Google","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T13:03:59.314Z","createdAt":"2026-01-18T13:03:59.314Z"},{"id":"q-3957","question":"You're building a React Native feed with FlatList that shows posts with images; on mid-range devices the scrolling stutters and images pop in slowly, what practical, beginner-friendly plan would you follow to diagnose and fix it, including FlatList tuning, memoization, and image loading strategies, and a tiny hook to measure frame times plus a minimal optimized item component?","answer":"Measure frame times with a small hook using a blind-spot: requestAnimationFrame to log delta times during scroll, then wrap the item component in React.memo and stabilize props. Tune FlatList: windowS","explanation":"## Why This Is Asked\n\nThis question tests practical RN debugging for smooth UIs, corner-case performance tweaks, and simple hooks. It favors candidates who ground fixes in real-world constraints rather than theory.\n\n## Key Concepts\n- FlatList virtualization and tuning (windowSize, initialNumToRender, maxToRenderPerBatch)\n- Memoization to reduce re-renders (React.memo)\n- Image loading optimizations (placeholders, progressive loading, caching)\n- Lightweight frame-time measurement for profiling\n- getItemLayout for stable item measurement\n\n## Code Example\n```javascript\nimport React from 'react';\nimport { FlatList, Image, View } from 'react-native';\n\nconst Item = React.memo(({ post }) => (\n  <View>\n    <Image source={{uri: post.image}} style={{width: 100, height: 100}} />\n  </View>\n));\n\nexport default function Feed({ data }) {\n  return (\n    <FlatList\n      data={data}\n      renderItem={({ item }) => <Item post={item} /> }\n      keyExtractor={item => item.id}\n      getItemLayout={(data, index) => ({ length: 120, offset: index * 120, index })}\n      windowSize={21}\n      initialNumToRender={10}\n      maxToRenderPerBatch={5}\n    />\n  );\n}\n```\n\n## Follow-up Questions\n- How would you test on-device performance after changes?\n- What trade-offs do you consider between memory usage and render speed?","diagram":null,"difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T17:27:04.096Z","createdAt":"2026-01-18T17:27:04.096Z"},{"id":"q-3984","question":"Design an advanced real-time data feed in a cross-platform React Native app (Meta/Microsoft level). The UI must render live stock prices for 200 symbols with updates every 50–100 ms. Explain end-to-end: native bridge architecture (TurboModule/Fabric vs legacy bridge), threading model for decoding, memory management, and how you would push updates to JS with minimal GC pressure. Include a concise outline of a hook like useLivePrices(symbols) and a small testing plan?","answer":"Proposed answer: Use a TurboModule-backed native bridge with Fabric, feed runs on a worker thread; decode frames to delta array; write to a shared ring buffer; push to JS via JSI and batch UI updates ","explanation":"## Why This Is Asked\nThis question probes cross-thread data flow, Native Modules evolution (TurboModules, Fabric), and performance at scale in RN.\n\n## Key Concepts\n- TurboModule + Fabric bridge vs legacy bridge\n- worker threads, WebSocket decoding\n- ring buffer + JSI bridge; minimal GC pressure\n- memoized React rendering with immutable price maps\n\n## Code Example\n```javascript\nfunction useLivePrices(symbols) {\n  const [prices, setPrices] = useState(new Map());\n  useEffect(() => {\n    const sub = NativeLivePrices.subscribe(symbols, (updates) => {\n      setPrices(prev => new Map([...updates]));\n    });\n    return () => sub.unsubscribe();\n  }, [symbols]);\n  return prices;\n}\n```\n\n## Follow-up Questions\n- How would you monitor ring buffer memory and overflow?\n- How handle bursty update rates and backpressure on the JS thread?","diagram":"flowchart TD\n  A[WebSocket Feed] --> B[Native Worker]\n  B --> C[Ring Buffer]\n  C --> D[JS Bridge via JSI]\n  D --> E[React Native JS]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T18:45:53.586Z","createdAt":"2026-01-18T18:45:53.587Z"},{"id":"q-4172","question":"You're building a beginner React Native app that lists articles from an API. On device rotation and relaunch, you must preserve scroll position and minimize network usage. Design a minimal offline-first cache (data + timestamp) using AsyncStorage, plus a small hook to read/write and an optimized ListItem. Explain eviction and error handling?","answer":"Cache API responses in AsyncStorage as JSON { data, ts }. On mount, load cache; if ts within 5 minutes, render cached data, else fetch. Expose a useArticlesCache hook returning articles and save funct","explanation":"## Why This Is Asked\nTests knowledge of offline-first caching, RN persistence, and simple state restoration.\n\n## Key Concepts\n- AsyncStorage\n- scroll position restoration\n- cache invalidation\n\n## Code Example\n```javascript\nimport {useEffect, useState} from 'react';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\nexport function useArticlesCache(key = 'articles') {\n  const [articles, setArticles] = useState([]);\n  async function load() {\n    const cached = await AsyncStorage.getItem(key);\n    if (cached) {\n      const {data, ts} = JSON.parse(cached);\n      if (Date.now() - ts < 5 * 60 * 1000) { setArticles(data); return; }\n    }\n  }\n  async function save(data) {\n    await AsyncStorage.setItem(key, JSON.stringify({data, ts: Date.now()}));\n    setArticles(data);\n  }\n  useEffect(() => { load(); }, []);\n  return {articles, save};\n}\n```\n\n## Follow-up Questions\n- How would you handle cache invalidation for updates?\n- How would you test the caching behavior in development?\n","diagram":"flowchart TD\n  A[Mount] --> B[Load cache]\n  B --> C{Fresh?}\n  C -- Yes --> D[Render cached]\n  C -- No --> E[Fetch API]\n  E --> F[Store in AsyncStorage]\n  F --> G[Render]\n","difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","NVIDIA","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T06:51:30.464Z","createdAt":"2026-01-19T06:51:30.466Z"},{"id":"q-4236","question":"You're building a delivery-driver app at Uber-scale or Scale AI where push notifications must reliably navigate to the correct screen even when the app is backgrounded or killed. Describe a notification router architecture that maps payloads to routes, persists last navigated state, prevents duplicate navigations, and handles data-payload vs notification-payload differences. Include a small hook sketch that debounces navigation and a minimal navigation service using react-navigation?","answer":"Design a notification router that maps payload to a deep link, persists lastRoute in AsyncStorage, and guards against duplicate navigations. Use a central NavigationService with a queue, handle foregr","explanation":"## Why This Is Asked\nThis question tests practical push handling and navigation restoration in a RN app with real user flows and edge cases.\n\n## Key Concepts\n- Push notification payload handling (FCM/APNs) and difference between data and notification payloads\n- Navigation state restoration and a central NavigationService\n- Debouncing, idempotent navigation, and duplicate avoidance\n- AsyncStorage for lastRoute and a simple queue\n- Testing strategies for foreground/background/killed states\n\n## Code Example\n```javascript\n// Minimal hook sketch\nimport { useEffect, useRef } from 'react';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport { getNavigationRef } from './NavigationService';\n\nfunction mapPayloadToRoute(p) {\n  // implement payload-to-route mapping\n  const route = p?.targetRoute;\n  return route || null;\n}\n\nexport function useNotifyNavigate() {\n  const nav = getNavigationRef();\n  const timer = useRef(null);\n\n  useEffect(() => {\n    const onNotify = (payload) => {\n      const route = mapPayloadToRoute(payload);\n      if (!route) return;\n      clearTimeout(timer.current);\n      timer.current = setTimeout(async () => {\n        const last = await AsyncStorage.getItem('lastRoute');\n        if (last === route) return;\n        await AsyncStorage.setItem('lastRoute', route);\n        nav?.navigate(route);\n      }, 150);\n    };\n    NotificationCenter.addListener('notify', onNotify);\n    return () => NotificationCenter.removeListener('notify', onNotify);\n  }, [nav]);\n}\n```\n\n## Follow-up Questions\n- How would you test race conditions between fast successive notifications?\n- How would you adapt for multi-window or deep linking across platforms?","diagram":"flowchart TD\n  N[Notification] --> R[Router]\n  R --> S[Screen]\n  S --> L[LastRoute]\n  N --foreground--> F[Navigate]\n  N --backgroundKilled--> K[Security/Queue]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Scale Ai","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T09:50:08.013Z","createdAt":"2026-01-19T09:50:08.013Z"},{"id":"q-4266","question":"You’re building a beginner-friendly React Native app that shows field markers on a map. Implement an offline-capable data layer: fetch markers from a REST endpoint, cache them locally, and render only markers in the current viewport. Include a small hook useViewportMarkers(region) that throttles network calls (1 request/sec) and merges remote updates into the local cache with a minimal UI example?","answer":"Design an offline-capable data layer for map markers in React Native: fetch markers via REST, cache them with AsyncStorage, and render only markers within the current viewport from react-native-maps R","explanation":"## Why This Is Asked\n\nTests ability to implement a realistic, offline-capable data layer for map UI, with viewport-aware rendering and incremental updates.\n\n## Key Concepts\n\n- Offline caching with AsyncStorage or MMKV\n- Viewport-filtered rendering using react-native-maps Region\n- Throttling network calls to avoid floods\n- Merging remote updates into local cache\n- Hook design pattern for region-driven data updates\n\n## Code Example\n\n```javascript\nimport { useEffect, useState, useRef } from 'react'\nimport AsyncStorage from '@react-native-async-storage/async-storage'\nimport { fetchMarkersForRegion } from './api'\n\nexport function useViewportMarkers(region) {\n  const [markers, setMarkers] = useState([])\n  const lastRegion = useRef(null)\n  useEffect(() => {\n    let mounted = true\n    const key = JSON.stringify(region)\n    if (!region) return\n    const fetchIfNeeded = async () => {\n      if (lastRegion.current === key) return\n      lastRegion.current = key\n      const data = await fetchMarkersForRegion(region)\n      if (mounted) {\n        await AsyncStorage.setItem('markers_'+key, JSON.stringify(data))\n        setMarkers(data)\n      }\n    }\n    const t = setTimeout(fetchIfNeeded, 150)\n    return () => { mounted = false; clearTimeout(t) }\n  }, [region])\n  return markers\n}\n```\n\n## Follow-up Questions\n\n- How would you add clustering for dense areas?\n- How would you test cache invalidation and data freshness in offline mode?\n","diagram":null,"difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","IBM","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T10:56:48.318Z","createdAt":"2026-01-19T10:56:48.318Z"},{"id":"q-4402","question":"You're building a beginner-friendly React Native screen that lists latest articles from a paginated API. The screen auto-refreshes every 30 seconds and supports pull-to-refresh. Ensure that in-flight fetches are canceled when a new fetch starts or the screen unmounts, using AbortController. Provide a small hook useCancelableFetch(url) and show minimal UI wiring?","answer":"Use a Cancelable fetch with AbortController; keep a ref to the latest request id; on each refresh cancel the previous request and start a new one; clear the interval on unmount; only update state if t","explanation":"## Why This Is Asked\n\nTests practical React Native fetch patterns: cancellation prevents stale data and memory leaks during auto-refresh and manual refresh. It also checks hook design and safe state updates in unmount scenarios.\n\n## Key Concepts\n\n- AbortController usage in fetch calls\n- useEffect cleanup and interval management\n- Race condition avoidance with latest-request checks\n- Small custom hook design for reusable cancellation logic\n\n## Code Example\n\n```javascript\nimport { useEffect, useRef, useState } from 'react';\n\nexport function useCancelableFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const currentReq = useRef(0);\n\n  useEffect(() => {\n    let isActive = true;\n    const ctrl = new AbortController();\n    const id = ++currentReq.current;\n    setLoading(true);\n    fetch(url, { signal: ctrl.signal })\n      .then(res => res.json())\n      .then(d => {\n        if (isActive && id === currentReq.current) {\n          setData(d);\n          setLoading(false);\n        }\n      })\n      .catch(e => {\n        if (isActive && e.name !== 'AbortError') setError(e);\n        if (isActive) setLoading(false);\n      });\n    return () => {\n      isActive = false;\n      ctrl.abort();\n    };\n  }, [url]);\n\n  return { data, loading, error };\n}\n```\n\n## Follow-up Questions\n\n- How would you test useCancelableFetch with RN Testing Library? \n- How would you extend it to support pagination without race conditions?","diagram":null,"difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Netflix","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T17:34:06.986Z","createdAt":"2026-01-19T17:34:06.986Z"},{"id":"q-4503","question":"You’re building a beginner-friendly React Native app that shows city events fetched from an API. Implement a local cache with AsyncStorage and a hook useCacheList(endpoint) that loads cached data first, then fetches fresh data, and merges by id while preserving user order. Also handle cache invalidation and duplicates. Provide a minimal hook sketch and a small component example?","answer":"Load cached events from AsyncStorage under 'events_cache', render it immediately, then fetch fresh data. Merge by id keeping the cached order, replacing with fresh items when ids match, and append any new ids. Handle cache invalidation by timestamp or manual refresh, and deduplicate by id.","explanation":"## Why This Is Asked\nTests offline caching, data merging by id, and simple hook design for React Native with AsyncStorage.\n\n## Key Concepts\n- AsyncStorage usage for simple persistence\n- useEffect/useState lifecycle and dependency on endpoint\n- Merging lists by id while preserving user-visible order\n- Exposing a small API (data, loading, error, refetch) for components\n\n## Code Example\n```javascript\nimport { useState, useEffect } from 'react';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\nexport function useCacheList(endpoint) {\n  const [data, setData] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const loadData = async () => {\n      try {\n        // Load cached data first\n        const cached = await AsyncStorage.getItem(`cache_${endpoint}`);\n        if (cached) {\n          setData(JSON.parse(cached));\n        }\n\n        // Fetch fresh data\n        const response = await fetch(endpoint);\n        const freshData = await response.json();\n\n        // Merge by id, preserving cached order\n        const merged = mergeById(data, freshData);\n        setData(merged);\n\n        // Update cache\n        await AsyncStorage.setItem(`cache_${endpoint}`, JSON.stringify(merged));\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    loadData();\n  }, [endpoint]);\n\n  return { data, loading, error, refetch: () => loadData() };\n}\n\nfunction mergeById(cached, fresh) {\n  const map = new Map();\n  \n  // Preserve cached order\n  cached.forEach(item => map.set(item.id, item));\n  \n  // Update with fresh data\n  fresh.forEach(item => {\n    if (map.has(item.id)) {\n      map.set(item.id, item);\n    } else {\n      // Append new items\n      cached.push(item);\n    }\n  });\n  \n  return Array.from(map.values());\n}\n```\n\n## Component Example\n```javascript\nfunction EventsList() {\n  const { data, loading, error } = useCacheList('/api/events');\n\n  if (loading) return <ActivityIndicator />;\n  if (error) return <Text>Error: {error.message}</Text>;\n\n  return (\n    <FlatList\n      data={data}\n      keyExtractor={item => item.id}\n      renderItem={({ item }) => <EventCard event={item} />}\n    />\n  );\n}\n```","diagram":null,"difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Meta","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T05:33:39.144Z","createdAt":"2026-01-19T21:44:43.444Z"},{"id":"q-4584","question":"You're building an Incident Feed in React Native (mobile) with paginated posts (images/videos) that must work offline. Design a data layer and a hook useInfiniteViewportFeed(region, opts) that loads the current viewport pages, prefetches ahead, caches results locally (LRU image cache + JSON store), throttles network calls, merges remote updates deterministically, and preserves scroll position when navigating away and back. Include edge cases and a minimal code sketch?","answer":"Design a local-first cache with a Post[] store and an LRU image cache. Use region-based viewport to fetch pages, throttle to 1 req/sec, and prefetch 1–2 pages ahead. Merge remote updates with per-post revision numbers and preserve scroll position using FlatList's maintainVisibleContentPosition prop.","explanation":"## Why This Is Asked\nAssesses data modeling for offline-first experiences, viewport-aware data loading, and deterministic merging of remote updates in a mobile React Native setting.\n\n## Key Concepts\n- Local-first caching (JSON store + image cache)\n- Viewport-driven prefetching and throttling\n- Conflict resolution via per-item revisions\n- Scroll position restoration across navigations\n\n## Code Example\n```javascript\n// sketch\nfunction useInfiniteViewportFeed(region, {prefetch = 2, throttleMs = 1000} = {}) {\n  // state: items, pages, loading, error\n  // logic: load current viewport pages, prefetch\n```","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T05:56:52.999Z","createdAt":"2026-01-20T02:36:05.452Z"},{"id":"q-4630","question":"You're building a React Native field-service app that supports offline work and real-time collaboration on shared checklists. Propose a CRDT-based local-first data layer (data model, conflict resolution, and offline/online sync) implemented via a Rust-native module bridged to React Native for efficient merges. Describe how you'd handle garbage collection, security, and latency, and provide a small hook useCRDTSync() sketch and a minimal UI snippet to illustrate usage; include trade-offs?","answer":"Design a delta-CRDT with a core model: Checklist {id, items[]}, Item {id, text, checked}, Comment {id, text}. Each entity carries a vector clock and tombstones. A Rust native module exposes mergeDelta","explanation":"## Why This Is Asked\nTests ability to design a robust offline-first, real-time collaboration layer with CRDTs and native module integration, including data modeling, delta handling, and performance considerations.\n\n## Key Concepts\n- Delta-state CRDTs and vector clocks\n- Tombstones and garbage collection\n- Bridge design: Rust native module exposed to React Native\n- Local storage: SQLite with delta log\n\n## Code Example\n```javascript\n// Minimal hook sketch\nfunction useCRDTSync() {\n  const [state, setState] = React.useState(null);\n  React.useEffect(() => {\n    const sub = subscribeToDeltaStream((d) => {\n      // applyDelta via NativeModules.RNCRDT.mergeDelta(d)\n    });\n    return () => sub.unsubscribe();\n  }, []);\n  const applyLocalChange = (c) => {\n    // convert to delta and send to Rust\n    NativeModules.RNCRDT.mergeDelta(c);\n  };\n  return { state, applyLocalChange, startSync: ()=>{} };\n}\n```\n\n## Follow-up Questions\n- How would you handle binary blobs (images, attachments) in the CRDT and ensure deduplication?\n- What strategies for encryption at rest and in-transit would you adopt in this pipeline?","diagram":"flowchart TD\n  A[React Native App] --> B[Rust CRDT Module]\n  B --> C[SQLite Local Store]\n  C --> D[Delta Queue]\n  D --> E[Network Sync]\n  E --> F[Remote Deltas]\n  F --> B","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Microsoft","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T05:47:50.317Z","createdAt":"2026-01-20T05:47:50.317Z"},{"id":"q-4742","question":"You're building a beginner-friendly React Native app that displays a grid of product cards. Implement a reusable Card component with accessible labels for iOS and Android, support a light/dark theme via the Appearance API, and provide a small hook useTheme() to expose the current theme. Show minimal usage and discuss accessibility considerations and trade-offs?","answer":"Create a reusable Card component as a Pressable with accessibilityLabel derived from props, accessibilityHint 'View details', and accessibilityRole 'button'. Bind colors to a theme via a useTheme() ho","explanation":"## Why This Is Asked\n\nTests practical RN skills: building reusable components, accessibility across platforms, and theming with Appearance API, plus a small hook pattern.\n\n## Key Concepts\n\n- Accessibility props (accessibilityLabel, accessibilityHint, accessibilityRole)\n- Theming with Appearance/useColorScheme and React Context\n- Custom hook useTheme and ThemeProvider\n- Performance considerations for re-renders and memoization\n\n## Code Example\n\n```javascript\nimport React, {createContext, useContext, useMemo, useState} from 'react';\nimport {Pressable, Text} from 'react-native';\n\nexport const ThemeContext = createContext('light');\nexport const useTheme = () => useContext(ThemeContext);\n\nexport function ThemeProvider({children}) {\n  // Simplified example; in real code use Appearance or useColorScheme\n  const [scheme] = useState('light');\n  const value = useMemo(() => ({scheme}), [scheme]);\n  return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>;\n}\n\nfunction Card({title, price}) {\n  const {scheme} = useTheme();\n  const bg = scheme === 'dark' ? '#222' : '#fff';\n  return (\n    <Pressable accessibilityLabel={title}\n               accessibilityHint=\"View details\"\n               accessibilityRole=\"button\"\n               style={{backgroundColor: bg}}>\n      <Text>{title}</Text>\n      <Text>{price}</Text>\n    </Pressable>\n  );\n}\n```\n\n## Follow-up Questions\n\n- How would you test accessibility coverage across iOS and Android?\n- How would you extend theming to allow user-selected custom colors without breaking contrast?","diagram":null,"difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","OpenAI","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T10:40:49.652Z","createdAt":"2026-01-20T10:40:49.652Z"},{"id":"q-475","question":"You're building a React Native app with complex animations that need to run at 60fps. The app has multiple animated components including a custom carousel, gesture-driven interactions, and background video processing. How would you optimize performance to maintain smooth animations?","answer":"Use **React Native's Reanimated 3** for UI thread animations to avoid JS bridge overhead. Implement **useAnimatedStyle** with **useDerivedValue** for efficient value sharing. Use **FlatList** instead of ScrollView for virtualized rendering, enable **removeClippedSubviews** to hide off-screen items, and provide **getItemLayout** for fixed item heights. Leverage **Gesture Handler** for native gesture recognition and **PanGesture** for smooth interactions.","explanation":"## Performance Optimization Strategy\n\n### Animation Framework\n- **Reanimated 3**: Runs animations on UI thread, prevents JS bridge blocking\n- **Shared Values**: Efficient state management across animation boundaries\n- **Worklets**: JS code executed on UI thread for smooth 60fps\n\n### List Optimization\n- **FlatList**: Virtualized rendering with memory efficiency\n- **removeClippedSubviews**: Hides off-screen items to reduce render load\n- **getItemLayout**: Provides fixed item heights for optimized scrolling\n\n### Gesture Handling\n- **Gesture Handler**: Native gesture recognition system\n- **PanGesture**: Smooth gesture-driven interactions with native performance\n\n### Background Processing\n- **Native Modules**: Offload video processing to native threads\n- **Web Workers**: Use for background computations when possible\n- **Optimized Codecs**: Choose efficient video formats and compression","diagram":"flowchart TD\n  A[User Interaction] --> B[Gesture Handler]\n  B --> C[Reanimated Worklet]\n  C --> D[UI Thread Animation]\n  D --> E[60fps Render]\n  F[FlatList] --> G[Virtualized Items]\n  G --> H[removeClippedSubviews]\n  H --> E\n  I[React.memo] --> J[Optimized Re-renders]\n  J --> E","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-10T03:28:36.246Z","createdAt":"2025-12-26 12:51:05"},{"id":"q-4831","question":"You're building a beginner-friendly React Native chat app with offline support. Outline a minimal local-first layer using SQLite to store messages, with a timestamp-based conflict resolution (latest wins) when syncing with the server. Implement a useChatSync(conversationId) hook that queues outgoing messages, retries failed sends with exponential backoff, and batches receipt/status updates. Include a small UI snippet showing sending and optimistic rendering?","answer":"Use SQLite to store messages locally with fields (id, convoId, text, sender, ts, status). On sync, resolve conflicts by taking the newer timestamp. The useChatSync(conversationId) hook maintains a que","explanation":"## Why This Is Asked\n\nTests ability to design offline-first data flow using a simple local store, conflict resolution, and a hook to manage network-retry semantics. It also touches UI implications for optimistic rendering.\n\n## Key Concepts\n\n- SQLite as local store\n- timestamp-based conflict resolution\n- message queue with exponential backoff\n- optimistic UI\n\n## Code Example\n\n```javascript\n// Minimal sketch\nexport function useChatSync(conversationId) {\n  // queue, retry, and sync logic\n}\n```\n\n## Follow-up Questions\n\n- How extend to handle deletions and edits?\n- How test offline-first reliability?\n","diagram":"flowchart TD\n  A[User sends message] --> B{Network?}\n  B -- Yes --> C[Send to server]\n  C --> D[Server ack]\n  B -- No --> E[Persist to local queue]","difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T15:12:02.678Z","createdAt":"2026-01-20T15:12:02.678Z"},{"id":"q-504","question":"How would you implement a custom button component in React Native that handles both iOS and Android platform-specific styling while maintaining consistent behavior?","answer":"Create a reusable button using Platform API for conditional styling. Use TouchableOpacity for touch handling, Platform.select for platform-specific props (shadowOpacity for iOS, elevation for Android)","explanation":"## Platform-Specific Implementation\n\n- Use `Platform.select()` to apply different styles per platform\n- iOS: Use `shadowOpacity` and `shadowRadius` for depth\n- Android: Use `elevation` for shadow effects\n\n## Touch Handling\n\n- `TouchableOpacity` provides visual feedback\n- `activeOpacity` prop controls press transparency\n- `disabled` prop prevents interaction\n\n## Performance\n\n- `StyleSheet.create()` optimizes style objects\n- Avoid inline styles for better performance\n- Use `useMemo` for complex style calculations","diagram":"flowchart TD\n  A[CustomButton Component] --> B{Platform Check}\n  B -->|iOS| C[iOS Styles: shadowOpacity]\n  B -->|Android| D[Android Styles: elevation]\n  C --> E[TouchableOpacity Wrapper]\n  D --> E\n  E --> F[Consistent onPress Handler]","difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Robinhood","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-25T01:16:06.061Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-533","question":"How would you optimize a React Native app with 50+ screens that's experiencing slow navigation and memory leaks, particularly on lower-end devices?","answer":"Implement lazy loading with React.lazy() and Suspense for screen components, use React.memo() for expensive renders, optimize FlatList with getItemLayout and removeClippedSubviews, implement proper cleanup in useEffect hooks, leverage Metro bundler's RAM bundles, and use React Navigation's optimization features.","explanation":"## Performance Optimization Strategies\n\n### Code Splitting & Lazy Loading\n- Use React.lazy() for screen components wrapped in Suspense\n- Implement route-based code splitting to reduce initial bundle size\n- Leverage Metro bundler's RAM bundles for improved memory efficiency\n\n### Memory Management\n- Proper cleanup in useEffect hooks to prevent memory leaks\n- Avoid closures in long-lived components that retain references\n- Use WeakMap/WeakSet for large data structures\n- Implement proper event listener cleanup\n\n### List Optimization\n```javascript\n<FlatList\n  data={items}\n  getItemLayout={(data, index) => ({length: ITEM_HEIGHT, offset: ITEM_HEIGHT * index, index})}\n  removeClippedSubviews={true}\n  maxToRenderPerBatch={10}\n  windowSize={10}\n  initialNumToRender={10}\n/>\n```\n\n### Engine & Build Optimizations\n- Use Hermes JavaScript engine for better performance\n- Implement bundle splitting and code optimization\n- Utilize React.memo() and useMemo() for expensive computations\n- Profile and optimize re-renders with React DevTools","diagram":"flowchart TD\n  A[App Startup] --> B[Route-based Lazy Loading]\n  B --> C[Screen Component Mount]\n  C --> D[React.memo Check]\n  D --> E[Render Optimization]\n  E --> F[FlatList Virtualization]\n  F --> G[Memory Cleanup]\n  G --> H[Performance Monitoring]\n  H --> I[Flipper Analysis]\n  I --> J[Optimization Iteration]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-09T08:44:45.928Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-560","question":"You're building a React Native app that needs to display a list of user profiles with images. The list should be performant with 1000+ items and support pull-to-refresh. How would you implement this using FlatList and what optimizations would you apply?","answer":"Use FlatList with keyExtractor for stable item identification, getItemLayout for optimized rendering calculations, and initialNumToRender to control the initial render batch. Implement pull-to-refresh functionality with the onRefresh prop and refreshing state. Use memoized renderItem components with React.memo to prevent unnecessary re-renders, implement image caching with react-native-fast-image, and optimize memory usage with removeClippedSubviews and windowSize props.","explanation":"## Key Implementation\n- Use FlatList instead of ScrollView for efficient virtualized rendering with large datasets\n- Implement keyExtractor for stable item identification and optimal diffing\n- Add getItemLayout to enable smooth scrolling by providing item dimensions upfront\n- Configure initialNumToRender and maxToRenderPerBatch to balance performance and user experience\n\n## Performance Optimizations\n- Memoize renderItem components with React.memo to prevent unnecessary re-renders\n- Use windowSize prop to control the render window and reduce memory footprint\n- Implement image caching with react-native-fast-image for efficient image loading\n- Consider removeClippedSubviews for memory optimization with complex lists\n- Optimize data structure to minimize update calculations\n\n## Refresh Pattern\n```javascript\n<FlatList\n  data={profiles}\n  onRefresh={handleRefresh}\n  refreshing={isRefreshing}\n  keyExtractor={(item) => item.id}\n  getItemLayout={(data, index) => ({\n    length: ITEM_HEIGHT,\n    offset: ITEM_HEIGHT * index,\n    index,\n  })}\n  initialNumToRender={20}\n  maxToRenderPerBatch={10}\n  windowSize={10}\n  removeClippedSubviews={true}\n  renderItem={memoizedItemRenderer}\n/>\n```","diagram":"flowchart TD\n  A[User Pulls Down] --> B[onRefresh Triggered]\n  B --> C[Set refreshing=true]\n  C --> D[Fetch New Data]\n  D --> E[Update State]\n  E --> F[Set refreshing=false]\n  F --> G[FlatList Re-renders]\n  G --> H[Display Updated List]","difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-08T11:56:33.226Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-589","question":"How do you handle different screen sizes and orientations in React Native?","answer":"In React Native, handle different screen sizes using Flexbox layouts with percentage-based dimensions and the `useWindowDimensions` hook to respond to size changes. For orientation changes, listen to dimension events and re-render components with updated layouts, while using Platform-specific styles for iOS and Android differences.","explanation":"## Key Concepts\n- **Flexbox Layout**: Primary responsive design tool\n- **Dimensions API**: Screen size detection\n- **Orientation Handling**: Dynamic adaptation\n\n## Implementation\n```javascript\nimport { useWindowDimensions } from 'react-native';\n\nconst { width, height } = useWindowDimensions();\nconst isLandscape = width > height;\n```\n\n## Best Practices\n- Use relative units over fixed pixels\n- Implement safe area insets with `react-native-safe-area-context`\n- Test on various device ratios\n- Consider platform differences (iOS vs Android)","diagram":"flowchart TD\n  A[App Start] --> B[Detect Screen Size]\n  B --> C[Apply Flexbox Layout]\n  C --> D[Handle Orientation Change]\n  D --> E[Update UI Accordingly]\n  E --> F[Monitor Size Changes]","difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Instacart","LinkedIn"],"eli5":null,"relevanceScore":null,"voiceKeywords":["flexbox layouts","percentage-based dimensions","usewindowdimensions hook","dimension events","platform-specific styles","react-native-safe-area-context","safe area insets","device ratios","orientation changes","screen sizes","ios vs android","responsive design"],"voiceSuitable":true,"isNew":false,"lastUpdated":"2026-01-06T04:04:20.726Z","createdAt":"2025-12-27T01:14:41.041Z"},{"id":"q-183","question":"What are Native Modules in React Native, when should you use them, and what are the key performance and threading considerations?","answer":"Native Modules bridge JavaScript and native code to access platform-specific APIs not available in JS. Use for Bluetooth, biometrics, camera controls, or performance-critical operations. Consider bridge overhead, threading model (main vs background), and async communication patterns.","explanation":"## Core Purpose\nNative Modules enable access to platform-specific APIs and performance-critical operations not available in JavaScript, creating a bridge between JS and native iOS/Android code.\n\n## When to Use\n**Ideal scenarios:**\n- Bluetooth/Peripheral communication\n- Biometric authentication\n- Advanced camera controls\n- Custom hardware integration\n- CPU-intensive calculations\n\n**When NOT to use:**\n- Simple UI operations\n- Basic storage needs\n- Network requests (use fetch/axios)\n- When JS performance is sufficient\n\n## Performance Considerations\n**Bridge Overhead:** Each async call crosses the bridge with serialization cost. Batch operations when possible.\n\n**Threading Model:**\n- Native modules run on main thread by default\n- Use background threads for heavy computations\n- JS thread must never block\n\n**Memory Management:**\n- Clean up native resources in dealloc\n- Avoid memory leaks across bridge\n- Use proper promise/reject patterns\n\n## Code Example\n```java\n// Android native module\n@ReactMethod\npublic Promise performHeavyComputation(Promise promise) {\n  new Thread(() -> {\n    try {\n      String result = heavyCalculation();\n      promise.resolve(result);\n    } catch (Exception e) {\n      promise.reject(\"ERROR\", e.getMessage());\n    }\n  }).start();\n}\n```\n\n## Real-World Applications\n- **Airbnb:** Custom camera filters\n- **Discord:** Voice chat integration\n- **Uber:** Location services optimization\n- **Spotify:** Audio processing modules","diagram":"flowchart TD\n  A[JavaScript Code] --> B[React Native Bridge]\n  B --> C[Native Module]\n  C --> D[Platform API]\n  D --> E[Hardware/OS Features]\n  E --> F[Native Module]\n  F --> B\n  B --> A","difficulty":"beginner","tags":["native","bridge"],"channel":"react-native","subChannel":"native-modules","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":["native modules","bridge","threading model","async communication","platform-specific apis","performance","background threads"],"voiceSuitable":true,"isNew":false,"lastUpdated":"2025-12-27T05:47:47.542Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-206","question":"How would you optimize React Native list performance with Hermes and Reanimated when dealing with 10k+ items containing complex animations?","answer":"Implement a FlatList with getItemLayout for predictable heights, memoized render items using React.memo, Reanimated 2 shared values for UI-thread animations, Hermes bytecode optimization for faster JavaScript execution, and eliminate inline functions to prevent unnecessary re-renders.","explanation":"## Concept Overview\nOptimizing large-scale React Native lists requires a multi-faceted approach addressing JavaScript execution efficiency, layout calculation optimization, and animation performance management.\n\n## Implementation Details\n- **FlatList Optimization**: Configure `getItemLayout` for predictable item heights, enable `removeClippedSubviews` for memory efficiency, and tune `maxToRenderPerBatch` for balanced rendering\n- **Hermes Engine Benefits**: Leverage bytecode precompilation for faster startup times, reduced memory footprint for better performance on low-end devices, and optimized JavaScript execution\n- **Reanimated 2 Integration**: Utilize `useSharedValue` for state management and `useAnimatedStyle` for UI-thread animations, preventing main thread blocking\n- **Memoization Strategy**: Apply `React.memo` to prevent unnecessary re-renders and `useCallback` for stable function references\n\n## Code Example\n```javascript\nconst OptimizedListItem = React.memo(({ item, sharedValue }) => {\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: sharedValue.value }]\n  }));\n  \n  return (\n    <Animated.View style={[styles.item, animatedStyle]}>\n      <Text>{item.title}</Text>\n    </Animated.View>\n  );\n});\n\nconst renderItem = useCallback(({ item }) => (\n  <OptimizedListItem item={item} sharedValue={scaleShared} />\n), []);\n\nreturn (\n  <FlatList\n    data={largeDataSet}\n    renderItem={renderItem}\n    getItemLayout={(data, index) => ({\n      length: ITEM_HEIGHT,\n      offset: ITEM_HEIGHT * index,\n      index,\n    })}\n    removeClippedSubviews\n    maxToRenderPerBatch={10}\n    windowSize={10}\n  />\n);\n```","diagram":"flowchart LR\n    A[10k+ Data Items] --> B[FlatList with getItemLayout]\n    B --> C[Memoized ListItem Components]\n    C --> D[Reanimated Shared Values]\n    D --> E[UI Thread Animations]\n    E --> F[Hermes Bytecode Execution]\n    F --> G[Optimized Rendering Pipeline]\n    \n    H[removeClippedSubviews] --> I[Reduced Memory Usage]\n    J[maxToRenderPerBatch] --> K[Controlled Rendering]\n    L[React.memo] --> M[Prevented Re-renders]\n    \n    I --> G\n    K --> G\n    M --> G","difficulty":"advanced","tags":["hermes","reanimated","profiling"],"channel":"react-native","subChannel":"performance","sourceUrl":null,"videos":{"longVideo":"https://www.youtube.com/watch?v=a2HkkkisIAg"},"companies":["Airbnb","Coinbase","Meta","Microsoft","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-08T11:23:07.594Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-233","question":"How does the Hermes engine improve React Native app startup performance compared to JavaScriptCore, and what are the specific trade-offs?","answer":"Hermes uses ahead-of-time (AOT) compilation to convert JavaScript to optimized bytecode during build time, reducing startup by 30-50% and memory usage by 20-30% compared to JavaScriptCore's just-in-time (JIT) compilation. It pre-compiles functions, eliminating parsing overhead at runtime, and uses a more compact bytecode format. Trade-offs include longer build times, larger bundle sizes, and potentially slower execution for dynamically generated code.","explanation":"## Core Architecture Differences\n\n**JavaScriptCore (JIT)**:\n- Parses and compiles JavaScript at runtime\n- Uses baseline JIT, then optimizes hot code paths\n- Higher initial overhead but better for dynamic patterns\n\n**Hermes (AOT)**:\n- Compiles to optimized bytecode during build\n- No runtime parsing or compilation\n- Smaller memory footprint and faster initialization\n\n## Performance Impact\n\n```javascript\n// Bundle size comparison (typical app)\nJSC Bundle: ~1.2MB  + runtime compilation\nHermes Bundle: ~800KB (bytecode) + minimal runtime\n\n// Startup time benchmarks\nTime to Interactive:\n- JSC: 1.8-2.2s\n- Hermes: 0.9-1.4s\n```\n\n## Memory Usage\n\nHermes reduces memory usage through:\n- Pre-allocated memory pools\n- Efficient bytecode execution\n- No JIT compiler memory overhead\n- Conservative garbage collection\n\n## Trade-offs and Considerations\n\n**Advantages**:\n- Faster cold start performance\n- Lower memory consumption\n- Predictable performance (no JIT warmup)\n- Better crash rates in production\n\n**Limitations**:\n- Longer build times (AOT compilation)\n- Larger initial bundle size\n- Slower for eval() and dynamic imports\n- Limited debugging capabilities\n\n## Implementation\n\n```json\n// metro.config.js\n{\n  \"transformer\": \"metro-react-native-babel-transformer\",\n  \"resolver\": {\n    \"resolverMainFields\": [\"react-native\", \"browser\", \"main\"]\n  },\n  \"engines\": {\n    \"hermes\": true\n  }\n}\n```\n\n## When to Choose Hermes\n\n- **Production apps** prioritizing startup performance\n- **Memory-constrained devices** (entry-level phones)\n- **Apps with stable codebase** (limited dynamic code)\n- **Large user bases** where performance consistency matters\n\n## When JavaScriptCore Might Be Better\n\n- **Development environments** with frequent hot reloads\n- **Apps heavy on dynamic code generation**\n- **Debugging-intensive development**\n- **Prototype or experimental features**\n\nReal-world data from Facebook's internal testing shows Hermes reduces crash rates by 25% and improves user retention through faster app initialization, making it the preferred choice for production React Native applications.","diagram":"flowchart LR\n    A[JavaScript Source] --> B[Metro Bundler]\n    B --> C[Hermes AOT Compilation]\n    C --> D[Bytecode Bundle]\n    D --> E[App Installation]\n    E --> F[Faster Startup]\n    F --> G[Hermes Runtime]\n    G --> H[Native Bridge]","difficulty":"beginner","tags":["hermes","reanimated","profiling"],"channel":"react-native","subChannel":"performance","sourceUrl":null,"videos":null,"companies":["Airbnb","Meta","Microsoft","Netflix","Salesforce","Shopify"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-26T16:36:41.195Z","createdAt":"2025-12-26 12:51:07"}],"subChannels":["general","native-modules","performance"],"companies":["Adobe","Airbnb","Amazon","Apple","Bloomberg","Citadel","Cloudflare","Coinbase","Databricks","Discord","DoorDash","Goldman Sachs","Google","Hashicorp","Hugging Face","IBM","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Netflix","OpenAI","Oracle","PayPal","Plaid","Robinhood","Salesforce","Scale Ai","Shopify","Snap","Snowflake","Square","Stripe","Tesla","Two Sigma","Uber","Zoom"],"stats":{"total":43,"beginner":14,"intermediate":12,"advanced":17,"newThisWeek":31}}