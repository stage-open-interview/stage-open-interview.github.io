{"questions":[{"id":"q-1048","question":"You're building a React Native field-ops app with intermittent connectivity that must display offline-first tasks with images and support incremental sync across devices. Describe architecture and provide a small implementation sketch using a local DB (WatermelonDB or Realm), a sync service, and conflict resolution. What edge cases and tests would you include?","answer":"Adopt offline-first strategy using WatermelonDB or Realm to store tasks and media locally. Implement a background SyncWorker that batches local changes, fetches remote deltas, and merges conflicts wit","explanation":"## Why This Is Asked\n\nTests ability to design offline-first systems, conflict resolution, and background sync in React Native.\n\n## Key Concepts\n\n- offline-first DB in RN (WatermelonDB/Realm)\n- delta-based incremental sync\n- conflict resolution strategy (LWW, per-field merges)\n- background tasks (Headless JS/WorkManager)\n\n## Code Example\n\n```javascript\n// Pseudo-code sketch for SyncWorker\nasync function processBatch(batch) {\n  // apply local changes, fetch remote deltas, merge conflicts\n}\n```\n\n## Follow-up Questions\n\n- How would you handle large binary media in offline cache?\n- How would you test race conditions across devices?","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Hugging Face","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T20:33:19.081Z","createdAt":"2026-01-12T20:33:19.081Z"},{"id":"q-1065","question":"You're building a React Native app for live collaboration that streams up to 4 simultaneous camera feeds using WebRTC. Describe end-to-end architecture for capture, encoding, and transport, how you'd implement backpressure and frame pacing to sustain ~30fps per feed, and provide a small implementation sketch (camera hook + simple backpressure queue) in code?","answer":"Use four RN camera streams via WebRTC with separate RTCPeerConnections and tracks. Capture frames with VisionCamera, encode in a native module using hardware encoders, and push to the correct WebRTC t","explanation":"## Why This Is Asked\nTests real-world RN streaming with WebRTC, multi-sensor coordination, and performance under backpressure.\n\n## Key Concepts\n- WebRTC integration in React Native\n- Camera capture pipelines and encoders\n- Backpressure, frame pacing, queue management\n- Resource constraints on mobile devices and cross-platform differences\n\n## Code Example\n```javascript\nfunction createBackpressureQueue(limit){\n  const q = [];\n  return {\n    enqueue(f){ if (q.length < limit){ q.push(f); return true } return false; },\n    dequeue(){ return q.shift(); },\n    size(){ return q.length; }\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test backpressure behavior under network jitter?\n- What are the trade-offs between software vs. native encoding paths in RN?","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Google","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T21:24:56.893Z","createdAt":"2026-01-12T21:24:56.893Z"},{"id":"q-1098","question":"You're building a React Native app for field technicians that must collect GPS and sensor data in the background every 15 minutes, even when the app is suspended. Describe a cross‑platform architecture using Android WorkManager and iOS BGTaskScheduler, a minimal RN bridge, and a small code sketch of a BackgroundTaskManager that schedules tasks, persists deadlines, and handles results. Include edge cases like battery saver, app termination, and user-initiated cancel?","answer":"Adopt a cross‑platform BackgroundTaskManager bridged to native: Android WorkManager (PeriodicWorkRequest, 15m, network/battery constraints) and iOS BGTaskScheduler (BGAppRefreshTask with earliestBegin","explanation":"## Why This Is Asked\nTests cross‑platform background execution, RN bridge design, and resilience under OS quotas.\n\n## Key Concepts\n- RN bridge to native modules (TurboModules/JSI)\n- Android WorkManager and iOS BGTaskScheduler\n- Headless JS tasks and data persistence\n- Backoff/retry, quotas, cancellation\n\n## Code Example\n```javascript\nclass BackgroundTaskManager {\n  static register() { /* native register */ }\n  static schedule() { /* schedule task via bridge */ }\n  static cancel() { /* cancel */ }\n}\nexport default BackgroundTaskManager;\n```\n\n## Follow-up Questions\n- How would you test for battery-saver constraints and app-termination scenarios?","diagram":"flowchart TD\nA[RN App] --> B[BackgroundTaskManager]\nB --> C[Android: WorkManager]\nB --> D[iOS: BGTaskScheduler]\nC --> E[Headless JS Task]\nD --> E\nE --> F[Local Persist]\nF --> G[Backoff/Retry]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T22:29:56.902Z","createdAt":"2026-01-12T22:29:56.902Z"},{"id":"q-1265","question":"You're building a real-time collaborative whiteboard in React Native that must support up to 1,000 participants with low latency and offline fallback. Describe an end-to-end architecture using WebRTC data channels for deltas, WebSocket signaling, and a CRDT for merging concurrent strokes. Include data model (stroke encoding, timestamps), backpressure handling, and a small code sketch implementing a delta encoder and an in-app delta queue that feeds an RN Canvas/Skia surface, with clear acceptance criteria?","answer":"Approach: peer-to-peer deltas via WebRTC data channels, signaling via WebSocket. Encode each stroke as compact deltas (move coordinate, pressure, color, width) with varint. Use a CRDT like RGA for ord","explanation":"## Why This Is Asked\n\nTests real-time collaboration design, data encoding efficiency, and RN-CRDT integration.\n\n## Key Concepts\n\n- WebRTC data channels for low-latency deltas\n- WebSocket signaling and fallback\n- CRDTs vs OT for merges\n- Delta encoding and backpressure\n- Fluid rendering on RN Canvas/Skia\n\n## Code Example\n\n```javascript\nfunction encodeStroke(stroke){\n  // delta-encode a stroke segment\n  // return compact object\n}\nfunction applyDelta(state, delta){\n  // patch canvas state with delta\n}\n```\n\n## Follow-up Questions\n\n- How would you scale the signaling and data channels to 1,000 participants?\n- How would you ensure idempotence and replay on reconnect?","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T07:32:10.415Z","createdAt":"2026-01-13T07:32:10.415Z"},{"id":"q-1537","question":"You're building a React Native app for field engineers in regulated environments. It collects GPS and accelerometer telemetry, signs each record with a device key, and batches uploads to a backend with offline-first guarantees and tamper-evident auditing. Describe the architecture, data flow, and provide a small code sketch: a LocalAuditLog module backed by SQLite and TweetNaCl for Ed25519 signing, plus a transport adapter with exponential backoff and key-rotation handling. Include edge cases around tenant isolation, data retention, and replay protection?","answer":"Use a LocalAuditLog backed by SQLite to store signed records. Sign each entry with Ed25519 (TweetNaCl) using a per-tenant device key, include a timestamp and previous hash for chaining. Batch 50–100 r","explanation":"## Why This Is Asked\nThis probes end-to-end data integrity in offline-first mobile apps, with regulatory considerations and tenant isolation.\n\n## Key Concepts\n- Local SQLite storage for durable offline data\n- Ed25519 signing (TweetNaCl) for tamper-evident logs\n- Batch transmission with exponential backoff and idempotent retries\n- Tenant isolation and per-tenant key rotation\n- Replay protection via nonces and chained hashes\n- Data-retention and auditability guarantees\n\n## Code Example\n```javascript\n// LocalAuditLog.ts (sketch)\nimport { open } from 'sqlite';\nimport sqlite3 from 'sqlite3';\nimport nacl from 'tweetnacl';\nimport naclUtil from 'tweetnacl-util';\n\ntype AuditRecord = {\n  id: string;\n  tenantId: string;\n  timestamp: number;\n  nonce: string;\n  payload: string;\n  hash?: string;\n  signature?: string;\n};\n\nexport class LocalAuditLog {\n  private db: any;\n  private keyPair: { publicKey: string; secretKey: string };\n\n  private constructor(db: any, keyPair: { publicKey: string; secretKey: string }) {\n    this.db = db; this.keyPair = keyPair;\n  }\n\n  static async create(dbPath: string): Promise<LocalAuditLog> {\n    const db = await open({ filename: dbPath, driver: sqlite3.Database });\n    await db.exec(`CREATE TABLE IF NOT EXISTS audits (\n      id TEXT PRIMARY KEY, tenantId TEXT, timestamp INTEGER, nonce TEXT,\n      payload TEXT, hash TEXT, signature TEXT, sent INTEGER DEFAULT 0\n    )`);\n    // placeholder keypair; in practice load from secure storage and rotate as needed\n    const keyPair = nacl.sign.keyPair();\n    return new LocalAuditLog(db, {\n      publicKey: naclUtil.encodeBase64(keyPair.publicKey),\n      secretKey: naclUtil.encodeBase64(keyPair.secretKey)\n    });\n  }\n\n  async append(tenantId: string, payload: string, nonce: string): Promise<void> {\n    const record: AuditRecord = {\n      id: crypto.randomUUID(), tenantId, timestamp: Date.now(), nonce, payload\n    };\n    const data = `${record.tenantId}|${record.timestamp}|${record.nonce}|${record.payload}`;\n    const sig = nacl.sign.detached(naclUtil.decodeBase64(this.keyPair.secretKey), naclUtil.decodeUTF8(data));\n    record.hash = this.hashRecord(record);\n    record.signature = naclUtil.encodeBase64(sig);\n    await this.db.run(`INSERT INTO audits (id, tenantId, timestamp, nonce, payload, hash, signature) VALUES (?, ?, ?, ?, ?, ?, ?)`,\n      record.id, record.tenantId, record.timestamp, record.nonce, record.payload, record.hash, record.signature);\n  }\n\n  async getBatch(limit: number): Promise<AuditRecord[]> {\n    const rows = await this.db.all(`SELECT * FROM audits WHERE sent = 0 ORDER BY timestamp ASC LIMIT ?`, limit);\n    return rows as AuditRecord[];\n  }\n\n  async markSent(ids: string[]): Promise<void> {\n    const placeholders = ids.map(() => '?').join(',');\n    await this.db.run(`UPDATE audits SET sent = 1 WHERE id IN (${placeholders})`, ids);\n  }\n\n  private hashRecord(r: AuditRecord): string {\n    return naclUtil.crypto_hash(`${r.tenantId}|${r.timestamp}|${r.nonce}|${r.payload}`);\n  }\n}\n```\n\n## Follow-up Questions\n- How would you securely store and rotate keys on device across app updates?\n- How would you migrate existing records during a key rotation without data loss?\n- How would you verify server integrity and prevent replay attacks in case of network replayed requests?","diagram":"flowchart TD\n  A[Mobile App] --> B[LocalAuditLog (SQLite)]\n  B --> C[Signer (TweetNaCl Ed25519)]\n  C --> D[Batcher]\n  D --> E[Transport with Retry]\n  E --> F[Backend]","difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Goldman Sachs","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T20:53:27.037Z","createdAt":"2026-01-13T20:53:27.038Z"},{"id":"q-1790","question":"You're building a cross-platform React Native app for field technicians that must display a map with thousands of POIs, support offline caching of tiles and markers, and perform incremental sync of POI updates when online. Design a data layer and UI flow to support offline-first maps, marker clustering, and conflict resolution. Provide a small code sketch for a WatermelonDB/Realm model and a MarkerLayer component, plus test ideas?","answer":"Adopt an offline-first data layer (WatermelonDB or Realm) for POIs and a disk tile cache. Implement incremental sync: push local POI deltas, pull server updates, and resolve conflicts using server-tim","explanation":"## Why This Is Asked\n\nEvaluates ability to design an offline-first map data model, incremental sync, and scalable UI rendering with clustering in a real RN app.\n\n## Key Concepts\n\n- Offline-first data model using WatermelonDB or Realm\n- Disk tile cache for maps\n- Incremental sync with delta PUSH and server updates\n- Conflict resolution via server-timestamp precedence or last-writer-wins with logs\n- Marker clustering with geohash or grid\n- Testing: offline edits, conflict scenarios, clustering accuracy, cache eviction\n\n## Code Example\n\n```javascript\n// WatermelonDB POI schema sketch\nconst poisSchema = tableSchema({\n  name: 'pois',\n  columns: [\n    { name: 'name', type: 'string' },\n    { name: 'lat', type: 'number' },\n    { name: 'lon', type: 'number' },\n    { name: 'last_modified', type: 'number' },\n  ],\n});\n\n// MarkerLayer sketch (conceptual)\nfunction MarkerLayer({ pois }) {\n  const clusters = clusterPoints(pois, 60); // 60px radius\n  return clusters.map((c) => (\n    <Marker key={c.id} coordinate={c.center} onPress={() => openPOI(c.pois[0].id)}>\n      <Callout>{c.count} POIs</Callout>\n    </Marker>\n  ));\n}\n```\n\n## Follow-up Questions\n\n- How would you test sync conflict resolution in a CI pipeline?\n- What metrics would you monitor to detect tile cache memory pressure?\n- How would you handle real-time map tile updates in online mode without blocking UI?","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Meta","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T10:51:03.589Z","createdAt":"2026-01-14T10:51:03.589Z"},{"id":"q-475","question":"You're building a React Native app with complex animations that need to run at 60fps. The app has multiple animated components including a custom carousel, gesture-driven interactions, and background video processing. How would you optimize performance to maintain smooth animations?","answer":"Use **React Native's Reanimated 3** for UI thread animations to avoid JS bridge overhead. Implement **useAnimatedStyle** with **useDerivedValue** for efficient value sharing. Use **FlatList** instead of ScrollView for virtualized rendering, enable **removeClippedSubviews** to hide off-screen items, and provide **getItemLayout** for fixed item heights. Leverage **Gesture Handler** for native gesture recognition and **PanGesture** for smooth interactions.","explanation":"## Performance Optimization Strategy\n\n### Animation Framework\n- **Reanimated 3**: Runs animations on UI thread, prevents JS bridge blocking\n- **Shared Values**: Efficient state management across animation boundaries\n- **Worklets**: JS code executed on UI thread for smooth 60fps\n\n### List Optimization\n- **FlatList**: Virtualized rendering with memory efficiency\n- **removeClippedSubviews**: Hides off-screen items to reduce render load\n- **getItemLayout**: Provides fixed item heights for optimized scrolling\n\n### Gesture Handling\n- **Gesture Handler**: Native gesture recognition system\n- **PanGesture**: Smooth gesture-driven interactions with native performance\n\n### Background Processing\n- **Native Modules**: Offload video processing to native threads\n- **Web Workers**: Use for background computations when possible\n- **Optimized Codecs**: Choose efficient video formats and compression","diagram":"flowchart TD\n  A[User Interaction] --> B[Gesture Handler]\n  B --> C[Reanimated Worklet]\n  C --> D[UI Thread Animation]\n  D --> E[60fps Render]\n  F[FlatList] --> G[Virtualized Items]\n  G --> H[removeClippedSubviews]\n  H --> E\n  I[React.memo] --> J[Optimized Re-renders]\n  J --> E","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-10T03:28:36.246Z","createdAt":"2025-12-26 12:51:05"},{"id":"q-504","question":"How would you implement a custom button component in React Native that handles both iOS and Android platform-specific styling while maintaining consistent behavior?","answer":"Create a reusable button using Platform API for conditional styling. Use TouchableOpacity for touch handling, Platform.select for platform-specific props (shadowOpacity for iOS, elevation for Android)","explanation":"## Platform-Specific Implementation\n\n- Use `Platform.select()` to apply different styles per platform\n- iOS: Use `shadowOpacity` and `shadowRadius` for depth\n- Android: Use `elevation` for shadow effects\n\n## Touch Handling\n\n- `TouchableOpacity` provides visual feedback\n- `activeOpacity` prop controls press transparency\n- `disabled` prop prevents interaction\n\n## Performance\n\n- `StyleSheet.create()` optimizes style objects\n- Avoid inline styles for better performance\n- Use `useMemo` for complex style calculations","diagram":"flowchart TD\n  A[CustomButton Component] --> B{Platform Check}\n  B -->|iOS| C[iOS Styles: shadowOpacity]\n  B -->|Android| D[Android Styles: elevation]\n  C --> E[TouchableOpacity Wrapper]\n  D --> E\n  E --> F[Consistent onPress Handler]","difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Robinhood","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-25T01:16:06.061Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-533","question":"How would you optimize a React Native app with 50+ screens that's experiencing slow navigation and memory leaks, particularly on lower-end devices?","answer":"Implement lazy loading with React.lazy() and Suspense for screen components, use React.memo() for expensive renders, optimize FlatList with getItemLayout and removeClippedSubviews, implement proper cleanup in useEffect hooks, leverage Metro bundler's RAM bundles, and use React Navigation's optimization features.","explanation":"## Performance Optimization Strategies\n\n### Code Splitting & Lazy Loading\n- Use React.lazy() for screen components wrapped in Suspense\n- Implement route-based code splitting to reduce initial bundle size\n- Leverage Metro bundler's RAM bundles for improved memory efficiency\n\n### Memory Management\n- Proper cleanup in useEffect hooks to prevent memory leaks\n- Avoid closures in long-lived components that retain references\n- Use WeakMap/WeakSet for large data structures\n- Implement proper event listener cleanup\n\n### List Optimization\n```javascript\n<FlatList\n  data={items}\n  getItemLayout={(data, index) => ({length: ITEM_HEIGHT, offset: ITEM_HEIGHT * index, index})}\n  removeClippedSubviews={true}\n  maxToRenderPerBatch={10}\n  windowSize={10}\n  initialNumToRender={10}\n/>\n```\n\n### Engine & Build Optimizations\n- Use Hermes JavaScript engine for better performance\n- Implement bundle splitting and code optimization\n- Utilize React.memo() and useMemo() for expensive computations\n- Profile and optimize re-renders with React DevTools","diagram":"flowchart TD\n  A[App Startup] --> B[Route-based Lazy Loading]\n  B --> C[Screen Component Mount]\n  C --> D[React.memo Check]\n  D --> E[Render Optimization]\n  E --> F[FlatList Virtualization]\n  F --> G[Memory Cleanup]\n  G --> H[Performance Monitoring]\n  H --> I[Flipper Analysis]\n  I --> J[Optimization Iteration]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-09T08:44:45.928Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-560","question":"You're building a React Native app that needs to display a list of user profiles with images. The list should be performant with 1000+ items and support pull-to-refresh. How would you implement this using FlatList and what optimizations would you apply?","answer":"Use FlatList with keyExtractor for stable item identification, getItemLayout for optimized rendering calculations, and initialNumToRender to control the initial render batch. Implement pull-to-refresh functionality with the onRefresh prop and refreshing state. Use memoized renderItem components with React.memo to prevent unnecessary re-renders, implement image caching with react-native-fast-image, and optimize memory usage with removeClippedSubviews and windowSize props.","explanation":"## Key Implementation\n- Use FlatList instead of ScrollView for efficient virtualized rendering with large datasets\n- Implement keyExtractor for stable item identification and optimal diffing\n- Add getItemLayout to enable smooth scrolling by providing item dimensions upfront\n- Configure initialNumToRender and maxToRenderPerBatch to balance performance and user experience\n\n## Performance Optimizations\n- Memoize renderItem components with React.memo to prevent unnecessary re-renders\n- Use windowSize prop to control the render window and reduce memory footprint\n- Implement image caching with react-native-fast-image for efficient image loading\n- Consider removeClippedSubviews for memory optimization with complex lists\n- Optimize data structure to minimize update calculations\n\n## Refresh Pattern\n```javascript\n<FlatList\n  data={profiles}\n  onRefresh={handleRefresh}\n  refreshing={isRefreshing}\n  keyExtractor={(item) => item.id}\n  getItemLayout={(data, index) => ({\n    length: ITEM_HEIGHT,\n    offset: ITEM_HEIGHT * index,\n    index,\n  })}\n  initialNumToRender={20}\n  maxToRenderPerBatch={10}\n  windowSize={10}\n  removeClippedSubviews={true}\n  renderItem={memoizedItemRenderer}\n/>\n```","diagram":"flowchart TD\n  A[User Pulls Down] --> B[onRefresh Triggered]\n  B --> C[Set refreshing=true]\n  C --> D[Fetch New Data]\n  D --> E[Update State]\n  E --> F[Set refreshing=false]\n  F --> G[FlatList Re-renders]\n  G --> H[Display Updated List]","difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-08T11:56:33.226Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-589","question":"How do you handle different screen sizes and orientations in React Native?","answer":"In React Native, handle different screen sizes using Flexbox layouts with percentage-based dimensions and the `useWindowDimensions` hook to respond to size changes. For orientation changes, listen to dimension events and re-render components with updated layouts, while using Platform-specific styles for iOS and Android differences.","explanation":"## Key Concepts\n- **Flexbox Layout**: Primary responsive design tool\n- **Dimensions API**: Screen size detection\n- **Orientation Handling**: Dynamic adaptation\n\n## Implementation\n```javascript\nimport { useWindowDimensions } from 'react-native';\n\nconst { width, height } = useWindowDimensions();\nconst isLandscape = width > height;\n```\n\n## Best Practices\n- Use relative units over fixed pixels\n- Implement safe area insets with `react-native-safe-area-context`\n- Test on various device ratios\n- Consider platform differences (iOS vs Android)","diagram":"flowchart TD\n  A[App Start] --> B[Detect Screen Size]\n  B --> C[Apply Flexbox Layout]\n  C --> D[Handle Orientation Change]\n  D --> E[Update UI Accordingly]\n  E --> F[Monitor Size Changes]","difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Instacart","LinkedIn"],"eli5":null,"relevanceScore":null,"voiceKeywords":["flexbox layouts","percentage-based dimensions","usewindowdimensions hook","dimension events","platform-specific styles","react-native-safe-area-context","safe area insets","device ratios","orientation changes","screen sizes","ios vs android","responsive design"],"voiceSuitable":true,"isNew":false,"lastUpdated":"2026-01-06T04:04:20.726Z","createdAt":"2025-12-27T01:14:41.041Z"},{"id":"q-183","question":"What are Native Modules in React Native, when should you use them, and what are the key performance and threading considerations?","answer":"Native Modules bridge JavaScript and native code to access platform-specific APIs not available in JS. Use for Bluetooth, biometrics, camera controls, or performance-critical operations. Consider bridge overhead, threading model (main vs background), and async communication patterns.","explanation":"## Core Purpose\nNative Modules enable access to platform-specific APIs and performance-critical operations not available in JavaScript, creating a bridge between JS and native iOS/Android code.\n\n## When to Use\n**Ideal scenarios:**\n- Bluetooth/Peripheral communication\n- Biometric authentication\n- Advanced camera controls\n- Custom hardware integration\n- CPU-intensive calculations\n\n**When NOT to use:**\n- Simple UI operations\n- Basic storage needs\n- Network requests (use fetch/axios)\n- When JS performance is sufficient\n\n## Performance Considerations\n**Bridge Overhead:** Each async call crosses the bridge with serialization cost. Batch operations when possible.\n\n**Threading Model:**\n- Native modules run on main thread by default\n- Use background threads for heavy computations\n- JS thread must never block\n\n**Memory Management:**\n- Clean up native resources in dealloc\n- Avoid memory leaks across bridge\n- Use proper promise/reject patterns\n\n## Code Example\n```java\n// Android native module\n@ReactMethod\npublic Promise performHeavyComputation(Promise promise) {\n  new Thread(() -> {\n    try {\n      String result = heavyCalculation();\n      promise.resolve(result);\n    } catch (Exception e) {\n      promise.reject(\"ERROR\", e.getMessage());\n    }\n  }).start();\n}\n```\n\n## Real-World Applications\n- **Airbnb:** Custom camera filters\n- **Discord:** Voice chat integration\n- **Uber:** Location services optimization\n- **Spotify:** Audio processing modules","diagram":"flowchart TD\n  A[JavaScript Code] --> B[React Native Bridge]\n  B --> C[Native Module]\n  C --> D[Platform API]\n  D --> E[Hardware/OS Features]\n  E --> F[Native Module]\n  F --> B\n  B --> A","difficulty":"beginner","tags":["native","bridge"],"channel":"react-native","subChannel":"native-modules","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":["native modules","bridge","threading model","async communication","platform-specific apis","performance","background threads"],"voiceSuitable":true,"isNew":false,"lastUpdated":"2025-12-27T05:47:47.542Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-206","question":"How would you optimize React Native list performance with Hermes and Reanimated when dealing with 10k+ items containing complex animations?","answer":"Implement a FlatList with getItemLayout for predictable heights, memoized render items using React.memo, Reanimated 2 shared values for UI-thread animations, Hermes bytecode optimization for faster JavaScript execution, and eliminate inline functions to prevent unnecessary re-renders.","explanation":"## Concept Overview\nOptimizing large-scale React Native lists requires a multi-faceted approach addressing JavaScript execution efficiency, layout calculation optimization, and animation performance management.\n\n## Implementation Details\n- **FlatList Optimization**: Configure `getItemLayout` for predictable item heights, enable `removeClippedSubviews` for memory efficiency, and tune `maxToRenderPerBatch` for balanced rendering\n- **Hermes Engine Benefits**: Leverage bytecode precompilation for faster startup times, reduced memory footprint for better performance on low-end devices, and optimized JavaScript execution\n- **Reanimated 2 Integration**: Utilize `useSharedValue` for state management and `useAnimatedStyle` for UI-thread animations, preventing main thread blocking\n- **Memoization Strategy**: Apply `React.memo` to prevent unnecessary re-renders and `useCallback` for stable function references\n\n## Code Example\n```javascript\nconst OptimizedListItem = React.memo(({ item, sharedValue }) => {\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: sharedValue.value }]\n  }));\n  \n  return (\n    <Animated.View style={[styles.item, animatedStyle]}>\n      <Text>{item.title}</Text>\n    </Animated.View>\n  );\n});\n\nconst renderItem = useCallback(({ item }) => (\n  <OptimizedListItem item={item} sharedValue={scaleShared} />\n), []);\n\nreturn (\n  <FlatList\n    data={largeDataSet}\n    renderItem={renderItem}\n    getItemLayout={(data, index) => ({\n      length: ITEM_HEIGHT,\n      offset: ITEM_HEIGHT * index,\n      index,\n    })}\n    removeClippedSubviews\n    maxToRenderPerBatch={10}\n    windowSize={10}\n  />\n);\n```","diagram":"flowchart LR\n    A[10k+ Data Items] --> B[FlatList with getItemLayout]\n    B --> C[Memoized ListItem Components]\n    C --> D[Reanimated Shared Values]\n    D --> E[UI Thread Animations]\n    E --> F[Hermes Bytecode Execution]\n    F --> G[Optimized Rendering Pipeline]\n    \n    H[removeClippedSubviews] --> I[Reduced Memory Usage]\n    J[maxToRenderPerBatch] --> K[Controlled Rendering]\n    L[React.memo] --> M[Prevented Re-renders]\n    \n    I --> G\n    K --> G\n    M --> G","difficulty":"advanced","tags":["hermes","reanimated","profiling"],"channel":"react-native","subChannel":"performance","sourceUrl":null,"videos":{"longVideo":"https://www.youtube.com/watch?v=a2HkkkisIAg"},"companies":["Airbnb","Coinbase","Meta","Microsoft","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-08T11:23:07.594Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-233","question":"How does the Hermes engine improve React Native app startup performance compared to JavaScriptCore, and what are the specific trade-offs?","answer":"Hermes uses ahead-of-time (AOT) compilation to convert JavaScript to optimized bytecode during build time, reducing startup by 30-50% and memory usage by 20-30% compared to JavaScriptCore's just-in-time (JIT) compilation. It pre-compiles functions, eliminating parsing overhead at runtime, and uses a more compact bytecode format. Trade-offs include longer build times, larger bundle sizes, and potentially slower execution for dynamically generated code.","explanation":"## Core Architecture Differences\n\n**JavaScriptCore (JIT)**:\n- Parses and compiles JavaScript at runtime\n- Uses baseline JIT, then optimizes hot code paths\n- Higher initial overhead but better for dynamic patterns\n\n**Hermes (AOT)**:\n- Compiles to optimized bytecode during build\n- No runtime parsing or compilation\n- Smaller memory footprint and faster initialization\n\n## Performance Impact\n\n```javascript\n// Bundle size comparison (typical app)\nJSC Bundle: ~1.2MB  + runtime compilation\nHermes Bundle: ~800KB (bytecode) + minimal runtime\n\n// Startup time benchmarks\nTime to Interactive:\n- JSC: 1.8-2.2s\n- Hermes: 0.9-1.4s\n```\n\n## Memory Usage\n\nHermes reduces memory usage through:\n- Pre-allocated memory pools\n- Efficient bytecode execution\n- No JIT compiler memory overhead\n- Conservative garbage collection\n\n## Trade-offs and Considerations\n\n**Advantages**:\n- Faster cold start performance\n- Lower memory consumption\n- Predictable performance (no JIT warmup)\n- Better crash rates in production\n\n**Limitations**:\n- Longer build times (AOT compilation)\n- Larger initial bundle size\n- Slower for eval() and dynamic imports\n- Limited debugging capabilities\n\n## Implementation\n\n```json\n// metro.config.js\n{\n  \"transformer\": \"metro-react-native-babel-transformer\",\n  \"resolver\": {\n    \"resolverMainFields\": [\"react-native\", \"browser\", \"main\"]\n  },\n  \"engines\": {\n    \"hermes\": true\n  }\n}\n```\n\n## When to Choose Hermes\n\n- **Production apps** prioritizing startup performance\n- **Memory-constrained devices** (entry-level phones)\n- **Apps with stable codebase** (limited dynamic code)\n- **Large user bases** where performance consistency matters\n\n## When JavaScriptCore Might Be Better\n\n- **Development environments** with frequent hot reloads\n- **Apps heavy on dynamic code generation**\n- **Debugging-intensive development**\n- **Prototype or experimental features**\n\nReal-world data from Facebook's internal testing shows Hermes reduces crash rates by 25% and improves user retention through faster app initialization, making it the preferred choice for production React Native applications.","diagram":"flowchart LR\n    A[JavaScript Source] --> B[Metro Bundler]\n    B --> C[Hermes AOT Compilation]\n    C --> D[Bytecode Bundle]\n    D --> E[App Installation]\n    E --> F[Faster Startup]\n    F --> G[Hermes Runtime]\n    G --> H[Native Bridge]","difficulty":"beginner","tags":["hermes","reanimated","profiling"],"channel":"react-native","subChannel":"performance","sourceUrl":null,"videos":null,"companies":["Airbnb","Meta","Microsoft","Netflix","Salesforce","Shopify"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-26T16:36:41.195Z","createdAt":"2025-12-26 12:51:07"}],"subChannels":["general","native-modules","performance"],"companies":["Airbnb","Amazon","Citadel","Cloudflare","Coinbase","Databricks","Discord","DoorDash","Goldman Sachs","Google","Hashicorp","Hugging Face","Instacart","LinkedIn","Meta","Microsoft","NVIDIA","Netflix","Oracle","PayPal","Robinhood","Salesforce","Shopify","Stripe","Tesla","Two Sigma","Uber","Zoom"],"stats":{"total":14,"beginner":4,"intermediate":5,"advanced":5,"newThisWeek":6}}