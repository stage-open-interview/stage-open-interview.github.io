{"questions":[{"id":"q-1048","question":"You're building a React Native field-ops app with intermittent connectivity that must display offline-first tasks with images and support incremental sync across devices. Describe architecture and provide a small implementation sketch using a local DB (WatermelonDB or Realm), a sync service, and conflict resolution. What edge cases and tests would you include?","answer":"Adopt offline-first strategy using WatermelonDB or Realm to store tasks and media locally. Implement a background SyncWorker that batches local changes, fetches remote deltas, and merges conflicts wit","explanation":"## Why This Is Asked\n\nTests ability to design offline-first systems, conflict resolution, and background sync in React Native.\n\n## Key Concepts\n\n- offline-first DB in RN (WatermelonDB/Realm)\n- delta-based incremental sync\n- conflict resolution strategy (LWW, per-field merges)\n- background tasks (Headless JS/WorkManager)\n\n## Code Example\n\n```javascript\n// Pseudo-code sketch for SyncWorker\nasync function processBatch(batch) {\n  // apply local changes, fetch remote deltas, merge conflicts\n}\n```\n\n## Follow-up Questions\n\n- How would you handle large binary media in offline cache?\n- How would you test race conditions across devices?","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Hugging Face","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T20:33:19.081Z","createdAt":"2026-01-12T20:33:19.081Z"},{"id":"q-1065","question":"You're building a React Native app for live collaboration that streams up to 4 simultaneous camera feeds using WebRTC. Describe end-to-end architecture for capture, encoding, and transport, how you'd implement backpressure and frame pacing to sustain ~30fps per feed, and provide a small implementation sketch (camera hook + simple backpressure queue) in code?","answer":"Use four RN camera streams via WebRTC with separate RTCPeerConnections and tracks. Capture frames with VisionCamera, encode in a native module using hardware encoders, and push to the correct WebRTC t","explanation":"## Why This Is Asked\nTests real-world RN streaming with WebRTC, multi-sensor coordination, and performance under backpressure.\n\n## Key Concepts\n- WebRTC integration in React Native\n- Camera capture pipelines and encoders\n- Backpressure, frame pacing, queue management\n- Resource constraints on mobile devices and cross-platform differences\n\n## Code Example\n```javascript\nfunction createBackpressureQueue(limit){\n  const q = [];\n  return {\n    enqueue(f){ if (q.length < limit){ q.push(f); return true } return false; },\n    dequeue(){ return q.shift(); },\n    size(){ return q.length; }\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test backpressure behavior under network jitter?\n- What are the trade-offs between software vs. native encoding paths in RN?","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Google","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T21:24:56.893Z","createdAt":"2026-01-12T21:24:56.893Z"},{"id":"q-1098","question":"You're building a React Native app for field technicians that must collect GPS and sensor data in the background every 15 minutes, even when the app is suspended. Describe a cross‑platform architecture using Android WorkManager and iOS BGTaskScheduler, a minimal RN bridge, and a small code sketch of a BackgroundTaskManager that schedules tasks, persists deadlines, and handles results. Include edge cases like battery saver, app termination, and user-initiated cancel?","answer":"Adopt a cross‑platform BackgroundTaskManager bridged to native: Android WorkManager (PeriodicWorkRequest, 15m, network/battery constraints) and iOS BGTaskScheduler (BGAppRefreshTask with earliestBegin","explanation":"## Why This Is Asked\nTests cross‑platform background execution, RN bridge design, and resilience under OS quotas.\n\n## Key Concepts\n- RN bridge to native modules (TurboModules/JSI)\n- Android WorkManager and iOS BGTaskScheduler\n- Headless JS tasks and data persistence\n- Backoff/retry, quotas, cancellation\n\n## Code Example\n```javascript\nclass BackgroundTaskManager {\n  static register() { /* native register */ }\n  static schedule() { /* schedule task via bridge */ }\n  static cancel() { /* cancel */ }\n}\nexport default BackgroundTaskManager;\n```\n\n## Follow-up Questions\n- How would you test for battery-saver constraints and app-termination scenarios?","diagram":"flowchart TD\nA[RN App] --> B[BackgroundTaskManager]\nB --> C[Android: WorkManager]\nB --> D[iOS: BGTaskScheduler]\nC --> E[Headless JS Task]\nD --> E\nE --> F[Local Persist]\nF --> G[Backoff/Retry]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T22:29:56.902Z","createdAt":"2026-01-12T22:29:56.902Z"},{"id":"q-1265","question":"You're building a real-time collaborative whiteboard in React Native that must support up to 1,000 participants with low latency and offline fallback. Describe an end-to-end architecture using WebRTC data channels for deltas, WebSocket signaling, and a CRDT for merging concurrent strokes. Include data model (stroke encoding, timestamps), backpressure handling, and a small code sketch implementing a delta encoder and an in-app delta queue that feeds an RN Canvas/Skia surface, with clear acceptance criteria?","answer":"Approach: peer-to-peer deltas via WebRTC data channels, signaling via WebSocket. Encode each stroke as compact deltas (move coordinate, pressure, color, width) with varint. Use a CRDT like RGA for ord","explanation":"## Why This Is Asked\n\nTests real-time collaboration design, data encoding efficiency, and RN-CRDT integration.\n\n## Key Concepts\n\n- WebRTC data channels for low-latency deltas\n- WebSocket signaling and fallback\n- CRDTs vs OT for merges\n- Delta encoding and backpressure\n- Fluid rendering on RN Canvas/Skia\n\n## Code Example\n\n```javascript\nfunction encodeStroke(stroke){\n  // delta-encode a stroke segment\n  // return compact object\n}\nfunction applyDelta(state, delta){\n  // patch canvas state with delta\n}\n```\n\n## Follow-up Questions\n\n- How would you scale the signaling and data channels to 1,000 participants?\n- How would you ensure idempotence and replay on reconnect?","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T07:32:10.415Z","createdAt":"2026-01-13T07:32:10.415Z"},{"id":"q-1537","question":"You're building a React Native app for field engineers in regulated environments. It collects GPS and accelerometer telemetry, signs each record with a device key, and batches uploads to a backend with offline-first guarantees and tamper-evident auditing. Describe the architecture, data flow, and provide a small code sketch: a LocalAuditLog module backed by SQLite and TweetNaCl for Ed25519 signing, plus a transport adapter with exponential backoff and key-rotation handling. Include edge cases around tenant isolation, data retention, and replay protection?","answer":"Use a LocalAuditLog backed by SQLite to store signed records. Sign each entry with Ed25519 (TweetNaCl) using a per-tenant device key, include a timestamp and previous hash for chaining. Batch 50–100 r","explanation":"## Why This Is Asked\nThis probes end-to-end data integrity in offline-first mobile apps, with regulatory considerations and tenant isolation.\n\n## Key Concepts\n- Local SQLite storage for durable offline data\n- Ed25519 signing (TweetNaCl) for tamper-evident logs\n- Batch transmission with exponential backoff and idempotent retries\n- Tenant isolation and per-tenant key rotation\n- Replay protection via nonces and chained hashes\n- Data-retention and auditability guarantees\n\n## Code Example\n```javascript\n// LocalAuditLog.ts (sketch)\nimport { open } from 'sqlite';\nimport sqlite3 from 'sqlite3';\nimport nacl from 'tweetnacl';\nimport naclUtil from 'tweetnacl-util';\n\ntype AuditRecord = {\n  id: string;\n  tenantId: string;\n  timestamp: number;\n  nonce: string;\n  payload: string;\n  hash?: string;\n  signature?: string;\n};\n\nexport class LocalAuditLog {\n  private db: any;\n  private keyPair: { publicKey: string; secretKey: string };\n\n  private constructor(db: any, keyPair: { publicKey: string; secretKey: string }) {\n    this.db = db; this.keyPair = keyPair;\n  }\n\n  static async create(dbPath: string): Promise<LocalAuditLog> {\n    const db = await open({ filename: dbPath, driver: sqlite3.Database });\n    await db.exec(`CREATE TABLE IF NOT EXISTS audits (\n      id TEXT PRIMARY KEY, tenantId TEXT, timestamp INTEGER, nonce TEXT,\n      payload TEXT, hash TEXT, signature TEXT, sent INTEGER DEFAULT 0\n    )`);\n    // placeholder keypair; in practice load from secure storage and rotate as needed\n    const keyPair = nacl.sign.keyPair();\n    return new LocalAuditLog(db, {\n      publicKey: naclUtil.encodeBase64(keyPair.publicKey),\n      secretKey: naclUtil.encodeBase64(keyPair.secretKey)\n    });\n  }\n\n  async append(tenantId: string, payload: string, nonce: string): Promise<void> {\n    const record: AuditRecord = {\n      id: crypto.randomUUID(), tenantId, timestamp: Date.now(), nonce, payload\n    };\n    const data = `${record.tenantId}|${record.timestamp}|${record.nonce}|${record.payload}`;\n    const sig = nacl.sign.detached(naclUtil.decodeBase64(this.keyPair.secretKey), naclUtil.decodeUTF8(data));\n    record.hash = this.hashRecord(record);\n    record.signature = naclUtil.encodeBase64(sig);\n    await this.db.run(`INSERT INTO audits (id, tenantId, timestamp, nonce, payload, hash, signature) VALUES (?, ?, ?, ?, ?, ?, ?)`,\n      record.id, record.tenantId, record.timestamp, record.nonce, record.payload, record.hash, record.signature);\n  }\n\n  async getBatch(limit: number): Promise<AuditRecord[]> {\n    const rows = await this.db.all(`SELECT * FROM audits WHERE sent = 0 ORDER BY timestamp ASC LIMIT ?`, limit);\n    return rows as AuditRecord[];\n  }\n\n  async markSent(ids: string[]): Promise<void> {\n    const placeholders = ids.map(() => '?').join(',');\n    await this.db.run(`UPDATE audits SET sent = 1 WHERE id IN (${placeholders})`, ids);\n  }\n\n  private hashRecord(r: AuditRecord): string {\n    return naclUtil.crypto_hash(`${r.tenantId}|${r.timestamp}|${r.nonce}|${r.payload}`);\n  }\n}\n```\n\n## Follow-up Questions\n- How would you securely store and rotate keys on device across app updates?\n- How would you migrate existing records during a key rotation without data loss?\n- How would you verify server integrity and prevent replay attacks in case of network replayed requests?","diagram":"flowchart TD\n  A[Mobile App] --> B[LocalAuditLog (SQLite)]\n  B --> C[Signer (TweetNaCl Ed25519)]\n  C --> D[Batcher]\n  D --> E[Transport with Retry]\n  E --> F[Backend]","difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Goldman Sachs","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T20:53:27.037Z","createdAt":"2026-01-13T20:53:27.038Z"},{"id":"q-1790","question":"You're building a cross-platform React Native app for field technicians that must display a map with thousands of POIs, support offline caching of tiles and markers, and perform incremental sync of POI updates when online. Design a data layer and UI flow to support offline-first maps, marker clustering, and conflict resolution. Provide a small code sketch for a WatermelonDB/Realm model and a MarkerLayer component, plus test ideas?","answer":"Adopt an offline-first data layer (WatermelonDB or Realm) for POIs and a disk tile cache. Implement incremental sync: push local POI deltas, pull server updates, and resolve conflicts using server-tim","explanation":"## Why This Is Asked\n\nEvaluates ability to design an offline-first map data model, incremental sync, and scalable UI rendering with clustering in a real RN app.\n\n## Key Concepts\n\n- Offline-first data model using WatermelonDB or Realm\n- Disk tile cache for maps\n- Incremental sync with delta PUSH and server updates\n- Conflict resolution via server-timestamp precedence or last-writer-wins with logs\n- Marker clustering with geohash or grid\n- Testing: offline edits, conflict scenarios, clustering accuracy, cache eviction\n\n## Code Example\n\n```javascript\n// WatermelonDB POI schema sketch\nconst poisSchema = tableSchema({\n  name: 'pois',\n  columns: [\n    { name: 'name', type: 'string' },\n    { name: 'lat', type: 'number' },\n    { name: 'lon', type: 'number' },\n    { name: 'last_modified', type: 'number' },\n  ],\n});\n\n// MarkerLayer sketch (conceptual)\nfunction MarkerLayer({ pois }) {\n  const clusters = clusterPoints(pois, 60); // 60px radius\n  return clusters.map((c) => (\n    <Marker key={c.id} coordinate={c.center} onPress={() => openPOI(c.pois[0].id)}>\n      <Callout>{c.count} POIs</Callout>\n    </Marker>\n  ));\n}\n```\n\n## Follow-up Questions\n\n- How would you test sync conflict resolution in a CI pipeline?\n- What metrics would you monitor to detect tile cache memory pressure?\n- How would you handle real-time map tile updates in online mode without blocking UI?","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Meta","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T10:51:03.589Z","createdAt":"2026-01-14T10:51:03.589Z"},{"id":"q-2072","question":"You’re building a beginner-friendly React Native gallery that shows a 2x2 grid of images loaded from a remote JSON endpoint. Describe how you would implement offline-first caching with AsyncStorage, automatic data refresh on reconnect, and a small hook sketch to fetch and cache the image list (including error handling and a simple retry strategy)?","answer":"Use a hook useImageList that first loads cached results from AsyncStorage, falling back to fetch on miss or stale timestamp; on success, cache data with timestamp. Subscribe to NetInfo to refresh when","explanation":"## Why This Is Asked\nTests ability to design a resilient, beginner-friendly offline-first feature using core RN APIs, with practicalCaching and reconnect handling.\n\n## Key Concepts\n- AsyncStorage for caching\n- NetInfo for connectivity events\n- FlatList with numColumns=2 for a grid\n- Simple retry/backoff and error handling\n- Stale data strategy (timestamp checks)\n\n## Code Example\n```javascript\nimport {useEffect, useState, useCallback} from 'react';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport NetInfo from '@react-native-community/netinfo';\n\nexport function useImageList(endpoint) {\n  const [images, setImages] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  const load = useCallback(async (force = false) => {\n    if (!force) {\n      const cached = await AsyncStorage.getItem('images_cache');\n      if (cached) {\n        setImages(JSON.parse(cached));\n        setLoading(false);\n        return;\n      }\n    }\n    try {\n      const res = await fetch(endpoint);\n      const data = await res.json();\n      setImages(data);\n      await AsyncStorage.setItem('images_cache', JSON.stringify(data));\n      await AsyncStorage.setItem('images_cache_ts', Date.now().toString());\n      setError(null);\n    } catch (e) {\n      setError(e);\n    } finally {\n      setLoading(false);\n    }\n  }, [endpoint]);\n\n  useEffect(() => {\n    load();\n    const unsubscribe = NetInfo.addEventListener(state => {\n      if (state.isConnected) load(true);\n    });\n    return () => unsubscribe();\n  }, [load]);\n\n  return { images, loading, error, retry: () => load(true) };\n}\n```\n\n## Follow-up Questions\n- How would you test the offline cache invalidation strategy?\n- How would you adapt this for paginated loading with large datasets?","diagram":"flowchart TD\n  A[Open Gallery] --> B{Cached data?}\n  B -- Yes --> C[Show cached]\n  B -- No --> D[Fetch JSON]\n  D --> E[Cache results]\n  E --> C","difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T23:25:37.824Z","createdAt":"2026-01-14T23:25:37.824Z"},{"id":"q-2292","question":"In a React Native app for real-time dashboards, you must render up to 16 live charts and 8 image tiles refreshed via WebSocket without UI jank. How would you implement a cross-platform image tile pipeline using TurboModules (JSI) that decodes, caches, and delivers tiles on a background thread, while using a virtualization list to keep 60fps? Include a concise native interface sketch and a JS wrapper?","answer":"Use a TurboModule with a native tile decoder running on a dedicated worker thread; expose decodeTile and evictOldTiles. Implement a bounded LRU cache in JS and feed imgs to a FlatList. Backpressure vi","explanation":"## Why This Is Asked\nTests understanding of cross-platform RN bridges, background work, and memory-aware UI performance for dashboards.\n\n## Key Concepts\n- TurboModules/JSI bridging\n- background decoding threads\n- LRU caching and eviction\n- list virtualization for 60fps\n- memory pressure handling and backpressure\n\n## Code Example\n\n```javascript\n// Native module interface (TS-like)\nexport interface TileDecoderModule {\n  decodeTile(tileId: string, data: Uint8Array): Promise<ImageSource>;\n  evictOldTiles(limit: number): void;\n}\n```\n\n```javascript\n// JS wrapper sketch\ntype TileInfo = { id: string; bytes: Uint8Array; };\nclass TileDecoder {\n  private mod = (require('react-native')).NativeTileDecoder as TileDecoderModule;\n  async ensureTile(info: TileInfo) { return this.mod.decodeTile(info.id, info.bytes); }\n}\n```\n\n## Follow-up Questions\n- How would you test backpressure handling and eviction strategies?\n- How would you measure decode latency and frame drop under memory pressure?","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Databricks"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T10:51:59.033Z","createdAt":"2026-01-15T10:51:59.033Z"},{"id":"q-2436","question":"In a DoorDash-style React Native app with intermittent connectivity, how would you implement offline-first order placement using an AsyncStorage-backed Outbox queue, a background worker that processes queued actions when online, and idempotent retry semantics? Provide a minimal enqueueOrder and processQueue sketch?","answer":"Use an AsyncStorage-backed Outbox with fields like id, type, payload, retryCount, and status. On placeOrder, enqueue. A background worker runs when online (via NetInfo), iterates pending items, calls ","explanation":"## Why This Is Asked\n\nAssess offline-first data integrity, background processing, and idempotent retries in a real-world order flow.\n\n## Key Concepts\n\n- Outbox pattern\n- AsyncStorage persistence\n- Background processing lifecycle\n- Idempotency and exponential backoff\n- Conflict resolution\n\n## Code Example\n\n```javascript\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\n// enqueue an order for later processing\nasync function enqueueOrder(order) {\n  const item = { id: order.id, type: 'order', payload: order, retryCount: 0, status: 'pending' };\n  const qRaw = await AsyncStorage.getItem('orderOutbox');\n  const queue = qRaw ? JSON.parse(qRaw) : [];\n  queue.push(item);\n  await AsyncStorage.setItem('orderOutbox', JSON.stringify(queue));\n}\n\n// process queue\nasync function processQueue() {\n  const qRaw = await AsyncStorage.getItem('orderOutbox');\n  const queue = qRaw ? JSON.parse(qRaw) : [];\n  for (const it of queue.filter(i => i.status === 'pending')) {\n    try {\n      await api.placeOrder(it.payload, { idempotencyKey: it.id });\n      it.status = 'completed';\n    } catch (e) {\n      it.retryCount = (it.retryCount || 0) + 1;\n      // optional: computeBackoff(it.retryCount)\n    }\n  }\n  await AsyncStorage.setItem('orderOutbox', JSON.stringify(queue));\n}\n``` \n\n## Follow-up Questions\n\n- How would you test offline recovery and ensure no duplicate orders occur?\n- How would you integrate with a true background task runner to survive app suspends?\n","diagram":"flowchart TD\n  Offline(Offline/No Network) --> Queue[Outbox Queue]\n  Queue -->|Process| Server[Server API]\n  Server -->|Success| Remove[Remove from Queue]\n  Server -->|Failure| Backoff[Backoff & Retry]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T17:53:56.829Z","createdAt":"2026-01-15T17:53:56.829Z"},{"id":"q-2459","question":"You're building a cross-platform React Native app that requires a native module 'TileCache' to prefetch and cache map tiles for offline use. Outline the architecture, how the JavaScript bridge would interact with the iOS and Android implementations, memory management and eviction strategy, and a minimal code sketch showing the JS API and a native bridge interface to fetch a tile by z/x/y within a viewport. Include testing considerations?","answer":"TileCache is a TurboModule exposing preloadTiles(bounds, zoom), getTile(x,y,z), and clearCache. iOS (Swift) and Android (Kotlin) back the cache with a disk LRU, synchronized with a background task que","explanation":"## Why This Is Asked\n\nInterfacing JS with native modules across platforms is error-prone; this tests depth in native modules, memory, and caching.\n\n## Key Concepts\n\n- React Native bridges (JSI/TurboModules)\n- Cross-platform native modules (iOS/Android)\n- Disk + in-memory LRU cache and eviction\n- Background work and synchronization\n- Robust testing: misses, eviction, corruption, offline paths\n\n## Code Example\n\n```javascript\nexport type TileKey = { x: number; y: number; z: number; viewportId?: string };\nexport interface TileCacheApi {\n  preloadTiles(bounds: { ne: { lat: number; lng: number }; sw: { lat: number; lng: number } }, zoom: number): void;\n  getTile(x: number, y: number, z: number): Promise<string | null>;\n  clearCache(): void;\n}\n```\n\n## Follow-up Questions\n\n- How would you expose progress events and error codes to JS?\n- How would you test cache eviction under rapid viewport changes?\n","diagram":"flowchart TD\n  A[React Native JS] --> B[TileCache TurboModule]\n  B --> C[iOS Swift Native]\n  B --> D[Android Kotlin Native]\n  C --> E[Disk Cache]\n  D --> E\n  A --> F[App UI uses getTile()]\n","difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","IBM","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T19:01:04.355Z","createdAt":"2026-01-15T19:01:04.355Z"},{"id":"q-2501","question":"You're building a beginner-friendly React Native field-data app for solar installations that allows technicians to submit a checklist and attach photos while offline. Describe an offline-first submission queue design: data model, how to store locally, how to detect connectivity, batching strategy, and a small hook sketch that enqueues items with a retry/backoff policy using AsyncStorage. Include a minimal example snippet for the hook?","answer":"Store a local offline queue in AsyncStorage as JSON: {id, payload, timestamp, retries}. On submit, push to queue and mark pending. Use NetInfo to detect online; when online, batch up to 10 items and P","explanation":"## Why This Is Asked\n\nTests offline-first data capture patterns, local persistence, network awareness, and retry/backoff in a React Native context.\n\n## Key Concepts\n\n- AsyncStorage for persistent queue\n- NetInfo to detect connectivity\n- Batch submission and idempotency\n- Exponential backoff with max cap\n- Test strategies for offline scenarios\n\n## Code Example\n\n```javascript\nimport { useEffect, useState } from 'react';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport NetInfo from '@react-native-community/netinfo';\n\nexport const useOfflineQueue = (storageKey = 'offline_submissions') => {\n  const [queue, setQueue] = useState([]);\n  useEffect(() => {\n    (async () => {\n      const raw = await AsyncStorage.getItem(storageKey);\n      setQueue(raw ? JSON.parse(raw) : []);\n    })();\n  }, [storageKey]);\n\n  const enqueue = async (payload) => {\n    const item = { id: `${Date.now()}-${Math.random()}`, payload, timestamp: Date.now(), retries: 0 };\n    const next = [...queue, item];\n    setQueue(next);\n    await AsyncStorage.setItem(storageKey, JSON.stringify(next));\n  };\n\n  const flush = async () => {\n    if (!queue.length) return;\n    const toSend = queue.map(i => i.payload);\n    try {\n      const res = await fetch('https://example.com/api/submissions', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(toSend),\n      });\n      if (res.ok) {\n        await AsyncStorage.setItem(storageKey, JSON.stringify([]));\n        setQueue([]);\n      } else {\n        throw new Error('server-error');\n      }\n    } catch (e) {\n      const advanced = queue.map(i => ({ ...i, retries: i.retries + 1 }));\n      setQueue(advanced);\n      await AsyncStorage.setItem(storageKey, JSON.stringify(advanced));\n    }\n  };\n\n  return { queue, enqueue, flush };\n};\n```\n\n## Follow-up Questions\n\n- How would you test offline queue behavior on a real device? \n- How would you adapt the approach for large payloads or binary attachments (photos)?","diagram":null,"difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T20:43:56.876Z","createdAt":"2026-01-15T20:43:56.876Z"},{"id":"q-2615","question":"You're building a field-service React Native app that must perform a background data refresh every 15 minutes to fetch location-tagged asset metadata, even when the app is terminated on both Android and iOS. Design a cross-platform background task broker using Android WorkManager and iOS BGTaskScheduler. Specify data models, scheduling constraints (network/battery), how to handle token refresh, and provide a minimal React hook sketch (useBackgroundSync) to start/stop the background work and expose status?","answer":"Design a cross-platform background broker with Android WorkManager using PeriodicWorkRequest configured for 15-minute intervals, network connectivity, and battery optimization constraints, and iOS BGTaskScheduler using BGProcessingTask with earliestBeginDate, network connectivity, and external power requirements. Implement secure token refresh with persistent storage, handle app termination scenarios, and provide React Native bridge integration for real-time status updates.","explanation":"## Why This Is Asked\nTests ability to design cross-platform background work with proper lifecycle handling, constraint management, and security considerations for field-service applications requiring continuous data synchronization.\n\n## Key Concepts\n- Cross-platform native module development bridging React Native to Android and iOS\n- WorkManager vs BGTaskScheduler architecture, constraint-based scheduling, and termination handling\n- Secure persistent storage for authentication tokens and pending operations\n- Token refresh flow management and error recovery mechanisms\n- React hook patterns for background task lifecycle management","diagram":"flowchart TD\n  A[User action] --> B[Schedule task via NativeBridge]\n  B --> C[Android WorkManager / iOS BGTaskScheduler]\n  C --> D[Fetch data]\n  D --> E[Store results locally and sync to server]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Microsoft","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T05:00:33.061Z","createdAt":"2026-01-16T02:44:48.041Z"},{"id":"q-2631","question":"You're building a React Native field map app that shows a live route panel with up to 500 waypoints delivered over a WebSocket. Design a component architecture that minimizes re-renders, handles backpressure when bursts occur, and keeps the map smooth at 60fps. Provide a concise implementation sketch for a useLiveWaypoints hook (buffering and a render queue) and a minimal native bridge sketch if needed. What tests would you add to verify performance and correctness?","answer":"Adopt a data path that decouples ingestion from rendering: a ring buffer accepts WebSocket messages, a RAF-tied render queue drains a fixed batch per frame, and a memoized selector updates a capped po","explanation":"## Why This Is Asked\nTests practical RN performance patterns: streaming data, backpressure, and rendering at 60fps. The candidate must show how to separate data ingestion from rendering and explain trade-offs.\n\n## Key Concepts\n- WebSocket streaming and buffering\n- Render queue driven by requestAnimationFrame\n- Immutable data updates and memoization\n- Map overlay with a capped, debounced point set\n- Memory profiling and cross-device testing\n\n## Code Example\n```javascript\nimport { useEffect, useRef, useState } from 'react';\n\nexport function useLiveWaypoints(wsUrl) {\n  const [points, setPoints] = useState([]);\n  const buffer = useRef([]);\n  const raf = useRef<number | null>(null);\n\n  useEffect(() => {\n    const ws = new WebSocket(wsUrl);\n    ws.onmessage = (ev) => {\n      const p = JSON.parse(ev.data); // {lat, lng, ts, id}\n      buffer.current.push(p);\n    };\n    return () => ws.close();\n  }, [wsUrl]);\n\n  useEffect(() => {\n    const loop = () => {\n      const b = buffer.current;\n      if (b.length) {\n        const batchSize = Math.min(b.length, 30);\n        const batch = b.splice(0, batchSize);\n        setPoints((prev) => {\n          const merged = prev.concat(batch);\n          return merged.slice(-500);\n        });\n      }\n      raf.current = requestAnimationFrame(loop);\n    };\n    raf.current = requestAnimationFrame(loop);\n    return () => {\n      if (raf.current) cancelAnimationFrame(raf.current);\n    };\n  }, []);\n\n  return points;\n}\n```\n\n## Follow-up Questions\n- How would you test backpressure behavior under bursty data?\n- How would you adapt this for offline caching and replay after reconnect?","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Instacart","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T04:14:40.962Z","createdAt":"2026-01-16T04:14:40.962Z"},{"id":"q-2841","question":"You're building a React Native feed that displays images from a CDN with three size variants (thumb, medium, large). Implement an adaptive image loader that selects the best variant based current network speed, device pixel density, and battery saver mode, with graceful fallbacks on flaky networks. Describe data models, caching (SQLite/Realm) strategy, and provide a minimal hook useAdaptiveImage that returns {uri, loading, error} and triggers prefetches. Provide a small code sketch?","answer":"Use NetInfo to estimate bandwidth and battery mode, and PixelRatio to pick a variant (thumb/medium/large). Prefetch non-selected variants and cache the chosen URI with TTL in Realm/SQLite. The hook us","explanation":"## Why This Is Asked\nTests ability to design a responsive image loading strategy that balances UX and data usage, incorporating network state, device capabilities, and offline caching in React Native.\n\n## Key Concepts\n- Variant selection logic using NetInfo, PixelRatio, and battery saver state\n- Local caching strategy (Realm/SQLite) with TTL and cache busting\n- Image loading lifecycle and prefetching to minimize jank\n\n## Code Example\n```javascript\nimport { useEffect, useState, useCallback } from 'react'\nimport NetInfo from '@react-native-community/netinfo'\nimport { PixelRatio } from 'react-native'\n\nfunction useAdaptiveImage(sizes, baseUri) {\n  const [uri, setUri] = useState(sizes.medium)\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState(null)\n\n  const resolveVariant = useCallback((info) => {\n    const bandwidth = info.type === 'wifi' ? 1000 : info.details?.speed ?? 500\n    const dpr = PixelRatio.get()\n    const batterySaver = info.batterySaverEnabled\n    let chosen = sizes.medium\n    if (!batterySaver && bandwidth > 800 && dpr >= 2) chosen = sizes.large\n    else if (bandwidth < 400) chosen = sizes.thumb\n    return chosen\n  }, [sizes])\n\n  useEffect(() => {\n    let mounted = true\n    NetInfo.fetch().then(info => {\n      if (!mounted) return\n      const variant = resolveVariant(info)\n      setUri(variant)\n      // pretend fetch/cache logic here\n      setLoading(false)\n    }).catch(err => {\n      if (mounted) { setError(err); setLoading(false) }\n    })\n    return () => { mounted = false }\n  }, [resolveVariant])\n\n  const refresh = useCallback(() => {\n    setLoading(true)\n    NetInfo.fetch().then(info => {\n      const variant = resolveVariant(info)\n      setUri(variant)\n      setLoading(false)\n    }).catch(err => setError(err))\n  }, [resolveVariant])\n\n  return { uri, loading, error, refresh }\n}\n```\n\n## Follow-up Questions\n- How would you validate cache invalidation and handle remote URL changes?\n- How would you test behavior under intermittent connectivity and battery saver toggling?","diagram":"flowchart TD\n  NetState[Network State] --> Variant[Variant Selection]\n  Variant --> Cache[Cache Store (Realm/SQLite)]\n  NetState --> Prefetch[Prefetch Other Variants]\n  DPRBattery[DPR & Battery] --> Variant","difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T14:35:34.825Z","createdAt":"2026-01-16T14:35:34.825Z"},{"id":"q-2883","question":"You're building an offline-first React Native field-inspection app where technicians submit checklists with photos while offline. Describe end-to-end sync: data model (Checklists, Items, Attachments, Revisions), local storage choice (Realm vs SQLite), sync engine (queueing, retry/backoff, push vs pull), and conflict resolution strategy (vector clocks vs server revisions or CRDT). Include a small hook sketch that enqueues updates with backoff using a background task?","answer":"Use Realm for offline data graph (Checklist, Items, Attachments) with a per-record revision. Local SyncQueue holds pending mutations. Detect connectivity via NetInfo; a background worker batches and a","explanation":"## Why This Is Asked\nThis question probes practical offline-sync engineering, conflict handling at scale, and RN background work.\n\n## Key Concepts\n- Offline-first data modeling and synchronization\n- Conflict resolution strategies (vector clocks, last-writer-wins, CRDTs)\n- Background tasks in React Native and storage choices\n\n## Code Example\n```javascript\n// Hook sketch: enqueue mutations for sync\nimport { useCallback } from 'react'\nconst useEnqueueMutation = (store) => {\n  return useCallback((mut) => {\n    // push to SyncQueue in Realm/SQLite\n  }, [store])\n}\n```\n\n## Follow-up Questions\n- How would you test conflict scenarios across devices?\n- How would you ensure media uploads (photos) are reliably retried?\n","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","MongoDB","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T15:53:57.439Z","createdAt":"2026-01-16T15:53:57.439Z"},{"id":"q-2964","question":"You're building a React Native app for field technicians that must upload short audio notes recorded in-app while the app is in the background on both Android and iOS. The design should ensure battery and network constraints are respected, handle token refresh, and tolerate app termination. Design a cross-platform background upload pipeline: Android (WorkManager/ForegroundService) and iOS (BGProcessingTask), define data models (AudioNote, UploadState), scheduling constraints, retry strategy, and provide a minimal React hook sketch (useAudioUpload) to enqueue notes, start/stop background tasks, and expose progress?","answer":"Architect a cross-platform background upload pipeline via a native module (TurboModules/JSI). Android uses a ForegroundService with WorkManager for uploads under network and battery constraints; iOS u","explanation":"## Why This Is Asked\n\nThis question tests designing robust cross‑platform background tasks with native modules and a JS bridge, including scheduling, constraints, and error handling.\n\n## Key Concepts\n\n- React Native bridging (JSI/TurboModules)\n- Android ForegroundService + WorkManager\n- iOS BGProcessingTask\n- Data models and state machines (AudioNote, UploadState)\n- Backoff strategies and token refresh\n\n## Code Example\n\n```javascript\n// Minimal hook sketch\nexport function useAudioUpload() {\n  // enqueue, start, stop, and progress subscription\n}\n```\n\n## Follow-up Questions\n\n- How would you test across lifecycle events (app kill/restart, device reboot)?\n- How would you handle offline queueing and idempotent retries?\n","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Google","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T19:27:03.829Z","createdAt":"2026-01-16T19:27:03.829Z"},{"id":"q-3096","question":"You have a React Native dashboard app that renders a FlatList of 1,000+ items with images; data arrives in bursts and causes frame drops on both iOS and Android. Design a performance strategy to keep scroll smooth: virtualization tweaks, memoization, and batched updates. Implement a minimal hook useLiveList that subscribes to a native update channel, batches updates, and flushes periodically. Provide a concise sketch of usage in a component?","answer":"To maintain smooth scrolling with 1,000+ items, leverage FlatList's virtualization features: getItemLayout for predictable heights, initialNumToRender to control initial load, maxToRenderPerBatch to limit concurrent renders, windowSize to manage offscreen items, removeClippedSubviews for Android optimization, and a stable keyExtractor for efficient re-renders. Memoize list items using React.memo and wrap render functions in useCallback to prevent unnecessary re-renders. For bursty data scenarios, implement a custom hook useLiveList that batches updates using a buffer and flushes periodically via requestAnimationFrame or setInterval. The hook subscribes to a native event emitter, accumulates updates in a ref buffer, and applies them in controlled batches to prevent frame drops.","explanation":"## Why This Is Asked\nReal-world rendering challenges with large lists and bursty updates.\n\n## Key Concepts\n- FlatList virtualization\n- Memoization and stable keys\n- Batched updates and interval flushing\n- Native event emitters and bridging\n\n## Code Example\n```javascript\nimport { useEffect, useRef, useState } from 'react';\nimport { NativeEventEmitter, NativeModules } from 'react-native';\n\nexport function useLiveList(channel) {\n  const [updates, setUpdates] = useState([]);\n  const buf = useRef([]);\n  \n  useEffect(() => {\n    const emitter = new NativeEventEmitter(NativeModules[channel]);\n    const subscription = emitter.addListener('dataUpdate', (data) => {\n      buf.current.push(data);\n    });\n    \n    const flushInterval = setInterval(() => {\n      if (buf.current.length > 0) {\n        setUpdates(prev => [...prev, ...buf.current]);\n        buf.current = [];\n      }\n    }, 16); // ~60fps\n    \n    return () => {\n      subscription.remove();\n      clearInterval(flushInterval);\n    };\n  }, [channel]);\n  \n  return updates;\n}\n\n// Usage in component\nfunction LiveDashboard() {\n  const data = useLiveList('LiveDataSource');\n  \n  const renderItem = useCallback(({ item }) => (\n    <MemoizedListItem item={item} />\n  ), []);\n  \n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem}\n      getItemLayout={(data, index) => ({ length: 80, offset: 80 * index, index })}\n      initialNumToRender={10}\n      maxToRenderPerBatch={5}\n      windowSize={10}\n      removeClippedSubviews\n      keyExtractor={(item, index) => `item-${item.id || index}`}\n    />\n  );\n}\n```","diagram":"flowchart TD\n  DataSource[Data Source] --> FlatList[FlatList]\n  FlatList --> Renderer[Item Renderer]\n  NativeUpdates[Native Updates] --> Buffer[Batcher]\n  Buffer --> FlatList","difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Salesforce","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T05:00:07.377Z","createdAt":"2026-01-17T02:18:01.243Z"},{"id":"q-3113","question":"You're building a React Native product catalog for a large retailer. The catalog has 5,000 SKUs with high-res thumbnails and stock status updates via a streaming WebSocket. Implement a concrete plan: a useLiveCatalog hook to batch updates, and a 3-column FlatList with progressive images to keep scroll smooth. Include a minimal usage sketch and trade-offs?","answer":"Use a useLiveCatalog hook that buffers WebSocket updates in 16ms frames, merges into an immutable Map SKU->item, and exposes getVisibleItems. Render a 3-column FlatList with a ProgressiveImage compone","explanation":"## Why This Is Asked\n\nTests ability to design a streaming data pipeline in RN and keep UI responsive with large catalogs.\n\n## Key Concepts\n\n- Batched, time-bounded updates from WebSocket\n- Immutable data maps for O(1) updates and predictable renders\n- Progressive image loading and memoized row renders\n- FlatList optimizations: getItemLayout, keyExtractor, numColumns\n\n## Code Example\n\n```javascript\n// Minimal sketch: useLiveCatalog hook\nimport { useEffect, useRef, useState } from 'react';\nfunction useLiveCatalog(url) {\n  const [items, setItems] = useState(new Map());\n  const batch = useRef([]);\n  useEffect(() => {\n    const ws = new WebSocket(url);\n    ws.onmessage = (ev) => {\n      batch.current.push(JSON.parse(ev.data));\n    };\n    const t = setInterval(() => {\n      if (!batch.current.length) return;\n      const next = new Map(items);\n      for (const it of batch.current) next.set(it.id, it);\n      setItems(next);\n      batch.current = [];\n    }, 16);\n    return () => clearInterval(t);\n  }, [url]);\n  return Array.from(items.values());\n}\n```\n\n## Follow-up Questions\n\n- How would you test memory footprint and frame rate on mid-range devices?\n- How would you adapt to offline rehydration after app restart?","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Instacart","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T03:59:01.090Z","createdAt":"2026-01-17T03:59:01.092Z"},{"id":"q-3520","question":"Design a cross-platform ML inference bridge for React Native that loads models from the bundle or remote storage, runs inference on a dedicated worker thread (Android: TensorFlow Lite, iOS: Core ML), enforces a memory budget, and exposes a hook useMLInference(modelName, inputs) that queues inputs with backpressure and returns predictions asynchronously. Include architecture, data flow, error handling, and a minimal hook + native module outline?","answer":"Implement a cross-platform NativeModule that loads models from bundle or remote, runs inference on a worker thread via TFLite/Core ML, enforces a memory budget, and exposes useMLInference(modelName, i","explanation":"## Why This Is Asked\nTests ability to design a scalable, cross‑platform ML bridge, handle memory budgets, dynamic model loading, and a React hook API that cleanly abstracts native work.\n\n## Key Concepts\n- React Native bridging and native modules\n- Cross‑platform ML inference (TFLite/Core ML)\n- Dynamic model loading and versioning\n- Concurrency, worker threads, and input backpressure\n- Memory budgeting and lifecycle management\n\n## Code Example\n```javascript\n// Minimal hook sketch (conceptual)\nimport { useEffect, useRef, useState } from 'react';\nimport { NativeModules } from 'react-native';\nconst { MLBridge } = NativeModules;\n\nexport function useMLInference(modelName, inputs) {\n  const [pred, setPred] = useState(null);\n  const queue = useRef([]);\n\n  useEffect(() => {\n    if (!inputs) return;\n    queue.current.push(inputs);\n    MLBridge.enqueue(modelName, inputs)\n      .then(result => setPred(result))\n      .catch(() => {});\n  }, [modelName, inputs]);\n\n  return pred;\n}\n```\n\n## Follow-up Questions\n- How would you implement model versioning and cache invalidation?\n- How would you test latency, throughput, and memory across devices?","diagram":"flowchart TD\n  JS Layer --> NativeBridge\n  NativeBridge --> WorkerThread\n  WorkerThread --> Model\n  Model --> Predictions","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Hugging Face"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T19:34:20.215Z","createdAt":"2026-01-17T19:34:20.215Z"},{"id":"q-3579","question":"You're building a React Native app used offline by technicians that stores sensitive data locally (checklists, photos). Propose a secure offline storage design that preserves data-at-rest encryption with per-user keys, biometric unlock, and key rotation. Include data model considerations, library choices (Realm vs SQLite), a key-wrapping strategy, and a minimal hook sketch for encrypting on save and decrypting on read?","answer":"Implement envelope encryption with per-record AES-256-GCM keys wrapped by user-specific master keys stored in platform-backed keystores, protected by biometric authentication for secure offline data storage.","explanation":"## Why This Is Asked\n\nThis question evaluates your understanding of secure offline persistence, key management, and platform integration within React Native applications.\n\n## Key Concepts\n\n- Client-side encryption using AES-256-GCM\n- Envelope encryption with key wrapping strategies\n- Biometric authentication via iOS Keychain and Android Keystore\n- Key rotation and data re-wrapping processes\n- Offline storage architecture: Realm vs SQLCipher trade-offs\n\n## Code Example\n\n```javascript\nimport { encrypt, decrypt } from 'crypto-lib';\n\nfunction useEncryptedStore() {\n  const saveRecord = async (record) => {\n    // Generate per-record key, wrap with master key, store encrypted fields\n  };\n  const loadRecord = async (id) => {\n    // Decrypt wrapped key, decrypt and return record\n  };\n  \n  return { saveRecord, loadRecord };\n}\n```","diagram":"flowchart TD\n  A[User Data] --> B[Encryption Layer]\n  B --> C[Encrypted Store]\n  C --> D[Biometric Unlock]\n  D --> E[Decrypt on Read]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T05:36:43.495Z","createdAt":"2026-01-17T22:30:23.810Z"},{"id":"q-3620","question":"You're building a field-work React Native app that must remind technicians of their daily checklist. Design a cross-platform local notification flow: request permission, schedule a daily reminder at a configurable time, handle foreground/background taps, and provide a small hook useDailyReminder(hour, minute, message) to schedule and cancel reminders. Include edge cases like time zone changes and app restarts?","answer":"I would implement a cross-platform hook that requests notification permissions on initialization, uses native modules to schedule a daily UNNotificationRequest on iOS and a NotificationCompat channel on Android, persists reminder configuration in AsyncStorage for app restart durability, handles time zone changes by rescheduling when the device's time zone shifts, and provides a clean useDailyReminder(hour, minute, message) interface with methods to schedule and cancel reminders.","explanation":"## Why This Is Asked\n\nThis question tests knowledge of cross-platform local notifications, permission handling, and lifecycle management in React Native, along with the ability to create a clean, reusable hook interface.\n\n## Key Concepts\n- Cross-platform local notifications (iOS/Android)\n- Permission flow and user prompts\n- Scheduling recurring notifications at specific times\n- Foreground, background, and notification tap handling\n- State persistence and idempotent rescheduling (time zones, app restarts)\n\n## Code Example\n```javascript\n// useDailyReminder hook sketch\nimport { useEffect } from 'react'\nimport { Platform } from 'react-na","diagram":"flowchart TD\n  A[User configures reminder] --> B[Request permissions]\n  B --> C{Permission granted?}\n  C -->|Yes| D[Schedule daily notification]\n  C -->|No| E[Abort with fallback]\n  D --> F[Handle foreground]\n  D --> G[Handle background]\n  F & G --> H[On notification opened -> navigate to Tasks]\n  H --> I[App continues]\n","difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Meta","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T05:14:01.554Z","createdAt":"2026-01-17T23:42:07.492Z"},{"id":"q-3746","question":"You're shipping a React Native app that streams live location updates for 1,000 devices on a map. How would you design a scalable data pipeline and UI to render pins with 60fps panning, prioritizing tiles in the visible region, using a native spatial index (R-tree) and a JS dataflow with observable streams? Include batching, backpressure, and a hook sketch to enqueue updates?","answer":"Use a native spatial index (R-tree) to bucket 1k devices by lat/lon and expose updates through a TurboModule. On JS, implement a backpressure-enabled queue that batches updates by map tiles and thrott","explanation":"## Why This Is Asked\nTests ability to design cross‑platform, high‑throughput UI with native modules and JS streams. Evaluates decisions around spatial indexing, dataflow, backpressure, and region‑aware rendering.\n\n## Key Concepts\n- React Native bridging (TurboModules/JSI)\n- Native spatial indexing (R-tree)\n- Backpressure and batching patterns\n- Region-based rendering and virtualization\n- Production performance profiling for 1k pins at 60fps\n\n## Code Example\n```javascript\n// Hook sketch\nfunction useRegionUpdates(mapRef, { throttleMs = 100, tileSize = 256 } = {}) {\n  const [updates, setUpdates] = useState([]);\n  useEffect(() => {\n    const sub = regionProvider.subscribe(({ region, data }) => {\n      if (region.visible) enqueue(data);\n    });\n    return () => sub.unsubscribe();\n  }, [mapRef]);\n  function enqueue(item) {\n    // simple backpressure queue logic here\n  }\n  return updates;\n}\n```\n\n## Follow-up Questions\n- How would you test the backpressure behavior under bursty updates?\n- How would you handle device rotation and tile re-tiling to maintain stability?","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Meta","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T07:42:56.185Z","createdAt":"2026-01-18T07:42:56.185Z"},{"id":"q-3820","question":"You're building a React Native shopping app for an enterprise with 1,000+ product images per category and flaky connectivity. Design a cross-platform image prefetching system that preloads images for the currently visible category plus the next two categories, runs on app foreground and background (Android WorkManager + iOS BGTaskScheduler), uses an LRU disk cache, handles cache invalidation when images update, and provides an RN hook usePrefetchImages(categories, maxConcurrent). Provide a minimal usage sketch with FlatList integration?","answer":"Use a disk-based LRU cache (category folders + metadata.json). Expose usePrefetchImages(categories, {concurrency}) that fetches current category and next two, dedup in-flight, and saves with a version","explanation":"## Why This Is Asked\n\nThis question tests practical offline caching and cross-platform background work integration in React Native, focusing on image-heavy workloads and fluctuating network quality.\n\n## Key Concepts\n\n- Disk-based cache with metadata\n- LRU eviction and size caps\n- Background tasks (WorkManager/BGTaskScheduler)\n- Concurrency control and de-duplication\n- React Native hook integration with FlatList\n\n## Code Example\n\n```javascript\nimport { useEffect, useRef } from 'react';\n\nexport function usePrefetchImages(categories, maxConcurrent = 4) {\n  // skeleton: maintain in-flight set, queue, and cache lookup\n}\n```\n\n## Follow-up Questions\n\n- How would you test eviction and update handling?\n- How would you invalidate cached items when image versions update?\n","diagram":"flowchart TD\nA[Categories] --> B[Prefetch queue]\nB --> C{Cache hit?}\nC -->|yes| D[Serve from cache]\nC -->|no| E[Fetch & store]","difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Tesla","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T10:44:05.366Z","createdAt":"2026-01-18T10:44:05.367Z"},{"id":"q-3860","question":"Design a real-time, cross-asset heatmap dashboard in React Native that renders 1,000+ cells updating at 60fps. Data arrives via WebSocket; explain data modeling, a high-throughput renderer (Canvas or GL), and how you would offload updates to a native module/worker (JSI/TurboModule) to avoid UI thread jank. Include a hook sketch for backpressure batching?","answer":"Leverage a batched data model: a flat array of 1k cells, each with value, color, ts. WebSocket feeds deltas into a native ring buffer; a TurboModule/JSI bridge exposes a getLatestFrame() that returns ","explanation":"## Why This Is Asked\nTests ability to design a high-throughput, cross-thread data path and render path in RN.\n\n## Key Concepts\n- Real-time data pipelines; native modules; JSI/TurboModules\n- Efficient rendering of 1000+ cells; Canvas/GL\n- Backpressure, ring buffers, memory reuse\n\n## Code Example\n```javascript\nfunction useHeatmapFeed(url: string) {\n  // sketch: set up WebSocket, a bounded queue, and frame-driven drain\n}\n```\n\n## Follow-up Questions\n- How would you test the rendering path under memory pressure?\n- How would you handle dropped frames and consistency guarantees?","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Google","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T13:03:59.314Z","createdAt":"2026-01-18T13:03:59.314Z"},{"id":"q-3957","question":"You're building a React Native feed with FlatList that shows posts with images; on mid-range devices the scrolling stutters and images pop in slowly, what practical, beginner-friendly plan would you follow to diagnose and fix it, including FlatList tuning, memoization, and image loading strategies, and a tiny hook to measure frame times plus a minimal optimized item component?","answer":"Measure frame times with a small hook using a blind-spot: requestAnimationFrame to log delta times during scroll, then wrap the item component in React.memo and stabilize props. Tune FlatList: windowS","explanation":"## Why This Is Asked\n\nThis question tests practical RN debugging for smooth UIs, corner-case performance tweaks, and simple hooks. It favors candidates who ground fixes in real-world constraints rather than theory.\n\n## Key Concepts\n- FlatList virtualization and tuning (windowSize, initialNumToRender, maxToRenderPerBatch)\n- Memoization to reduce re-renders (React.memo)\n- Image loading optimizations (placeholders, progressive loading, caching)\n- Lightweight frame-time measurement for profiling\n- getItemLayout for stable item measurement\n\n## Code Example\n```javascript\nimport React from 'react';\nimport { FlatList, Image, View } from 'react-native';\n\nconst Item = React.memo(({ post }) => (\n  <View>\n    <Image source={{uri: post.image}} style={{width: 100, height: 100}} />\n  </View>\n));\n\nexport default function Feed({ data }) {\n  return (\n    <FlatList\n      data={data}\n      renderItem={({ item }) => <Item post={item} /> }\n      keyExtractor={item => item.id}\n      getItemLayout={(data, index) => ({ length: 120, offset: index * 120, index })}\n      windowSize={21}\n      initialNumToRender={10}\n      maxToRenderPerBatch={5}\n    />\n  );\n}\n```\n\n## Follow-up Questions\n- How would you test on-device performance after changes?\n- What trade-offs do you consider between memory usage and render speed?","diagram":null,"difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T17:27:04.096Z","createdAt":"2026-01-18T17:27:04.096Z"},{"id":"q-3984","question":"Design an advanced real-time data feed in a cross-platform React Native app (Meta/Microsoft level). The UI must render live stock prices for 200 symbols with updates every 50–100 ms. Explain end-to-end: native bridge architecture (TurboModule/Fabric vs legacy bridge), threading model for decoding, memory management, and how you would push updates to JS with minimal GC pressure. Include a concise outline of a hook like useLivePrices(symbols) and a small testing plan?","answer":"Proposed answer: Use a TurboModule-backed native bridge with Fabric, feed runs on a worker thread; decode frames to delta array; write to a shared ring buffer; push to JS via JSI and batch UI updates ","explanation":"## Why This Is Asked\nThis question probes cross-thread data flow, Native Modules evolution (TurboModules, Fabric), and performance at scale in RN.\n\n## Key Concepts\n- TurboModule + Fabric bridge vs legacy bridge\n- worker threads, WebSocket decoding\n- ring buffer + JSI bridge; minimal GC pressure\n- memoized React rendering with immutable price maps\n\n## Code Example\n```javascript\nfunction useLivePrices(symbols) {\n  const [prices, setPrices] = useState(new Map());\n  useEffect(() => {\n    const sub = NativeLivePrices.subscribe(symbols, (updates) => {\n      setPrices(prev => new Map([...updates]));\n    });\n    return () => sub.unsubscribe();\n  }, [symbols]);\n  return prices;\n}\n```\n\n## Follow-up Questions\n- How would you monitor ring buffer memory and overflow?\n- How handle bursty update rates and backpressure on the JS thread?","diagram":"flowchart TD\n  A[WebSocket Feed] --> B[Native Worker]\n  B --> C[Ring Buffer]\n  C --> D[JS Bridge via JSI]\n  D --> E[React Native JS]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T18:45:53.586Z","createdAt":"2026-01-18T18:45:53.587Z"},{"id":"q-4172","question":"You're building a beginner React Native app that lists articles from an API. On device rotation and relaunch, you must preserve scroll position and minimize network usage. Design a minimal offline-first cache (data + timestamp) using AsyncStorage, plus a small hook to read/write and an optimized ListItem. Explain eviction and error handling?","answer":"Cache API responses in AsyncStorage as JSON { data, ts }. On mount, load cache; if ts within 5 minutes, render cached data, else fetch. Expose a useArticlesCache hook returning articles and save funct","explanation":"## Why This Is Asked\nTests knowledge of offline-first caching, RN persistence, and simple state restoration.\n\n## Key Concepts\n- AsyncStorage\n- scroll position restoration\n- cache invalidation\n\n## Code Example\n```javascript\nimport {useEffect, useState} from 'react';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\nexport function useArticlesCache(key = 'articles') {\n  const [articles, setArticles] = useState([]);\n  async function load() {\n    const cached = await AsyncStorage.getItem(key);\n    if (cached) {\n      const {data, ts} = JSON.parse(cached);\n      if (Date.now() - ts < 5 * 60 * 1000) { setArticles(data); return; }\n    }\n  }\n  async function save(data) {\n    await AsyncStorage.setItem(key, JSON.stringify({data, ts: Date.now()}));\n    setArticles(data);\n  }\n  useEffect(() => { load(); }, []);\n  return {articles, save};\n}\n```\n\n## Follow-up Questions\n- How would you handle cache invalidation for updates?\n- How would you test the caching behavior in development?\n","diagram":"flowchart TD\n  A[Mount] --> B[Load cache]\n  B --> C{Fresh?}\n  C -- Yes --> D[Render cached]\n  C -- No --> E[Fetch API]\n  E --> F[Store in AsyncStorage]\n  F --> G[Render]\n","difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","NVIDIA","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T06:51:30.464Z","createdAt":"2026-01-19T06:51:30.466Z"},{"id":"q-4236","question":"You're building a delivery-driver app at Uber-scale or Scale AI where push notifications must reliably navigate to the correct screen even when the app is backgrounded or killed. Describe a notification router architecture that maps payloads to routes, persists last navigated state, prevents duplicate navigations, and handles data-payload vs notification-payload differences. Include a small hook sketch that debounces navigation and a minimal navigation service using react-navigation?","answer":"Design a notification router that maps payload to a deep link, persists lastRoute in AsyncStorage, and guards against duplicate navigations. Use a central NavigationService with a queue, handle foregr","explanation":"## Why This Is Asked\nThis question tests practical push handling and navigation restoration in a RN app with real user flows and edge cases.\n\n## Key Concepts\n- Push notification payload handling (FCM/APNs) and difference between data and notification payloads\n- Navigation state restoration and a central NavigationService\n- Debouncing, idempotent navigation, and duplicate avoidance\n- AsyncStorage for lastRoute and a simple queue\n- Testing strategies for foreground/background/killed states\n\n## Code Example\n```javascript\n// Minimal hook sketch\nimport { useEffect, useRef } from 'react';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport { getNavigationRef } from './NavigationService';\n\nfunction mapPayloadToRoute(p) {\n  // implement payload-to-route mapping\n  const route = p?.targetRoute;\n  return route || null;\n}\n\nexport function useNotifyNavigate() {\n  const nav = getNavigationRef();\n  const timer = useRef(null);\n\n  useEffect(() => {\n    const onNotify = (payload) => {\n      const route = mapPayloadToRoute(payload);\n      if (!route) return;\n      clearTimeout(timer.current);\n      timer.current = setTimeout(async () => {\n        const last = await AsyncStorage.getItem('lastRoute');\n        if (last === route) return;\n        await AsyncStorage.setItem('lastRoute', route);\n        nav?.navigate(route);\n      }, 150);\n    };\n    NotificationCenter.addListener('notify', onNotify);\n    return () => NotificationCenter.removeListener('notify', onNotify);\n  }, [nav]);\n}\n```\n\n## Follow-up Questions\n- How would you test race conditions between fast successive notifications?\n- How would you adapt for multi-window or deep linking across platforms?","diagram":"flowchart TD\n  N[Notification] --> R[Router]\n  R --> S[Screen]\n  S --> L[LastRoute]\n  N --foreground--> F[Navigate]\n  N --backgroundKilled--> K[Security/Queue]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Scale Ai","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T09:50:08.013Z","createdAt":"2026-01-19T09:50:08.013Z"},{"id":"q-4266","question":"You’re building a beginner-friendly React Native app that shows field markers on a map. Implement an offline-capable data layer: fetch markers from a REST endpoint, cache them locally, and render only markers in the current viewport. Include a small hook useViewportMarkers(region) that throttles network calls (1 request/sec) and merges remote updates into the local cache with a minimal UI example?","answer":"Design an offline-capable data layer for map markers in React Native: fetch markers via REST, cache them with AsyncStorage, and render only markers within the current viewport from react-native-maps R","explanation":"## Why This Is Asked\n\nTests ability to implement a realistic, offline-capable data layer for map UI, with viewport-aware rendering and incremental updates.\n\n## Key Concepts\n\n- Offline caching with AsyncStorage or MMKV\n- Viewport-filtered rendering using react-native-maps Region\n- Throttling network calls to avoid floods\n- Merging remote updates into local cache\n- Hook design pattern for region-driven data updates\n\n## Code Example\n\n```javascript\nimport { useEffect, useState, useRef } from 'react'\nimport AsyncStorage from '@react-native-async-storage/async-storage'\nimport { fetchMarkersForRegion } from './api'\n\nexport function useViewportMarkers(region) {\n  const [markers, setMarkers] = useState([])\n  const lastRegion = useRef(null)\n  useEffect(() => {\n    let mounted = true\n    const key = JSON.stringify(region)\n    if (!region) return\n    const fetchIfNeeded = async () => {\n      if (lastRegion.current === key) return\n      lastRegion.current = key\n      const data = await fetchMarkersForRegion(region)\n      if (mounted) {\n        await AsyncStorage.setItem('markers_'+key, JSON.stringify(data))\n        setMarkers(data)\n      }\n    }\n    const t = setTimeout(fetchIfNeeded, 150)\n    return () => { mounted = false; clearTimeout(t) }\n  }, [region])\n  return markers\n}\n```\n\n## Follow-up Questions\n\n- How would you add clustering for dense areas?\n- How would you test cache invalidation and data freshness in offline mode?\n","diagram":null,"difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","IBM","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T10:56:48.318Z","createdAt":"2026-01-19T10:56:48.318Z"},{"id":"q-4402","question":"You're building a beginner-friendly React Native screen that lists latest articles from a paginated API. The screen auto-refreshes every 30 seconds and supports pull-to-refresh. Ensure that in-flight fetches are canceled when a new fetch starts or the screen unmounts, using AbortController. Provide a small hook useCancelableFetch(url) and show minimal UI wiring?","answer":"Use a Cancelable fetch with AbortController; keep a ref to the latest request id; on each refresh cancel the previous request and start a new one; clear the interval on unmount; only update state if t","explanation":"## Why This Is Asked\n\nTests practical React Native fetch patterns: cancellation prevents stale data and memory leaks during auto-refresh and manual refresh. It also checks hook design and safe state updates in unmount scenarios.\n\n## Key Concepts\n\n- AbortController usage in fetch calls\n- useEffect cleanup and interval management\n- Race condition avoidance with latest-request checks\n- Small custom hook design for reusable cancellation logic\n\n## Code Example\n\n```javascript\nimport { useEffect, useRef, useState } from 'react';\n\nexport function useCancelableFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const currentReq = useRef(0);\n\n  useEffect(() => {\n    let isActive = true;\n    const ctrl = new AbortController();\n    const id = ++currentReq.current;\n    setLoading(true);\n    fetch(url, { signal: ctrl.signal })\n      .then(res => res.json())\n      .then(d => {\n        if (isActive && id === currentReq.current) {\n          setData(d);\n          setLoading(false);\n        }\n      })\n      .catch(e => {\n        if (isActive && e.name !== 'AbortError') setError(e);\n        if (isActive) setLoading(false);\n      });\n    return () => {\n      isActive = false;\n      ctrl.abort();\n    };\n  }, [url]);\n\n  return { data, loading, error };\n}\n```\n\n## Follow-up Questions\n\n- How would you test useCancelableFetch with RN Testing Library? \n- How would you extend it to support pagination without race conditions?","diagram":null,"difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Netflix","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T17:34:06.986Z","createdAt":"2026-01-19T17:34:06.986Z"},{"id":"q-4503","question":"You’re building a beginner-friendly React Native app that shows city events fetched from an API. Implement a local cache with AsyncStorage and a hook useCacheList(endpoint) that loads cached data first, then fetches fresh data, and merges by id while preserving user order. Also handle cache invalidation and duplicates. Provide a minimal hook sketch and a small component example?","answer":"Load cached events from AsyncStorage under 'events_cache', render it immediately, then fetch fresh data. Merge by id keeping the cached order, replacing with fresh items when ids match, and append any new ids. Handle cache invalidation by timestamp or manual refresh, and deduplicate by id.","explanation":"## Why This Is Asked\nTests offline caching, data merging by id, and simple hook design for React Native with AsyncStorage.\n\n## Key Concepts\n- AsyncStorage usage for simple persistence\n- useEffect/useState lifecycle and dependency on endpoint\n- Merging lists by id while preserving user-visible order\n- Exposing a small API (data, loading, error, refetch) for components\n\n## Code Example\n```javascript\nimport { useState, useEffect } from 'react';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\nexport function useCacheList(endpoint) {\n  const [data, setData] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const loadData = async () => {\n      try {\n        // Load cached data first\n        const cached = await AsyncStorage.getItem(`cache_${endpoint}`);\n        if (cached) {\n          setData(JSON.parse(cached));\n        }\n\n        // Fetch fresh data\n        const response = await fetch(endpoint);\n        const freshData = await response.json();\n\n        // Merge by id, preserving cached order\n        const merged = mergeById(data, freshData);\n        setData(merged);\n\n        // Update cache\n        await AsyncStorage.setItem(`cache_${endpoint}`, JSON.stringify(merged));\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    loadData();\n  }, [endpoint]);\n\n  return { data, loading, error, refetch: () => loadData() };\n}\n\nfunction mergeById(cached, fresh) {\n  const map = new Map();\n  \n  // Preserve cached order\n  cached.forEach(item => map.set(item.id, item));\n  \n  // Update with fresh data\n  fresh.forEach(item => {\n    if (map.has(item.id)) {\n      map.set(item.id, item);\n    } else {\n      // Append new items\n      cached.push(item);\n    }\n  });\n  \n  return Array.from(map.values());\n}\n```\n\n## Component Example\n```javascript\nfunction EventsList() {\n  const { data, loading, error } = useCacheList('/api/events');\n\n  if (loading) return <ActivityIndicator />;\n  if (error) return <Text>Error: {error.message}</Text>;\n\n  return (\n    <FlatList\n      data={data}\n      keyExtractor={item => item.id}\n      renderItem={({ item }) => <EventCard event={item} />}\n    />\n  );\n}\n```","diagram":null,"difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Meta","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T05:33:39.144Z","createdAt":"2026-01-19T21:44:43.444Z"},{"id":"q-4584","question":"You're building an Incident Feed in React Native (mobile) with paginated posts (images/videos) that must work offline. Design a data layer and a hook useInfiniteViewportFeed(region, opts) that loads the current viewport pages, prefetches ahead, caches results locally (LRU image cache + JSON store), throttles network calls, merges remote updates deterministically, and preserves scroll position when navigating away and back. Include edge cases and a minimal code sketch?","answer":"Design a local-first cache with a Post[] store and an LRU image cache. Use region-based viewport to fetch pages, throttle to 1 req/sec, and prefetch 1–2 pages ahead. Merge remote updates with per-post revision numbers and preserve scroll position using FlatList's maintainVisibleContentPosition prop.","explanation":"## Why This Is Asked\nAssesses data modeling for offline-first experiences, viewport-aware data loading, and deterministic merging of remote updates in a mobile React Native setting.\n\n## Key Concepts\n- Local-first caching (JSON store + image cache)\n- Viewport-driven prefetching and throttling\n- Conflict resolution via per-item revisions\n- Scroll position restoration across navigations\n\n## Code Example\n```javascript\n// sketch\nfunction useInfiniteViewportFeed(region, {prefetch = 2, throttleMs = 1000} = {}) {\n  // state: items, pages, loading, error\n  // logic: load current viewport pages, prefetch\n```","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T05:56:52.999Z","createdAt":"2026-01-20T02:36:05.452Z"},{"id":"q-4630","question":"You're building a React Native field-service app that supports offline work and real-time collaboration on shared checklists. Propose a CRDT-based local-first data layer (data model, conflict resolution, and offline/online sync) implemented via a Rust-native module bridged to React Native for efficient merges. Describe how you'd handle garbage collection, security, and latency, and provide a small hook useCRDTSync() sketch and a minimal UI snippet to illustrate usage; include trade-offs?","answer":"Design a delta-CRDT with a core model: Checklist {id, items[]}, Item {id, text, checked}, Comment {id, text}. Each entity carries a vector clock and tombstones. A Rust native module exposes mergeDelta","explanation":"## Why This Is Asked\nTests ability to design a robust offline-first, real-time collaboration layer with CRDTs and native module integration, including data modeling, delta handling, and performance considerations.\n\n## Key Concepts\n- Delta-state CRDTs and vector clocks\n- Tombstones and garbage collection\n- Bridge design: Rust native module exposed to React Native\n- Local storage: SQLite with delta log\n\n## Code Example\n```javascript\n// Minimal hook sketch\nfunction useCRDTSync() {\n  const [state, setState] = React.useState(null);\n  React.useEffect(() => {\n    const sub = subscribeToDeltaStream((d) => {\n      // applyDelta via NativeModules.RNCRDT.mergeDelta(d)\n    });\n    return () => sub.unsubscribe();\n  }, []);\n  const applyLocalChange = (c) => {\n    // convert to delta and send to Rust\n    NativeModules.RNCRDT.mergeDelta(c);\n  };\n  return { state, applyLocalChange, startSync: ()=>{} };\n}\n```\n\n## Follow-up Questions\n- How would you handle binary blobs (images, attachments) in the CRDT and ensure deduplication?\n- What strategies for encryption at rest and in-transit would you adopt in this pipeline?","diagram":"flowchart TD\n  A[React Native App] --> B[Rust CRDT Module]\n  B --> C[SQLite Local Store]\n  C --> D[Delta Queue]\n  D --> E[Network Sync]\n  E --> F[Remote Deltas]\n  F --> B","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Microsoft","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T05:47:50.317Z","createdAt":"2026-01-20T05:47:50.317Z"},{"id":"q-4742","question":"You're building a beginner-friendly React Native app that displays a grid of product cards. Implement a reusable Card component with accessible labels for iOS and Android, support a light/dark theme via the Appearance API, and provide a small hook useTheme() to expose the current theme. Show minimal usage and discuss accessibility considerations and trade-offs?","answer":"Create a reusable Card component as a Pressable with accessibilityLabel derived from props, accessibilityHint 'View details', and accessibilityRole 'button'. Bind colors to a theme via a useTheme() ho","explanation":"## Why This Is Asked\n\nTests practical RN skills: building reusable components, accessibility across platforms, and theming with Appearance API, plus a small hook pattern.\n\n## Key Concepts\n\n- Accessibility props (accessibilityLabel, accessibilityHint, accessibilityRole)\n- Theming with Appearance/useColorScheme and React Context\n- Custom hook useTheme and ThemeProvider\n- Performance considerations for re-renders and memoization\n\n## Code Example\n\n```javascript\nimport React, {createContext, useContext, useMemo, useState} from 'react';\nimport {Pressable, Text} from 'react-native';\n\nexport const ThemeContext = createContext('light');\nexport const useTheme = () => useContext(ThemeContext);\n\nexport function ThemeProvider({children}) {\n  // Simplified example; in real code use Appearance or useColorScheme\n  const [scheme] = useState('light');\n  const value = useMemo(() => ({scheme}), [scheme]);\n  return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>;\n}\n\nfunction Card({title, price}) {\n  const {scheme} = useTheme();\n  const bg = scheme === 'dark' ? '#222' : '#fff';\n  return (\n    <Pressable accessibilityLabel={title}\n               accessibilityHint=\"View details\"\n               accessibilityRole=\"button\"\n               style={{backgroundColor: bg}}>\n      <Text>{title}</Text>\n      <Text>{price}</Text>\n    </Pressable>\n  );\n}\n```\n\n## Follow-up Questions\n\n- How would you test accessibility coverage across iOS and Android?\n- How would you extend theming to allow user-selected custom colors without breaking contrast?","diagram":null,"difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","OpenAI","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T10:40:49.652Z","createdAt":"2026-01-20T10:40:49.652Z"},{"id":"q-475","question":"You're building a React Native app with complex animations that need to run at 60fps. The app has multiple animated components including a custom carousel, gesture-driven interactions, and background video processing. How would you optimize performance to maintain smooth animations?","answer":"Use **React Native's Reanimated 3** for UI thread animations to avoid JS bridge overhead. Implement **useAnimatedStyle** with **useDerivedValue** for efficient value sharing. Use **FlatList** instead of ScrollView for virtualized rendering, enable **removeClippedSubviews** to hide off-screen items, and provide **getItemLayout** for fixed item heights. Leverage **Gesture Handler** for native gesture recognition and **PanGesture** for smooth interactions.","explanation":"## Performance Optimization Strategy\n\n### Animation Framework\n- **Reanimated 3**: Runs animations on UI thread, prevents JS bridge blocking\n- **Shared Values**: Efficient state management across animation boundaries\n- **Worklets**: JS code executed on UI thread for smooth 60fps\n\n### List Optimization\n- **FlatList**: Virtualized rendering with memory efficiency\n- **removeClippedSubviews**: Hides off-screen items to reduce render load\n- **getItemLayout**: Provides fixed item heights for optimized scrolling\n\n### Gesture Handling\n- **Gesture Handler**: Native gesture recognition system\n- **PanGesture**: Smooth gesture-driven interactions with native performance\n\n### Background Processing\n- **Native Modules**: Offload video processing to native threads\n- **Web Workers**: Use for background computations when possible\n- **Optimized Codecs**: Choose efficient video formats and compression","diagram":"flowchart TD\n  A[User Interaction] --> B[Gesture Handler]\n  B --> C[Reanimated Worklet]\n  C --> D[UI Thread Animation]\n  D --> E[60fps Render]\n  F[FlatList] --> G[Virtualized Items]\n  G --> H[removeClippedSubviews]\n  H --> E\n  I[React.memo] --> J[Optimized Re-renders]\n  J --> E","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-10T03:28:36.246Z","createdAt":"2025-12-26 12:51:05"},{"id":"q-4831","question":"You're building a beginner-friendly React Native chat app with offline support. Outline a minimal local-first layer using SQLite to store messages, with a timestamp-based conflict resolution (latest wins) when syncing with the server. Implement a useChatSync(conversationId) hook that queues outgoing messages, retries failed sends with exponential backoff, and batches receipt/status updates. Include a small UI snippet showing sending and optimistic rendering?","answer":"Use SQLite to store messages locally with fields (id, convoId, text, sender, ts, status). On sync, resolve conflicts by taking the newer timestamp. The useChatSync(conversationId) hook maintains a que","explanation":"## Why This Is Asked\n\nTests ability to design offline-first data flow using a simple local store, conflict resolution, and a hook to manage network-retry semantics. It also touches UI implications for optimistic rendering.\n\n## Key Concepts\n\n- SQLite as local store\n- timestamp-based conflict resolution\n- message queue with exponential backoff\n- optimistic UI\n\n## Code Example\n\n```javascript\n// Minimal sketch\nexport function useChatSync(conversationId) {\n  // queue, retry, and sync logic\n}\n```\n\n## Follow-up Questions\n\n- How extend to handle deletions and edits?\n- How test offline-first reliability?\n","diagram":"flowchart TD\n  A[User sends message] --> B{Network?}\n  B -- Yes --> C[Send to server]\n  C --> D[Server ack]\n  B -- No --> E[Persist to local queue]","difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T15:12:02.678Z","createdAt":"2026-01-20T15:12:02.678Z"},{"id":"q-4850","question":"You're building a React Native app for field technicians to annotate inspection photos offline. Design an offline-first image pipeline that uses a Rust-native module bridged to React Native to downsample, watermark, and generate thumbnails. Include data model and memory constraints, incremental sync with the server, a conflict resolution strategy, and a minimal hook useImagePipeline(region) plus a small UI usage snippet. Discuss trade-offs?","answer":"Use a local SQLite cache of ImageRecord{id, path, region, metadata, status, lastModified}. Bridge a Rust image pipeline (downsample, watermark, thumbnail) via a native module; process in a bounded thr","explanation":"## Why This Is Asked\nReal-world offline media pipelines in RN require native perf paths and robust sync.\n\n## Key Concepts\n- Local cache, schema, and provenance tracking\n- Rust-native bridge, memory budgeting, and backpressure\n- Delta-sync with optimistic conflicts and resolution\n- Hooks and minimal UI to drive developer ergonomics\n\n## Code Example\n```javascript\nexport function useImagePipeline(region){\n  // skeleton hook returning thumbnails and refresh actions\n  const [thumbs, setThumbs] = useState([]);\n  useEffect(()=>{ /* subscribe to region cache */ }, [region]);\n  return {thumbs, reprocessImage: (id)=>{/* queue */}};\n}\n```\n\n## Follow-up Questions\n- How would you test memory usage on low-end devices?\n- How would you handle partial failures in the Rust bridge during processing?","diagram":"flowchart TD\n  A[Region] --> B[Cache Lookup]\n  B --> C[Rust Processing]\n  C --> D[Local Files]\n  D --> E[Delta Sync]","difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T16:16:34.927Z","createdAt":"2026-01-20T16:16:34.928Z"},{"id":"q-4892","question":"You're building a DoorDash-like app with real-time notifications. Design and implement an offline-friendly push-notification surface using a Rust-native module bridged to React Native that decodes a compact binary protocol and streams events to JS in order. Include: data model (Notification, Channel, ReadState, Expiry), bridging approach (JSI + TurboModules), guarantees (at-least-once delivery, ordering, dedup), a small hook useNotifications() and a minimal UI snippet that groups by Channel and shows unread badges; discuss trade-offs?","answer":"Implement a JSI-based Rust native module to decode a binary notification stream and expose an EventEmitter to JS. Use a per-channel sequence number with id-based dedup, and a local SQLite store for of","explanation":"## Why This Is Asked\nTests ability to design cross-platform native bridges, offline resilience, and real-time UX.\n\n## Key Concepts\n- RN native modules, JSI, TurboModules, EventEmitter\n- Binary protocol decoding, per-channel sequencing, dedup\n- Offline storage (SQLite) and backpressure\n\n## Code Example\n```javascript\n// skeleton: useNotifications hook\nexport function useNotifications() {\n  // subscribe to native events and group by channel\n}\n```\n\n## Follow-up Questions\n- How would you verify ordering guarantees under network hiccups?\n- How would you handle token rotation and secure message decryption in the Rust layer?","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Meta","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T17:50:16.360Z","createdAt":"2026-01-20T17:50:16.360Z"},{"id":"q-4985","question":"Design a peer-to-peer offline-first sync layer for a React Native ride-hailing app that uses WebRTC to exchange data when connectivity is flaky. Define data namespaces (RideRequests, DriverStatus, Messages), explain conflict resolution (vector clocks, tombstones), and security (end-to-end encryption, minimal crypto). Include a small hook useP2PQueue() and a minimal UI snippet to enqueue and view pending operations; discuss latency, privacy, and scalability trade-offs?","answer":"Use a peer-to-peer offline-first mesh with WebRTC DataChannels to sync a CRDT-based data layer across devices when connectivity is flaky. Define namespaces RideRequests, DriverStatus, and Messages; apply vector clocks for causality tracking and tombstones for deletion handling. Implement end-to-end encryption using minimal crypto (AES-256-GCM with ECDH key exchange) and provide a useP2PQueue() hook for managing pending operations with automatic retry and conflict resolution.","explanation":"## Why This Is Asked\nTests ability to design offline-first, distributed data synchronization with real-world constraints (latency, privacy, scale) in a mobile fleet context. Emphasizes secure, conflict-aware replication without centralized bottlenecks.\n\n## Key Concepts\n- WebRTC DataChannels for direct device sync\n- CRDT-based namespaces for idempotent merges\n- Vector clocks for causality, tombstones for deletes\n- End-to-end encryption and minimal key management\n- Garbage collection strategy for tombstones and stale data\n\n## Code Example\n```javascript\n// useP2PQueue.ts\nimport { useState, useEffect } from 'react';\nimport { P2PSyncManager } from './syncManager';\n\nexport const useP2PQueue = () => {\n  const [pendingOps, setPendingOps] = useState([]);\n  const [isConnected, setIsConnected] = useState(false);\n  \n  useEffect(() => {\n    const sync = new P2PSyncManager();\n    sync.onConnectionChange(setIsConnected);\n    sync.onPendingOpsChange(setPendingOps);\n    return () => sync.disconnect();\n  }, []);\n  \n  const enqueue = async (namespace, operation) => {\n    await syncManager.enqueueOperation(namespace, operation);\n  };\n  \n  return { pendingOps, isConnected, enqueue };\n};\n```\n\n## Trade-offs\n- **Latency**: Direct P2P reduces round-trip time vs cloud relay\n- **Privacy**: Data stays on-device, no third-party exposure\n- **Scalability**: Mesh topology scales linearly but requires connection management","diagram":"flowchart TD\n  LocalChange[Local Change] --> Merge[Merge & CRDT Apply]\n  Sync[Sync] --> RemotePeer[Remote Peer]\n  RemotePeer --> Conflict[Conflict Resolution]\n  Tombstone[GC Tombstones] --> End[Done]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-21T04:34:55.859Z","createdAt":"2026-01-20T22:37:23.746Z"},{"id":"q-5026","question":"In a cross-platform React Native conferencing feature for a global low-latency call app, design a cross-platform video pipeline using WebRTC and a custom native module for hardware-accelerated encoding/decoding. Describe how you would integrate an ultra-low-latency data channel for chat, implement dynamic simulcast with per-peer bitrate, ensure end-to-end encryption, and handle lifecycle across background/foreground and app suspend states. Provide concrete APIs you would implement and trade-offs?","answer":"Implement a cross-platform React Native bridge CallEngine to manage a native WebRTC stack with per-peer simulcast, adaptive bitrate control, and hardware-accelerated codecs via a Rust/C++ native module. Encrypt media streams using SRTP and data channels with DTLS-SRTP, while handling lifecycle events through native background modes and proper peer connection management across background/foreground transitions and app suspend states.","explanation":"## Why This Is Asked\nTests the ability to design a real-time media stack in React Native, balancing performance, security, and lifecycle management across platforms with a practical bridge to native code.\n\n## Key Concepts\n- WebRTC with per-peer simulcast and adaptive bitrate\n- Native module bridges (Rust/C++) for performance-critical operations\n- SRTP encryption and DTLS-SRTP for data channels\n- Lifecycle handling: background/foreground suspend/resume\n- API design for cross-platform consistency\n\n## Code Example\n```javascript\n// RN CallEngine interface\nexport function startCall(roomId: string):\n```","diagram":"flowchart TD\n  RNUI[React Native UI] --> NativeBridge[CallEngine Bridge]\n  NativeBridge --> WebRTC[Native WebRTC Stack]\n  WebRTC --> RemotePeer[Remote Peer]\n  RemotePeer --> Server[Signaling/Media Server]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Netflix","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-21T05:17:43.125Z","createdAt":"2026-01-21T02:23:57.937Z"},{"id":"q-504","question":"How would you implement a custom button component in React Native that handles both iOS and Android platform-specific styling while maintaining consistent behavior?","answer":"Create a reusable button using Platform API for conditional styling. Use TouchableOpacity for touch handling, Platform.select for platform-specific props (shadowOpacity for iOS, elevation for Android)","explanation":"## Platform-Specific Implementation\n\n- Use `Platform.select()` to apply different styles per platform\n- iOS: Use `shadowOpacity` and `shadowRadius` for depth\n- Android: Use `elevation` for shadow effects\n\n## Touch Handling\n\n- `TouchableOpacity` provides visual feedback\n- `activeOpacity` prop controls press transparency\n- `disabled` prop prevents interaction\n\n## Performance\n\n- `StyleSheet.create()` optimizes style objects\n- Avoid inline styles for better performance\n- Use `useMemo` for complex style calculations","diagram":"flowchart TD\n  A[CustomButton Component] --> B{Platform Check}\n  B -->|iOS| C[iOS Styles: shadowOpacity]\n  B -->|Android| D[Android Styles: elevation]\n  C --> E[TouchableOpacity Wrapper]\n  D --> E\n  E --> F[Consistent onPress Handler]","difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Robinhood","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-25T01:16:06.061Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-5093","question":"Design and implement an offline-first analytics dashboard in React Native that streams high-volume time-series data. The app should ingest millions of points, store locally with a high-performance time-series DB (SQLite/WatermelonDB), support on-device windowed aggregations and progressive rendering via a Skia-based native module bridged to RN, and synchronize deltas with the backend under flaky connectivity using a push/pull strategy. Expose a JS API useTimeWindowedSeries(windowMs, fetchDelta) and show a minimal UI snippet?","answer":"Architect a local-first analytics module using a time-series store (WatermelonDB/SQLite) with schema Points(id, ts, value, tag). Implement on-device windowed rollups (minute/hour) and a Skia-driven ch","explanation":"## Why This Is Asked\nTests end-to-end architecture for high-throughput data, offline-first design, and efficient native bridges in React Native.\n\n## Key Concepts\n- Time-series data modeling on mobile; local DB with incremental rollups\n- Native Skia bridge for performant rendering\n- Delta-based sync under intermittent connectivity (push/pull)\n- API surface design (useTimeWindowedSeries) and UI integration\n\n## Code Example\n```javascript\n// Minimal hook sketch\nfunction useTimeWindowedSeries(windowMs) {\n  // state + native bridge integration for windowed data\n  const [series, setSeries] = useState([])\n  // ... implementation details\n  return series\n}\n```\n```\n\n## Follow-up Questions\n- How would you handle late-arriving data and out-of-order events?\n- How would you validate performance under memory pressure and flaky networks?","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Plaid","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T05:53:18.494Z","createdAt":"2026-01-21T05:53:18.494Z"},{"id":"q-5197","question":"You’re building a real-time social feed in React Native (Twitter-like) where posts include text and media. Updates come over WebSocket and the network is flaky. Describe an architecture to render the feed with optimistic UI, handle out-of-order events, deduplicate, and persist a local feed in WatermelonDB/SQLite. Include a useFeedLive() hook sketch and a minimal UI snippet that demonstrates optimistic like/upvote and an offline action queue that syncs when online. What trade-offs do you consider?","answer":"Use a local immutable feed with WatermelonDB/SQLite, a pending-actions queue, and a WebSocket-based live feed. On user actions, perform optimistic UI updates, enqueue the action with an id, and reconc","explanation":"## Why This Is Asked\nTests ability to design offline-first, real-time data flows with conflict resolution in RN apps, including data persistence and user experience during flaky networks.\n\n## Key Concepts\n- Offline-first persistence with a local DB (WatermelonDB/SQLite)\n- Real-time sync via WebSocket with dedup and sequencing\n- Optimistic UI and reconciliation to minimize perceived latency\n- Action queues for offline edits and batched syncs\n- Idempotent server endpoints and conflict resolution strategies\n\n## Code Example\n```javascript\n// useFeedLive.js (sketch)\nimport { useEffect, useState } from 'react'\nimport { fetchInitialFeed, subscribeToFeed, applyEvent } from './api'\n\nexport function useFeedLive() {\n  const [feed, setFeed] = useState([])\n  useEffect(() => {\n    fetchInitialFeed().then(setFeed)\n    const unsub = subscribeToFeed((ev) => {\n      setFeed((f) => applyEvent(f, ev))\n    })\n    return unsub\n  }, [])\n  const like = (postId) => {\n    setFeed((f) => f.map(p => p.id === postId ? { ...p, liked: true, likes: p.likes + 1 } : p))\n    enqueueAction({ type: 'like', postId, ts: Date.now() })\n  }\n  return { feed, like }\n}\n```\n\n## Follow-up Questions\n- How would you test the reconciliation logic for out-of-order WebSocket events?\n- What metrics would you collect to verify offline/online sync reliability and user-perceived latency?","diagram":"flowchart TD\n  A[WebSocket Event] --> B[Update cache]\n  C[User action] --> D[Pending queue]\n  D --> E[Flush to server]\n  E --> F[Server ack]","difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T10:39:27.873Z","createdAt":"2026-01-21T10:39:27.873Z"},{"id":"q-5260","question":"In a Hermes-enabled React Native app for field technicians, implement an offline-first form engine for dynamic checklists with text, number, image, and signature fields. Submissions must be stored offline, validated on-device, and synced to a REST backend using versioned records and optimistic updates. Describe the data model, conflict resolution, and provide a minimal useFormSync(formId) hook plus a UI snippet that captures a filled form and triggers sync?","answer":"Store locally in WatermelonDB/SQLite with fields: id, formId, fields (JSON), version, dirty, attachments. On save, increment version and mark dirty. Sync with POST /forms/{id}/sync; conflicts resolved","explanation":"## Why This Is Asked\nThis question probes practical offline-first design without CRDTs, focusing on consistency, versioning, and RN patterns.\n\n## Key Concepts\n- Offline persistence (SQLite/WatermelonDB)\n- Versioned records and optimistic updates\n- Conflict resolution via last-writer-wins on server side\n- Attachments handling and validation\n- Hook design useFormSync(formId)\n\n## Code Example\n```javascript\n// Form model\ntype FormSubmission = {\n  id: string\n  formId: string\n  fields: Record<string, any>\n  version: number\n  dirty: boolean\n  attachments?: string[]\n}\n\nasync function syncSubmission(sub: FormSubmission) {\n  // POST to server and reconcile\n}\n```\n\n## Follow-up Questions\n- How would you test race conditions and conflicts?\n- How would you scale this to thousands of concurrent submissions?","diagram":"flowchart TD\nA[User fills form] --> B[Local DB dirty record]\nB --> C{Online}\nC -->|Yes| D[Push to server /forms/{id}/sync]\nC -->|No| E[Retry on reconnect]\nD --> F[Server ack]\nF --> G[Clear dirty flag]","difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Netflix","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T13:26:29.241Z","createdAt":"2026-01-21T13:26:29.241Z"},{"id":"q-5314","question":"You're building a high-frequency React Native dashboard for quantitative traders that streams market data at 500–1000 updates/sec. Propose an architecture to handle data ingestion, local caching, and UI rendering without dropping frames. Specifically, design a native Rust-based module bridged via JSI to perform in-process data processing and a React Native listener that updates a FlatList with minimal GC pressure. Include data model, synchronization strategy, and a small hook sketch useLiveMarketStream() and a minimal UI snippet?","answer":"Design a Rust-native module (JSI/TurboModule) with a single ingest thread and a zero-copy ring buffer feeding JS. Handle 500–1000 updates/sec, batch serialize, and minimize allocations to reduce GC pa","explanation":"## Why This Is Asked\nAssesss system design under high-frequency data, native module interoperability, and performance debugging in RN. Focus on Rust interop, back-pressure, memory budgets, and test strategy.\n\n## Key Concepts\n- React Native TurboModules and JSI\n- Native thread isolation and back-pressure\n- Zero-copy data sharing and ring buffers\n- FlatList virtualization and key stability\n- GC pressure and memory budgeting\n\n## Code Example\n```javascript\nfunction useLiveMarketStream() {\n  // placeholder hook that subscribes to native events\n  // returns an iterator or array of latest ticks for rendering\n}\n```\n\n## Follow-up Questions\n- How would you verify zero-copy transfers across the JS/N-API boundary?\n- What instrumentation would you add to detect dropped frames and memory spikes?","diagram":"flowchart TD\n  MarketFeed[Market Data Feed]\n  RustModule[N Rust Native Module (JSI)]\n  Bridge[JS Bridge]\n  Hook[useLiveMarketStream()]\n  UI[FlatList UI]\n\n  MarketFeed --> RustModule\n  RustModule --> Bridge\n  Bridge --> Hook\n  Hook --> UI","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T16:07:43.132Z","createdAt":"2026-01-21T16:07:43.132Z"},{"id":"q-533","question":"How would you optimize a React Native app with 50+ screens that's experiencing slow navigation and memory leaks, particularly on lower-end devices?","answer":"Implement lazy loading with React.lazy() and Suspense for screen components, use React.memo() for expensive renders, optimize FlatList with getItemLayout and removeClippedSubviews, implement proper cleanup in useEffect hooks, leverage Metro bundler's RAM bundles, and use React Navigation's optimization features.","explanation":"## Performance Optimization Strategies\n\n### Code Splitting & Lazy Loading\n- Use React.lazy() for screen components wrapped in Suspense\n- Implement route-based code splitting to reduce initial bundle size\n- Leverage Metro bundler's RAM bundles for improved memory efficiency\n\n### Memory Management\n- Proper cleanup in useEffect hooks to prevent memory leaks\n- Avoid closures in long-lived components that retain references\n- Use WeakMap/WeakSet for large data structures\n- Implement proper event listener cleanup\n\n### List Optimization\n```javascript\n<FlatList\n  data={items}\n  getItemLayout={(data, index) => ({length: ITEM_HEIGHT, offset: ITEM_HEIGHT * index, index})}\n  removeClippedSubviews={true}\n  maxToRenderPerBatch={10}\n  windowSize={10}\n  initialNumToRender={10}\n/>\n```\n\n### Engine & Build Optimizations\n- Use Hermes JavaScript engine for better performance\n- Implement bundle splitting and code optimization\n- Utilize React.memo() and useMemo() for expensive computations\n- Profile and optimize re-renders with React DevTools","diagram":"flowchart TD\n  A[App Startup] --> B[Route-based Lazy Loading]\n  B --> C[Screen Component Mount]\n  C --> D[React.memo Check]\n  D --> E[Render Optimization]\n  E --> F[FlatList Virtualization]\n  F --> G[Memory Cleanup]\n  G --> H[Performance Monitoring]\n  H --> I[Flipper Analysis]\n  I --> J[Optimization Iteration]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-09T08:44:45.928Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-5355","question":"You're building a cross-platform React Native chat app with end-to-end encryption. Design the crypto layer as a Rust-native module bridged via JSI to React Native. Explain key management (long-term device keys, ephemeral session keys, forward secrecy), secure storage (Keychain/Keystore), onboarding/verification flow (out-of-band trust, key ratcheting), and offline messaging with rekeying. Include a minimal hook useEncryptAndSend() and a UI snippet that shows sending an encrypted message?","answer":"Use a Rust crypto module bridged to RN via JSI; maintain a per-device long-term X25519 key and ephemeral session keys; achieve forward secrecy with a Double Ratchet-like ratchet; store private keys in","explanation":"## Why This Is Asked\nTests integration of high-assurance cryptography with a mobile bridge, plus secure storage, verification UX, and offline resilience.\n\n## Key Concepts\n- End-to-end encryption with per-device long-term keys and per-session keys\n- Rust-native module bridged to RN via JSI for performance and safety\n- Forward secrecy via a ratcheting scheme (Double Ratchet-like)\n- Secure storage using Keychain/Keystore with biometric unlock\n- Out-of-band verification and key rotation flow\n- Offline messaging with rekeying and queueing\n\n## Code Example\n```javascript\n// Minimal sketch for useEncryptAndSend()\nfunction useEncryptAndSend() {\n  // returns sendEncrypted(toId, plaintext) and status\n  // actual implementation rests in Rust module exposed to JS\n  return {\n    sendEncrypted: async (toId, text) => {\n      // placeholder: calls into Rust crypto layer\n      return await crypto.encryptAndSend(toId, text)\n    },\n    status: 'idle'\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test property-based security guarantees (secrecy, authenticity, forward secrecy)?\n- How would you handle key compromise and re-key strategies in a multi-device user scenario?","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T19:09:00.131Z","createdAt":"2026-01-21T19:09:00.131Z"},{"id":"q-5424","question":"Design a high‑performance React Native feature: an app used by field crews showing a dynamic top‑k shipments list (top 100 by urgency) with intermittent connectivity. Propose an architecture that minimizes bridge crosses, uses local persistence (SQLite) with an on‑device delta applier via a native module (TurboModule/Fabric) or WASM, and a streaming delta protocol (WebSocket or SSE) with backpressure and offline replay. Include a concrete API for a hook useTopK(region, k, opts) and a minimal UI snippet showing usage, plus key trade‑offs and testing plan?","answer":"Architect for offline-first top‑k with minimal bridge crosses: use SQLite for durable storage, a native delta applier (TurboModule/Fabric) or WASM to serialize updates, and a streaming delta protocol ","explanation":"## Why This Is Asked\nAssesses ability to design a near‑real‑time RN feature with offline resilience, bridge‑efficient data paths, and native module integration. Evaluates persistence strategy, streaming protocol, and a practical hook/UI contract.\n\n## Key Concepts\n- Local persistence (SQLite) with an efficient on‑device delta applier in a native module\n- Minimize React Native bridge traffic via native code and WASM off the JS thread\n- Streaming deltas (WebSocket/SSE) with backpressure and offline replay\n- Top‑k cache strategy (LRU, eviction, revalidation)\n- Hook API and minimal UI integration for live updates\n\n## Code Example\n```javascript\n// useTopK hook sketch (high level, to be implemented with native bridge)\nfunction useTopK(region, k, opts = {}) {\n  // subscribe to delta stream from native module\n  // read initial top‑k from SQLite, update in memory cache\n  // return { items: Array<Shipment>, loading, error }\n}\n```\n\n## Follow-up Questions\n- How would you test delta correctness under intermittent connectivity and rapid delta bursts?\n- What strategies ensure deterministic ordering when deltas arrive out‑of‑order across devices?","diagram":"flowchart TD\n  A[React Native JavaScript] --> B[Delta Stream Native Module]\n  B --> C[SQLite Core]\n  C --> D[LRU Top‑K Cache]\n  D --> E[Top‑K UI]\n  F[Offline Replay & Backfill] --> B","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Citadel","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T21:51:08.932Z","createdAt":"2026-01-21T21:51:08.932Z"},{"id":"q-5576","question":"You're building a beginner-friendly onboarding flow in a React Native app for a fintech use case. Design an accessible three-screen onboarding with smooth transitions between screens on low-end devices, using either Animated or Reanimated. Include a skip/Next, progress indicator, and ensure screen reader order. Provide a small hook useOnboardingStep() and a minimal UI snippet to illustrate usage. What would you implement and why?","answer":"Implement a three-screen onboarding with a single Animated.Value for progress, slide screens with translateX, and fade in/out text. Use accessibilityLabel, accessibilityHint, and accessible wrappers t","explanation":"## Why This Is Asked\n\nThis question assesses practical skills in cross-platform UI, accessibility, and basic animation with React Native—core for production onboarding flows on constrained devices.\n\n## Key Concepts\n\n- Accessibility in React Native (accessibilityLabel, accessibilityHint, accessible)\n- Basic animation patterns (Animated or Reanimated) and sequencing\n- State flow for multi-screen experiences\n- Performance considerations on lower-end devices\n\n## Code Example\n\n```javascript\nimport React from 'react'\n```\n\n```javascript\n// Minimal hook and usage sketch\nexport function useOnboardingStep(initial = 0) {\n  const [step, setStep] = React.useState(initial)\n  function next() { setStep((s) => Math.min(2, s + 1)) }\n  function skip() { setStep(2) }\n  const isLast = step === 2\n  return { step, next, skip, isLast }\n}\n```\n\n```javascript\n// Minimal UI snippet\nimport { Animated, View, Text, Button } from 'react-native'\nexport function OnboardingScreen({ label, index, anim }) {\n  return (\n    <Animated.View style={{ transform: [{ translateX: anim }] }}>\n      <Text accessibilityLabel={`Onboarding step ${index + 1}`}>\n        {label}\n      </Text>\n    </Animated.View>\n  )\n}\n```\n\n## Follow-up Questions\n\n- How would you test accessibility across iOS and Android devices?\n- How would you adjust the flow for dynamic screens loaded from a remote config?","diagram":null,"difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T07:06:34.547Z","createdAt":"2026-01-22T07:06:34.547Z"},{"id":"q-560","question":"You're building a React Native app that needs to display a list of user profiles with images. The list should be performant with 1000+ items and support pull-to-refresh. How would you implement this using FlatList and what optimizations would you apply?","answer":"Use FlatList with keyExtractor for stable item identification, getItemLayout for optimized rendering calculations, and initialNumToRender to control the initial render batch. Implement pull-to-refresh functionality with the onRefresh prop and refreshing state. Use memoized renderItem components with React.memo to prevent unnecessary re-renders, implement image caching with react-native-fast-image, and optimize memory usage with removeClippedSubviews and windowSize props.","explanation":"## Key Implementation\n- Use FlatList instead of ScrollView for efficient virtualized rendering with large datasets\n- Implement keyExtractor for stable item identification and optimal diffing\n- Add getItemLayout to enable smooth scrolling by providing item dimensions upfront\n- Configure initialNumToRender and maxToRenderPerBatch to balance performance and user experience\n\n## Performance Optimizations\n- Memoize renderItem components with React.memo to prevent unnecessary re-renders\n- Use windowSize prop to control the render window and reduce memory footprint\n- Implement image caching with react-native-fast-image for efficient image loading\n- Consider removeClippedSubviews for memory optimization with complex lists\n- Optimize data structure to minimize update calculations\n\n## Refresh Pattern\n```javascript\n<FlatList\n  data={profiles}\n  onRefresh={handleRefresh}\n  refreshing={isRefreshing}\n  keyExtractor={(item) => item.id}\n  getItemLayout={(data, index) => ({\n    length: ITEM_HEIGHT,\n    offset: ITEM_HEIGHT * index,\n    index,\n  })}\n  initialNumToRender={20}\n  maxToRenderPerBatch={10}\n  windowSize={10}\n  removeClippedSubviews={true}\n  renderItem={memoizedItemRenderer}\n/>\n```","diagram":"flowchart TD\n  A[User Pulls Down] --> B[onRefresh Triggered]\n  B --> C[Set refreshing=true]\n  C --> D[Fetch New Data]\n  D --> E[Update State]\n  E --> F[Set refreshing=false]\n  F --> G[FlatList Re-renders]\n  G --> H[Display Updated List]","difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-08T11:56:33.226Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-5686","question":"In a React Native feed app for a streaming service, you need to render a live, high-velocity stream of posts without blocking the UI or crashing on memory. Propose an incremental rendering strategy using FlatList virtualization, windowing, and a local cache that survives network hiccups. Outline useLiveIncrementalFeed(source, opts) hook and a minimal UI snippet showing how to render sections and items. Discuss backpressure, update deduping, and memory budget?","answer":"Use a moving viewport window with FlatList virtualization and a local cache (WatermelonDB/SQLite). Deduplicate by id and sequence; apply backpressure by batching updates in requestAnimationFrame and t","explanation":"## Why This Is Asked\nThe prompt tests ability to design a real-world RN feed with high-velocity data, focusing on performance, memory, offline resilience, and clean API.\n\n## Key Concepts\n- FlatList virtualization and windowing\n- Local cache with deduplication by id/sequence\n- Backpressure and batched updates\n- Cross-platform memory budgets and scrolling perf\n\n## Code Example\n```javascript\nfunction useLiveIncrementalFeed(source, options) {\n  // sketch: manage window, cache, and sync\n}\n```\n\n## Follow-up Questions\n- How would you test memory usage and garbage Collection pauses?\n- How would you handle variable item heights that break getItemLayout?","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Netflix","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T11:32:27.919Z","createdAt":"2026-01-22T11:32:27.919Z"},{"id":"q-5721","question":"You're building a cross-platform React Native app for field technicians that must stay in sync with a central server via a persistent WebSocket. Design and implement a native module 'WebSocketSync' (iOS and Android) that keeps a durable connection, queues outgoing messages while offline, reconnects with exponential backoff, and guarantees at-least-once delivery with idempotent event handlers. Provide an API surface (connect(url), subscribe(event, cb), publish(event, data)), a TS hook useWebSocketSync(channel) that replays missed messages after reconnect, and a minimal UI snippet to publish a 'checkpoint' event. Discuss memory, battery, and consistency trade-offs?","answer":"Implemented WebSocketSync with a durable native module (iOS/Android) exposing connect(url), subscribe(event, cb), publish(event, data). Keeps an offline queue in SQLite, reconnects with exponential ba","explanation":"## Why This Is Asked\n\nTests design of a real-time sync surface with offline resilience, cross‑platform native bridge, and robust delivery guarantees.\n\n## Key Concepts\n\n- Durable WebSocket bridge in React Native\n- Offline queue stored locally (SQLite/Realm)\n- Exponential backoff on reconnects\n- Idempotent handlers and messageId for at-least-once delivery\n- TypeScript hook useWebSocketSync for replaying missed messages\n- Testing strategies for intermittent connectivity\n\n## Code Example\n\n```javascript\n// Minimal hook usage\nfunction MyComponent() {\n  const { subscribe, publish } = useWebSocketSync(\"checkpoint\");\n  useEffect(() => {\n    const unsub = subscribe(\"checkpoint_ack\", payload => console.log(payload));\n    publish({ type: \"checkpoint\", ts: Date.now() });\n    return unsub;\n  }, []);\n  return null;\n}\n```\n\n## Follow-up Questions\n\n- How would you test network flakiness and ensure idempotence across restarts?\n- How to bound memory usage for the offline queue on low-end devices?\n","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Meta","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T13:16:34.537Z","createdAt":"2026-01-22T13:16:34.537Z"},{"id":"q-589","question":"How do you handle different screen sizes and orientations in React Native?","answer":"In React Native, handle different screen sizes using Flexbox layouts with percentage-based dimensions and the `useWindowDimensions` hook to respond to size changes. For orientation changes, listen to dimension events and re-render components with updated layouts, while using Platform-specific styles for iOS and Android differences.","explanation":"## Key Concepts\n- **Flexbox Layout**: Primary responsive design tool\n- **Dimensions API**: Screen size detection\n- **Orientation Handling**: Dynamic adaptation\n\n## Implementation\n```javascript\nimport { useWindowDimensions } from 'react-native';\n\nconst { width, height } = useWindowDimensions();\nconst isLandscape = width > height;\n```\n\n## Best Practices\n- Use relative units over fixed pixels\n- Implement safe area insets with `react-native-safe-area-context`\n- Test on various device ratios\n- Consider platform differences (iOS vs Android)","diagram":"flowchart TD\n  A[App Start] --> B[Detect Screen Size]\n  B --> C[Apply Flexbox Layout]\n  C --> D[Handle Orientation Change]\n  D --> E[Update UI Accordingly]\n  E --> F[Monitor Size Changes]","difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Instacart","LinkedIn"],"eli5":null,"relevanceScore":null,"voiceKeywords":["flexbox layouts","percentage-based dimensions","usewindowdimensions hook","dimension events","platform-specific styles","react-native-safe-area-context","safe area insets","device ratios","orientation changes","screen sizes","ios vs android","responsive design"],"voiceSuitable":true,"isNew":false,"lastUpdated":"2026-01-06T04:04:20.726Z","createdAt":"2025-12-27T01:14:41.041Z"},{"id":"q-5906","question":"You're building a React Native e‑commerce app that must display a responsive product grid on phones and tablets. How would you implement a FlatList-driven grid that adapts numColumns to screen width, minimizes reflows, and remains smooth during rotation? Provide a small hook useNumColumns() and a minimal renderItem, plus any performance tweaks?","answer":"Implement useNumColumns() that derives columns from width breakpoints (e.g., 2 for narrow, 3–4 for tablet). Use FlatList with numColumns={useNumColumns()} and a stable keyExtractor. Provide getItemLay","explanation":"## Why This Is Asked\nThis tests practical RN layout skill: building a responsive grid with FlatList, ensuring smooth rotations, and avoiding layout thrash. It also evaluates performance-minded patterns like getItemLayout and memoization.\n\n## Key Concepts\n- FlatList numColumns and dynamic layouts\n- Responsive breakpoints with useWindowDimensions\n- getItemLayout for fixed heights\n- Memoization of renderItem and stable keys\n- Orientation changes and re-render strategy\n\n## Code Example\n```javascript\nimport { useWindowDimensions, FlatList } from 'react-native'\nimport React, { useMemo } from 'react'\n\nexport function useNumColumns(breaks = [400, 800, 1200]) {\n  const { width } = useWindowDimensions()\n  return useMemo(() => {\n    if (width < breaks[0]) return 2\n    if (width < breaks[1]) return 3\n    if (width < breaks[2]) return 4\n    return 5\n  }, [width, breaks])\n}\n\nfunction Item({ item }) {\n  // simple render, assume fixed height for getItemLayout\n  return <ProductCard data={item} />\n}\n\nexport function ProductGrid({ data }) {\n  const numColumns = useNumColumns()\n  const ITEM_HEIGHT = 180\n  const getItemLayout = (_, index) => (\n    { length: ITEM_HEIGHT, offset: ITEM_HEIGHT * index, index }\n  )\n\n  const renderItem = useCallback(({ item }) => <Item item={item} />, [])\n\n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem}\n      keyExtractor={item => item.id}\n      numColumns={numColumns}\n      getItemLayout={getItemLayout}\n      initialNumToRender={10}\n      maxToRenderPerBatch={10}\n      windowSize={21}\n    />\n  )\n}\n```\n\n## Follow-up Questions\n- How would you test on different devices and during rotation?\n- How would you adjust for dynamic image heights within grid items?","diagram":null,"difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Hugging Face","Instacart"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T21:45:38.789Z","createdAt":"2026-01-22T21:45:38.789Z"},{"id":"q-6008","question":"You're building a cross-platform React Native app used for enterprise document collaboration. Implement an offline-first, full-text search index for thousands of documents stored locally, with delta sync when online. Propose a Rust-native module bridged to RN to power indexing and search. Include data model, inverted index, tokenization, delta sync, and a JS API useIndexSearch(query, options) plus a minimal UI snippet. Address security, storage, and testing?","answer":"Propose a Rust-native index module bridged to RN powering an offline-first full-text search over documents. Data model: inverted index with term dictionary, document IDs, field weights; tokenizer and ","explanation":"## Why This Is Asked\\n\\nThis question probes knowledge of native modules, offline-first search, and practical indexing trade-offs in RN at scale.\\n\\n## Key Concepts\\n- React Native bridge (JSI) with Rust for perf\\n- Inverted index, tokenizer, stop-words, IDF-like weighting\\n- Delta sync, conflict handling, incremental indexing\\n- Encryption at rest, key management, access control\\n- Testing: indexing latency, correctness, offline UX\\n\\n## Code Example\\n```javascript\\n// Example API usage\\nconst hits = await index.useIndexSearch('design docs', {limit: 25, fuzzy: true});\\n```\\n\\n## Follow-up Questions\\n- How would you test index accuracy with evolving docs?\\n- How would you migrate index format across app versions?","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","Salesforce","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T04:25:05.911Z","createdAt":"2026-01-23T04:25:05.911Z"},{"id":"q-6040","question":"You're building a beginner-friendly React Native app that lists products from a REST API. Implement a simple offline cache with TTL using AsyncStorage: on startup, load from cache if not expired; otherwise fetch from API and update cache. Create a hook useCachedQuery(key, fetchFn, ttl) returning {data, loading, error}. Show a minimal UI using FlatList and this hook. Include considerations for cache invalidation and offline-first UX?","answer":"Store a TTL-driven cache in AsyncStorage. In useCachedQuery(key, fetchFn, ttl), read cached {data, ts}. If Date.now() - ts < ttl, return cached data with loading=false; else fetch from fetchFn, update","explanation":"## Why This Is Asked\nTests practical offline-first data handling in React Native. It probes AsyncStorage usage, hook design, and clear cache invalidation logic that affects UX.\n\n## Key Concepts\n- AsyncStorage caching with TTL\n- Custom React hook design: useCachedQuery\n- Offline-first UX and error handling\n- FlatList integration for data rendering\n\n## Code Example\n```javascript\nimport { useEffect, useState } from 'react';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\nexport function useCachedQuery(key, fetchFn, ttl) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  const load = async () => {\n    setLoading(true);\n    try {\n      const cached = await AsyncStorage.getItem(key);\n      if (cached) {\n        const { value, ts } = JSON.parse(cached);\n        if (Date.now() - ts < ttl) {\n          setData(value);\n          setLoading(false);\n          return;\n        }\n      }\n      const fresh = await fetchFn();\n      await AsyncStorage.setItem(key, JSON.stringify({ value: fresh, ts: Date.now() }));\n      setData(fresh);\n    } catch (e) {\n      setError(e);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => { load(); }, [key]);\n  return { data, loading, error, refetch: load };\n}\n```\n\n## Follow-up Questions\n- How would you adjust TTL to balance freshness and offline availability?\n- How would you test offline-first behavior in a RN app?","diagram":"flowchart TD\n  A[Open products list] --> B[Check cache TTL]\n  B --> C{Cache valid?}\n  C -- Yes --> D[Render cached data]\n  C -- No --> E[Fetch from API]\n  E --> F[Update cache]\n  F --> D\n  D --> G[UI ready]","difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","NVIDIA","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T06:02:00.448Z","createdAt":"2026-01-23T06:02:00.448Z"},{"id":"q-6164","question":"You’re building a cross‑platform React Native photo gallery that must handle thousands of HEIC photos efficiently on mid‑range devices. Propose a hybrid approach using a native module (JSI bridged) for decoding thumbnails and a local cache for metadata. Include: (1) Photo data model, (2) a useViewportPhotos(region) hook throttled to 1s, (3) a minimal 2-column grid UI snippet, (4) trade-offs vs a pure JS implementation?","answer":"Architect a hybrid approach: a native module PhotoIO (JSI TurboModule) to enumerate HEIC photos, decode thumbnails, and extract metadata; cache metadata locally in SQLite. Provide a useViewportPhotos(","explanation":"## Why This Is Asked\nThis task probes advanced RN skills: native modules, performance tuning, and complex UI data loading.\n\n## Key Concepts\n- React Native bridging with JSI/TurboModules\n- HEIC decoding and thumbnail generation\n- Local caching with SQLite\n- useViewportPhotos throttling\n- Cross‑platform trade-offs\n\n## Code Example\n```javascript\n// useViewportPhotos.ts\nexport function useViewportPhotos(region) {\n  // debounced fetch from native cache\n}\n```\n\n## Follow-up Questions\n- How would you validate on low‑end devices?\n- How would you handle memory pressure and rotation?","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Hugging Face"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T11:30:52.701Z","createdAt":"2026-01-23T11:30:52.701Z"},{"id":"q-6290","question":"You're building an enterprise React Native app for on-device analytics that streams high-frequency sensor data (accelerometer/gyroscope) to a remote server. Design a native module (Rust via JSI bridge on iOS/Android) that samples at configurable rates, uses a ring buffer, caches locally with SQLite, and batches uploads when online. Include a JS hook useSensorStream() and a minimal UI snippet to visualize live metrics; discuss latency, battery, and privacy trade-offs?","answer":"I'd implement a high-frequency sensor module in Rust via a JSI bridge, exposing start/stop, rate, and a stream of samples to RN. Use a ring buffer in native memory, cache samples locally with SQLite, ","explanation":"## Why This Is Asked\nThis tests building a high-throughput, battery-conscious data path with a native module bridged to RN, plus local caching and batch uploads.\n\n## Key Concepts\n- React Native native modules via JSI/TurboModules\n- High-frequency data ingestion and memory efficiency\n- Local SQLite caching and batched network uploads\n- Privacy and battery optimization strategies\n\n## Code Example\n```javascript\n// Minimal useSensorStream hook sketch\nimport { useEffect, useState } from 'react';\nimport { NativeModules, NativeEventEmitter } from 'react-native';\nconst { SensorModule } = NativeModules;\nexport function useSensorStream(rate = 100) {\n  const [samples, setSamples] = useState([]);\n  useEffect(() => {\n    const onSample = (e) =>\n      setSamples((s) => [...s, e.sample].slice(-512));\n    const emitter = new NativeEventEmitter(SensorModule);\n    const sub = emitter.addListener('SensorSample', onSample);\n    SensorModule.start(rate);\n    return () => { sub.remove(); SensorModule.stop(); };\n  }, [rate]);\n  return samples;\n}\n```\n\n## Follow-up Questions\n- How would you adapt the sampling rate for power constraints in real-time?\n- What privacy safeguards and encryption would you implement for cached data?","diagram":"flowchart TD\n  A[React Native App] --> B[JSI Bridge]\n  B --> C[Native Sensor Sampler]\n  C --> D[Ring Buffer]\n  D --> E[SQLite Cache]\n  E --> F[Upload Queue]\n  F --> G[Network]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T17:57:15.677Z","createdAt":"2026-01-23T17:57:15.677Z"},{"id":"q-6307","question":"In a React Native app for a DoorDash-like platform, implement an offline-first cart that syncs with the backend when online. Design a hook useOfflineCart() backed by SQLite (addItem, updateQty, removeItem, clearCart). Explain conflict resolution for concurrent edits from multiple devices, and sketch the data model and a small UI snippet showing the cart drawer and a manual Sync button. Include testing considerations for offline/online transitions?","answer":"Implement useOfflineCart() backed by SQLite with a CartItems table (id, name, qty, price, updatedAt, dirty). The hook keeps an in-memory map, applies optimistic updates, and syncs deltas on connect. R","explanation":"## Why This Is Asked\n\nTests ability to design an offline-first sync layer, choose an persistent store, and handle concurrent edits with realistic conflict resolution and testing strategies.\n\n## Key Concepts\n\n- Offline-first data sync and delta propagation\n- SQLite integration in React Native\n- Conflict resolution: per-item last-updated-wins\n- Optimistic UI and synchronization strategy\n- Testing offline/online transitions and race conditions\n\n## Code Example\n\n```javascript\nfunction useOfflineCart() {\n  // skeleton: initialize SQLite, provide addItem, updateQty, removeItem, clearCart, sync\n}\n```\n\n## Follow-up Questions\n\n- How would you test conflicting edits from two devices?\n- How would you scale the data model for large carts and price drift handling?","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T18:51:24.913Z","createdAt":"2026-01-23T18:51:24.913Z"},{"id":"q-6344","question":"You're building a React Native app for status updates. Implement a minimal emoji-rich, searchable status composer: a TextInput for status, a horizontally scrolling emoji picker, and a FlatList of past updates. Describe how you'd implement a local in-memory emoji index with debounced search and memoized results via a useEmojiSearch hook, plus a small UI snippet to illustrate usage. Include trade-offs?","answer":"Implement a local emoji index (char,name) in memory. Create useEmojiSearch(query) that debounces input (~150ms) and uses useMemo to derive results by name.includes(query.toLowerCase()). Use React.memo","explanation":"## Why This Is Asked\nGauges candidate ability to architect a small, realistic feature with performance thoughts and React hooks.\n\n## Key Concepts\n- In-memory indexing for fast, offline search\n- Debounce input and memoize results\n- Component memoization to avoid re-renders\n\n## Code Example\n```javascript\nconst EMOJIS = [\n  {char:'😀', name:'grinning'},\n  {char:'🎉', name:'party'},\n  {char:'🚀', name:'rocket'}\n];\n\nfunction useEmojiSearch(query){\n  const [q, setQ] = React.useState(query);\n  const [debounced, setDebounced] = React.useState(query);\n  React.useEffect(() => {\n    const t = setTimeout(() => setDebounced(q), 150);\n    return () => clearTimeout(t);\n  }, [q]);\n  const results = React.useMemo(\n    () => EMOJIS.filter(e => e.name.toLowerCase().includes(debounced.toLowerCase())),\n    [debounced]\n  );\n  return { query: q, setQuery: setQ, results };\n}\n```\n\n```javascript\nfunction EmojiPicker(){\n  const { query, setQuery, results } = useEmojiSearch('');\n  return (\n    <>\n      <TextInput value={query} onChangeText={setQuery} placeholder=\"Search emoji\" />\n      <FlatList\n        data={results}\n        horizontal\n        keyExtractor={e => e.name}\n        renderItem={({ item }) => (\n          <Text accessibilityLabel={item.name}>{item.char}</Text>\n        )}\n      />\n    </>\n  );\n}\n```\n\n## Follow-up Questions\n- How would you handle a much larger emoji set or theme switching?\n- How would you test the debounce timing and memoization behavior?","diagram":null,"difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Netflix","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T19:54:28.361Z","createdAt":"2026-01-23T19:54:28.361Z"},{"id":"q-6381","question":"You're building a high-frequency price ticker in a cross-platform React Native app for real-time analytics. Design a native module using JSI/TurboModules that subscribes to a WebSocket feed, writes ticks into a native ring buffer, and exposes usePriceStream(ticker, { Hz, bufSize }) returning { price, ts }. Implement backpressure that drops oldest ticks, ensure a dedicated native thread, and provide a minimal Sparkline UI plus a small data table. Include data model, lifecycle, testing, and discuss latency, GC, battery, and security trade-offs?","answer":"Implement a cross-platform native module using JSI/TurboModules that subscribes to a WebSocket feed, writes ticks into a native ring buffer, and exposes usePriceStream(ticker, { Hz, bufSize }) returning { price, ts }. The module should handle backpressure by dropping oldest ticks when the buffer is full, run on a dedicated native thread, include a minimal Sparkline UI component and data table, and address data modeling, lifecycle management, testing strategies, and latency/GC/battery/security trade-offs.","explanation":"## Why This Is Asked\n\nReal-time data pipelines in React Native require careful design of the native/JS boundary, proper thread management, and backpressure handling to prevent UI performance degradation.\n\n## Key Concepts\n\n- React Native bridging using JSI/TurboModules for optimal performance\n- Native ring buffers and dedicated threading for low-latency data processing\n- Backpressure strategies and their impact on GC, battery consumption, and memory usage\n- Testing methodologies for real-time pipelines and meeting strict latency budgets\n\n## Code Example\n\n```javascript\n// Minimal hook implementation sketch\nfunction usePriceStream(ticker, opts) {\n  // Subscribe to native module and stream real-time price updates\n}\n```\n\n## Follow-up Questions\n\n- How would you test backpressure behavior under bursty input conditions?\n- What strategies would you use to optimize memory usage for high-frequency updates?","diagram":"flowchart TD\n  RN[React Native App] --> NM[JSI/TurboModule]\n  NM --> WS[WebSocket Feed]\n  WS --> RB[Ring Buffer]\n  RB --> RN\n  RN --> UI[Sparkline UI]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T04:33:24.658Z","createdAt":"2026-01-23T21:42:31.375Z"},{"id":"q-6403","question":"In a cross-platform React Native whiteboard app for distributed teams, design a native module (JSI/TurboModules) that streams local strokes into React Native, using a per-room CRDT to merge drawings offline and online. Implement useStrokeStream(roomId,{ Hz, bufSize }) => { stroke, ts }. Include backpressure that drops oldest strokes to maintain latency, a dedicated native thread, and a minimal canvas UI snippet. Discuss latency, memory pressure, battery, and security trade-offs?","answer":"Prototype a Rust-based TurboModule that subscribes to a canvas stroke stream, writes to a fixed-size ring buffer, and a background thread emits stroke deltas at a configurable Hz. Expose useStrokeStream(roomId, { Hz, bufSize }) => { stroke, ts } with automatic backpressure handling that drops oldest strokes to maintain latency targets.","explanation":"## Why This Is Asked\nAdvanced real-time collaboration requires native modules, CRDTs and offline support in React Native, plus careful backpressure and threading considerations.\n\n## Key Concepts\n- TurboModules/JSI for native performance\n- Fixed-size ring buffer with backpressure\n- Operation-based CRDT with tombstones\n- Background thread and per-room isolation\n- Testing for CRDT merges and latency budgets\n\n## Code Example\n\n```javascript\n// useStrokeStream hook sketch\nfunction useStrokeStream(roomId, { Hz, bufSize }) {\n  // subscribe to native stream and map to { stroke, ts }\n}\n```\n\n## Follow-up","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T05:19:32.585Z","createdAt":"2026-01-23T22:32:51.584Z"},{"id":"q-6555","question":"You're building a cross‑platform React Native analytics dashboard for a financial trading floor. The app must ingest high‑volume tick data locally, apply per‑instrument sliding window aggregations (volume, VWAP) in real time, and render responsive charts. Propose a native module (Rust via JSI) that streams ticks from a local UDP feed, maintains per‑instrument sliding windows in a lock‑free ring buffer, persists only deltas to SQLite, and exposes a hook useTickStream(instrumentId,{ windowMs, maxBuf }) => { tick, agg }. Include backpressure handling (drop oldest when lagging), and a minimal chart UI. Discuss latency, memory, and privacy considerations?","answer":"Design a Rust JSI native module that opens a UDP port for local tick data, parses Tick{instrumentId,ts,price,volume}, and writes into per-instrument lock-free ring buffers. JS exposes useTickStream(in","explanation":"## Why This Is Asked\n\nAssesses ability to architect a high‑throughput, low‑latency data path across JS↔native boundaries, with concurrency, memory constraints, and privacy concerns in a realistic financial context.\n\n## Key Concepts\n\n- Rust/J SI bridge for high‑throughput data\n- Lock‑free per‑instrument ring buffers\n- UDP socket ingestion and packet parsing\n- Sliding window aggregations (volume, VWAP)\n- Delta persistence with SQLite WAL\n- Backpressure strategies and latency budgets\n- Minimal charting UMA integration\n\n## Code Example\n\n```javascript\n// Skeleton showing how the hook might be used\nconst { tick, agg } = useTickStream(\"INSTR_ABC\", { windowMs: 1000, maxBuf: 1024 })\n```\n\n## Follow-up Questions\n\n- How would you validate latency guarantees under bursty UDP traffic?\n- How would you adapt the design for protocol changes or multi‑region deployments?","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T07:56:30.540Z","createdAt":"2026-01-24T07:56:30.540Z"},{"id":"q-6666","question":"In a React Native app for field technicians, design a cross‑platform video pipeline that applies real‑time on‑device processing (noise reduction) via a native module bridged to React Native. Expose API useLiveVideoProcessor({ enabled, resolution, bitrate }) returning a frame stream consumed by a VideoPreview component. Include a minimal UI sketch and discuss latency, battery, and privacy trade‑offs?","answer":"I'd implement a cross‑platform native module (Java/Kotlin and Objective‑C) that taps the camera, runs a lightweight denoise path, and exposes a FrameStream to RN. The hook useLiveVideoProcessor({ enab","explanation":"## Why This Is Asked\nTests integration of native modules with React Native, real‑time video pipelines, and performance budgeting; emphasizes cross‑platform concerns, memory/backpressure handling, and privacy practices.\n\n## Key Concepts\n- Native module bridging (Java/Kotlin, Objective‑C)\n- Frame streaming API and backpressure\n- VideoPreview integration and minimal UI sketch\n- Latency targets, battery impact, and privacy guarantees\n\n## Code Example\n```javascript\n// useLiveVideoProcessor.ts (sketch)\nexport function useLiveVideoProcessor(opts: { enabled: boolean; resolution: {w:number; h:number}; bitrate?: number; }) {\n  // placeholder hook sketch: starts/stops native stream and exposes latest frame\n  const [frame, setFrame] = React.useState<any>(null)\n  React.useEffect(() => {\n    if (!opts.enabled) return\n    // Native module would provide a frame stream; here we poll for simplicity\n    const id = setInterval(() => {\n      const f = NativeVideoFrameStreamer.popFrame()\n      if (f) setFrame(f)\n    }, 16)\n    return () => clearInterval(id)\n  }, [opts.enabled, opts.resolution, opts.bitrate])\n  return { frame, status: 'running' }\n}\n```\n\n## Follow-up Questions\n- How would you measure and optimize end‑to‑end latency across devices?\n- What privacy controls would you implement if frames could contain sensitive data?","diagram":"flowchart TD\n  A[Camera] --> B[Native FrameStreamer]\n  B --> C[React Native Bridge]\n  C --> D[VideoPreview UI]\n  D --> E[User Interaction]","difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Salesforce","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T12:58:14.588Z","createdAt":"2026-01-24T12:58:14.588Z"},{"id":"q-6776","question":"In a high-frequency, bank-grade React Native app, design a cross-platform native module (JSI/TurboModule) that streams per-symbol market ticks into React Native with backpressure. It must run on a dedicated native thread, expose useMarketStream(symbol,{ Hz, bufSize }) => { tick, ts }, drop oldest ticks when full, and provide a minimal chart UI snippet showing a sparkline. Describe the API, data model, backpressure strategy, and discuss latency, memory, battery, and security implications?","answer":"Architect a TurboModule with a dedicated native thread and per-symbol ring buffer. Expose useMarketStream(symbol,{ Hz, bufSize }) => { tick, ts }. Backpressure drops oldest ticks when full; ticks push","explanation":"## Why This Is Asked\nTests mastery of RN native modules, concurrency, and real-time data handling under strict security.\n\n## Key Concepts\n- React Native, JSI, TurboModules\n- Native threads, ring buffers, backpressure\n- Real-time data streaming and per-symbol subscriptions\n- Security, battery, and privacy considerations\n\n## Code Example\n```javascript\n// useMarketStream hook sketch\nimport { useMarketStream } from 'market-native'\n\nfunction Sparkline({ symbol }) {\n  const ticks = useMarketStream(symbol, { Hz: 60, bufSize: 1024 })\n  // render sparkline from ticks\n}\n```\n\n## Follow-up Questions\n- How would you test backpressure behavior? \n- How to measure latency and energy impact across devices?","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Snowflake","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T17:02:57.304Z","createdAt":"2026-01-24T17:02:57.304Z"},{"id":"q-6782","question":"Describe a cross-platform, on-device audio pipeline for voice commands in a React Native ride-hailing app. Design a native module bridged to RN that performs real-time noise suppression and echo cancellation, exposing startCapture(config) and a frame stream consumed by a VoicePreview. Include latency targets and privacy/power tradeoffs?","answer":"Propose a TurboModule bridged native audio module. Implement startCapture(config) configuring OS sessions, run DSP on a dedicated thread, and emit frames to React Native via a callback. Use AVAudioEng","explanation":"## Why This Is Asked\n\nReal-time voice UIs in field apps require efficient native modules, cross-platform bridging, and careful threading and privacy considerations. This question probes practical design, API ergonomics, and trade-offs under latency and power constraints.\n\n## Key Concepts\n\n- React Native TurboModules/JSI bridging\n- Real-time DSP: noise suppression, echo cancellation\n- Dedicated DSP/native thread and backpressure\n- Cross-platform audio pipelines (iOS/Android)\n- Privacy and battery considerations, permission flows\n\n## Code Example\n\n```javascript\n// useVoiceCapture hook outline (RN side)\nfunction useVoiceCapture(onFrame) {\n  useEffect(() => {\n    NativeVoiceModule.startCapture({ sampleRate: 16000, channels: 1 });\n    const sub = NativeVoiceModule.onFrame(({ frame, ts }) => onFrame(frame, ts));\n    return () => { sub.remove(); NativeVoiceModule.stopCapture(); };\n  }, [onFrame]);\n}\n```\n\n## Follow-up Questions\n\n- How would you measure and ensure sub-50ms end-to-end latency across devices?\n- What testing strategy would you use for privacy and performance across iOS/Android?","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Lyft","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T17:26:27.865Z","createdAt":"2026-01-24T17:26:27.867Z"},{"id":"q-6813","question":"You're building an enterprise React Native app that must work efficiently offline on battery-constrained devices. Design a cross-platform native module (JSI) that provides an asynchronous battery-aware data fetch layer: useBatteryAwareFetch({ url, cachePolicy, maxStalenessMs }) => { data, fromCache, ttl }. Describe your caching strategy (SQLite + LRU), how you switch to offline when battery saver is on, and how you measure energy cost. Include a minimal UI snippet and a hook useBatteryAwareFetch(url, options) to illustrate usage?","answer":"Implement a JSI bridge exposing useBatteryAwareFetch that delegates to a background fetcher with an SQLite-based LRU cache. When battery saver is on or device is unplugged, serve data from cache with ","explanation":"## Why This Is Asked\n\nTests ability to design a battery-conscious, offline-friendly data layer with native bridges, cache invalidation, and observability.\n\n## Key Concepts\n\n- React Native JSI/TurboModule bridge\n- SQLite-based LRU caching with cachePolicy and maxStalenessMs\n- Battery-aware fallbacks and background revalidation\n- HTTP semantics: ETag/Last-Modified for invalidation\n- Observability: energy cost, cache hit rate, latency\n\n## Code Example\n\n```javascript\n// Patterned API sketch\ntype CachePolicy = 'remoteOnly'|'cacheFirst'|'cacheAndRemote';\nasync function fetchWithBattery(url, { cachePolicy = 'cacheFirst', maxStalenessMs = 300000 } = {}) {\n  const { data, fromCache } = await BatteryAwareFetch.fetch(url, { cachePolicy, maxStalenessMs });\n  return { data, fromCache };\n}\n```\n\n## Follow-up Questions\n\n- How would you validate energy savings across devices and OS versions?\n- How would you handle data versioning when the schema evolves?","diagram":"flowchart TD\n  A[RN calls useBatteryAwareFetch] --> B{Battery Saver?}\n  B -- Yes --> C[Serve cached data (maxStalenessMs)]\n  B -- No --> D[Fetch fresh data from network]\n  C --> E[UI render]\n  D --> E","difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Google","Hashicorp"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T18:46:56.989Z","createdAt":"2026-01-24T18:46:56.990Z"},{"id":"q-6866","question":"You're building an enterprise React Native app used by field technicians to securely store credentials offline. Design a cross-platform TurboModule vault that stores an encrypted blob in secure storage, derives a session key with Argon2, unlocks via biometrics, and decrypts on demand. Each credential uses AES-GCM with a nonce. API: init(masterKey), storeCredential(id,data), retrieveCredential(id), deleteCredential(id). Provide useVault() and a minimal UI. What trade-offs and testing strategies would you apply?","answer":"Implement a TurboModule vault that stores an encrypted blob in secure storage, deriving a session key with Argon2, unlocking via biometrics and decrypting on demand. Use AES-GCM with per-record nonces","explanation":"## Why This Is Asked\n\nTests integration of native modules, secure storage, and UI design under realistic offline constraints. It also probes threat modeling, key management, and performance considerations.\n\n## Key Concepts\n\n- React Native TurboModule / JSI bridging\n- Platform secure storage, keystore/keychain\n- Argon2 KDF, AES-GCM encryption, nonces\n- Biometric unlock, session keys, memory safety\n- Auto-lock, tamper-resistance, attack surface reduction\n\n## Code Example\n\n```javascript\n// TS interface sketch for vault API\ntype VaultAPI = { init(masterKey: string): Promise<void>; storeCredential(id: string, data: string): Promise<void>; retrieveCredential(id: string): Promise<string | null>; deleteCredential(id: string): Promise<void>; }\n```\n\n## Follow-up Questions\n\n- How would you test key rotation and re-encryption? \n- How would you simulate offline-first access and failure modes in CI?","diagram":"flowchart TD\n  A[User saves credential] --> B[Encrypt with vaultKey]\n  B --> C[Store in secure blob]\n  C --> D[Retrieve]\n  D --> E[Decrypt on use]\n  E --> F[UI displays]","difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","NVIDIA","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T20:49:17.439Z","createdAt":"2026-01-24T20:49:17.440Z"},{"id":"q-6952","question":"In a field-service React Native app, design a cross-platform native module that streams raw camera frames (YUV) at a configurable FPS from Android (Camera2/CameraX) and iOS (AVFoundation) into React Native, with backpressure to drop frames when the JS thread lags. Expose API useCameraStream({ enabled, width, height, fps, format }) => { frame: ArrayBuffer, ts } and provide a minimal UI to annotate a frame and export a PNG snapshot. Explain frame lifecycle, memory budget, and privacy considerations (ephemeral frames, on-device processing, no persisted data)?","answer":"Implement a TurboModule bridging to Android Camera2/CameraX and iOS AVFoundation that streams raw frames (YUV) at a configurable FPS into React Native. Expose useCameraStream({ enabled, width, height, fps, format }) => { frame: ArrayBuffer, ts } and provide a minimal UI to annotate a frame and export a PNG snapshot. The solution should handle frame lifecycle with proper memory budgeting, implement backpressure to drop frames when JS thread lags, and ensure privacy through ephemeral frames and on-device processing only.","explanation":"## Why This Is Asked\nTests native module bridging, frame data lifecycle, and real-time constraints in a mobile context.\n\n## Key Concepts\n\n- TurboModules/JSI bridge, native camera APIs (Camera2, AVFoundation)\n- Efficient frame buffers, zero-copy where possible\n- Backpressure, frame dropping, and memory budgeting\n- Ephemeral, on-device processing for privacy\n\n## Code Example\n\n```javascript\n// Sketch: useCameraStream hook\nfunction useCameraStream(opts) { /* ... */ }\n```\n\n## Follow-up Questions\n\n- How would you test frame latency and drop rate?\n- How would you validate privacy guarantees with automated testing?\n- What strategies would you use for memory optimization across different device capabilities?","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","IBM","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T05:28:38.118Z","createdAt":"2026-01-25T02:33:38.965Z"},{"id":"q-7055","question":"In a React Native app for on-site inspections, implement a cross-platform TurboModule useLiveFrameStream({ Hz, bufSize, format }) that captures the device camera frames (NV12/NV21), streams them to React Native with backpressure on a dedicated native thread, and exposes { frame, ts, meta } with dynamic Hz and buffer sizing. Provide a minimal UI snippet rendering frames in grayscale via a GL shader. Outline the API, data model, backpressure policy (drop oldest when full), latency/memory/battery implications, and security considerations (in-flight and at-rest)?","answer":"Approach: build a TurboModule exposing useLiveFrameStream({ Hz, bufSize, format }) => { frame, ts, meta }. Run a native worker thread with a circular buffer of frames (NV12). Producer at requested Hz,","explanation":"## Why This Is Asked\n\nReal-time, cross-platform camera streaming tests deep NDK/SDK knowledge, memory budgets, and secure data handling inside the React Native bridge.\n\n## Key Concepts\n\n- TurboModules/JSI integration and worker threads\n- Ring buffers and backpressure policies\n- Native vs JS rendering pipelines (GL shaders)\n- Frame metadata: ts, exposure, ISO; security considerations\n\n## Code Example\n\n```javascript\n// Placeholder interface sketch for the hook usage\nconst { frame, ts, meta } = useLiveFrameStream({ Hz: 30, bufSize: 60, format: 'NV12' })\n```\n\n## Follow-up Questions\n\n- How would you test backpressure behavior under burst capture?\n- What changes to reduce latency further without increasing CPU load?\n```","diagram":"flowchart TD\n  A(Camera Capture) --> B(Dedicated Native Thread)\n  B --> C(TurboModule Bridge)\n  C --> D(React Native JS)\n  D --> E(UI Preview)\n","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T07:37:00.689Z","createdAt":"2026-01-25T07:37:00.690Z"},{"id":"q-7107","question":"Design a cross-platform React Native module to render a 1,000×1,000 heatmap in a logistics analytics app. Build a TurboModule/JSI native data source (Rust/Swift/Kotlin) that streams tiles on demand on a dedicated thread with backpressure (bufSize). Expose a hook useHeatmapTiles(viewport) => { x, y, value, ts } and a minimal TileCanvas component for rendering. Describe data model, caching, eviction, latency, and battery trade-offs, with a small UI sketch?","answer":"Leverage a Rust/TurboModule data source on a dedicated worker thread with a bounded ring buffer (bufSize) to stream tiles on-demand. Expose Tile { x, y, value, ts } and a hook useHeatmapTiles(viewport","explanation":"## Why This Is Asked\nTests cross-language TurboModule design, on-device streaming, and cache-aware rendering for large heatmaps under tight memory and battery constraints. It also exercises evaluation of backpressure, thread usage, and rendering paths in React Native.\n\n## Key Concepts\n- TurboModule/JSI integration between JS and native (Rust/Swift/Kotlin)\n- Dedicated worker thread with a bounded buffer for streaming tiles\n- Tile data model and viewport-driven prefetch\n- JS-side LRU caching and eviction policy\n- Canvas/GL-based rendering with stable frame timing\n\n## Code Example\n```javascript\n// useHeatmapTiles hook sketch (pseudo)\nfunction useHeatmapTiles(viewport) {\n  const [tiles, setTiles] = React.useState([]);\n  // subscribe to native TileStream, map incoming tiles to state\n  // drop/overwrite logic to respect backpressure\n  return tiles;\n}\n```\n\n## Follow-up Questions\n- How would you scale to multi-resolution zoom and dynamic viewport changes?\n- How would you test backpressure behavior under bursty tile requests and network hiccups?\n","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T09:37:14.628Z","createdAt":"2026-01-25T09:37:14.628Z"},{"id":"q-7160","question":"You're building a beginner-friendly React Native analytics feature. Implement a cross-platform native module bridged to RN that queues lightweight user events (screen views, taps) while offline and flushes them to a REST endpoint when online. Expose API useUserAnalytics({ enabled, endpoint, maxQueueSize }) => { enqueue(event), flush() }. Include a minimal UI to simulate events and a live log. Describe data model, offline storage, backpressure, and retry strategy?","answer":"An optimal answer demonstrates: implement a TurboModule in Swift/Kotlin with an in-memory queue plus SQLite persistence; expose enqueue(event) and flush(); enforce maxQueueSize by dropping oldest when","explanation":"## Why This Is Asked\n\nTests bridging native modules, offline-first data handling, and robust retry logic, essential for reliable RN apps on devices with flaky connectivity.\n\n## Key Concepts\n- TurboModule/native bridge\n- Local persistence (SQLite) for offline\n- In-memory queue with maxQueueSize and drop-oldest policy\n- Batch flush and exponential backoff\n- Event data model: id, type, ts, payload\n\n## Code Example\n\n```javascript\n// Minimal hook useUserAnalytics (skeleton)\nimport { useEffect } from 'react';\nimport { NativeModules } from 'react-native';\nconst { UserAnalyticsModule } = NativeModules;\nexport function useUserAnalytics({ endpoint, enabled = true, maxQueueSize = 1000 }) {\n  // enqueue and flush wrappers would be implemented here\n}\n```\n\n## Follow-up Questions\n- How would you test offline flushing and duplicate suppression?\n- How would you protect privacy and redact PII before enqueue?","diagram":null,"difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T11:39:06.951Z","createdAt":"2026-01-25T11:39:06.951Z"},{"id":"q-7324","question":"Design a real-time physics sandbox in React Native where the simulation runs in a dedicated native thread via a Rust module bridged with JSI. Design the API usePhysicsWorld({ gravity: [gx,gy,gz], timeStep }) => { bodies: [{ id, pos, vel, shape, size, mass }] }, step(), subscribeFrame({ Hz }) => Frame[] and a minimal frontend sketch to render spheres. Include backpressure, deterministic stepping, and cross-platform concerns?","answer":"Use a native Rust thread for the physics loop, exposed via a JSI TurboModule. API: usePhysicsWorld({ gravity: [gx,gy,gz], timeStep }) => { bodies: [{ id, pos, vel, shape, size, mass }] }, step(), subs","explanation":"## Why This Is Asked\n\nTests RN native module integration, real-time deterministic simulation, and backpressure handling across iOS/Android.\n\n## Key Concepts\n\n- JSI TurboModule bridging\n- Dedicated native thread\n- Fixed time step\n- Backpressure strategy\n- Memory pool management\n- Cross-platform parity\n\n## Code Example\n\n```javascript\nimport { PhysicsModule } from 'react-native-physics';\nconst world = PhysicsModule.usePhysicsWorld({ gravity: [0,-9.8,0], timeStep: 1/60 });\nworld.subscribeFrame(frame => render(frame.bodies));\n```\n\n## Follow-up Questions\n\n- How would you test determinism across devices?\n- How would you handle dynamic bodies addition/removal mid-simulation?","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Robinhood","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T18:46:23.464Z","createdAt":"2026-01-25T18:46:23.464Z"},{"id":"q-7575","question":"In a React Native app, implement a minimal cross‑platform theming system that supports light and dark modes via a ThemeContext and a user toggle, persisting the choice with AsyncStorage. Ensure a Button consumes theme colors and provide a small usage example component. Outline how you would test theme persistence and platform differences?","answer":"Create a ThemeContext with a palette (background, text, primary). Initialize from Appearance/useColorScheme. Persist chosen theme in AsyncStorage under 'app_theme'. Build a ThemedButton that consumes ","explanation":"## Why This Is Asked\nTests practical theming, context usage, cross‑platform styling, and persistence basics.\n\n## Key Concepts\n- ThemeContext and useContext\n- useColorScheme/Appearance API\n- AsyncStorage for persistence\n- Themed components pattern\n- Basic testing strategies\n\n## Code Example\n```javascript\nimport React, {createContext, useContext, useState, useEffect} from 'react'\n\nconst defaultTheme = {\n  background: '#ffffff', text: '#000000', primary: '#1f6feb'\n}\n\nconst ThemeContext = createContext(defaultTheme)\n\nexport const ThemeProvider = ({children}) => {\n  const colorScheme = useColorScheme()\n  const [theme, setTheme] = useState(defaultTheme)\n\n  useEffect(() => {\n    const load = async () => {\n      const saved = await AsyncStorage.getItem('app_theme')\n      if (saved) setTheme(JSON.parse(saved))\n      else if (colorScheme === 'dark') setTheme({background: '#000000', text: '#ffffff', primary: '#4dabf7'})\n    }\n    load()\n  }, [])\n\n  const toggle = async () => {\n    const next = theme.background === '#ffffff'\n      ? {background: '#000000', text: '#ffffff', primary: '#4dabf7'}\n      : {background: '#ffffff', text: '#000000', primary: '#1f6feb'}\n    setTheme(next)\n    await AsyncStorage.setItem('app_theme', JSON.stringify(next))\n  }\n\n  return (\n    <ThemeContext.Provider value={{theme, toggle}}>\n      {children}\n    </ThemeContext.Provider>\n  )\n}\n\nexport const ThemedButton = ({title, onPress}) => {\n  const {theme} = useContext(ThemeContext)\n  return (\n    <TouchableOpacity onPress={onPress} style={{backgroundColor: theme.primary, padding: 12, borderRadius: 6}}>\n      <Text style={{color: theme.text}}>{title}</Text>\n    </TouchableOpacity>\n  )\n}\n```\n\n## Follow-up Questions\n- How would you test cross‑platform theming (unit and snapshot) and simulate system color changes? \n- How would you extend to per‑component theming or accessibility (increase contrast, font scale)?","diagram":"flowchart TD\n  A[Theme Toggle] --> B[ThemeContext update]\n  B --> C[UI re-render with new colors]\n  C --> D[Persist to AsyncStorage]\n  D --> E[Load on startup]","difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Meta","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T07:59:13.355Z","createdAt":"2026-01-26T07:59:13.355Z"},{"id":"q-7738","question":"You're building a real-time analytics dashboard in React Native that streams JSON events from a remote server. Design a cross-platform native module (TurboModule/JSI) in Rust that buffers incoming events on a dedicated background thread, implements backpressure by dropping oldest events when the buffer is full, and exposes a hook useEventStream(endpoint,{Hz,bufSize}) => { event, ts }. Provide a minimal frontend usage snippet and a sparkline UI sketch. Discuss latency, memory, and security implications?","answer":"Built a cross-platform Rust TurboModule that buffers JSON events on a dedicated background thread using a fixed-size ring buffer. It drops oldest events when full to apply backpressure, and exposes us","explanation":"## Why This Is Asked\n\nAssesses cross-language bridging (Rust with React Native), a streaming data path, and backpressure handling with concrete performance and security trade-offs.\n\n## Key Concepts\n\n- TurboModules/JSI bridging\n- Rust background thread and fixed-size ring buffer\n- Backpressure: drop oldest when buffer full\n- Efficient JSON parsing with minimal copies\n- Sparkline rendering integration and latency budgeting\n\n## Code Example\n\n```javascript\nimport { useEventStream } from 'react-native-native-bridge';\nfunction MetricsSparkline({ endpoint }) {\n  const { event, ts } = useEventStream(endpoint, { Hz: 60, bufSize: 256 });\n  // render sparkline from last 256 events\n  return <Sparkline data={/* derived from event series */} />\n}\n```\n\n## Follow-up Questions\n\n- How would you test latency under network jitter and packet loss?\n- How would you extend to multiple concurrent streams with per-stream backpressure?\n","diagram":null,"difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Slack","Twitter","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T15:47:09.932Z","createdAt":"2026-01-26T15:47:09.932Z"},{"id":"q-7951","question":"Design a cross-platform background task runner in a React Native app used by Coinbase, Netflix, and Tesla that executes CPU-heavy computations off the JS thread using a native Rust core bridged via TurboModules. API: useBackgroundTask({ taskId, type, payload }) -> Promise<{ result, finishedAt }>, cancelTask(taskId), onProgress(taskId, pct). Explain scheduling, memory budgeting, sandboxing, cancellation semantics, and error handling. Provide a minimal TS usage snippet and a small native module sketch?","answer":"Implement a Rust-core worker pool exposed through a TurboModule. API: useBackgroundTask({taskId,type,payload}) -> Promise<{result,finishedAt}>, cancelTask(taskId), onProgress(taskId, pct). Schedule CPU-heavy tasks using priority queues with fair-share allocation across apps. Implement per-task memory budgets via Rust's allocator limits and process isolation. Cancellation uses atomic flags with immediate worker termination. Errors propagate through structured Result types with platform-specific mapping.","explanation":"## Why This Is Asked\nReal-world apps need heavy computations off the JS thread to preserve UI responsiveness. A cross-platform Rust core with a TurboModule bridge tests low-level threading, memory budgets, and error handling across iOS/Android.\n\n## Key Concepts\n- TurboModule bridge with a Rust core\n- Per-task worker pool and scheduling policy\n- Per-task memory budgets and sandboxing\n- Deterministic cancellation and timeout handling\n- Structured error propagation and observability\n\n## Code Example\n```javascript\n// usage example\nimport { useBackgroundTask } from './nativeBackground';\nasync function runHeavyComputation() {\n  const { result, finishedAt } = await useBackgroundTask({\n    taskId: 'crypto-analysis',\n    type: 'cpu-heavy',\n    payload: { data: largeDataSet }\n  });\n  return result;\n}\n```","diagram":"flowchart TD\n  A[React Native (JS)] --> B[TurboModule Bridge]\n  B --> C[Rust Worker Pool]\n  C --> D[Result to JS]\n  B --> E[Progress Updates]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Netflix","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T05:51:14.117Z","createdAt":"2026-01-27T02:34:42.091Z"},{"id":"q-8033","question":"Design a cross-platform native module bridged to React Native that generates on-device image thumbnails. The module should take a list of image URIs, a target thumbnail size, and output thumbnails asynchronously on a worker thread, with a JS hook useImageThumbs({ uris, size, quality }) => { thumbs, progress, error }. Include a minimal React Native UI sketch and discuss memory usage, cache strategy, and Android/iOS parity?","answer":"On iOS, use CGImageSourceCreateThumbnailAtIndex with maxDimension; on Android, use BitmapFactory.Options.inSampleSize and Bitmap.createScaledBitmap. Run on a background thread; support cancelation; st","explanation":"## Why This Is Asked\nTests bridging, threading, and practical image processing in RN without blocking the UI.\n\n## Key Concepts\n- Native modules bridged to React Native\n- Background work and cancelation\n- Cross-platform image thinning: iOS CG APIs vs Android Bitmap APIs\n- Memory budgets and caching for thumbnails\n\n## Code Example\n```javascript\n// useImageThumbs hook skeleton\nimport { NativeModules, NativeEventEmitter } from 'react-native';\nconst { ImageThumbModule } = NativeModules;\nexport function useImageThumbs({ uris, size, quality }) {\n  // Implementation would subscribe to native events and manage state\n  return { thumbs: [], progress: 0, error: null };\n}\n```\n\n## Follow-up Questions\n- How would you handle progressive loading vs batch completion and cancelation across platforms?\n- How would you validate memory usage under low-memory conditions and adjust cache sizing?","diagram":null,"difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Meta","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T06:54:43.784Z","createdAt":"2026-01-27T06:54:43.784Z"},{"id":"q-8078","question":"Design a beginner-level pattern: implement useLocationWithBatteryGuard() that adapts location polling intervals based on battery level and AppState, and build a simple LocationList UI showing live coords and a sparkline. Explain your API choices, interval strategy, permission handling, and how you test power vs accuracy trade-offs?","answer":"Create useLocationWithBatteryGuard() that uses AppState to pause in background and getBatteryLevel() to map to intervals (1s >80%, 5s 20–80%, 15s <20%). Wire a LocationProvider that feeds coords to Lo","explanation":"## Why This Is Asked\n\nAssess practical power-aware location handling in RN apps, using AppState and battery APIs, plus a simple UI.\n\n## Key Concepts\n\n- AppState\n- Battery level access\n- Polling strategies\n- Permissions (LOCATION)\n\n## Code Example\n\n```javascript\nimport { useEffect, useState } from 'react';\nimport { AppState } from 'react-native';\nimport { getBatteryLevel } from 'react-native-device-info';\n\nfunction useLocationWithBatteryGuard() {\n  const [coords, setCoords] = useState(null);\n  useEffect(() => {\n    let interval = null;\n    const determineInterval = async () => {\n      const lvl = await getBatteryLevel();\n      if (lvl > 0.8) return 1000;\n      if (lvl > 0.2) return 5000;\n      return 15000;\n    };\n    const start = async () => {\n      const ms = await determineInterval();\n      interval = setInterval(() => {\n        // request location here\n      }, ms);\n    };\n    start();\n    const subscription = AppState.addEventListener('change', async (state) => {\n      if (state === 'background') clearInterval(interval);\n      else {\n        const ms = await determineInterval();\n        interval = setInterval(() => {\n          // request location here\n        }, ms);\n      }\n    });\n    return () => {\n      clearInterval(interval);\n      subscription.remove();\n    };\n  }, []);\n  return coords;\n}\n```\n\n## Follow-up Questions\n\n- How would you test this on real devices?\n- How would you adjust for location permission revocation at runtime?\n- How would you handle rapid battery level changes during a session?","diagram":"flowchart TD\n  A[Start] --> B[Check AppState]\n  B --> C{Foreground?}\n  C -- Yes --> D[Check battery level]\n  D --> E[Set polling interval]\n  E --> F[Poll location]\n  F --> G[Render UI]\n  G --> H[On background stop]\n","difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Netflix","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T08:46:35.174Z","createdAt":"2026-01-27T08:46:35.174Z"},{"id":"q-8144","question":"Design a beginner-friendly React Native feature for a city bike app: implement a FlatList that shows nearby bikes fetched from a mock API, add pull-to-refresh and infinite scrolling, and expose a custom hook useNearbyBikes returning { bikes, loading, error, refresh, loadMore }; how would you structure the data model, error handling, and offline caching with AsyncStorage?","answer":"Implement a custom hook useNearbyBikes that fetches from a mocked API and returns { bikes, loading, error, refresh, loadMore }. Bind a FlatList to bikes with keyExtractor and renderItem showing name a","explanation":"## Why This Is Asked\nTests basic RN data flow and user interaction: list rendering, simple data fetching, basic offline caching, and clear error paths in a city-bike context.\n\n## Key Concepts\n- FlatList basics: keyExtractor, renderItem, onRefresh, onEndReached\n- Custom hooks for data fetch\n- AsyncStorage offline caching\n- Basic error handling and user feedback\n\n## Code Example\n```javascript\n// useNearbyBikes hook (simplified)\nexport function useNearbyBikes() {\n  const [bikes, setBikes] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [page, setPage] = useState(1);\n\n  const fetchBikes = async (refresh = false) => {\n    setLoading(true);\n    try {\n      const res = await fetch(`/mock/nearby-bikes?page=${refresh ? 1 : page}`);\n      const data = await res.json();\n      setBikes(prev => refresh ? data : [...prev, ...data]);\n      // store to AsyncStorage would be here\n    } catch (e) {\n      setError(e);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => { fetchBikes(true); }, []);\n  return { bikes, loading, error, refresh: () => fetchBikes(true), loadMore: () => { setPage(p => p + 1); fetchBikes(false); } };\n}\n```\n\n## Follow-up Questions\n- How would you test onRefresh and onEndReached edge cases?\n- How would you mock location and handle permissions to influence nearby results?","diagram":"flowchart TD\n  A[Start] --> B[Fetch nearby bikes]\n  B --> C[Render FlatList]\n  C --> D[Pull-to-refresh]\n  D --> E[Refresh data]\n  C --> F[Endless scroll]\n  F --> B","difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T11:31:26.085Z","createdAt":"2026-01-27T11:31:26.088Z"},{"id":"q-8283","question":"In a React Native app targeting Apple platforms, design a cross‑platform native module (JSI/TurboModule) that performs real‑time GPU‑accelerated denoising on video frames and exposes useImageDenoise({ enabled, resolution, strength }) => { frameStream } consumed by a VideoPreview component. Discuss multi‑window lifecycle on macOS, latency budgets, memory pressure, and privacy implications, and provide a minimal UI sketch to toggle denoise and adjust strength?","answer":"Implement as a TurboModule using Metal on Apple platforms to run real‑time denoising in a dedicated native thread. Expose useImageDenoise({ enabled, resolution, strength }) => { frameStream } (JSI bri","explanation":"## Why This Is Asked\nTests bridging, hardware‑accelerated processing, and platform lifecycle. It verifies understanding of on‑device privacy and energy use in a realistic Apple‑centric RN app.\n\n## Key Concepts\n- TurboModule/JSI integration with Metal\n- GPU‑accelerated image processing\n- Frame streaming with backpressure\n- macOS multi‑window lifecycle\n- Privacy: on‑device processing only\n\n## Code Example\n```javascript\nimport { NativeModules, useEffect } from 'react-native';\nconst { ImageDenoise } = NativeModules;\nexport function useImageDenoise(opts){ /* hook wiring frameStream to UI */ }\n```\n\n## Follow-up Questions\n- How would you test frame backpressure under memory pressure?\n- How would you adapt the API for camera capture vs playback workflows?","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Coinbase","Databricks"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T18:00:22.097Z","createdAt":"2026-01-27T18:00:22.097Z"},{"id":"q-8308","question":"In a React Native app for finance, design a cross-platform native module that streams incremental on-device AI inference results from an anomaly detector. Expose useAIDelegateStream({ Hz, bufSize }) => { token, score, ts }, run on a dedicated native thread, implement backpressure that drops oldest items when full, and provide a minimal UI sparkline to visualize scores. Discuss latency, memory, battery, and privacy trade-offs?","answer":"Design a cross-platform native module (iOS/Android) streaming incremental AI inference results for an on-device anomaly detector in RN. Bridge via JSI/TurboModules, run on a dedicated thread, expose u","explanation":"## Why This Is Asked\n\nTests ability to design a tight native bridge for streaming AI in RN, handling threading and backpressure.\n\n## Key Concepts\n\n- Cross-platform native module (JSI/TurboModules)\n- Dedicated native thread and thread safety\n- Ring buffer backpressure and latency trade-offs\n- Privacy implications of on-device inference\n\n## Code Example\n\n```javascript\n// Pseudo usage\nconst { token, score, ts } = await useAIDelegateStream({ Hz: 10, bufSize: 128 });\n```\n\n## Follow-up Questions\n\n- How would you test backpressure behavior under burst input?\n- How would you expose model selection and hot-swap without restarting streams?\n","diagram":"flowchart TD\n  RN[React Native] --> Bridge[JSI/TurboModule Bridge]\n  Bridge --> NativeThread[Native Thread]\n  NativeThread --> Buffer[Ring Buffer]\n  Buffer --> RNJS[React Native JS]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","LinkedIn","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T19:22:13.417Z","createdAt":"2026-01-27T19:22:13.417Z"},{"id":"q-8343","question":"In a React Native delivery app, implement a cross-platform native module using a motion sensor bridge that detects a simple 'stop' gesture (pause + device on desk) from accelerometer/gyroscope data and streams events to React Native as { gesture, ts, confidence }. Expose startGestureDetection({ intervalMs, sensitivity }) and stopGestureDetection(), plus a hook useGestureStream() and a minimal UI demo. Include battery/privacy trade-offs?","answer":"Implement a TurboModule bridge to iOS CoreMotion and Android SensorManager, run a lightweight gesture detector on a dedicated worker thread, emit events {gesture, ts, confidence}. Hook useGestureStrea","explanation":"## Why This Is Asked\n\nTests ability to design a real native module bridge with a practical user-facing feature that is beginner-friendly yet shows core concepts: bridging, event streams, and energy/privacy tradeoffs.\n\n## Key Concepts\n\n- React Native TurboModules and native bridges\n- Sensor data handling and lightweight gesture detection\n- Event emitters and backpressure for streams\n- Battery life considerations and user privacy\n\n## Code Example\n\n```javascript\n// skeleton: useGestureStream hook\nimport { useEffect, useState } from 'react'\n\nexport function useGestureStream(opts) {\n  const [data, setData] = useState(null)\n  useEffect(() => {\n    const sub = NativeModules.MotionBridge.onGesture((e) => setData(e))\n    MotionBridge.startGestureDetection(opts)\n    return () => { MotionBridge.stopGestureDetection(); sub.remove() }\n  }, [opts])\n  return data\n}\n```\n\n## Follow-up Questions\n\n- How would you test for false positives in a device- and OS-variant environment?\n- How would you measure the energy impact and optimize?\n","diagram":"flowchart TD\n  A[Start] --> B[Init bridge]\n  B --> C[Receive sensor frames]\n  C --> D[Gesture detector]\n  D --> E[Emit events]\n","difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Coinbase"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T20:43:06.739Z","createdAt":"2026-01-27T20:43:06.739Z"},{"id":"q-8417","question":"You’re building a React Native app that streams live camera frames to compute a real-time exposure histogram. Implement a cross-platform native module bridged to React Native that exposes useExposureHistogram({ enabled, frameRate, region }) => { histogram, ts }, and a MinimalHistogramView for a 256-bin sparkline. Discuss backpressure, battery, privacy, and how you’d test on-device performance?","answer":"Implement a cross-platform TurboModule that leverages CameraX on Android and AVFoundation on iOS to capture live camera frames on a dedicated background thread. Compute a 256-bin luminance histogram for each frame, applying optional region-of-interest cropping. The module exposes a React Native hook `useExposureHistogram({ enabled, frameRate, region }) => { histogram, ts }` that streams histogram data with timestamps at the specified frame rate. Include a lightweight `MinimalHistogramView` component that renders a 256-bin sparkline visualization using React Native's native view primitives for optimal performance. Implement frame skipping and buffering strategies to handle backpressure when processing can't keep up with camera input.","explanation":"## Why This Is Asked\n\nTests ability to design and integrate real-time, cross-platform native modules while handling performance constraints, privacy considerations, and device-specific optimizations for camera-derived data streams.\n\n## Key Concepts\n\n- Cross-platform native modules (TurboModule/JSI)\n- Real-time data pipelines and backpressure handling\n- Memory and battery optimization for per-frame processing\n- Privacy-first design: on-device processing without data persistence\n- Camera API integration (CameraX/AVFoundation)\n- Background thread processing for UI responsiveness\n\n## Code Example\n\n```javascript\n// Usage sketch\nfunction MyHistogram() { \n  const { histogram, ts } = useExposureHistogram({ \n    enabled: true, \n    frameRate: 15, \n    region: { x: 0, y: 0, width: 1, height: 1 } \n  });\n  \n  return <MinimalHistogramView histogram={histogram} />;\n}\n```\n\n## Performance Considerations\n\n**Backpressure**: Implement frame dropping when processing queue exceeds threshold, use circular buffers for histogram data, and expose configurable quality tiers to balance accuracy vs. throughput.\n\n**Battery Impact**: Limit frame rates based on battery level, pause processing when app is backgrounded, and use hardware-accelerated histogram computation where available.\n\n**Privacy**: Process all data on-device with no network transmission, automatically clear histogram buffers when disabled, and ensure camera permissions are properly scoped.\n\n**Testing**: Use React Native's built-in performance monitoring, test on target devices with varying hardware capabilities, and implement custom performance metrics for frame processing latency and memory usage.","diagram":null,"difficulty":"intermediate","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","PayPal","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-28T04:48:48.908Z","createdAt":"2026-01-27T23:40:36.442Z"},{"id":"q-8442","question":"In a React Native offline-first task app, design a small cross-platform native module wrapping SQLite with API addTask({id, text, done}) and getTasks() that returns Promise<Task[]>, plus initSchema() to create tables. Provide a minimal RN wrapper and a UI snippet to add/list tasks. Outline migrations, data types, threading, and error handling?","answer":"Design a lightweight native module (RNSQLite) that bridges iOS and Android to SQLite. Implement initSchema() to create a tasks table with columns (id TEXT PRIMARY KEY, text TEXT, done INTEGER, timestamp INTEGER), addTask({id, text, done}) and getTasks() as Promise-based methods with proper error handling and background threading.","explanation":"## Why This Is Asked\nTests the ability to design a cross-platform native module for offline data storage with minimal surface area—a common requirement in production apps. Probes understanding of SQLite data modeling, migrations, and React Native bridging fundamentals.\n\n## Key Concepts\n- React Native bridging: Promises, threading, error handling\n- Local storage: SQLite schema design and migrations\n- Data mapping: JavaScript booleans/strings to SQL data types\n- Offline-first considerations and testability\n\n## Code Example\n```javascript\n// RN wrapper sketch\nimport { NativeModules } from 'react-native';\nconst { RNSQLite } = NativeModules;\nexport function addTask(task) { return RNSQLite.","diagram":null,"difficulty":"beginner","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Instacart","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-28T05:50:50.178Z","createdAt":"2026-01-28T02:38:24.584Z"},{"id":"q-8497","question":"Design a cross-platform native module for React Native that enables deterministic input replay for accessibility testing. It should record/timestamp touch events (single and multi-touch) on iOS and Android, run on a dedicated native thread, expose useInputReplay(roomId, { Hz, bufSize }) => { event, ts }, and provide a minimal React Native UI snippet to replay captured events on a canvas. Include backpressure by dropping oldest events to keep latency low and discuss memory, security, and jitter implications?","answer":"Core approach: implement a TurboModule with a native ring buffer capturing touch events (single/multi-touch) from iOS and Android on a dedicated thread. Expose useInputReplay(roomId,{Hz,bufSize}) => {","explanation":"## Why This Is Asked\nTests knowledge of cross-platform native modules, real-time data streams, and replay semantics under memory constraints and privacy concerns. It checks ability to design deterministic input capture, backpressure strategies, and a minimal UI integration.\n\n## Key Concepts\n- TurboModules/JSI bridging\n- Native threading and a ring buffer\n- Touch event model (single/multi-touch)\n- Backpressure and latency trade-offs\n- Privacy and security in on-device data handling\n\n## Code Example\n```javascript\nfunction ReplayCanvas({roomId}){\n  const {events, ready} = useInputReplay(roomId, { Hz: 60, bufSize: 1024 });\n  // render events on a canvas as a sparkline-like trace\n  return null;\n}\n```\n\n## Follow-up Questions\n- How would you test latency and determinism across iOS/Android under background/Doze states?\n- How would you handle clock drift and device sleep/wake scenarios to preserve replay fidelity?","diagram":"flowchart TD\n  A[Input Event] --> B[Native Ring Buffer]\n  B --> C[JSI Bridge]\n  C --> D[React Native JS]\n  D --> E[Replay UI]","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Hugging Face","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-28T05:52:41.697Z","createdAt":"2026-01-28T05:52:41.697Z"},{"id":"q-183","question":"What are Native Modules in React Native, when should you use them, and what are the key performance and threading considerations?","answer":"Native Modules bridge JavaScript and native code to access platform-specific APIs not available in JS. Use for Bluetooth, biometrics, camera controls, or performance-critical operations. Consider bridge overhead, threading model (main vs background), and async communication patterns.","explanation":"## Core Purpose\nNative Modules enable access to platform-specific APIs and performance-critical operations not available in JavaScript, creating a bridge between JS and native iOS/Android code.\n\n## When to Use\n**Ideal scenarios:**\n- Bluetooth/Peripheral communication\n- Biometric authentication\n- Advanced camera controls\n- Custom hardware integration\n- CPU-intensive calculations\n\n**When NOT to use:**\n- Simple UI operations\n- Basic storage needs\n- Network requests (use fetch/axios)\n- When JS performance is sufficient\n\n## Performance Considerations\n**Bridge Overhead:** Each async call crosses the bridge with serialization cost. Batch operations when possible.\n\n**Threading Model:**\n- Native modules run on main thread by default\n- Use background threads for heavy computations\n- JS thread must never block\n\n**Memory Management:**\n- Clean up native resources in dealloc\n- Avoid memory leaks across bridge\n- Use proper promise/reject patterns\n\n## Code Example\n```java\n// Android native module\n@ReactMethod\npublic Promise performHeavyComputation(Promise promise) {\n  new Thread(() -> {\n    try {\n      String result = heavyCalculation();\n      promise.resolve(result);\n    } catch (Exception e) {\n      promise.reject(\"ERROR\", e.getMessage());\n    }\n  }).start();\n}\n```\n\n## Real-World Applications\n- **Airbnb:** Custom camera filters\n- **Discord:** Voice chat integration\n- **Uber:** Location services optimization\n- **Spotify:** Audio processing modules","diagram":"flowchart TD\n  A[JavaScript Code] --> B[React Native Bridge]\n  B --> C[Native Module]\n  C --> D[Platform API]\n  D --> E[Hardware/OS Features]\n  E --> F[Native Module]\n  F --> B\n  B --> A","difficulty":"beginner","tags":["native","bridge"],"channel":"react-native","subChannel":"native-modules","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":["native modules","bridge","threading model","async communication","platform-specific apis","performance","background threads"],"voiceSuitable":true,"isNew":false,"lastUpdated":"2025-12-27T05:47:47.542Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-206","question":"How would you optimize React Native list performance with Hermes and Reanimated when dealing with 10k+ items containing complex animations?","answer":"Implement a FlatList with getItemLayout for predictable heights, memoized render items using React.memo, Reanimated 2 shared values for UI-thread animations, Hermes bytecode optimization for faster JavaScript execution, and eliminate inline functions to prevent unnecessary re-renders.","explanation":"## Concept Overview\nOptimizing large-scale React Native lists requires a multi-faceted approach addressing JavaScript execution efficiency, layout calculation optimization, and animation performance management.\n\n## Implementation Details\n- **FlatList Optimization**: Configure `getItemLayout` for predictable item heights, enable `removeClippedSubviews` for memory efficiency, and tune `maxToRenderPerBatch` for balanced rendering\n- **Hermes Engine Benefits**: Leverage bytecode precompilation for faster startup times, reduced memory footprint for better performance on low-end devices, and optimized JavaScript execution\n- **Reanimated 2 Integration**: Utilize `useSharedValue` for state management and `useAnimatedStyle` for UI-thread animations, preventing main thread blocking\n- **Memoization Strategy**: Apply `React.memo` to prevent unnecessary re-renders and `useCallback` for stable function references\n\n## Code Example\n```javascript\nconst OptimizedListItem = React.memo(({ item, sharedValue }) => {\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: sharedValue.value }]\n  }));\n  \n  return (\n    <Animated.View style={[styles.item, animatedStyle]}>\n      <Text>{item.title}</Text>\n    </Animated.View>\n  );\n});\n\nconst renderItem = useCallback(({ item }) => (\n  <OptimizedListItem item={item} sharedValue={scaleShared} />\n), []);\n\nreturn (\n  <FlatList\n    data={largeDataSet}\n    renderItem={renderItem}\n    getItemLayout={(data, index) => ({\n      length: ITEM_HEIGHT,\n      offset: ITEM_HEIGHT * index,\n      index,\n    })}\n    removeClippedSubviews\n    maxToRenderPerBatch={10}\n    windowSize={10}\n  />\n);\n```","diagram":"flowchart LR\n    A[10k+ Data Items] --> B[FlatList with getItemLayout]\n    B --> C[Memoized ListItem Components]\n    C --> D[Reanimated Shared Values]\n    D --> E[UI Thread Animations]\n    E --> F[Hermes Bytecode Execution]\n    F --> G[Optimized Rendering Pipeline]\n    \n    H[removeClippedSubviews] --> I[Reduced Memory Usage]\n    J[maxToRenderPerBatch] --> K[Controlled Rendering]\n    L[React.memo] --> M[Prevented Re-renders]\n    \n    I --> G\n    K --> G\n    M --> G","difficulty":"advanced","tags":["hermes","reanimated","profiling"],"channel":"react-native","subChannel":"performance","sourceUrl":null,"videos":{"longVideo":"https://www.youtube.com/watch?v=a2HkkkisIAg"},"companies":["Airbnb","Coinbase","Meta","Microsoft","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-08T11:23:07.594Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-233","question":"How does the Hermes engine improve React Native app startup performance compared to JavaScriptCore, and what are the specific trade-offs?","answer":"Hermes uses ahead-of-time (AOT) compilation to convert JavaScript to optimized bytecode during build time, reducing startup by 30-50% and memory usage by 20-30% compared to JavaScriptCore's just-in-time (JIT) compilation. It pre-compiles functions, eliminating parsing overhead at runtime, and uses a more compact bytecode format. Trade-offs include longer build times, larger bundle sizes, and potentially slower execution for dynamically generated code.","explanation":"## Core Architecture Differences\n\n**JavaScriptCore (JIT)**:\n- Parses and compiles JavaScript at runtime\n- Uses baseline JIT, then optimizes hot code paths\n- Higher initial overhead but better for dynamic patterns\n\n**Hermes (AOT)**:\n- Compiles to optimized bytecode during build\n- No runtime parsing or compilation\n- Smaller memory footprint and faster initialization\n\n## Performance Impact\n\n```javascript\n// Bundle size comparison (typical app)\nJSC Bundle: ~1.2MB  + runtime compilation\nHermes Bundle: ~800KB (bytecode) + minimal runtime\n\n// Startup time benchmarks\nTime to Interactive:\n- JSC: 1.8-2.2s\n- Hermes: 0.9-1.4s\n```\n\n## Memory Usage\n\nHermes reduces memory usage through:\n- Pre-allocated memory pools\n- Efficient bytecode execution\n- No JIT compiler memory overhead\n- Conservative garbage collection\n\n## Trade-offs and Considerations\n\n**Advantages**:\n- Faster cold start performance\n- Lower memory consumption\n- Predictable performance (no JIT warmup)\n- Better crash rates in production\n\n**Limitations**:\n- Longer build times (AOT compilation)\n- Larger initial bundle size\n- Slower for eval() and dynamic imports\n- Limited debugging capabilities\n\n## Implementation\n\n```json\n// metro.config.js\n{\n  \"transformer\": \"metro-react-native-babel-transformer\",\n  \"resolver\": {\n    \"resolverMainFields\": [\"react-native\", \"browser\", \"main\"]\n  },\n  \"engines\": {\n    \"hermes\": true\n  }\n}\n```\n\n## When to Choose Hermes\n\n- **Production apps** prioritizing startup performance\n- **Memory-constrained devices** (entry-level phones)\n- **Apps with stable codebase** (limited dynamic code)\n- **Large user bases** where performance consistency matters\n\n## When JavaScriptCore Might Be Better\n\n- **Development environments** with frequent hot reloads\n- **Apps heavy on dynamic code generation**\n- **Debugging-intensive development**\n- **Prototype or experimental features**\n\nReal-world data from Facebook's internal testing shows Hermes reduces crash rates by 25% and improves user retention through faster app initialization, making it the preferred choice for production React Native applications.","diagram":"flowchart LR\n    A[JavaScript Source] --> B[Metro Bundler]\n    B --> C[Hermes AOT Compilation]\n    C --> D[Bytecode Bundle]\n    D --> E[App Installation]\n    E --> F[Faster Startup]\n    F --> G[Hermes Runtime]\n    G --> H[Native Bridge]","difficulty":"beginner","tags":["hermes","reanimated","profiling"],"channel":"react-native","subChannel":"performance","sourceUrl":null,"videos":null,"companies":["Airbnb","Meta","Microsoft","Netflix","Salesforce","Shopify"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-26T16:36:41.195Z","createdAt":"2025-12-26 12:51:07"}],"subChannels":["general","native-modules","performance"],"companies":["Adobe","Airbnb","Amazon","Anthropic","Apple","Bloomberg","Citadel","Cloudflare","Coinbase","Databricks","Discord","DoorDash","Goldman Sachs","Google","Hashicorp","Hugging Face","IBM","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Netflix","OpenAI","Oracle","PayPal","Plaid","Robinhood","Salesforce","Scale Ai","Shopify","Slack","Snap","Snowflake","Square","Stripe","Tesla","Twitter","Two Sigma","Uber","Zoom"],"stats":{"total":88,"beginner":25,"intermediate":25,"advanced":38,"newThisWeek":40}}