{"questions":[{"id":"q-464","question":"How would you implement a custom UICollectionViewFlowLayout that supports dynamic cell heights and sticky headers while maintaining smooth scrolling performance?","answer":"Use `prepare()` to calculate attributes, cache them in a dictionary, and implement `shouldInvalidateLayout(forBoundsChange:)` to handle sticky headers. Optimize with `estimatedItemSize` and avoid expe","explanation":"## Key Implementation Steps\n\n- Override `prepare()` to calculate and cache layout attributes\n- Implement `layoutAttributesForElements(in:)` for visible elements\n- Use `shouldInvalidateLayout(forBoundsChange:)` for sticky headers\n- Set `estimatedItemSize` for dynamic heights\n\n## Performance Optimizations\n\n- Cache calculations to avoid repeated work\n- Use `UICollectionViewFlowLayoutInvalidationContext` for targeted updates\n- Implement `targetContentOffset(forProposedContentOffset:)` for smooth scrolling\n\n## Common Pitfalls\n\n- Don't perform expensive calculations in `layoutAttributesForElements(in:)`\n- Handle rotation and size changes properly\n- Manage memory for cached attributes","diagram":"flowchart TD\n  A[prepare() - Calculate Attributes] --> B[Cache in Dictionary]\n  B --> C[layoutAttributesForElements]\n  C --> D[shouldInvalidateLayout]\n  D --> E[Sticky Headers Logic]\n  E --> F[Smooth Scrolling]","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Lyft","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"lastUpdated":"2025-12-24T02:46:33.607Z","createdAt":"2025-12-26 12:51:05"},{"id":"q-495","question":"How would you implement a simple UITableView with custom cells in iOS using Swift?","answer":"Create a UITableViewCell subclass, register it with tableView.register(UITableViewCell.self, forCellReuseIdentifier: \"cell\"), implement UITableViewDataSource methods (numberOfRowsInSection, cellForRow","explanation":"## Implementation Steps\n- Create custom UITableViewCell class with outlets\n- Register cell class or nib with table view\n- Implement UITableViewDataSource protocol\n- Configure cells in cellForRowAt method\n- Handle cell selection and data updates\n\n## Key Concepts\n- Reusable cell pattern for performance\n- Delegation pattern for table view events\n- Auto Layout for cell sizing\n- Data source management","diagram":"flowchart TD\n  A[Create Custom Cell] --> B[Register Cell]\n  B --> C[Implement DataSource]\n  C --> D[Configure Cell]\n  D --> E[Handle Selection]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Oracle","Snowflake","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"lastUpdated":"2025-12-27T04:55:26.244Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-525","question":"You're building a food delivery app like DoorDash. How would you implement background location updates to track delivery drivers while balancing battery life and accuracy?","answer":"Use CLLocationManager with significantLocationChangeMonitoring for battery efficiency, switching to standard location updates during active deliveries. Implement region-based geofencing for restaurant","explanation":"## Background Location Strategy\n\n- **significantLocationChangeMonitoring**: Battery-efficient for idle drivers\n- **Standard location updates**: High accuracy during active deliveries\n- **Geofencing**: CLRegion for restaurant/destination zones\n- **Deferred updates**: Batch location data to reduce wake-ups\n\n## Implementation Details\n\n```swift\nlet locationManager = CLLocationManager()\nlocationManager.allowsBackgroundLocationUpdates = true\nlocationManager.pausesLocationUpdatesAutomatically = true\nlocationManager.activityType = .otherNavigation\n```\n\n## Battery Optimization\n\n- Use desiredAccuracy = .kCLLocationBestForNavigation only when needed\n- Implement distanceFilter to reduce unnecessary updates\n- Consider using Core Motion for activity detection\n- Handle location updates in background task","diagram":"flowchart TD\n  A[Driver Idle] --> B[Significant Location Change]\n  B --> C{Delivery Accepted?}\n  C -->|Yes| D[Standard Location Updates]\n  C -->|No| B\n  D --> E[Active Navigation]\n  E --> F{Near Destination?}\n  F -->|Yes| G[Geofence Trigger]\n  F -->|No| E\n  G --> H[Delivery Complete]\n  H --> A","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Microsoft","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"lastUpdated":"2025-12-25T15:01:07.131Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-578","question":"What's the difference between weak and unowned references in Swift, and when would you use each?","answer":"Weak references are optional and become nil when the referenced object is deallocated. Unowned references are non-optional and assume the referenced object will always exist. Use weak for optional rel","explanation":"## Memory Management\n\nSwift uses ARC (Automatic Reference Counting) to manage memory. Strong references create retain cycles, so we use weak/unowned to break them.\n\n## Weak References\n\n- Always optional (automatically set to nil on deallocation)\n- Use for optional relationships\n- Common pattern: delegates, outlets\n\n```swift\nweak var delegate: MyDelegate?\n```\n\n## Unowned References\n\n- Non-optional (assumes reference always exists)\n- Use when you know the reference will outlive the holder\n- Common pattern: parent-child relationships\n\n```swift\nunowned let parent: ParentClass\n```\n\n## Key Differences\n\n- Weak: optional, safe, nil on deallocation\n- Unowned: non-optional, faster, crashes if accessed after deallocation","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"lastUpdated":"2025-12-27T01:13:27.377Z","createdAt":"2025-12-27T01:13:27.377Z"},{"id":"q-181","question":"Explain the difference between weak and unowned references in Swift and provide practical use cases for each?","answer":"weak: optional, nils automatically when object deallocates. unowned: non-optional, assumes object exists, crash if accessed after deallocation.","explanation":"## Why Asked\nTests memory management understanding and preventing retain cycles in iOS development\n## Key Concepts\n- Automatic Reference Counting (ARC)\n- Strong reference cycles\n- Optional vs non-optional references\n- Lifetime expectations\n## Code Example\n```\nclass Parent {\n    weak var child: Child?\n    unowned let partner: Parent\n}\n\n// weak: when object might become nil (e.g., delegates)\n// unowned: when object outlives reference (e.g., parent-child)\n```\n## Follow-up Questions\n- How do you identify retain cycles?\n- What happens when you access an unowned reference after deallocation?\n- When should you use strong references instead?","diagram":"flowchart TD\n  A[Object Created] --> B{Reference Type?}\n  B -->|May become nil| C[weak var]\n  B -->|Always exists| D[unowned]\n  C --> E[Becomes nil on deallocation]\n  D --> F[Crashes if accessed after deallocation]","difficulty":"intermediate","tags":["swift","language"],"channel":"ios","subChannel":"swift","sourceUrl":null,"videos":{"shortVideo":"https://www.youtube.com/watch?v=bMNwHNOVdXw","longVideo":"https://www.youtube.com/watch?v=8KQcTDGqQEc"},"companies":["Amazon","Apple","Google","Meta","Microsoft"],"eli5":"Imagine you're playing with building blocks! A 'weak' reference is like saying 'I'm looking at my friend's red block.' If your friend takes their block away, you just shrug and say 'Oh well, no red block anymore!' You don't cry or break anything. An 'unowned' reference is like saying 'I'm holding my friend's blue block and I KNOW it's there!' If your friend secretly takes the block away and you try to grab it, you'll trip and fall because you expected it to be there! Use weak references when you're just watching something that might disappear (like watching a toy car that might drive away). Use unowned references when you're absolutely sure something will stay there (like holding onto your mom's hand while crossing the street).","relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"lastUpdated":"2025-12-25T12:48:56.713Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-257","question":"What is optional chaining in Swift and how does it compare to force unwrapping, optional binding, and optional chaining with method calls when accessing nested optional properties?","answer":"Optional chaining (?.) safely unwraps optionals, returning nil if any link fails instead of throwing runtime errors. Unlike force unwrapping (!), it prevents crashes. It's more concise than if-let/guard-let for single access and works with methods, subscripts, and nested optionals like person?.address?.street?.count.","explanation":"## Core Concept\nOptional chaining (?.) provides a safe way to access properties, methods, and subscripts of optional values, returning nil if any part of the chain is nil.\n\n## Key Differences\n- **Force unwrapping (!)**: Crashes if nil\n- **Optional binding**: Requires separate if-let/guard-let blocks\n- **Optional chaining**: Single-line safe access\n\n## Code Examples\n```swift\n// Nested optionals\nlet streetCount = person?.address?.street?.count\n\n// Method calls with optional chaining\nlet result = optionalObject?.method()?.property\n\n// Subscript access\nlet value = dictionary?[key]?.nestedValue\n```\n\n## Performance & Best Practices\n- Slight overhead vs force unwrapping due to nil checks\n- Use when you need single access to deeply nested optionals\n- Prefer optional binding for multiple operations on the same value\n- Avoid excessive chaining that reduces code readability\n\n## Common Pitfalls\n- Forgetting that the result is always optional\n- Mixing with force unwrapping in the same chain\n- Not handling the nil case appropriately","diagram":"graph TD\n    A[person] --> B[residence?]\n    B --> C[address?]\n    C --> D[street: String]\n    \n    E[Optional Chaining ?. ] --> F{Check residence}\n    F -->|nil| G[Return nil]\n    F -->|exists| H{Check address}\n    H -->|nil| G\n    H -->|exists| I[Return street value]\n    \n    style G fill:#ffcccc\n    style I fill:#ccffcc","difficulty":"beginner","tags":["optionals","protocols","generics"],"channel":"ios","subChannel":"swift","sourceUrl":null,"videos":{"shortVideo":"https://www.youtube.com/watch?v=Hfpx494ess8","longVideo":"https://www.youtube.com/watch?v=S8-QO2wUbRg"},"companies":["Amazon","Apple","Google","Meta","Microsoft","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"lastUpdated":"2025-12-26T16:39:04.627Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-204","question":"How would you optimize a UITableView with 10,000+ complex cells using Auto Layout while maintaining 60fps scrolling and memory efficiency?","answer":"Use cell reuse, pre-calculate heights, implement heightForRowAt caching, and optimize Auto Layout constraints with manual layout when needed.","explanation":"## Concept Overview\nOptimizing large UITableViews requires balancing memory usage, rendering performance, and smooth scrolling. Auto Layout adds computational overhead that becomes critical at scale.\n\n## Implementation Details\n\n### Cell Reuse Strategy\n```swift\noverride func prepareForReuse() {\n    super.prepareForReuse()\n    // Reset expensive operations\n    imageView.image = nil\n    complexView.resetContent()\n}\n```\n\n### Height Caching System\n```swift\nprivate var heightCache: [IndexPath: CGFloat] = [:]\n\nfunc tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n    if let cached = heightCache[indexPath] {\n        return cached\n    }\n    let height = calculateHeight(for: indexPath)\n    heightCache[indexPath] = height\n    return height\n}\n```\n\n### Auto Layout Optimization\n- Use `setNeedsLayout()` instead of `layoutIfNeeded()`\n- Prefer `intrinsicContentSize` over complex constraints\n- Implement `systemLayoutSizeFitting` for height calculation\n\n### Memory Management\n- Use weak references for cell closures\n- Implement `didEndDisplaying` for cleanup\n- Consider async image loading with placeholder\n\n## Common Pitfalls\n- Not caching heights leads to expensive recalculations\n- Complex Auto Layout in cell configuration blocks\n- Memory leaks from strong reference cycles\n- Ignoring cell reuse lifecycle","diagram":"flowchart LR\n    A[User Scrolls] --> B[dequeueReusableCell]\n    B --> C{Height Cached?}\n    C -->|Yes| D[Use Cached Height]\n    C -->|No| E[Calculate Height]\n    E --> F[Cache Height]\n    F --> G[Configure Cell]\n    G --> H[Apply Constraints]\n    H --> I[Render Cell]\n    I --> J[Display]\n    D --> G","difficulty":"advanced","tags":["autolayout","tableview","collectionview"],"channel":"ios","subChannel":"uikit","sourceUrl":null,"videos":null,"companies":["Airbnb","Apple","Capital One","Lyft","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"lastUpdated":"2025-12-26T12:38:17.524Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-232","question":"How does Auto Layout constraint resolution work when creating a UITableView with dynamic cell heights?","answer":"Auto Layout resolves constraints by calculating required cell heights based on content, then UITableView applies these heights during layout.","explanation":"## Concept Overview\nAuto Layout constraint resolution is the process where iOS calculates the size and position of views based on their constraints. For UITableView with dynamic cells, this happens in two phases.\n\n## Implementation Details\n1. **System Layout Size Fitting**: UITableView calls `systemLayoutSizeFitting` on each cell prototype\n2. **Constraint Resolution**: Auto Layout engine resolves all constraints to determine cell height\n3. **Height Caching**: UITableView caches calculated heights for performance\n4. **Layout Application**: Heights are applied during the table view's layout pass\n\n## Code Example\n```swift\n// In UITableViewCell subclass\noverride func awakeFromNib() {\n    super.awakeFromNib()\n    // Enable auto-sizing\n    contentView.translatesAutoresizingMaskIntoConstraints = false\n}\n\n// In UITableViewController\ntableView.rowHeight = UITableView.automaticDimension\ntableView.estimatedRowHeight = 100\n```\n\n## Common Pitfalls\n- Missing `translatesAutoresizingMaskIntoConstraints = false`\n- Incomplete constraint chains leading to ambiguous layouts\n- Performance issues with complex constraint hierarchies\n- Not setting `estimatedRowHeight` causing layout delays","diagram":"graph TD\n    A[UITableView] --> B[Cell Prototype]\n    B --> C[Auto Layout Engine]\n    C --> D[Constraint Resolution]\n    D --> E[Height Calculation]\n    E --> F[Height Caching]\n    F --> G[Layout Application]\n    G --> H[Final Cell Display]","difficulty":"beginner","tags":["autolayout","tableview","collectionview"],"channel":"ios","subChannel":"uikit","sourceUrl":null,"videos":null,"companies":["Airbnb","Apple","Google","Meta","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"lastUpdated":"2025-12-27T04:55:46.823Z","createdAt":"2025-12-26 12:51:07"}],"subChannels":["general","swift","uikit"],"companies":["Airbnb","Amazon","Apple","Capital One","DoorDash","Google","Lyft","Meta","Microsoft","NVIDIA","Oracle","Snowflake","Stripe","Uber","Zoom"],"stats":{"total":8,"beginner":4,"intermediate":3,"advanced":1,"newThisWeek":8}}