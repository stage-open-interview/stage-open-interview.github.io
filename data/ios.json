{"questions":[{"id":"q-1064","question":"Design and implement a streaming app's episode grid using a UICollectionView with a compositional layout that supports dynamic item sizes, infinite scrolling, and efficient image caching; use a modern iOS approach (Diffable Data Source, NSCache, prefetching), ensure accessibility and testability?","answer":"Implement a UICollectionView grid for episodes using a compositional layout and a single diffable data source. Use NSCache to cache episode artwork, set up prefetching to load next pages, and implemen","explanation":"## Why This Is Asked\n\nTests practical experience building a robust iOS grid for streaming content, focusing on modern data sources, memory efficiency, and accessibility in a scalable way.\n\n## Key Concepts\n\n- UICollectionView with Diffable Data Source\n- UICollectionViewCompositionalLayout\n- Prefetching and infinite scrolling\n- Image caching with NSCache\n- Accessibility labels and testing strategies\n\n## Code Example\n\n```swift\n// Example diffable data source setup\nlet dataSource = UICollectionViewDiffableDataSource<Int, Episode>(collectionView: collectionView) { cv, indexPath, episode in\n  let cell = cv.dequeueReusableCell(withReuseIdentifier: \"EpisodeCell\", for: indexPath) as! EpisodeCell\n  cell.configure(with: episode)\n  return cell\n}\n```\n\n## Follow-up Questions\n\n- How would you handle memory pressure and invalidate cached images?\n- How would you test diffable data source updates and scrolling behavior?\n","diagram":null,"difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Netflix","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T21:23:50.063Z","createdAt":"2026-01-12T21:23:50.063Z"},{"id":"q-1164","question":"You're building a lightweight notes app for iOS. Implement a NotesEditor view (SwiftUI) that autosaves to disk as the user types, using a 500ms debounce. Persist to a local JSON file in the app's documents directory. Ensure rapid typing doesn't cause multiple disk writes, and provide a minimal unit test that verifies the file content is updated after a debounce period?","answer":"Implement a SwiftUI NotesEditor with a @Published note. Debounce saves to disk at 500ms using Combine: $note.debounce(for: .milliseconds(500), scheduler: RunLoop.main).sink { save(note) }. Persist by ","explanation":"## Why This Is Asked\nTests practical understanding of combining UI state with asynchronous persistence, a common real-world pattern.\n\n## Key Concepts\n- Combine debouncing for UI-driven writes\n- File I/O and JSON encoding in Swift\n- SwiftUI data flow and @Published bindings\n- Unit testing asynchronous code and filesystem writes\n\n## Code Example\n```swift\nimport Combine\nimport SwiftUI\n\nclass NotesStore: ObservableObject {\n  @Published var note: String = \"\"\n  private var cancellables = Set<AnyCancellable>()\n  init() {\n    $note\n      .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n      .sink { [weak self] text in\n        self?.save(text)\n      }\n      .store(in: &cancellables)\n  }\n  func save(_ text: String) {\n    let json = [\"note\": text]\n    if let data = try? JSONSerialization.data(withJSONObject: json, options: []) {\n      let url = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]\n        .appendingPathComponent(\"notes.json\")\n      try? data.write(to: url)\n    }\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test cancellation of a pending save when the app moves to background?\n- How would you extend to multi-note scenarios with conflict resolution?","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Google","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T03:30:46.016Z","createdAt":"2026-01-13T03:30:46.016Z"},{"id":"q-1185","question":"In an iOS app, you are displaying a feed of user avatars in a UICollectionView with infinite scrolling. Explain how you would implement incremental image loading that cancels obsolete requests, caches images both in memory and on disk, uses Swift concurrency for loading, and ensures smooth scrolling under memory pressure, including prefetching and memory-pressure handling strategies?","answer":"Use a two-tier cache and cancellable loading. Use NSCache for memory and a disk cache via FileManager. For each cell, spawn a Task tied to the cell's lifecycle; cancel on prepareForReuse. Load with UR","explanation":"## Why This Is Asked\n\nThis question tests practical image loading in a scrolling feed, covering cancellation semantics with cell reuse, multi-level caching, and Swift concurrency, plus handling memory pressure and prefetching.\n\n## Key Concepts\n\n- UICollectionView infinite scrolling\n- Memory and disk caching strategy\n- Swift concurrency and Task cancellation\n- Cell reuse and race condition handling\n- Prefetching and memory-pressure testing\n\n## Code Example\n\n```swift\nimport UIKit\n\nactor ImageCache {\n  private var memory = NSCache<NSString, UIImage>()\n  private let diskURL: URL\n  func load(_ url: URL) async -> UIImage? { ... }\n}\n```\n\n## Follow-up Questions\n\n- How would you measure scrolling smoothness and cache hit rate in production?\n- How would you adapt this for SwiftUI's AsyncImage?","diagram":"flowchart TD\n  A[Start] --> B[CellForItemAt]\n  B --> C[Check memory cache]\n  C -->|Hit| D[Bind image]\n  C -->|Miss| E[Check disk cache]\n  E -->|Hit| F[Decode & cache]\n  E -->|Miss| G[Network fetch]\n  G --> H[Decode & cache on disk & memory]\n  H --> I[Bind to cell]","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Bloomberg","Goldman Sachs"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T04:38:02.306Z","createdAt":"2026-01-13T04:38:02.307Z"},{"id":"q-1439","question":"In a recipe-list iOS app, implement a multi-select ingredient filter as tappable chips using UIKit. Given a static dataset of recipes with ingredients, create a chips bar that allows selecting multiple ingredients, a Clear button, and a table view that shows only recipes containing all selected ingredients. Ensure accessibility labels and VoiceOver order, and provide a simple unit test validating the filter logic?","answer":"I would model Recipe{name, ingredients}, store a static dataset, and build a ChipsView with a horizontal UICollectionView of UIButton chips. Maintain a Set<String> selected; tapping toggles a chip. Fi","explanation":"## Why This Is Asked\nAssesses ability to translate a UX requirement into a single view using UIKit, including state management, filtering logic, and accessibility. It also touches testing of business logic separate from UI.\n\n## Key Concepts\n- UIKit: UICollectionView for chips, UITableView for results\n- Data modeling with Structs, Sets, and filtering\n- Accessibility: labels, traits, and VoiceOver order\n- Testing: unit-test the filtering function independent of UI\n\n## Code Example\n```swift\nstruct Recipe {\n  let name: String\n  let ingredients: [String]\n}\n\nfunc filtered(_ recipes: [Recipe], by selected: Set<String>) -> [Recipe] {\n  guard !selected.isEmpty else { return recipes }\n  return recipes.filter { selected.isSubset(of: Set($0.ingredients)) }\n}\n```\n\n## Follow-up Questions\n- How would you scale this if the dataset grows to thousands of recipes?\n- How would you adapt this to SwiftUI and compare the data flow with UIKit?","diagram":"flowchart TD\n  A[Load dataset] --> B[Render chips]\n  B --> C{Chip tapped?}\n  C -->|Yes| D[Update selected set]\n  D --> E[Apply filter]\n  E --> F[Update results view]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Databricks","DoorDash"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T17:00:06.297Z","createdAt":"2026-01-13T17:00:06.297Z"},{"id":"q-1573","question":"Design a beginner iOS feature: a SwiftUI-based **Favorites** screen for a recipe app. It should load a predefined array of Recipe objects from a local JSON file, display in a single-column list, allow tapping to mark/unmark as favorite, persist favorites in **UserDefaults**, and provide a search bar to filter by name **case-insensitively**. Explain how you'd structure the model, storage, and UI, and how you'd test search and persistence?","answer":"Use MVVM with a Recipe model, decode JSON into Recipe structs, and store favorites as a Set of ids in @AppStorage (UserDefaults). Bind the list to an @Published filtered array driven by a search strin","explanation":"## Why This Is Asked\\n\\nAssesses ability to combine SwiftUI, local persistence, and simple filtering.\\n\\n## Key Concepts\\n- MVVM with SwiftUI\\n- Data binding and @Published\\n- Local persistence via JSON + UserDefaults\\n- Search filtering with case-insensitive comparison\\n- Testability of filtering and persistence\\n\\n## Code Example\\n```swift\\nstruct Recipe: Codable, Identifiable { let id: String; let name: String; var isFavorite: Bool }\\nclass RecipeViewModel: ObservableObject { @Published var recipes: [Recipe] = []; @Published var search = \\\"\\\"; var filtered: [Recipe] { recipes.filter { $0.name.lowercased().contains(search.lowercased()) } } @AppStorage(\\\"favorites\\\") var favorites: Set<String> = [] }\\n```\\n\\n## Follow-up Questions\\n- How would you scale to a larger dataset?\\n- How would you handle data refresh with a remote source","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Google","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T22:36:50.906Z","createdAt":"2026-01-13T22:36:50.906Z"},{"id":"q-1611","question":"Design and implement an offline-first notes feature for iOS: store locally in SQLite, use a simple CRDT-like merge or last-writer-wins with version vectors for conflict resolution, and sync changes via a WebSocket protocol, all in Swift using async/await. Include data model, conflict handling, and testing strategy?","answer":"Store notes locally in SQLite with per-note revision tracking and a change log; edits increment revision and emit deltas. Sync via WebSocket streaming with note ID, revision, delta, device ID, and timestamp. Resolve conflicts using last-writer-wins based on timestamps, with fallback to manual merge for simultaneous edits.","explanation":"## Why This Is Asked\n\nTests ability to design robust offline-first data synchronization using modern iOS paradigms, with explicit conflict resolution and test planning.\n\n## Key Concepts\n\n- SQLite local persistence with per-note revision and ChangeLog\n- Delta encoding and event streaming over WebSocket\n- Swift concurrency (async/await) for network and DB operations\n- Conflict resolution strategies: Last-Writer-Wins vs CRDT\n- Testing under intermittent connectivity and out-of-order delivery\n\n## Code Example\n\n```swift\nstruct Note: Identifiable, Codable {\n  let id: UUID\n  var content: String\n  var","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["OpenAI","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T05:30:06.361Z","createdAt":"2026-01-14T02:36:55.710Z"},{"id":"q-1681","question":"In an iOS SwiftUI app, build a minimal Notes editor screen: a multiline TextEditor bound to a string. Implement an autosave that triggers 1 second after the user stops typing, saving the draft to UserDefaults under the key 'noteDraft'. Load the draft on view appear. Include a tiny unit test that simulates typing and asserts the draft is saved after the debounce delay?","answer":"Bind a SwiftUI TextEditor to @State text. Implement onChange(text) to cancel a previous DispatchWorkItem and schedule a new one that calls saveDraft after 1 second. saveDraft writes to UserDefaults wi","explanation":"## Why This Is Asked\nTests ability to design simple, observable UI with a practical persistence pattern.\n\n## Key Concepts\n- SwiftUI TextEditor binding\n- Debounce using DispatchWorkItem\n- UserDefaults persistence\n- Lightweight unit testing of async behavior\n\n## Code Example\n```javascript\n// Swift-like pseudocode demonstrating debounce autosave\nclass NoteViewModel: ObservableObject {\n  @Published var text = \"\"\n  private var workItem: DispatchWorkItem?\n  func textChanged(_ newValue: String) {\n    text = newValue\n    workItem?.cancel()\n    let item = DispatchWorkItem { self.saveDraft() }\n    workItem = item\n    DispatchQueue.main.asyncAfter(deadline: .now() + 1.0, execute: item)\n  }\n  func saveDraft() {\n    UserDefaults.standard.set(text, forKey: \"noteDraft\")\n  }\n  func loadDraft() {\n    text = UserDefaults.standard.string(forKey: \"noteDraft\") ?? \"\"\n  }\n}\n```\n\n## Follow-up Questions\n- How would you extend to support multiple notes?  \n- How would you ensure autosave runs if the app goes to background?  \n- How would you test the debounce logic more deterministically?","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T06:53:06.062Z","createdAt":"2026-01-14T06:53:06.063Z"},{"id":"q-1718","question":"In a high-traffic iOS app for autonomous telemetry, describe a robust data pipeline that streams sensor data into local batches and uploads to cloud with offline queueing and crash recovery. Include how to handle backpressure, idempotency, and testing. Provide concrete Swift components and a minimal prototype?","answer":"Design a data pipeline: SensorFeed emits Data chunks; a Batcher groups into fixed-size batches with a batch nonce. UploadService uses URLSession with a background session, writes a persistent queue to","explanation":"## Why This Is Asked\nTests ability to design resilient, testable data pipelines under intermittent connectivity, with proper use of background tasks and on-device persistence.\n\n## Key Concepts\n- Background URLSession\n- Persisted queues and idempotent uploads\n- Backoff strategies with jitter\n- Deterministic testing via mocks\n\n## Code Example\n```swift\nimport Foundation\nclass UploadService {\n  static let shared = UploadService()\n  func enqueue(_ data: Data) { /*...*/ }\n}\n```\n\n## Follow-up Questions\n- How would you handle multiple device types with different background limits?\n- How would you measure battery impact and optimize?","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","NVIDIA","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T07:52:02.313Z","createdAt":"2026-01-14T07:52:02.313Z"},{"id":"q-464","question":"How would you implement a custom UICollectionViewFlowLayout that supports dynamic cell heights and sticky headers while maintaining smooth scrolling performance?","answer":"Override `prepare()` to pre-calculate and cache layout attributes in a dictionary for efficient access. Implement `shouldInvalidateLayout(forBoundsChange:)` to handle sticky header positioning, and use `estimatedItemSize` with automatic height calculation. Cache the results to avoid expensive recalculations during scrolling.","explanation":"## Key Implementation Steps\n\n- Override `prepare()` to calculate and cache layout attributes for all elements\n- Implement `layoutAttributesForElements(in:)` to return cached attributes for visible elements\n- Use `shouldInvalidateLayout(forBoundsChange:)` to manage sticky header behavior during scroll\n- Set `estimatedItemSize` to enable dynamic height calculation for variable content\n\n## Performance Optimizations\n\n- Cache calculations in memory to avoid repeated expensive operations\n- Use `UICollectionViewFlowLayoutInvalidationContext` for targeted layout updates instead of full invalidation\n- Implement `targetContentOffset(forProposedContentOffset:)` to ensure smooth scrolling behavior\n\n## Common Pitfalls\n\n- Avoid performing expensive calculations in `layoutAttributesForElements(in:)` as it's called frequently\n- Don't invalidate the entire layout unnecessarily; use targeted invalidation contexts instead\n- Be careful with memory usage when caching large amounts of layout attributes","diagram":"flowchart TD\n  A[prepare() - Calculate Attributes] --> B[Cache in Dictionary]\n  B --> C[layoutAttributesForElements]\n  C --> D[shouldInvalidateLayout]\n  D --> E[Sticky Headers Logic]\n  E --> F[Smooth Scrolling]","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Lyft","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-09T09:00:07.232Z","createdAt":"2025-12-26 12:51:05"},{"id":"q-495","question":"How would you implement a simple UITableView with custom cells in iOS using Swift?","answer":"Create a UITableViewCell subclass, register it using tableView.register(CustomCell.self, forCellReuseIdentifier: \"cell\"), and implement the required UITableViewDataSource methods: numberOfRowsInSection and cellForRowAt.","explanation":"## Implementation Steps\n- Create a custom UITableViewCell class with IBOutlet connections\n- Register the cell class or nib with the table view\n- Implement the UITableViewDataSource protocol methods\n- Configure cell content in the cellForRowAt method\n- Handle cell selection and data updates\n\n## Key Concepts\n- Reusable cell pattern for optimal performance\n- Delegation pattern for table view event handling\n- Auto Layout for dynamic cell sizing\n- Efficient data source management","diagram":"flowchart TD\n  A[Create Custom Cell] --> B[Register Cell]\n  B --> C[Implement DataSource]\n  C --> D[Configure Cell]\n  D --> E[Handle Selection]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Oracle","Snowflake","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-08T11:59:05.660Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-525","question":"You're building a food delivery app like DoorDash. How would you implement background location updates to track delivery drivers while balancing battery life and accuracy?","answer":"Use CLLocationManager with significantLocationChangeMonitoring for battery efficiency, switching to standard location updates during active deliveries. Implement region-based geofencing for restaurant and destination zones to trigger location updates only when necessary.","explanation":"## Background Location Strategy\n\n- **significantLocationChangeMonitoring**: Battery-efficient for idle drivers\n- **Standard location updates**: High accuracy during active deliveries\n- **Geofencing**: CLRegion for restaurant/destination zones\n- **Deferred updates**: Batch location data to reduce wake-ups\n\n## Implementation Details\n\n```swift\nlet locationManager = CLLocationManager()\nlocationManager.allowsBackgroundLocationUpdates = true\nlocationManager.pausesLocationUpdatesAutomatically = true\nlocationManager.activityType = .otherNavigation\n```\n\n## Battery Optimization\n\n- Use desiredAccuracy = kCLLocationAccuracyHundredMeters for monitoring\n- Switch to kCLLocationAccuracyBestForNavigation during deliveries\n- Implement adaptive update frequency based on speed and proximity\n- Leverage iOS motion detection to pause updates when stationary","diagram":"flowchart TD\n  A[Driver Idle] --> B[Significant Location Change]\n  B --> C{Delivery Accepted?}\n  C -->|Yes| D[Standard Location Updates]\n  C -->|No| B\n  D --> E[Active Navigation]\n  E --> F{Near Destination?}\n  F -->|Yes| G[Geofence Trigger]\n  F -->|No| E\n  G --> H[Delivery Complete]\n  H --> A","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Microsoft","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-09T08:42:22.344Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-578","question":"What's the difference between weak and unowned references in Swift, and when would you use each?","answer":"Weak references are optional and automatically become nil when the referenced object is deallocated. Unowned references are non-optional and assume the referenced object will always exist. Use weak for optional relationships where the referenced object might be deallocated first.","explanation":"## Memory Management\n\nSwift uses ARC (Automatic Reference Counting) to manage memory automatically. Strong references can create retain cycles, so we use weak and unowned references to break them.\n\n## Weak References\n\n- Always optional (automatically set to nil on deallocation)\n- Use for optional relationships\n- Common patterns: delegates, outlets\n\n```swift\nweak var delegate: MyDelegate?\n```\n\n## Unowned References\n\n- Non-optional (assumes reference always exists)\n- Use when you know the reference will outlive the holder\n- Common patterns: parent-child relationships\n\n```swift\nunowned let parent: ParentClass\n```\n\n## Key Differences\n\nChoose weak when the reference might become nil during execution. Choose unowned when you're certain the reference will always exist throughout the object's lifetime.","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-08T11:52:32.417Z","createdAt":"2025-12-27T01:13:27.377Z"},{"id":"q-181","question":"Explain the difference between weak and unowned references in Swift and provide practical use cases for each?","answer":"Weak references are optional and automatically become nil when the referenced object is deallocated, while unowned references are non-optional and assume the object will always exist during the reference's lifetime, causing a crash if accessed after deallocation.","explanation":"## Why Asked\nTests memory management understanding and preventing retain cycles in iOS development\n\n## Key Concepts\n- Automatic Reference Counting (ARC)\n- Strong reference cycles\n- Optional vs non-optional references\n- Lifetime expectations\n\n## Code Example\n```\nclass Parent {\n    weak var child: Child?\n    unowned let partner: Parent\n}\n\n// weak: when object might become nil (e.g., delegates)\n// unowned: when object outlives reference (e.g., parent-child)\n```\n\n## Follow-up Questions\n- How do you identify retain cycles?\n- What happens when you access an unowned reference after deallocation?\n- When would you choose weak vs unowned in a real application?","diagram":"flowchart TD\n  A[Object Created] --> B{Reference Type?}\n  B -->|May become nil| C[weak var]\n  B -->|Always exists| D[unowned]\n  C --> E[Becomes nil on deallocation]\n  D --> F[Crashes if accessed after deallocation]","difficulty":"intermediate","tags":["swift","language"],"channel":"ios","subChannel":"swift","sourceUrl":null,"videos":{"shortVideo":"https://www.youtube.com/watch?v=bMNwHNOVdXw","longVideo":"https://www.youtube.com/watch?v=8KQcTDGqQEc"},"companies":["Amazon","Apple","Google","Meta","Microsoft"],"eli5":"Imagine you're playing with building blocks! A 'weak' reference is like saying 'I'm looking at my friend's red block.' If your friend takes their block away, you just shrug and say 'Oh well, no red block anymore!' You don't cry or break anything. An 'unowned' reference is like saying 'I'm holding my friend's blue block and I KNOW it's there!' If your friend secretly takes the block away and you try to grab it, you'll trip and fall because you expected it to be there! Use weak references when you're just watching something that might disappear (like watching a toy car that might drive away). Use unowned references when you're absolutely sure something will stay there (like holding onto your mom's hand while crossing the street).","relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-01T06:41:21.669Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-257","question":"What is optional chaining in Swift and how does it compare to force unwrapping, optional binding, and optional chaining with method calls when accessing nested optional properties?","answer":"Optional chaining (?.) safely unwraps optionals, returning nil if any link fails instead of throwing runtime errors. Unlike force unwrapping (!), it prevents crashes. It's more concise than if-let/guard-let for single access and works with methods, subscripts, and nested optionals like person?.address?.street?.count.","explanation":"## Core Concept\nOptional chaining (?.) provides a safe way to access properties, methods, and subscripts of optional values, returning nil if any part of the chain is nil.\n\n## Key Differences\n- **Force unwrapping (!)**: Crashes if nil\n- **Optional binding**: Requires separate if-let/guard-let blocks\n- **Optional chaining**: Single-line safe access\n\n## Code Examples\n```swift\n// Nested optionals\nlet streetCount = person?.address?.street?.count\n\n// Method calls with optional chaining\nlet result = optionalObject?.method()?.property\n\n// Subscript access\nlet value = dictionary?[key]?.nestedValue\n```\n\n## Performance & Best Practices\n- Slight overhead vs force unwrapping due to nil checks\n- Use when you need single access to deeply nested optionals\n- Prefer optional binding for multiple operations on the same value\n- Avoid excessive chaining that reduces code readability\n\n## Common Pitfalls\n- Forgetting that the result is always optional\n- Mixing with force unwrapping in the same chain\n- Not handling the nil case appropriately","diagram":"graph TD\n    A[person] --> B[residence?]\n    B --> C[address?]\n    C --> D[street: String]\n    \n    E[Optional Chaining ?. ] --> F{Check residence}\n    F -->|nil| G[Return nil]\n    F -->|exists| H{Check address}\n    H -->|nil| G\n    H -->|exists| I[Return street value]\n    \n    style G fill:#ffcccc\n    style I fill:#ccffcc","difficulty":"beginner","tags":["optionals","protocols","generics"],"channel":"ios","subChannel":"swift","sourceUrl":null,"videos":{"shortVideo":"https://www.youtube.com/watch?v=Hfpx494ess8","longVideo":"https://www.youtube.com/watch?v=S8-QO2wUbRg"},"companies":["Amazon","Apple","Google","Meta","Microsoft","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-26T16:39:04.627Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-204","question":"How would you optimize a UITableView with 10,000+ complex cells using Auto Layout while maintaining 60fps scrolling and memory efficiency?","answer":"Use cell reuse, pre-calculate heights, implement heightForRowAt caching, and optimize Auto Layout constraints with manual layout when needed.","explanation":"## Concept Overview\nOptimizing large UITableViews requires balancing memory usage, rendering performance, and smooth scrolling. Auto Layout adds computational overhead that becomes critical at scale.\n\n## Implementation Details\n\n### Cell Reuse Strategy\n```swift\noverride func prepareForReuse() {\n    super.prepareForReuse()\n    // Reset expensive operations\n    imageView.image = nil\n    complexView.resetContent()\n}\n```\n\n### Height Caching System\n```swift\nprivate var heightCache: [IndexPath: CGFloat] = [:]\n\nfunc tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n    if let cached = heightCache[indexPath] {\n        return cached\n    }\n    let height = calculateHeight(for: indexPath)\n    heightCache[indexPath] = height\n    return height\n}\n```\n\n### Auto Layout Optimization\n- Use `setNeedsLayout()` instead of `layoutIfNeeded()`\n- Prefer `intrinsicContentSize` over complex constraints\n- Implement `systemLayoutSizeFitting` for height calculation\n\n### Memory Management\n- Use weak references for cell closures\n- Implement `didEndDisplaying` for cleanup\n- Consider async image loading with placeholder\n\n## Common Pitfalls\n- Not caching heights leads to expensive recalculations\n- Complex Auto Layout in cell configuration blocks\n- Memory leaks from strong reference cycles\n- Ignoring cell reuse lifecycle","diagram":"flowchart LR\n    A[User Scrolls] --> B[dequeueReusableCell]\n    B --> C{Height Cached?}\n    C -->|Yes| D[Use Cached Height]\n    C -->|No| E[Calculate Height]\n    E --> F[Cache Height]\n    F --> G[Configure Cell]\n    G --> H[Apply Constraints]\n    H --> I[Render Cell]\n    I --> J[Display]\n    D --> G","difficulty":"advanced","tags":["autolayout","tableview","collectionview"],"channel":"ios","subChannel":"uikit","sourceUrl":null,"videos":null,"companies":["Airbnb","Apple","Capital One","Lyft","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-26T12:38:17.524Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-232","question":"How does Auto Layout constraint resolution work when creating a UITableView with dynamic cell heights?","answer":"Auto Layout resolves constraints by calculating required cell heights based on content, then UITableView applies these heights during layout.","explanation":"## Concept Overview\nAuto Layout constraint resolution is the process where iOS calculates the size and position of views based on their constraints. For UITableView with dynamic cells, this happens in two phases.\n\n## Implementation Details\n1. **System Layout Size Fitting**: UITableView calls `systemLayoutSizeFitting` on each cell prototype\n2. **Constraint Resolution**: Auto Layout engine resolves all constraints to determine cell height\n3. **Height Caching**: UITableView caches calculated heights for performance\n4. **Layout Application**: Heights are applied during the table view's layout pass\n\n## Code Example\n```swift\n// In UITableViewCell subclass\noverride func awakeFromNib() {\n    super.awakeFromNib()\n    // Enable auto-sizing\n    contentView.translatesAutoresizingMaskIntoConstraints = false\n}\n\n// In UITableViewController\ntableView.rowHeight = UITableView.automaticDimension\ntableView.estimatedRowHeight = 100\n```\n\n## Common Pitfalls\n- Missing `translatesAutoresizingMaskIntoConstraints = false`\n- Incomplete constraint chains leading to ambiguous layouts\n- Performance issues with complex constraint hierarchies\n- Not setting `estimatedRowHeight` causing layout delays","diagram":"graph TD\n    A[UITableView] --> B[Cell Prototype]\n    B --> C[Auto Layout Engine]\n    C --> D[Constraint Resolution]\n    D --> E[Height Calculation]\n    E --> F[Height Caching]\n    F --> G[Layout Application]\n    G --> H[Final Cell Display]","difficulty":"beginner","tags":["autolayout","tableview","collectionview"],"channel":"ios","subChannel":"uikit","sourceUrl":null,"videos":null,"companies":["Airbnb","Apple","Google","Meta","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-27T04:55:46.823Z","createdAt":"2025-12-26 12:51:07"}],"subChannels":["general","swift","uikit"],"companies":["Airbnb","Amazon","Apple","Bloomberg","Capital One","Databricks","Discord","DoorDash","Goldman Sachs","Google","IBM","Lyft","Meta","Microsoft","NVIDIA","Netflix","OpenAI","Oracle","Snowflake","Stripe","Tesla","Uber","Zoom"],"stats":{"total":16,"beginner":8,"intermediate":5,"advanced":3,"newThisWeek":8}}