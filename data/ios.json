{"questions":[{"id":"q-1064","question":"Design and implement a streaming app's episode grid using a UICollectionView with a compositional layout that supports dynamic item sizes, infinite scrolling, and efficient image caching; use a modern iOS approach (Diffable Data Source, NSCache, prefetching), ensure accessibility and testability?","answer":"Implement a UICollectionView grid for episodes using a compositional layout and a single diffable data source. Use NSCache to cache episode artwork, set up prefetching to load next pages, and implemen","explanation":"## Why This Is Asked\n\nTests practical experience building a robust iOS grid for streaming content, focusing on modern data sources, memory efficiency, and accessibility in a scalable way.\n\n## Key Concepts\n\n- UICollectionView with Diffable Data Source\n- UICollectionViewCompositionalLayout\n- Prefetching and infinite scrolling\n- Image caching with NSCache\n- Accessibility labels and testing strategies\n\n## Code Example\n\n```swift\n// Example diffable data source setup\nlet dataSource = UICollectionViewDiffableDataSource<Int, Episode>(collectionView: collectionView) { cv, indexPath, episode in\n  let cell = cv.dequeueReusableCell(withReuseIdentifier: \"EpisodeCell\", for: indexPath) as! EpisodeCell\n  cell.configure(with: episode)\n  return cell\n}\n```\n\n## Follow-up Questions\n\n- How would you handle memory pressure and invalidate cached images?\n- How would you test diffable data source updates and scrolling behavior?\n","diagram":null,"difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Netflix","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T21:23:50.063Z","createdAt":"2026-01-12T21:23:50.063Z"},{"id":"q-1164","question":"You're building a lightweight notes app for iOS. Implement a NotesEditor view (SwiftUI) that autosaves to disk as the user types, using a 500ms debounce. Persist to a local JSON file in the app's documents directory. Ensure rapid typing doesn't cause multiple disk writes, and provide a minimal unit test that verifies the file content is updated after a debounce period?","answer":"Implement a SwiftUI NotesEditor with a @Published note. Debounce saves to disk at 500ms using Combine: $note.debounce(for: .milliseconds(500), scheduler: RunLoop.main).sink { save(note) }. Persist by ","explanation":"## Why This Is Asked\nTests practical understanding of combining UI state with asynchronous persistence, a common real-world pattern.\n\n## Key Concepts\n- Combine debouncing for UI-driven writes\n- File I/O and JSON encoding in Swift\n- SwiftUI data flow and @Published bindings\n- Unit testing asynchronous code and filesystem writes\n\n## Code Example\n```swift\nimport Combine\nimport SwiftUI\n\nclass NotesStore: ObservableObject {\n  @Published var note: String = \"\"\n  private var cancellables = Set<AnyCancellable>()\n  init() {\n    $note\n      .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n      .sink { [weak self] text in\n        self?.save(text)\n      }\n      .store(in: &cancellables)\n  }\n  func save(_ text: String) {\n    let json = [\"note\": text]\n    if let data = try? JSONSerialization.data(withJSONObject: json, options: []) {\n      let url = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]\n        .appendingPathComponent(\"notes.json\")\n      try? data.write(to: url)\n    }\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test cancellation of a pending save when the app moves to background?\n- How would you extend to multi-note scenarios with conflict resolution?","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Google","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T03:30:46.016Z","createdAt":"2026-01-13T03:30:46.016Z"},{"id":"q-1185","question":"In an iOS app, you are displaying a feed of user avatars in a UICollectionView with infinite scrolling. Explain how you would implement incremental image loading that cancels obsolete requests, caches images both in memory and on disk, uses Swift concurrency for loading, and ensures smooth scrolling under memory pressure, including prefetching and memory-pressure handling strategies?","answer":"Use a two-tier cache and cancellable loading. Use NSCache for memory and a disk cache via FileManager. For each cell, spawn a Task tied to the cell's lifecycle; cancel on prepareForReuse. Load with UR","explanation":"## Why This Is Asked\n\nThis question tests practical image loading in a scrolling feed, covering cancellation semantics with cell reuse, multi-level caching, and Swift concurrency, plus handling memory pressure and prefetching.\n\n## Key Concepts\n\n- UICollectionView infinite scrolling\n- Memory and disk caching strategy\n- Swift concurrency and Task cancellation\n- Cell reuse and race condition handling\n- Prefetching and memory-pressure testing\n\n## Code Example\n\n```swift\nimport UIKit\n\nactor ImageCache {\n  private var memory = NSCache<NSString, UIImage>()\n  private let diskURL: URL\n  func load(_ url: URL) async -> UIImage? { ... }\n}\n```\n\n## Follow-up Questions\n\n- How would you measure scrolling smoothness and cache hit rate in production?\n- How would you adapt this for SwiftUI's AsyncImage?","diagram":"flowchart TD\n  A[Start] --> B[CellForItemAt]\n  B --> C[Check memory cache]\n  C -->|Hit| D[Bind image]\n  C -->|Miss| E[Check disk cache]\n  E -->|Hit| F[Decode & cache]\n  E -->|Miss| G[Network fetch]\n  G --> H[Decode & cache on disk & memory]\n  H --> I[Bind to cell]","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Bloomberg","Goldman Sachs"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T04:38:02.306Z","createdAt":"2026-01-13T04:38:02.307Z"},{"id":"q-1439","question":"In a recipe-list iOS app, implement a multi-select ingredient filter as tappable chips using UIKit. Given a static dataset of recipes with ingredients, create a chips bar that allows selecting multiple ingredients, a Clear button, and a table view that shows only recipes containing all selected ingredients. Ensure accessibility labels and VoiceOver order, and provide a simple unit test validating the filter logic?","answer":"I would model Recipe{name, ingredients}, store a static dataset, and build a ChipsView with a horizontal UICollectionView of UIButton chips. Maintain a Set<String> selected; tapping toggles a chip. Fi","explanation":"## Why This Is Asked\nAssesses ability to translate a UX requirement into a single view using UIKit, including state management, filtering logic, and accessibility. It also touches testing of business logic separate from UI.\n\n## Key Concepts\n- UIKit: UICollectionView for chips, UITableView for results\n- Data modeling with Structs, Sets, and filtering\n- Accessibility: labels, traits, and VoiceOver order\n- Testing: unit-test the filtering function independent of UI\n\n## Code Example\n```swift\nstruct Recipe {\n  let name: String\n  let ingredients: [String]\n}\n\nfunc filtered(_ recipes: [Recipe], by selected: Set<String>) -> [Recipe] {\n  guard !selected.isEmpty else { return recipes }\n  return recipes.filter { selected.isSubset(of: Set($0.ingredients)) }\n}\n```\n\n## Follow-up Questions\n- How would you scale this if the dataset grows to thousands of recipes?\n- How would you adapt this to SwiftUI and compare the data flow with UIKit?","diagram":"flowchart TD\n  A[Load dataset] --> B[Render chips]\n  B --> C{Chip tapped?}\n  C -->|Yes| D[Update selected set]\n  D --> E[Apply filter]\n  E --> F[Update results view]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Databricks","DoorDash"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T17:00:06.297Z","createdAt":"2026-01-13T17:00:06.297Z"},{"id":"q-1573","question":"Design a beginner iOS feature: a SwiftUI-based **Favorites** screen for a recipe app. It should load a predefined array of Recipe objects from a local JSON file, display in a single-column list, allow tapping to mark/unmark as favorite, persist favorites in **UserDefaults**, and provide a search bar to filter by name **case-insensitively**. Explain how you'd structure the model, storage, and UI, and how you'd test search and persistence?","answer":"Use MVVM with a Recipe model, decode JSON into Recipe structs, and store favorites as a Set of ids in @AppStorage (UserDefaults). Bind the list to an @Published filtered array driven by a search strin","explanation":"## Why This Is Asked\\n\\nAssesses ability to combine SwiftUI, local persistence, and simple filtering.\\n\\n## Key Concepts\\n- MVVM with SwiftUI\\n- Data binding and @Published\\n- Local persistence via JSON + UserDefaults\\n- Search filtering with case-insensitive comparison\\n- Testability of filtering and persistence\\n\\n## Code Example\\n```swift\\nstruct Recipe: Codable, Identifiable { let id: String; let name: String; var isFavorite: Bool }\\nclass RecipeViewModel: ObservableObject { @Published var recipes: [Recipe] = []; @Published var search = \\\"\\\"; var filtered: [Recipe] { recipes.filter { $0.name.lowercased().contains(search.lowercased()) } } @AppStorage(\\\"favorites\\\") var favorites: Set<String> = [] }\\n```\\n\\n## Follow-up Questions\\n- How would you scale to a larger dataset?\\n- How would you handle data refresh with a remote source","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Google","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T22:36:50.906Z","createdAt":"2026-01-13T22:36:50.906Z"},{"id":"q-1611","question":"Design and implement an offline-first notes feature for iOS: store locally in SQLite, use a simple CRDT-like merge or last-writer-wins with version vectors for conflict resolution, and sync changes via a WebSocket protocol, all in Swift using async/await. Include data model, conflict handling, and testing strategy?","answer":"Store notes locally in SQLite with per-note revision tracking and a change log; edits increment revision and emit deltas. Sync via WebSocket streaming with note ID, revision, delta, device ID, and timestamp. Resolve conflicts using last-writer-wins based on timestamps, with fallback to manual merge for simultaneous edits.","explanation":"## Why This Is Asked\n\nTests ability to design robust offline-first data synchronization using modern iOS paradigms, with explicit conflict resolution and test planning.\n\n## Key Concepts\n\n- SQLite local persistence with per-note revision and ChangeLog\n- Delta encoding and event streaming over WebSocket\n- Swift concurrency (async/await) for network and DB operations\n- Conflict resolution strategies: Last-Writer-Wins vs CRDT\n- Testing under intermittent connectivity and out-of-order delivery\n\n## Code Example\n\n```swift\nstruct Note: Identifiable, Codable {\n  let id: UUID\n  var content: String\n  var","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["OpenAI","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T05:30:06.361Z","createdAt":"2026-01-14T02:36:55.710Z"},{"id":"q-1681","question":"In an iOS SwiftUI app, build a minimal Notes editor screen: a multiline TextEditor bound to a string. Implement an autosave that triggers 1 second after the user stops typing, saving the draft to UserDefaults under the key 'noteDraft'. Load the draft on view appear. Include a tiny unit test that simulates typing and asserts the draft is saved after the debounce delay?","answer":"Bind a SwiftUI TextEditor to @State text. Implement onChange(text) to cancel a previous DispatchWorkItem and schedule a new one that calls saveDraft after 1 second. saveDraft writes to UserDefaults wi","explanation":"## Why This Is Asked\nTests ability to design simple, observable UI with a practical persistence pattern.\n\n## Key Concepts\n- SwiftUI TextEditor binding\n- Debounce using DispatchWorkItem\n- UserDefaults persistence\n- Lightweight unit testing of async behavior\n\n## Code Example\n```javascript\n// Swift-like pseudocode demonstrating debounce autosave\nclass NoteViewModel: ObservableObject {\n  @Published var text = \"\"\n  private var workItem: DispatchWorkItem?\n  func textChanged(_ newValue: String) {\n    text = newValue\n    workItem?.cancel()\n    let item = DispatchWorkItem { self.saveDraft() }\n    workItem = item\n    DispatchQueue.main.asyncAfter(deadline: .now() + 1.0, execute: item)\n  }\n  func saveDraft() {\n    UserDefaults.standard.set(text, forKey: \"noteDraft\")\n  }\n  func loadDraft() {\n    text = UserDefaults.standard.string(forKey: \"noteDraft\") ?? \"\"\n  }\n}\n```\n\n## Follow-up Questions\n- How would you extend to support multiple notes?  \n- How would you ensure autosave runs if the app goes to background?  \n- How would you test the debounce logic more deterministically?","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T06:53:06.062Z","createdAt":"2026-01-14T06:53:06.063Z"},{"id":"q-1718","question":"In a high-traffic iOS app for autonomous telemetry, describe a robust data pipeline that streams sensor data into local batches and uploads to cloud with offline queueing and crash recovery. Include how to handle backpressure, idempotency, and testing. Provide concrete Swift components and a minimal prototype?","answer":"Design a data pipeline: SensorFeed emits Data chunks; a Batcher groups into fixed-size batches with a batch nonce. UploadService uses URLSession with a background session, writes a persistent queue to","explanation":"## Why This Is Asked\nTests ability to design resilient, testable data pipelines under intermittent connectivity, with proper use of background tasks and on-device persistence.\n\n## Key Concepts\n- Background URLSession\n- Persisted queues and idempotent uploads\n- Backoff strategies with jitter\n- Deterministic testing via mocks\n\n## Code Example\n```swift\nimport Foundation\nclass UploadService {\n  static let shared = UploadService()\n  func enqueue(_ data: Data) { /*...*/ }\n}\n```\n\n## Follow-up Questions\n- How would you handle multiple device types with different background limits?\n- How would you measure battery impact and optimize?","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","NVIDIA","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T07:52:02.313Z","createdAt":"2026-01-14T07:52:02.313Z"},{"id":"q-1951","question":"You're building an **offline-first** image gallery in an iOS app. Describe in detail how you would implement a robust caching and download strategy that supports offline browsing, seamless updates when connectivity returns, and **conflict resolution**. Include data models, caching policy, background downloads, and testing approaches?","answer":"Implement an offline-first image gallery cache: an LRU disk cache plus in-memory NSCache, with a manifest table storing URL, etag, version, and local path. Use URLSession background downloads to fetch","explanation":"## Why This Is Asked\n\nTests practical offline-first data handling, persistence, and background task orchestration in a real iOS app, ensuring candidates address data modeling, consistency, and testing.\n\n## Key Concepts\n\n- Offline-first caching with disk persistence and memory caching\n- Background downloads with URLSession\n- Manifest data model including url, etag, version, localPath, timestamp\n- Conflict resolution via versioning or timestamps\n- Testing approaches for offline mode, eviction, and crash recovery\n\n\n## Code Example\n\n```swift\nstruct ImageManifest: Codable {\n  let url: URL\n  let etag: String?\n  let version: Int\n  let localPath: String\n  let timestamp: Date\n}\n```\n\n## Follow-up Questions\n\n- How would you ensure consistency when multiple images are downloaded in parallel?\n- What testing strategy would you use to validate cache crash recovery and version conflicts?","diagram":"flowchart TD\nA[User opens gallery] --> B[Check manifest]\nB --> C{Cache hit?}\nC -- Yes --> D[Serve from cache]\nC -- No --> E[Download via URLSession BG]\nE --> F[Update manifest]\nF --> D","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Scale Ai","Tesla","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T18:47:46.650Z","createdAt":"2026-01-14T18:47:46.650Z"},{"id":"q-2089","question":"Design an offline-first album sync for iOS that uses a CRDT-based OR-Set to resolve conflicts in PhotoMetadata across devices. Include data model, merge rules with per-album ACLs, and a test plan for intermittent connectivity?","answer":"Offline-first album sync using a CRDT (OR-Set) for PhotoMetadata (id, albumId, caption, tags, location, timestamp). Each device applies local edits, tombstones, and vector-clock-based merges. Enforce per-album ACLs during sync to prevent unauthorized access while maintaining eventual consistency across all devices.","explanation":"## Why This Is Asked\n\nTests ability to architect offline-first data sync with strong convergence guarantees under real-world constraints.\n\n## Key Concepts\n\n- CRDTs (OR-Set) for concurrent edits\n- Conflict resolution with vector clocks and tombstones\n- Data modeling with PhotoMetadata and ACLs\n- Integration with Core Data/CloudKit and offline testing\n\n## Code Example\n\n```swift\nstruct PhotoMetadata {\n  let id: String\n  let albumId: String\n  var caption: String\n  var tags: Set<String>\n  var location: String?\n  var timestamp: Date\n}\n\nfunc merge(_ a: PhotoMetadata, _ b: PhotoMetadata) -> PhotoMetad","diagram":"flowchart TD\n  A[Local Edit] --> B{Conflict?}\n  B -- Yes --> C[Apply OR-Set Merge]\n  B -- No --> D[Push to Server]\n  C --> D","difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","IBM","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T05:03:28.436Z","createdAt":"2026-01-14T23:40:04.038Z"},{"id":"q-2184","question":"Begin with a concrete scenario: You have an iOS app that shows a list of product names. Build a minimal UIKit view controller that renders the list in a `UITableView` with a search bar. Implement a 300ms **debounce** using Swift's async/await to filter results on a background queue, then present them on the main thread. Filter should be case-insensitive and preserve order. Provide the core view controller code and explain cancellation behavior?","answer":"Use Swift concurrency: on text change, cancel any active search Task, start a new one with a 300ms delay, then filter the dataset on a background queue using case-insensitive contains; update the UI o","explanation":"## Why This Is Asked\nTests understanding of concurrency, debouncing, and UI thread safety in a concrete, beginner-friendly scenario.\n\n## Key Concepts\n- Swift concurrency (async/await, Task)\n- Debounce pattern with cancellation\n- Background work vs main thread\n- Case-insensitive filtering\n- UITableView data source updates\n\n## Code Example\n```javascript\n// Swift-like pseudocode illustrating structure\n```\n\n## Follow-up Questions\n- How would you test debounce timing and cancellation?\n- How would you adapt this to a SwiftUI or Combine-based approach?\n","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Google","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T06:51:07.736Z","createdAt":"2026-01-15T06:51:07.737Z"},{"id":"q-2341","question":"Scenario: Build a real-time presence client for an iOS app used by distributed teams (Zoom/Square/PayPal). Use a WebSocket to publish/receive presence events, implement exponential backoff reconnect, background processing, and idempotent event application; provide a minimal Swift prototype and a test plan for intermittent networks. How would you implement this?","answer":"Use a WebSocket (URLSessionWebSocketTask) with automatic reconnect using exponential backoff, a background worker queue for message handling, and Idempotent application of presence events via sequence","explanation":"## Why This Is Asked\nReal-time presence with flaky networks requires robust reconnects and idempotent state application. This tests network resilience, offline handling, and Swift concurrency.\n\n## Key Concepts\n- WebSocket lifecycle and reconnect backoff\n- Idempotent event processing with sequence IDs\n- Background processing and thread safety\n- Local persistence for presence ledger and retry queue\n- Testing strategy for intermittent networks\n\n## Code Example\n```javascript\n// Swift-like skeleton using URLSessionWebSocketTask in Swift-equivalent pseudocode\nimport Foundation\n\nclass PresenceClient {\n  var wsTask: URLSessionWebSocketTask?\n  func connect() { /* backoff logic */ }\n  func receive() { /* handle messages, apply idempotently */ }\n}\n```\n\n## Follow-up Questions\n- How would you design unit tests to simulate network flakiness and out-of-order messages?\n- How would you propagate presence changes to connected peers while avoiding backpressure and storms?","diagram":null,"difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["PayPal","Square","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T13:16:06.351Z","createdAt":"2026-01-15T13:16:06.351Z"},{"id":"q-2355","question":"Design a live-map ETA/route update system for a rideshare app with intermittent connectivity. Describe an architecture using MapKit, CoreData offline persistence, and CloudKit sync with Swift concurrency. Include conflict resolution strategy, data integrity guarantees, and test plan?","answer":"Use MapKit for live routing, CoreData for offline persistence, and a CloudKit sync pipeline. An actor-isolated fetcher batches ETA/route updates, applies optimistic UI, and resolves conflicts with tim","explanation":"## Why This Is Asked\nThis question probes how a senior iOS engineer designs a resilient, offline-capable live-mapping feature.\n\n## Key Concepts\n- MapKit live updates\n- CoreData offline store\n- CloudKit sync and Swift concurrency\n- Conflict resolution and data integrity\n- Test strategies for flaky networks\n\n## Code Example\n```javascript\n// Swift-like pseudocode illustrating an actor-based sync pipeline\nactor RouteSync {\n  func apply(_ updates: [RouteUpdate]) {\n    // merge with local store, resolve conflicts by timestamp\n  }\n}\n```\n\n## Follow-up Questions\n- How would you measure latency vs. consistency in this system?\n- How would you test conflict scenarios with deterministic replay?","diagram":"flowchart TD\n  Start([Start]) --> Fetch[Fetch live updates]\n  Fetch --> Merge[Merge with local data]\n  Merge --> Render[Render on MapUI]\n  Render --> SyncDone[Done]","difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Lyft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T14:42:06.608Z","createdAt":"2026-01-15T14:42:06.609Z"},{"id":"q-2391","question":"Design a high-performance, offline-first photo feed in an iOS app. Render a UICollectionView that shows square image tiles with captions, support infinite scrolling, and prioritize visible cells for image downloads. Implement disk caching (LRU), memory pressure eviction, and offline fallback when network is unavailable. Ensure VoiceOver and Dynamic Type. Provide data model, caching strategy, testing plan, and a concise code sketch for an ImageLoader using async/await?","answer":"Use a two-tier image cache (NSCache + disk) and a Swift async/await loader. Cache key from the URL hash; store images in Caches/Photos. Prefetch upcoming cells, cancel in-flight fetches on reuse, and ","explanation":"## Why This Is Asked\nTests ability to design an offline-first image pipeline with robust caching, memory management, and accessibility in a real UI scenario.\n\n## Key Concepts\n- Two-tier caching (memory + disk)\n- LRU eviction under memory pressure\n- Prefetching and cancellation tied to visible cells\n- Accessibility: Dynamic Type and VoiceOver labels\n- Async/await data loading and main-thread UI updates\n\n## Code Example\n```swift\nimport UIKit\n\nactor ImageLoader {\n    private let memCache = NSCache<NSString, UIImage>()\n    private let fileManager = FileManager.default\n    private let diskDir: URL\n\n    init(diskFolder: URL) { self.diskDir = diskFolder }\n\n    func load(from url: URL) async -> UIImage? {\n        let key = url.absoluteString as NSString\n        if let image = memCache.object(forKey: key) { return image }\n        let path = diskDir.appendingPathComponent(url.lastPathComponent)\n        if let data = try? Data(contentsOf: path), let image = UIImage(data: data) {\n            memCache.setObject(image, forKey: key)\n            return image\n        }\n        guard let (data, _) = try? await URLSession.shared.data(from: url),\n              let image = UIImage(data: data) else { return nil }\n        memCache.setObject(image, forKey: key)\n        try? data.write(to: path)\n        return image\n    }\n}\n```","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Discord","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T15:55:00.634Z","createdAt":"2026-01-15T15:55:00.634Z"},{"id":"q-2570","question":"**iOS Beginner Challenge:** Build a minimal journaling screen where a user types notes, autosaves to a local file atomically, and displays a list of notes. Ensure data is preserved across app restarts, support background/foreground transitions, and debounce saves to avoid thrashing. Use Swift with SwiftUI, Codable Note, and FileManager in the Documents directory. Include a simple test plan?","answer":"Implement a 300ms debounced autosave mechanism that triggers on text changes, serialize the Note model using Codable, perform atomic writes by first saving to a temporary file then replacing the target file, and load existing notes on app launch. Handle app lifecycle transitions using ScenePhase to maintain data integrity during background and foreground states.","explanation":"## Why This Is Asked\nThis question assesses practical iOS development skills including data persistence, SwiftUI fundamentals, and robust file handling—essential competencies for junior iOS developers.\n\n## Key Concepts\n- SwiftUI state management and data binding\n- Codable protocol for data serialization\n- FileManager atomic operations in Documents directory\n- ScenePhase environment for app lifecycle management\n- Debounce pattern to optimize I/O operations\n\n## Code Example\n```swift\nimport SwiftUI\nstruct Note: Codable { let id: UUID; var text: String; let date: Date }\n```\n\n## Follow-up Questions","diagram":"flowchart TD\n  EditorUI(Editor UI) --> AutosaveDebounce(Autosave Debounce)\n  AutosaveDebounce --> TempWrite(Write to Temp File)\n  TempWrite --> AtomicSwap(Atomic Swap to Final File)\n  AtomicSwap --> NotesList(Notes List UI)","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T05:19:43.075Z","createdAt":"2026-01-15T23:32:15.321Z"},{"id":"q-2776","question":"Build a SwiftUI screen that loads a local JSON array of flashcards (id, question, answer) from the app bundle, displays one card at a time with a tap to flip, and includes a Next button. Persist the current index and per-card view counts to a local file atomically so the session resumes where left off on restart. Ensure Dynamic Type and Dark Mode compatibility; keep it beginner-friendly and testable?","answer":"Load JSON from bundle into [Flashcard] Codable; currentIndex and viewCount per card stored in Documents/flashcards_state.json. SwiftUI view shows a card with question; tapping flips to show answer; Ne","explanation":"## Why This Is Asked\nTests practical data loading, simple UI with state, and robust local persistence—core iOS basics for a junior role.\n\n## Key Concepts\n- Codable data models and JSON parsing\n- Local file persistence with atomic writes\n- SwiftUI state management and view updates\n- Dynamic Type and Dark Mode compatibility\n\n## Code Example\n```swift\nstruct Flashcard: Codable, Identifiable { let id: String; let question: String; let answer: String }\nclass FlashcardVM: ObservableObject {\n    @Published var cards: [Flashcard] = []\n    @Published var index: Int = 0\n    func load() { /* decode from bundle */ }\n    func saveState() {\n        // write to temp file, then replace final file\n    }\n}\n```\n\n## Follow-up Questions\n- How would you add unit tests to verify atomic write behavior?\n- How would you handle data migration if the JSON schema changes later?","diagram":"flowchart TD\nLoadJSON[Load JSON from bundle] --> ShowCard[Show current card]\nShowCard --> FlipCard[Tap to flip to reveal answer]\nFlipCard --> NextCard[Next card]\nNextCard --> Persist[Persist index and counts]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","OpenAI","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T11:35:22.978Z","createdAt":"2026-01-16T11:35:22.978Z"},{"id":"q-2805","question":"Design an offline-first, conflict-aware sync for an iOS chat feature using Core Data for local storage and a REST API. Describe the Change Journal you'd implement, incremental pull using a since timestamp, an upsert push queue for new/edited messages, and a deterministic conflict resolution policy (e.g., last-updated-wins with timestamps). Include data structures, synchronization flow, backoff strategy, and a minimal test plan?","answer":"Leverage a Core Data-backed Change Journal to track inserts/edits/deletes for Message(id, content, author, createdAt, updatedAt, localVersion). Sync loop pulls /messages?since=serverMax and pushes loc","explanation":"## Why This Is Asked\nTests ability to design robust offline sync, conflict resolution, and test strategy under real-world mobile constraints.\n\n## Key Concepts\n- Offline-first data model\n- Change Journal and per-item updatedAt\n- Incremental synchronization with since tokens\n- Conflict resolution: last-writer-wins with server vs local\n- Backoff and retry policy\n- Test plan: simulate offline/online churn, partial failures, and race conditions\n\n## Code Example\n```javascript\n// Pseudo-code: diff/merge function outline\nfunction mergeRemote(localItem, remoteItem) {\n  if (remoteItem.updatedAt > localItem.updatedAt) { return remoteItem; }\n  return localItem;\n}\n```\n\n## Follow-up Questions\n- How would you test the Change Journal under heavy-write scenarios?\n- How do you handle deletions and tombstones?\n","diagram":"flowchart TD\n  A[Local Change Journal] --> B[Sync Loop]\n  B --> C{Server Response}\n  C -- Conflicts --> D[Resolve by Last-Writer-Wins]\n  C -- No Conflicts --> E[Apply Updates]\n","difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","Twitter","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T13:09:29.478Z","createdAt":"2026-01-16T13:09:29.478Z"},{"id":"q-2859","question":"Design and implement a high-throughput annotation queue in an iOS app used for labeling image datasets. Build a per-image task manager using Swift Concurrency (actors, AsyncSequence) to assign image slices to workers, enforce in-order UI updates, backpressure when the back-end lags, and automatic retries with exponential backoff. Provide API surface, a minimal SwiftUI view demo, and explain trade-offs?","answer":"Leverage a per-image annotation queue implemented as an Actor to serialize state, with a TaskGroup dispatching annotation tasks to workers and streaming results via an AsyncSequence. UI updates on Mai","explanation":"## Why This Is Asked\nThis probes Swift Concurrency mastery (actors, TaskGroups), deterministic UI ordering, and robust back-end latency handling in a data-labeling workflow.\n\n## Key Concepts\n- Swift Concurrency: actors, TaskGroup\n- AsyncSequence and backpressure\n- MainActor UI updates\n- Local persistence (SQLite/GRDB)\n- Exponential backoff and cancellation\n\n## Code Example\n```javascript\n// Swift-concurrency sketch (illustrative)\nactor AnnotationQueue {\n  private var queue: [ImageTask] = []\n  func enqueue(_ t: ImageTask) { queue.append(t) }\n  func run() async {\n    for await task in tasks() {\n      // process\n    }\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test under memory pressure and flaky network?\n- How do you ensure deterministic UI ordering if tasks complete out of order?\n- How would you swap in a different persistence backend without changing the API surface?","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","NVIDIA","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T14:53:26.408Z","createdAt":"2026-01-16T14:53:26.408Z"},{"id":"q-2976","question":"Implement a local-first photo uploader in an iOS app: when users select multiple photos for upload, queue them in a disk-backed manifest, process with a bounded concurrency worker, upload via URLSession background tasks, retry with exponential backoff on failures, and expose progress to the UI. How would you implement and test this to ensure persistence across relaunch and background/foreground transitions?","answer":"Implement a local-first uploader: queue selected photos to a disk-backed manifest written atomically; drive processing with a bounded worker pool (semaphore-limited) that uses URLSession background up","explanation":"## Why This Is Asked\n\nInterview focus: robust offline-first upload pipeline with persistence and lifecycle resilience.\n\n## Key Concepts\n\n- Local persistence with atomic writes\n- URLSession background uploads\n- Bounded concurrency\n- Exponential backoff\n- Progress reporting\n- Lifecycle resilience\n\n## Code Example\n\n```swift\nstruct PhotoUpload: Codable { let id: UUID; let fileURL: URL; var status: Status }\nenum Status: String, Codable { case queued, uploading, done, failed, retrying }\n```\n\n## Follow-up Questions\n\n- How would you test the retry/backoff behavior?\n- How would you extend to support paused/resumed uploads and offline queuing?\n","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Netflix","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T19:39:07.994Z","createdAt":"2026-01-16T19:39:07.994Z"},{"id":"q-3149","question":"Build a tiny iOS 'Task Timer' app: create tasks each with a duration, run per-task timers that pause on background, resume on foreground, and persist elapsed time to disk atomically via a Codable Task model stored in the Documents directory. Use SwiftUI and Combine; debounce saves to avoid thrashing; provide per-task accessibility labels and a filter for Active/Completed. How would you implement this end-to-end?","answer":"Approach: define Task: id, title, duration, elapsed, isCompleted. Persist as [Task] to a JSON file in Documents; atomically replace file with a temp write. Use SwiftUI List, per-task Timer via Combine","explanation":"## Why This Is Asked\nTests practical iOS basics (SwiftUI, Combine, persistence), plus testing readiness and accessibility. It exercises timer logic, background/foreground handling, and robust file writes.\n\n## Key Concepts\n- SwiftUI, Combine timers, and scene phase for backgrounding\n- Codable data model and atomic disk writes\n- FileManager Documents storage and JSON encoding/decoding\n- Accessibility labeling and dynamic filtering\n\n## Code Example\n```swift\nstruct Task: Codable {\n  let id: UUID\n  var title: String\n  var duration: TimeInterval\n  var elapsed: TimeInterval\n  var isCompleted: Bool\n}\n```\n\n## Follow-up Questions\n- How would you test persistence across process termination?\n- How would you handle timer drift if the app is suspended for long periods?","diagram":"flowchart TD\n  A[Create Task] --> B[Start Timer]\n  B --> C{Background?}\n  C -- Yes --> D[Pause Timer]\n  C -- No --> E[Tick Elapsed]\n  D --> F[Foregrounded?]\n  F -- Yes --> G[Resume Timer]\n  G --> E\n  E --> H[Persist Elapsed]\n  H --> I[Filter: Active/Completed]\n  I --> J[UI reflects state]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Salesforce","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T04:47:05.280Z","createdAt":"2026-01-17T04:47:05.281Z"},{"id":"q-3326","question":"Design a real-time collaborative note editor for iOS that works offline and syncs via CloudKit. Describe architecture for a sequence CRDT text model with per-note version vectors, deterministic merges, and offline persistence in CoreData. Explain testing with simulated disconnects, concurrent edits, and data integrity checks?","answer":"Implement offline-first notes with CoreData storage and a sequence CRDT for text edits, each operation carrying a vector timestamp. Sync via CloudKit records; apply deterministic merges based on vecto","explanation":"## Why This Is Asked\n\nTests ability to design offline-first sync, CRDT concepts, and iOS persistence.\n\n## Key Concepts\n\n- Offline-first data model\n- CRDT/sequence CRDT for text\n- CloudKit + CoreData integration\n- Version vectors and deterministic conflict resolution\n- End-to-end testing with network partitions\n\n## Code Example\n\n```swift\n// Pseudo-code sketch\nstruct TextOp { let index: Int; let char: Character }\nclass NoteCRDT {\n  var ops: [TextOp] = []\n  func apply(_ op: TextOp) { /* apply */ }\n  func merge(with other: NoteCRDT) { /* merge */ }\n}\n```\n\n## Follow-up Questions\n\n- How would you model concurrent inserts at the same index?\n- What test strategies ensure merges are idempotent across devices?","diagram":null,"difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T11:34:40.851Z","createdAt":"2026-01-17T11:34:40.851Z"},{"id":"q-3357","question":"Design a secure offline-first vault feature for iOS that stores sensitive notes and attachments encrypted at rest with per-note keys, deriving keys from a user passphrase using a KDF, storing metadata in CoreData, and syncing encrypted blobs via CloudKit. Explain key management, rotation, and a testing plan including device loss, passphrase changes, and offline use?","answer":"Derive a 256-bit key from the user passphrase with HKDF-SHA256 and a per-note salt, then encrypt each note using AES-GCM. Store ciphertexts and nonces in CoreData; keep the envelope in a Secure Enclav","explanation":"## Why This Is Asked\nAssesses secure offline-first data vault design, practical crypto in Swift, and testability across device loss and passphrase changes.\n\n## Key Concepts\n- CryptoKit: AES-GCM, HKDF-SHA256\n- KDF with per-note salt; envelope key in Secure Enclave\n- CoreData for local metadata; CloudKit for encrypted blob sync\n- Key rotation and re-wrapping strategies\n- Testing: offline scenarios, passphrase rotation, data integrity\n\n## Code Example\n```swift\nimport CryptoKit\n\nfunc deriveKey(password: String, salt: Data) -> SymmetricKey {\n  let ikm = SymmetricKey(data: Data(password.utf8))\n  let key = HKDF<SHA256>.deriveKey(inputKeyMaterial: ikm, salt: salt, info: Data(), outputByteCount: 32)\n  return key\n}\n```\n\n```swift\n// Encryption\nfunc encrypt(plaintext: Data, key: SymmetricKey) throws -> Data {\n  let sealed = try AES.GCM.seal(plaintext, using: key)\n  return sealed.combined!\n}\n```\n\n```swift\n// Decryption\nfunc decrypt(data: Data, key: SymmetricKey) throws -> Data {\n  let box = try AES.GCM.SealedBox(combined: data)\n  return try AES.GCM.open(box, using: key)\n}\n```","diagram":"flowchart TD\n  A[User enters passphrase] --> B[Derive envelope key (HKDF-SHA256)]\n  B --> C[Unlock Secure Enclave key]\n  C --> D[Derive per-note keys]\n  D --> E[Decrypt notes and attachments]\n  E --> F[CloudKit sync of encrypted blobs]\n  F --> G[Conflict resolution & metadata updates]","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["OpenAI","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T13:14:43.641Z","createdAt":"2026-01-17T13:14:43.641Z"},{"id":"q-3696","question":"As a module for a rideshare delivery dashboard, implement a map-based order tracker that consumes live updates over a WebSocket. The app must survive offline: persist last-known Orders in Core Data, deduplicate updates by eventId, and replay queued events on reconnect with exponential backoff. Also handle out-of-order messages and debounce UI updates. Use Swift, MapKit, Core Data; prefer URLSessionWebSocketTask?","answer":"I would implement a WebSocketManager using URLSessionWebSocketTask that maintains a single live connection, deduplicates incoming events by eventId, and persists them as Order entities in Core Data. U","explanation":"## Why This Is Asked\nTests architecture for real-time data with offline resilience, data integrity, and a clean UI path.\n\n## Key Concepts\n- WebSocket lifecycle with URLSessionWebSocketTask\n- Offline-first Core Data schema and conflict-free merges\n- Event deduplication via eventId and replay strategy\n- MapKit annotations and debounced UI refresh\n- Backoff, reachability, and offline queue testing\n\n## Code Example\n```swift\n// Minimal sketch: WebSocket manager\nclass WSManager {\n  // connect, receive, dedupe, persist\n}\n```\n\n## Follow-up Questions\n- How would you test out-of-order events?  \n- What metrics would you monitor in production? ","diagram":"flowchart TD\n  A[WebSocket Connect] --> B[Receive Event]\n  B --> C{Deduplicate}\n  C -- unique--> D[Persist in Core Data]\n  B --> E[Queue if Offline]\n  E --> F[Replay on Reconnect]\n  D --> G[Update Map Annotations]\n  G --> H[Debounced UI Refresh]","difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T05:43:53.830Z","createdAt":"2026-01-18T05:43:53.830Z"},{"id":"q-3796","question":"Design a beginner-friendly iOS SwiftUI screen: a note editor with a live word count. Debounce user input with Combine (300ms) before updating the count, and persist the last note to disk across restarts. Include handling of background/foreground transitions and a basic test plan?","answer":"Implement a SwiftUI note editor that shows a live word count. Drive it with Combine: feed the field into a CurrentValueSubject<String,Never>, debounce 300ms on RunLoop.main, then update a @Published w","explanation":"## Why This Is Asked\nTests SwiftUI, Combine, and simple disk persistence in a beginner-friendly way, plus lifecycle handling.\n\n## Key Concepts\n- SwiftUI state management and data binding\n- Combine debounce to throttle rapid changes\n- Lightweight persistence to disk (Documents) with Codable or plain text\n- Lifecycle considerations (background/foreground)\n\n## Code Example\n```swift\nimport SwiftUI\nimport Combine\n\nclass NoteViewModel: ObservableObject {\n  @Published var text: String = \"\"\n  @Published var wordCount: Int = 0\n\n  private var cancellables = Set<AnyCancellable>()\n\n  init() {\n    $text\n      .debounce(for: .milliseconds(300), scheduler: RunLoop.main)\n      .map { $0.split(whereSeparator: { $0 == \" \" || $0 == \"\\n\" }).count }\n      .assign(to: \\.wordCount, on: self)\n      .store(in: &cancellables)\n  }\n\n  func saveToDisk() {\n    // write to Documents/notes.txt\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test that debounce correctly throttles rapid input?\n- How would you handle a save failure and retry strategy?","diagram":"flowchart TD\n  A[Text input] --> B[Combine pipeline]\n  B --> C{Debounced update}\n  C --> D[Update wordCount]\n  C --> E[Persist to disk]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Scale Ai","Stripe","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T09:42:59.881Z","createdAt":"2026-01-18T09:42:59.881Z"},{"id":"q-3921","question":"Design an iOS data pipeline for a live analytics feed. The app connects to a WebSocket to receive events (JSON per event), decodes them into a Codable Event, and renders a live, diffable list. Requirements: (1) use URLSessionWebSocketTask for the socket, (2) an in-memory buffer capped at 1,000 events with oldest drops, (3) on-disk queue preserving order with atomic writes, (4) a deterministic replay API for offline mode, (5) UI stays responsive; discuss concurrency, error handling, backpressure, and testing?","answer":"Use a structured concurrency pipeline with an actor-owned buffer and a separate I/O layer. Run the WebSocket on a background Task, decode to Event with JSONDecoder, push to an in-memory ring buffer (m","explanation":"## Why This Is Asked\nThis prompt probes end-to-end data pipeline correctness, including concurrency, backpressure, and offline replay, which are real-world pains in live dashboards.\n\n## Key Concepts\n- URLSessionWebSocketTask, Async/Await, actor model\n- Codable decoding, JSON streaming\n- In-memory buffering with bounded capacity and backpressure\n- Atomic disk writes and ordered replay (queue on disk)\n- DiffableDataSource, main-thread UI updates, testability\n\n## Code Example\n```javascript\n// Swift-like pseudocode for the event pipeline\nactor EventStore {\n  private var buffer: [Event] = []\n  private let maxBuffer = 1000\n  func append(_ e: Event) {\n    buffer.append(e)\n    if buffer.count > maxBuffer {\n      buffer.removeFirst(buffer.count - maxBuffer)\n    }\n  }\n}\n```\n\n## Follow-up Questions\n- How would you simulate bursty event streams in tests and measure latency?\n- How would you ensure exactly-once delivery semantics if the WebSocket reconnects?","diagram":"flowchart TD\n  WS[WebSocket] --> D[Decoder]\n  D --> B[Buffer 1000]\n  B --> Disk[DiskQueue]\n  D --> UIUpdate[UI Update]\n  UIUpdate --> Replay[Offline Replay]","difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Google","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T15:37:34.044Z","createdAt":"2026-01-18T15:37:34.044Z"},{"id":"q-3953","question":"Design and implement an offline-first, multi-device to-do collaboration feature for an iOS app. It should store locally in Core Data, sync with a REST API, and reconcile conflicts using a versioned record with last-writer-wins strategy. Use SwiftUI, async/await, and an Actor-based SyncManager to serialize cross-device updates. Provide an outline of data models, a minimal SwiftUI view, and a test plan?","answer":"Architect offline-first multi-device to-do sharing: local Core Data store, REST sync, and a versioned Task model. Use an Actor-based SyncManager to serialize network updates; resolve conflicts via las","explanation":"## Why This Is Asked\nReal-world problem of offline collaboration and conflict resolution on iOS, testing concurrency, data modeling, and testability.\n\n## Key Concepts\n- Core Data offline storage\n- Swift concurrency: async/await and actors\n- Conflict resolution: last-writer-wins with versioning\n- Background networking with URLSession\n\n## Code Example\n```javascript\n// Pseudo-Swift: SyncManager sketch\nactor SyncManager {\n  func enqueue(_ op: @Sendable () async -> Void) {}\n  func flush() async {}\n}\n```\n\n## Follow-up Questions\n- How would you test conflict scenarios with simulated latency?\n- How would you scale to thousands of concurrent users without server bottlenecks?","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T16:49:46.121Z","createdAt":"2026-01-18T16:49:46.121Z"},{"id":"q-3975","question":"Design an offline-first PDF annotation workflow for iOS: use PDFKit to render and annotate PDFs, persist annotation state in Core Data with per-document versioning, and implement a sync to a remote REST API that merges edits using last-modified timestamps. Include optimistic UI updates, conflict handling when the same annotation is edited offline across devices, and a test strategy for offline edits, conflict cases, and relaunch integrity?","answer":"Design for an offline-first PDF annotation flow: render PDFs with PDFKit, persist Annotations in Core Data with documentVersion; sync via REST using a SyncManager that handles idempotent PUTs and delt","explanation":"## Why This Is Asked\nExplores real-world offline-first sync with PDFs, requiring data modeling, conflict handling, and test planning.\n\n## Key Concepts\n- PDFKit rendering and annotation model\n- Core Data relationships and versioning\n- REST-based sync with delta diffs and idempotency\n- Conflict resolution and testing in flaky networks\n\n## Code Example\n```swift\n// Pseudo-models: Document, Annotation, SyncManager\n```\n\n## Follow-up Questions\n- How would you test eventual consistency across devices?\n- How would you handle large PDFs to avoid memory pressure?","diagram":null,"difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Google","Hashicorp"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T17:47:57.881Z","createdAt":"2026-01-18T17:47:57.881Z"},{"id":"q-4019","question":"Design an on-device analytics module for an iOS app that preserves user privacy. The module should: record lightweight events locally; batch and aggregate them into daily buckets; upload via a background URLSession with exponential backoff and jitter; honor a user opt-in/opt-out toggle and per-event consent; persist across restarts. Explain data model (Core Data or SQLite), storage lifecycle, encryption, and a test plan that simulates offline, partial writes, and data corruption?","answer":"Use Core Data with entities Event and DailyBucket, storing per-event consent and a payloadHash. Persist lightweight events locally, accumulate into daily buckets, and upload in a background URLSession","explanation":"## Why This Is Asked\n\nAssess ability to design privacy-conscious analytics with on-device processing and reliable background uploads.\n\n## Key Concepts\n\n- On-device data collection and consent management\n- Core Data vs SQLite schema design for Events and Aggregates\n- Encryption in transit and at rest, Keychain storage\n- Background transfers with URLSession, backoff and jitter\n- Data integrity: retries, deduping, corruption handling\n\n## Code Example\n\n```swift\n// Core Data model sketch\n@objc(Event)\nclass Event: NSManagedObject {\n  @NSManaged var id: String\n  @NSManaged var name: String\n  @NSManaged var timestamp: Date\n  @NSManaged var payloadHash: String\n  @NSManaged var consent: Bool\n}\n```\n\n## Follow-up Questions\n\n- How would you test for opt-in/opt-out changes affecting pending batches?\n- How would you detect and recover from partial writes or data corruption in the store?\n","diagram":"flowchart TD\n  A[Start] --> B[Capture Event]\n  B --> C[Hash Payload]\n  C --> D[Store Event in Core Data]\n  D --> E{Ready to Upload?}\n  E -->|Yes| F[Batch Daily Buckets]\n  F --> G[Background URLSession Upload]\n  G --> H[Retry with Backoff/Jitter]\n  H --> E","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","LinkedIn","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T19:38:53.127Z","createdAt":"2026-01-18T19:38:53.127Z"},{"id":"q-4135","question":"Implement a small flashcard quiz in iOS using SwiftUI: load questions from a bundled JSON (title, prompt, answer, category). Show a card with the prompt; tap to flip and reveal the answer; add Next/Prev to navigate; persist last index across restarts via UserDefaults; debounce taps; ensure accessibility by labeling the card and using VoiceOver hints. Include a basic unit test for JSON decoding and scoring?","answer":"Approach: Create a Card model Codable to parse; build a SwiftUI CardView with 3D flip animation; load questions from bundled JSON into a @Published array; track currentIndex in @State and persist to U","explanation":"## Why This Is Asked\nTests a beginner's ability to combine SwiftUI, Codable JSON loading, simple persistence, input debouncing, and accessibility in a tangible feature.\n\n## Key Concepts\n- SwiftUI state management\n- Codable and JSON loading\n- UserDefaults persistence\n- Debouncing taps\n- Accessibility labels\n\n## Code Example\n```swift\nstruct Card: Codable { let id: String; let prompt: String; let answer: String; let category: String }\n```\n\n```swift\nstruct CardView: View {\n  let card: Card\n  @State private var flipped = false\n  var body: some View {\n    ZStack {\n      if flipped { Text(card.answer) } else { Text(card.prompt) }\n    }\n    .rotation3DEffect(.degrees(flipped ? 180 : 0), axis: (0,1,0))\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test debouncing behavior in UI tests?\n- How would you adapt the data loading for a large deck (pagination or streaming)?","diagram":"flowchart TD\n  LoadJSON[Load questions from bundled JSON] --> CardView[Display card]\n  CardView --> Flip[Flip to reveal answer]\n  Flip --> Nav[Navigate Next/Prev]\n  Nav --> Persist[Persist index to UserDefaults]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T04:39:13.058Z","createdAt":"2026-01-19T04:39:13.059Z"},{"id":"q-4204","question":"Build a lightweight audio memo feature: in a SwiftUI app, allow recording a 15–60 second memo using AVAudioRecorder, save to the app's Documents directory with an atomic write, and display a list of memos with duration and date. Enable playback via AVAudioPlayer, persist memos across launches, and handle background/foreground transitions. Provide a minimal test plan focusing on file I/O integrity and playback reliability. Use Swift/SwiftUI?","answer":"Record audio memos using AVAudioRecorder, save to Documents as a unique file, and write to a temp path first then move for atomic save. Build a Codable Memo struct with id, date, duration, path; list ","explanation":"## Why This Is Asked\n- Introduces AVFoundation in a practical UI flow, offline storage, and lifecycle handling.\n- Exercises safe file writes and persistent metadata for a beginner-friendly scenario.\n\n## Key Concepts\n- AVAudioRecorder / AVAudioPlayer, SwiftUI, FileManager atomic writes\n- Documents directory, Codable model, and simple persistence\n- Accessibility labeling for media controls\n\n## Code Example\n```swift\nfunc atomicallySave(data: Data, to url: URL) throws {\n  let tempURL = url.appendingPathExtension(\"temp\")\n  try data.write(to: tempURL)\n  try FileManager.default.moveItem(at: tempURL, to: url)\n}\n```\n\n## Follow-up Questions\n- How would you test for audio corruption during a power loss or app termination?\n- How would you handle recording while the app moves to the background?","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Coinbase","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T08:44:02.388Z","createdAt":"2026-01-19T08:44:02.388Z"},{"id":"q-4298","question":"Build a beginner iOS SwiftUI FAQ viewer: load a bundled JSON of FAQs (id, question, answer, category), display a searchable list with a debounced search (Combine) that filters on question or answer, a tap expands to show the answer, and persist the last search query to UserDefaults. Include a basic unit test for JSON decoding and search filtering?","answer":"Decode FAQs with Codable from bundled JSON into FAQ models. Show a SwiftUI List with expandable rows. Add a debounced search using Combine that filters by question or answer. Persist last search query","explanation":"## Why This Is Asked\n\nAssesses ability to model data with Codable, design a lightweight SwiftUI UI, and implement debounced search with Combine. It also checks practical local persistence patterns and basic test coverage without network complexity.\n\n## Key Concepts\n\n- SwiftUI List and expandable rows\n- Codable decoding from a local JSON bundle\n- Combine-based debounced search and state binding\n- UserDefaults persistence for simple state\n\n## Code Example\n\n```swift\nstruct FAQ: Codable {\n  let id: Int\n  let question: String\n  let answer: String\n  let category: String?\n}\n```\n\n## Follow-up Questions\n\n- How would you scale the search to support fuzzy matching?\n- How would you add localization for questions and answers?","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Meta","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T11:52:07.770Z","createdAt":"2026-01-19T11:52:07.770Z"},{"id":"q-4369","question":"Design offline-first iOS chat feature: drafts are queued locally and synced to the server when online. Describe the CoreData data model (fields: id, convoId, localSeq, serverId, status, timestamp), the background sync pipeline using URLSession, and the conflict resolution strategy (per-convo ordering, idempotent upserts). Include a test plan for disconnects, message reordering, and partial failures?","answer":"Design offline-first chat: store drafts and sent messages in CoreData with fields id (UUID), convoId (UUID), localSeq (Int64), serverId (String?), status (pending/sent/delivered), timestamp, and conte","explanation":"## Why This Is Asked\n\nAssess ability to design offline-first data sync with robust conflict handling and test planning.\n\n## Key Concepts\n\n- CoreData modeling for messages and conversations\n- Local queue and optimistic UI updates\n- Background sync with URLSession\n- Conflict resolution using per-conversation ordering, serverSeq, and idempotent upserts\n- Testing offline scenarios, reordering, and partial failures\n\n## Code Example\n\n```swift\n// CoreData model sketch\n// Entities: Conversation(id: UUID), Message(id: UUID, convoId: UUID, localSeq: Int64, serverId: String?, status: String, timestamp: Date, content: String)\n```\n\n## Follow-up Questions\n\n- How would you simulate out-of-order deliveries in tests?\n- How would you scale per-convo queues for large datasets?\n","diagram":null,"difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Two Sigma","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T15:59:29.744Z","createdAt":"2026-01-19T15:59:29.744Z"},{"id":"q-4442","question":"Build a beginner SwiftUI iOS Gallery screen that loads image URLs from a bundled JSON, displays a grid, downloads images via URLSession, and caches each image on disk atomically in the Documents directory so it persists across restarts. Include a manual Refresh to re-fetch metadata and a basic unit test verifying disk write/read of a cached image?","answer":"Use a small MVVM SwiftUI gallery. Load image metadata from a bundled JSON into a model, then for each item check a disk cache dir for a local file; if missing, fetch with URLSession, write to a temp f","explanation":"## Why This Is Asked\n\nTests offline-first caching, atomic disk writes, and SwiftUI grid rendering with a testable data layer.\n\n## Key Concepts\n\n- SwiftUI LazyVGrid for gallery\n- URLSession data tasks for image fetch\n- FileManager and atomic writes to Documents cache\n- Codable parsing of bundled JSON\n- Persistence across restarts and simple unit tests\n\n## Code Example\n\n```swift\nimport Foundation\nimport SwiftUI\n\nstruct ImageItem: Decodable { let id: String; let url: String }\n\nclass GalleryVM: ObservableObject {\n    @Published var items: [ImageItem] = []\n    let cacheDir: URL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0].appendingPathComponent(\"imageCache\")\n\n    init() { loadMetadata() }\n\n    func loadMetadata() {\n        // load from Bundle JSON (omitted for brevity)\n    }\n\n    func localPath(for id: String) -> URL {\n        cacheDir.appendingPathComponent(\"\\(id).jpg\")\n    }\n\n    func fetchIfNeeded(item: ImageItem) async {\n        let path = localPath(for: item.id)\n        if FileManager.default.fileExists(atPath: path.path) { return }\n        guard let url = URL(string: item.url) else { return }\n        let (data, _) = try! await URLSession.shared.data(from: url)\n        // write atomically\n        let tmp = path.appendingPathExtension(\"tmp\")\n        try! data.write(to: tmp)\n        try! FileManager.default.moveItem(at: tmp, to: path)\n        await MainActor.run { self.objectWillChange.send() }\n    }\n}\n```\n\n## Follow-up Questions\n\n- How would you add a basic cache eviction policy?\n- How would you test network failure scenarios in this flow?","diagram":"flowchart TD\n  A[Bundled JSON loaded] --> B[Parse ImageItem list]\n  B --> C{Cached on disk?}\n  C -->|Yes| D[Display from disk]\n  C -->|No| E[URLSession fetch]\n  E --> F[Write temp file]\n  F --> G[Atomic move to final path]\n  G --> H[Update UI]\n  H --> I[Manual Refresh triggers reload]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","LinkedIn","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T19:04:47.086Z","createdAt":"2026-01-19T19:04:47.086Z"},{"id":"q-4535","question":"Design offline-first iOS feature: a 'Comments Console' for a document collaboration app. Users draft comments offline; changes persist in Core Data and are synced as delta patches when the network becomes available. Describe the data model, patch format, conflict resolution, and a test plan for offline edits, concurrent edits, and reconnect scenarios?","answer":"To implement an offline-first Comments Console, model Comment with id, documentId, authorId, text, createdAt, updatedAt, and a patch version. Persist locally in Core Data; compute deltas as patch objects containing baseVersion, changes, and timestamps. Apply patches using a reconciliation strategy that handles conflicts through either latest-writer-wins or server-validated merges. Ensure data consistency by maintaining version history and implementing rollback capabilities for failed sync operations.","explanation":"## Why This Is Asked\n\nAssesses offline-first design, delta-based syncing, and conflict handling under intermittent connectivity, which are critical in collaboration apps used by teams.\n\n## Key Concepts\n\n- Core Data data model for Comment and Patch objects\n- Delta/patch format including baseVersion, changes, and timestamps\n- Reconciliation strategy (latest-writer-wins or server-validated merges)\n- Robust test plan for offline edits, re-connect, and concurrency\n\n## Code Example\n\n```javascript\n// Swift-like pseudocode: apply a patch to a Comment\nfunc apply(patch: Patch, to comment: inout Comment) {\n    // Validate base version matches current state\n    guard patch.baseVersion == comment.version else {\n        // Handle conflict resolution\n        resolveConflict(patch: patch, comment: &comment)\n        return\n    }\n    \n    // Apply delta changes\n    for change in patch.changes {\n        switch change.type {\n        case .insert:\n            comment.text.insert(change.text, at: change.position)\n        case .delete:\n            comment.text.removeSubrange(change.range)\n        case .replace:\n            comment.text.replaceSubrange(change.range, with: change.text)\n        }\n    }\n    \n    // Update version and timestamps\n    comment.version += 1\n    comment.updatedAt = Date()\n}\n```","diagram":null,"difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Hugging Face"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T06:28:13.161Z","createdAt":"2026-01-19T22:45:20.221Z"},{"id":"q-464","question":"How would you implement a custom UICollectionViewFlowLayout that supports dynamic cell heights and sticky headers while maintaining smooth scrolling performance?","answer":"Override `prepare()` to pre-calculate and cache layout attributes in a dictionary for efficient access. Implement `shouldInvalidateLayout(forBoundsChange:)` to handle sticky header positioning, and use `estimatedItemSize` with automatic height calculation. Cache the results to avoid expensive recalculations during scrolling.","explanation":"## Key Implementation Steps\n\n- Override `prepare()` to calculate and cache layout attributes for all elements\n- Implement `layoutAttributesForElements(in:)` to return cached attributes for visible elements\n- Use `shouldInvalidateLayout(forBoundsChange:)` to manage sticky header behavior during scroll\n- Set `estimatedItemSize` to enable dynamic height calculation for variable content\n\n## Performance Optimizations\n\n- Cache calculations in memory to avoid repeated expensive operations\n- Use `UICollectionViewFlowLayoutInvalidationContext` for targeted layout updates instead of full invalidation\n- Implement `targetContentOffset(forProposedContentOffset:)` to ensure smooth scrolling behavior\n\n## Common Pitfalls\n\n- Avoid performing expensive calculations in `layoutAttributesForElements(in:)` as it's called frequently\n- Don't invalidate the entire layout unnecessarily; use targeted invalidation contexts instead\n- Be careful with memory usage when caching large amounts of layout attributes","diagram":"flowchart TD\n  A[prepare() - Calculate Attributes] --> B[Cache in Dictionary]\n  B --> C[layoutAttributesForElements]\n  C --> D[shouldInvalidateLayout]\n  D --> E[Sticky Headers Logic]\n  E --> F[Smooth Scrolling]","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Lyft","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-09T09:00:07.232Z","createdAt":"2025-12-26 12:51:05"},{"id":"q-4648","question":"In an iOS streaming app with offline transcripts per user, implement a secure offline cache that is per-user encrypted at rest, uses keys stored in the Keychain, and automatically re-encrypts on logout; design the data model, pick storage (Core Data vs SQLite), implement background downloads with URLSessionBackgroundTask, and a test plan to verify data isolation, migration, and crash recovery?","answer":"Use per-user envelope encryption: a per-user AES-256-GCM key is wrapped by a Keychain key; transcripts are stored as encrypted binary blobs in Core Data. Downloads run via URLSessionBackgroundTask; on","explanation":"## Why This Is Asked\n\nTests mastery of iOS offline security, per-user data isolation, and production-grade background downloads. It also probes trade-offs between Core Data and SQLite for binary blobs and how to manage key lifecycles across login/logout.\n\n## Key Concepts\n\n- Envelope encryption per user with Keychain-wrapped keys\n- Data-at-rest protections (NSFileProtection, encryption)\n- Storage choice: Core Data vs SQLite for binary blobs\n- Background downloads with URLSessionBackgroundTask\n- Key rotation and logout data purge, crash recovery\n\n## Code Example\n\n```swift\nimport CryptoKit\n\nfunc encrypt(_ payload: Data, with key: SymmetricKey) throws -> Data {\n  let sealed = try AES.GCM.seal(payload, using: key)\n  return sealed.combined!\n}\n\nfunc decrypt(_ data: Data, with key: SymmetricKey) throws -> Data {\n  let box = try AES.GCM.SealedBox(combined: data)\n  return try AES.GCM.open(box, using: key)\n}\n```\n\n## Follow-up Questions\n\n- How would you test cross-user data isolation in unit/integration tests?\n- How would you migrate transcripts if key derivation changes?","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T06:55:14.589Z","createdAt":"2026-01-20T06:55:14.589Z"},{"id":"q-4710","question":"**Offline-First Ledger:** Design an offline-first ledger viewer for a fintech app where data is encrypted end-to-end with keys in Secure Enclave, persisted atomically in a local database, and synced to a central server when online. Include per-user permissions, deterministic conflict resolution, and crash-safe writes. Use Swift, SwiftUI, and async/await; outline architecture, data model, encryption workflow, and a practical test plan; provide a concise code skeleton.**?","answer":"Design an offline-first ledger view for a fintech app: encrypt all local entries with a key stored in Secure Enclave (CryptoKit), persist atomically in a local database, and sync with a central server","explanation":"## Why This Is Asked\n\nTests depth in secure offline data handling, multi-user permissions, and robust sync.\n\n## Key Concepts\n\n- Offline-first data model with atomic writes\n- End-to-end encryption via Secure Enclave (CryptoKit)\n- Per-user permissions and auditability\n- Deterministic conflict resolution for sync\n- Swift Concurrency patterns and testability\n\n## Code Example\n\n```swift\nimport CryptoKit\n\nstruct LedgerEntry: Codable { let id: UUID; let amount: Decimal; let ts: Date }\n\nfinal class CryptoManager {\n  func encrypt(_ data: Data, using key: SymmetricKey) -> Data { /* ... */ }\n  func decrypt(_ data: Data, using key: SymmetricKey) -> Data { /* ... */ }\n  var key: SymmetricKey { /* Secure Enclave-backed key */ get { fatalError() } }\n}\n```\n\n## Follow-up Questions\n\n- How would you test key rotation without user disruption?\n- How would you simulate network partitions and reconciliation? \n","diagram":"flowchart TD\n  A(Local Store) --> B(Encryption & Decryption)\n  B --> C(Sync Engine)\n  C --> D(Server)\n  D --> A","difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Meta","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T09:10:03.477Z","createdAt":"2026-01-20T09:10:03.477Z"},{"id":"q-4751","question":"Implement a minimal To-Read list in SwiftUI: load articles from a bundled JSON (title, author, tag, publishedDate). Display as a list, allow tapping a row to toggle 'read' status, and debounce taps. Persist the array to UserDefaults using JSONEncoder/Decoder so state survives app restarts. Add a search bar that filters by title or tag with a 300ms debounce. Ensure accessibility for VoiceOver and Dynamic Type. What is your test plan?","answer":"Decode a bundled JSON into Article structs, toggle read on tap, and persist the updated array to UserDefaults via JSONEncoder/Decoder so state survives restarts. Implement a 300ms debounce on taps and","explanation":"## Why This Is Asked\n\nAssesses practical data flow and UI responsiveness for iOS: decoding, lightweight persistence, and debounced inputs in SwiftUI.\n\n## Key Concepts\n\n- SwiftUI List and @State/@ObservedObject\n- Codable Article type and UserDefaults persistence\n- Debounce patterns (Combine or DispatchQueue)\n- Accessibility: VoiceOver and Dynamic Type\n- Debounced search filtering\n\n## Code Example\n\n```swift\nstruct Article: Codable {\n  let id: String\n  let title: String\n  let author: String\n  let tag: String\n  let publishedDate: String\n  var read: Bool\n}\n```\n\n## Follow-up Questions\n\n- How would you extend to remote sync with conflict resolution?\n- How would you test persistence across app updates and data migrations?\n","diagram":"flowchart TD\n  A[Bundled JSON] --> B[Decode to [Article]]\n  B --> C[List UI with SwiftUI]\n  C --> D[Tap toggles read]\n  D --> E[Persist to UserDefaults]\n  C --> F[Search with debounce]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T10:51:31.724Z","createdAt":"2026-01-20T10:51:31.724Z"},{"id":"q-4792","question":"Build a minimal note-taking screen in iOS (SwiftUI) that lets users create notes with a title and body, assign 0-3 tags, and persist all notes to a single local JSON file in the Documents directory. Add a tag-based filter and a live search bar that debounces input to keep UI snappy. Ensure data persists across restarts, handle app background/foreground transitions, and provide basic accessibility hints?","answer":"I would implement a Codable Note type and a NotesStore class that loads/saves an array of notes to Documents/notes.json using an atomic write (temp file + swap). UI uses SwiftUI with @Published notes ","explanation":"## Why This Is Asked\nTests practical iOS fundamentals: Codable data models, file-based persistence with atomic writes, and SwiftUI data flow. It also exercises UX concerns like debounce for responsiveness and accessibility considerations.\n\n## Key Concepts\n- Codable data model for Note with title, body, tags, and date\n- File I/O in Documents with atomic write pattern\n- SwiftUI state management using @Published and binding for filters\n- Combine debouncing for search input\n- Tag-based filtering logic and accessibility labeling\n\n## Code Example\n```javascript\nimport Foundation\n\nstruct Note: Codable, Identifiable {\n  var id: UUID = UUID()\n  var title: String\n  var body: String\n  var tags: [String]\n  var date: Date = Date()\n}\n\nfinal class NotesStore: ObservableObject {\n  @Published var notes: [Note] = []\n  private let fileURL: URL = FileManager.default\n    .urls(for: .documentDirectory, in: .userDomainMask)[0]\n    .appendingPathComponent(\"notes.json\")\n\n  init() { load() }\n\n  func load() {\n    guard let data = try? Data(contentsOf: fileURL) else { return }\n    if let loaded = try? JSONDecoder().decode([Note].self, from: data) {\n      notes = loaded\n    }\n  }\n\n  func save() {\n    let tempURL = fileURL.appendingPathExtension(\"tmp\")\n    guard let data = try? JSONEncoder().encode(notes) else { return }\n    try? data.write(to: tempURL)\n    try? FileManager.default.replaceItemAtURL(fileURL, withItemAtURL: tempURL)\n  }\n}\n```\n\n## Follow-up Questions\n- How would you scale this to thousands of notes while keeping memory usage low?\n- How would you test atomic write correctness and debounce behavior?\n- How would you migrate to Core Data or add cloud sync later?","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Microsoft","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T13:14:40.687Z","createdAt":"2026-01-20T13:14:40.687Z"},{"id":"q-4895","question":"Build a beginner-friendly iOS SwiftUI feature: a draggable TaskList where items can be reordered via long-press drag, persisted locally in UserDefaults as a Codable array, and restored on app restart. Include a search bar to filter tasks and ensure VoiceOver announces drag-reorder actions. Provide a minimal test plan and a code skeleton?","answer":"To implement: define a Codable Task { let id: UUID; var title: String; var completed: Bool }. Persist via JSON in UserDefaults using Data, encode/decode on save and on app launch. Use a SwiftUI List w","explanation":"## Why This Is Asked\nTests ability to design a small, interactive UI with local persistence and accessibility considerations.\n\n## Key Concepts\n- SwiftUI List with onMove\n- Codable + UserDefaults/AppStorage\n- Searchable/filtering and dynamic type\n- VoiceOver drag feedback\n\n## Code Example\n```swift\nstruct Task: Codable, Identifiable { let id: UUID; var title: String; var completed: Bool }\nclass TaskVM: ObservableObject { @Published var tasks:[Task] = []; func save(){...} func load(){...} }\n```\n\n## Follow-up Questions\n- How would you scale for many items? \n- How handle schema changes? \n- How to write UI tests for reordering?","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["NVIDIA","Snowflake","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T17:52:00.808Z","createdAt":"2026-01-20T17:52:00.808Z"},{"id":"q-495","question":"How would you implement a simple UITableView with custom cells in iOS using Swift?","answer":"Create a UITableViewCell subclass, register it using tableView.register(CustomCell.self, forCellReuseIdentifier: \"cell\"), and implement the required UITableViewDataSource methods: numberOfRowsInSection and cellForRowAt.","explanation":"## Implementation Steps\n- Create a custom UITableViewCell class with IBOutlet connections\n- Register the cell class or nib with the table view\n- Implement the UITableViewDataSource protocol methods\n- Configure cell content in the cellForRowAt method\n- Handle cell selection and data updates\n\n## Key Concepts\n- Reusable cell pattern for optimal performance\n- Delegation pattern for table view event handling\n- Auto Layout for dynamic cell sizing\n- Efficient data source management","diagram":"flowchart TD\n  A[Create Custom Cell] --> B[Register Cell]\n  B --> C[Implement DataSource]\n  C --> D[Configure Cell]\n  D --> E[Handle Selection]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Oracle","Snowflake","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-08T11:59:05.660Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-5124","question":"iOS Beginner Challenge: Build a SwiftUI settings screen that lets a user choose a theme color from a small palette and adjust font size with a slider. Persist selections with @AppStorage so they survive app restarts; apply changes in real time to a live text preview; ensure accessibility labels for both color choices and the font size slider; include a concise test plan?","answer":"Use SwiftUI with two @AppStorage keys: one for themeColor (store as a hex or string) and one for fontSize (Double). Build a palette of color options; render them as tappable chips and reflect the sele","explanation":"## Why This Is Asked\nTests basic SwiftUI state management, on-device persistence, live UI updates, and accessibility considerations in a beginner-friendly setting.\n\n## Key Concepts\n- SwiftUI @AppStorage for lightweight persistence\n- Color theming and dynamic UI updates\n- Accessibility labeling and dynamic type considerations\n- Basic test planning: persistence, accessibility, UI consistency\n\n## Code Example\n```swift\n@AppStorage(\"themeColor\") private var themeColorHex: String = \"#4285F4\"\n@AppStorage(\"fontSize\") private var fontSize: Double = 14.0\n\nvar body: some View {\n  VStack {\n    // color palette and font size slider UI here\n    Text(\"Preview text\").font(.system(size: CGFloat(fontSize)))\n      .foregroundColor(Color(hex: themeColorHex))\n  }\n}\n```\n\n## Follow-up Questions\n- How would you validate edge cases like invalid saved color values?\n- How would you extend this to support dark mode vs light mode themes?","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T07:12:19.989Z","createdAt":"2026-01-21T07:12:19.989Z"},{"id":"q-5196","question":"In an offline-first iOS note app, design and implement a CRDT-based synchronization layer to merge edits across devices, using Core Data for local storage and a delta-based sync over WebSocket. Describe the data model, conflict resolution strategy, and convergence guarantees; outline a minimal Swift CRDT example and a test plan to validate correctness?","answer":"Design and implement a CRDT-based sync layer for an offline-first iOS note app. Store documents in Core Data; edits as per-character sequence CRDT with tombstones; delta-based sync over WebSocket; det","explanation":"## Why This Is Asked\nOffline collaboration on mobile requires robust conflict resolution and efficient synchronization. CRDTs provide convergence guarantees but are nuanced on iOS memory and serialization. This question tests data modeling, multithreading, and network resilience.\n\n## Key Concepts\n- CRDT design for text edits (sequence CRDT)\n- Core Data integration for local persistence\n- Delta-based synchronization and tombstones\n- Causality with vector clocks and deterministic merge\n- Testing offline/online scenarios\n\n## Code Example\n\n```swift\n// Minimal CRDT element\nstruct TextOp: Codable {\n  let id: UUID\n  let pos: Int\n  let ch: Character\n  let tombstone: Bool\n}\n```\n\n```swift\n// Pseudo-merge function signature\nfunc apply(_ op: TextOp, to doc: inout String) { /* deterministic insert/delete */ }\n```\n\n## Follow-up Questions\n- How to size and compress delta payloads?\n- How to test convergence under latency and reordering?\n- How to handle conflicts when edits arrive out-of-order?","diagram":"flowchart TD\n  A[Local Edit] --> B[CRDT Merge]\n  B --> C[Delta Sync over WebSocket]\n  C --> D[Remote Edits Applied]\n  D --> A","difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","NVIDIA","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T10:38:46.407Z","createdAt":"2026-01-21T10:38:46.409Z"},{"id":"q-5244","question":"Build a minimal iOS app named 'HuntList' with a grocery items list loaded from a bundled JSON. Allow adding items via a text field and persist the updated list to a local JSON file atomically in the Documents directory. Implement Dynamic Type and per-row VoiceOver hints; ensure the Add button is accessible. Debounce taps to avoid duplicates. Data must persist across restarts and respond to foreground/background transitions. Use SwiftUI; include a basic test plan for JSON decoding and atomic writes?","answer":"Load initial items from bundled JSON into a published array and display them in a SwiftUI List. Add items with a debounced tap to prevent duplicates. Persist updates with FileManager.default.write(to:","explanation":"## Why This Is Asked\nTests practical basics: SwiftUI, data persistence, debounced input, and accessibility, plus basic testing. It avoids the previous patterns and emphasizes correctness and UX.\n\n## Key Concepts\n- SwiftUI data flow; @Published; URL in Documents\n- JSON encoding/decoding; atomic file writes\n- Debounce input; accessibility labels/hints; Dynamic Type\n- ScenePhase changes and simple test planning\n\n## Code Example\n```javascript\n// Pseudo Swift-like snippet omitted for brevity\n```\n\n## Follow-up Questions\n- How would you handle large JSON files or synchronization across devices?\n- How would you test accessibility for VoiceOver in this flow?","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Google","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T11:57:35.926Z","createdAt":"2026-01-21T11:57:35.926Z"},{"id":"q-525","question":"You're building a food delivery app like DoorDash. How would you implement background location updates to track delivery drivers while balancing battery life and accuracy?","answer":"Use CLLocationManager with significantLocationChangeMonitoring for battery efficiency, switching to standard location updates during active deliveries. Implement region-based geofencing for restaurant and destination zones to trigger location updates only when necessary.","explanation":"## Background Location Strategy\n\n- **significantLocationChangeMonitoring**: Battery-efficient for idle drivers\n- **Standard location updates**: High accuracy during active deliveries\n- **Geofencing**: CLRegion for restaurant/destination zones\n- **Deferred updates**: Batch location data to reduce wake-ups\n\n## Implementation Details\n\n```swift\nlet locationManager = CLLocationManager()\nlocationManager.allowsBackgroundLocationUpdates = true\nlocationManager.pausesLocationUpdatesAutomatically = true\nlocationManager.activityType = .otherNavigation\n```\n\n## Battery Optimization\n\n- Use desiredAccuracy = kCLLocationAccuracyHundredMeters for monitoring\n- Switch to kCLLocationAccuracyBestForNavigation during deliveries\n- Implement adaptive update frequency based on speed and proximity\n- Leverage iOS motion detection to pause updates when stationary","diagram":"flowchart TD\n  A[Driver Idle] --> B[Significant Location Change]\n  B --> C{Delivery Accepted?}\n  C -->|Yes| D[Standard Location Updates]\n  C -->|No| B\n  D --> E[Active Navigation]\n  E --> F{Near Destination?}\n  F -->|Yes| G[Geofence Trigger]\n  F -->|No| E\n  G --> H[Delivery Complete]\n  H --> A","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Microsoft","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-09T08:42:22.344Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-578","question":"What's the difference between weak and unowned references in Swift, and when would you use each?","answer":"Weak references are optional and automatically become nil when the referenced object is deallocated. Unowned references are non-optional and assume the referenced object will always exist. Use weak for optional relationships where the referenced object might be deallocated first.","explanation":"## Memory Management\n\nSwift uses ARC (Automatic Reference Counting) to manage memory automatically. Strong references can create retain cycles, so we use weak and unowned references to break them.\n\n## Weak References\n\n- Always optional (automatically set to nil on deallocation)\n- Use for optional relationships\n- Common patterns: delegates, outlets\n\n```swift\nweak var delegate: MyDelegate?\n```\n\n## Unowned References\n\n- Non-optional (assumes reference always exists)\n- Use when you know the reference will outlive the holder\n- Common patterns: parent-child relationships\n\n```swift\nunowned let parent: ParentClass\n```\n\n## Key Differences\n\nChoose weak when the reference might become nil during execution. Choose unowned when you're certain the reference will always exist throughout the object's lifetime.","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-08T11:52:32.417Z","createdAt":"2025-12-27T01:13:27.377Z"},{"id":"q-181","question":"Explain the difference between weak and unowned references in Swift and provide practical use cases for each?","answer":"Weak references are optional and automatically become nil when the referenced object is deallocated, while unowned references are non-optional and assume the object will always exist during the reference's lifetime, causing a crash if accessed after deallocation.","explanation":"## Why Asked\nTests memory management understanding and preventing retain cycles in iOS development\n\n## Key Concepts\n- Automatic Reference Counting (ARC)\n- Strong reference cycles\n- Optional vs non-optional references\n- Lifetime expectations\n\n## Code Example\n```\nclass Parent {\n    weak var child: Child?\n    unowned let partner: Parent\n}\n\n// weak: when object might become nil (e.g., delegates)\n// unowned: when object outlives reference (e.g., parent-child)\n```\n\n## Follow-up Questions\n- How do you identify retain cycles?\n- What happens when you access an unowned reference after deallocation?\n- When would you choose weak vs unowned in a real application?","diagram":"flowchart TD\n  A[Object Created] --> B{Reference Type?}\n  B -->|May become nil| C[weak var]\n  B -->|Always exists| D[unowned]\n  C --> E[Becomes nil on deallocation]\n  D --> F[Crashes if accessed after deallocation]","difficulty":"intermediate","tags":["swift","language"],"channel":"ios","subChannel":"swift","sourceUrl":null,"videos":{"shortVideo":"https://www.youtube.com/watch?v=bMNwHNOVdXw","longVideo":"https://www.youtube.com/watch?v=8KQcTDGqQEc"},"companies":["Amazon","Apple","Google","Meta","Microsoft"],"eli5":"Imagine you're playing with building blocks! A 'weak' reference is like saying 'I'm looking at my friend's red block.' If your friend takes their block away, you just shrug and say 'Oh well, no red block anymore!' You don't cry or break anything. An 'unowned' reference is like saying 'I'm holding my friend's blue block and I KNOW it's there!' If your friend secretly takes the block away and you try to grab it, you'll trip and fall because you expected it to be there! Use weak references when you're just watching something that might disappear (like watching a toy car that might drive away). Use unowned references when you're absolutely sure something will stay there (like holding onto your mom's hand while crossing the street).","relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-01T06:41:21.669Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-257","question":"What is optional chaining in Swift and how does it compare to force unwrapping, optional binding, and optional chaining with method calls when accessing nested optional properties?","answer":"Optional chaining (?.) safely unwraps optionals, returning nil if any link fails instead of throwing runtime errors. Unlike force unwrapping (!), it prevents crashes. It's more concise than if-let/guard-let for single access and works with methods, subscripts, and nested optionals like person?.address?.street?.count.","explanation":"## Core Concept\nOptional chaining (?.) provides a safe way to access properties, methods, and subscripts of optional values, returning nil if any part of the chain is nil.\n\n## Key Differences\n- **Force unwrapping (!)**: Crashes if nil\n- **Optional binding**: Requires separate if-let/guard-let blocks\n- **Optional chaining**: Single-line safe access\n\n## Code Examples\n```swift\n// Nested optionals\nlet streetCount = person?.address?.street?.count\n\n// Method calls with optional chaining\nlet result = optionalObject?.method()?.property\n\n// Subscript access\nlet value = dictionary?[key]?.nestedValue\n```\n\n## Performance & Best Practices\n- Slight overhead vs force unwrapping due to nil checks\n- Use when you need single access to deeply nested optionals\n- Prefer optional binding for multiple operations on the same value\n- Avoid excessive chaining that reduces code readability\n\n## Common Pitfalls\n- Forgetting that the result is always optional\n- Mixing with force unwrapping in the same chain\n- Not handling the nil case appropriately","diagram":"graph TD\n    A[person] --> B[residence?]\n    B --> C[address?]\n    C --> D[street: String]\n    \n    E[Optional Chaining ?. ] --> F{Check residence}\n    F -->|nil| G[Return nil]\n    F -->|exists| H{Check address}\n    H -->|nil| G\n    H -->|exists| I[Return street value]\n    \n    style G fill:#ffcccc\n    style I fill:#ccffcc","difficulty":"beginner","tags":["optionals","protocols","generics"],"channel":"ios","subChannel":"swift","sourceUrl":null,"videos":{"shortVideo":"https://www.youtube.com/watch?v=Hfpx494ess8","longVideo":"https://www.youtube.com/watch?v=S8-QO2wUbRg"},"companies":["Amazon","Apple","Google","Meta","Microsoft","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-26T16:39:04.627Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-204","question":"How would you optimize a UITableView with 10,000+ complex cells using Auto Layout while maintaining 60fps scrolling and memory efficiency?","answer":"Use cell reuse, pre-calculate heights, implement heightForRowAt caching, and optimize Auto Layout constraints with manual layout when needed.","explanation":"## Concept Overview\nOptimizing large UITableViews requires balancing memory usage, rendering performance, and smooth scrolling. Auto Layout adds computational overhead that becomes critical at scale.\n\n## Implementation Details\n\n### Cell Reuse Strategy\n```swift\noverride func prepareForReuse() {\n    super.prepareForReuse()\n    // Reset expensive operations\n    imageView.image = nil\n    complexView.resetContent()\n}\n```\n\n### Height Caching System\n```swift\nprivate var heightCache: [IndexPath: CGFloat] = [:]\n\nfunc tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n    if let cached = heightCache[indexPath] {\n        return cached\n    }\n    let height = calculateHeight(for: indexPath)\n    heightCache[indexPath] = height\n    return height\n}\n```\n\n### Auto Layout Optimization\n- Use `setNeedsLayout()` instead of `layoutIfNeeded()`\n- Prefer `intrinsicContentSize` over complex constraints\n- Implement `systemLayoutSizeFitting` for height calculation\n\n### Memory Management\n- Use weak references for cell closures\n- Implement `didEndDisplaying` for cleanup\n- Consider async image loading with placeholder\n\n## Common Pitfalls\n- Not caching heights leads to expensive recalculations\n- Complex Auto Layout in cell configuration blocks\n- Memory leaks from strong reference cycles\n- Ignoring cell reuse lifecycle","diagram":"flowchart LR\n    A[User Scrolls] --> B[dequeueReusableCell]\n    B --> C{Height Cached?}\n    C -->|Yes| D[Use Cached Height]\n    C -->|No| E[Calculate Height]\n    E --> F[Cache Height]\n    F --> G[Configure Cell]\n    G --> H[Apply Constraints]\n    H --> I[Render Cell]\n    I --> J[Display]\n    D --> G","difficulty":"advanced","tags":["autolayout","tableview","collectionview"],"channel":"ios","subChannel":"uikit","sourceUrl":null,"videos":null,"companies":["Airbnb","Apple","Capital One","Lyft","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-26T12:38:17.524Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-232","question":"How does Auto Layout constraint resolution work when creating a UITableView with dynamic cell heights?","answer":"Auto Layout resolves constraints by calculating required cell heights based on content, then UITableView applies these heights during layout.","explanation":"## Concept Overview\nAuto Layout constraint resolution is the process where iOS calculates the size and position of views based on their constraints. For UITableView with dynamic cells, this happens in two phases.\n\n## Implementation Details\n1. **System Layout Size Fitting**: UITableView calls `systemLayoutSizeFitting` on each cell prototype\n2. **Constraint Resolution**: Auto Layout engine resolves all constraints to determine cell height\n3. **Height Caching**: UITableView caches calculated heights for performance\n4. **Layout Application**: Heights are applied during the table view's layout pass\n\n## Code Example\n```swift\n// In UITableViewCell subclass\noverride func awakeFromNib() {\n    super.awakeFromNib()\n    // Enable auto-sizing\n    contentView.translatesAutoresizingMaskIntoConstraints = false\n}\n\n// In UITableViewController\ntableView.rowHeight = UITableView.automaticDimension\ntableView.estimatedRowHeight = 100\n```\n\n## Common Pitfalls\n- Missing `translatesAutoresizingMaskIntoConstraints = false`\n- Incomplete constraint chains leading to ambiguous layouts\n- Performance issues with complex constraint hierarchies\n- Not setting `estimatedRowHeight` causing layout delays","diagram":"graph TD\n    A[UITableView] --> B[Cell Prototype]\n    B --> C[Auto Layout Engine]\n    C --> D[Constraint Resolution]\n    D --> E[Height Calculation]\n    E --> F[Height Caching]\n    F --> G[Layout Application]\n    G --> H[Final Cell Display]","difficulty":"beginner","tags":["autolayout","tableview","collectionview"],"channel":"ios","subChannel":"uikit","sourceUrl":null,"videos":null,"companies":["Airbnb","Apple","Google","Meta","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-27T04:55:46.823Z","createdAt":"2025-12-26 12:51:07"}],"subChannels":["general","swift","uikit"],"companies":["Adobe","Airbnb","Amazon","Apple","Bloomberg","Capital One","Citadel","Cloudflare","Coinbase","Databricks","Discord","DoorDash","Goldman Sachs","Google","Hashicorp","Hugging Face","IBM","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Netflix","OpenAI","Oracle","PayPal","Robinhood","Salesforce","Scale Ai","Slack","Snap","Snowflake","Square","Stripe","Tesla","Twitter","Two Sigma","Uber","Zoom"],"stats":{"total":50,"beginner":22,"intermediate":13,"advanced":15,"newThisWeek":34}}