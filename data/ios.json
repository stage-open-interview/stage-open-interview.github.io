{"questions":[{"id":"q-1064","question":"Design and implement a streaming app's episode grid using a UICollectionView with a compositional layout that supports dynamic item sizes, infinite scrolling, and efficient image caching; use a modern iOS approach (Diffable Data Source, NSCache, prefetching), ensure accessibility and testability?","answer":"Implement a UICollectionView grid for episodes using a compositional layout and a single diffable data source. Use NSCache to cache episode artwork, set up prefetching to load next pages, and implemen","explanation":"## Why This Is Asked\n\nTests practical experience building a robust iOS grid for streaming content, focusing on modern data sources, memory efficiency, and accessibility in a scalable way.\n\n## Key Concepts\n\n- UICollectionView with Diffable Data Source\n- UICollectionViewCompositionalLayout\n- Prefetching and infinite scrolling\n- Image caching with NSCache\n- Accessibility labels and testing strategies\n\n## Code Example\n\n```swift\n// Example diffable data source setup\nlet dataSource = UICollectionViewDiffableDataSource<Int, Episode>(collectionView: collectionView) { cv, indexPath, episode in\n  let cell = cv.dequeueReusableCell(withReuseIdentifier: \"EpisodeCell\", for: indexPath) as! EpisodeCell\n  cell.configure(with: episode)\n  return cell\n}\n```\n\n## Follow-up Questions\n\n- How would you handle memory pressure and invalidate cached images?\n- How would you test diffable data source updates and scrolling behavior?\n","diagram":null,"difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Netflix","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T21:23:50.063Z","createdAt":"2026-01-12T21:23:50.063Z"},{"id":"q-1164","question":"You're building a lightweight notes app for iOS. Implement a NotesEditor view (SwiftUI) that autosaves to disk as the user types, using a 500ms debounce. Persist to a local JSON file in the app's documents directory. Ensure rapid typing doesn't cause multiple disk writes, and provide a minimal unit test that verifies the file content is updated after a debounce period?","answer":"Implement a SwiftUI NotesEditor with a @Published note. Debounce saves to disk at 500ms using Combine: $note.debounce(for: .milliseconds(500), scheduler: RunLoop.main).sink { save(note) }. Persist by ","explanation":"## Why This Is Asked\nTests practical understanding of combining UI state with asynchronous persistence, a common real-world pattern.\n\n## Key Concepts\n- Combine debouncing for UI-driven writes\n- File I/O and JSON encoding in Swift\n- SwiftUI data flow and @Published bindings\n- Unit testing asynchronous code and filesystem writes\n\n## Code Example\n```swift\nimport Combine\nimport SwiftUI\n\nclass NotesStore: ObservableObject {\n  @Published var note: String = \"\"\n  private var cancellables = Set<AnyCancellable>()\n  init() {\n    $note\n      .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n      .sink { [weak self] text in\n        self?.save(text)\n      }\n      .store(in: &cancellables)\n  }\n  func save(_ text: String) {\n    let json = [\"note\": text]\n    if let data = try? JSONSerialization.data(withJSONObject: json, options: []) {\n      let url = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]\n        .appendingPathComponent(\"notes.json\")\n      try? data.write(to: url)\n    }\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test cancellation of a pending save when the app moves to background?\n- How would you extend to multi-note scenarios with conflict resolution?","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Google","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T03:30:46.016Z","createdAt":"2026-01-13T03:30:46.016Z"},{"id":"q-1185","question":"In an iOS app, you are displaying a feed of user avatars in a UICollectionView with infinite scrolling. Explain how you would implement incremental image loading that cancels obsolete requests, caches images both in memory and on disk, uses Swift concurrency for loading, and ensures smooth scrolling under memory pressure, including prefetching and memory-pressure handling strategies?","answer":"Use a two-tier cache and cancellable loading. Use NSCache for memory and a disk cache via FileManager. For each cell, spawn a Task tied to the cell's lifecycle; cancel on prepareForReuse. Load with UR","explanation":"## Why This Is Asked\n\nThis question tests practical image loading in a scrolling feed, covering cancellation semantics with cell reuse, multi-level caching, and Swift concurrency, plus handling memory pressure and prefetching.\n\n## Key Concepts\n\n- UICollectionView infinite scrolling\n- Memory and disk caching strategy\n- Swift concurrency and Task cancellation\n- Cell reuse and race condition handling\n- Prefetching and memory-pressure testing\n\n## Code Example\n\n```swift\nimport UIKit\n\nactor ImageCache {\n  private var memory = NSCache<NSString, UIImage>()\n  private let diskURL: URL\n  func load(_ url: URL) async -> UIImage? { ... }\n}\n```\n\n## Follow-up Questions\n\n- How would you measure scrolling smoothness and cache hit rate in production?\n- How would you adapt this for SwiftUI's AsyncImage?","diagram":"flowchart TD\n  A[Start] --> B[CellForItemAt]\n  B --> C[Check memory cache]\n  C -->|Hit| D[Bind image]\n  C -->|Miss| E[Check disk cache]\n  E -->|Hit| F[Decode & cache]\n  E -->|Miss| G[Network fetch]\n  G --> H[Decode & cache on disk & memory]\n  H --> I[Bind to cell]","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Bloomberg","Goldman Sachs"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T04:38:02.306Z","createdAt":"2026-01-13T04:38:02.307Z"},{"id":"q-1439","question":"In a recipe-list iOS app, implement a multi-select ingredient filter as tappable chips using UIKit. Given a static dataset of recipes with ingredients, create a chips bar that allows selecting multiple ingredients, a Clear button, and a table view that shows only recipes containing all selected ingredients. Ensure accessibility labels and VoiceOver order, and provide a simple unit test validating the filter logic?","answer":"I would model Recipe{name, ingredients}, store a static dataset, and build a ChipsView with a horizontal UICollectionView of UIButton chips. Maintain a Set<String> selected; tapping toggles a chip. Fi","explanation":"## Why This Is Asked\nAssesses ability to translate a UX requirement into a single view using UIKit, including state management, filtering logic, and accessibility. It also touches testing of business logic separate from UI.\n\n## Key Concepts\n- UIKit: UICollectionView for chips, UITableView for results\n- Data modeling with Structs, Sets, and filtering\n- Accessibility: labels, traits, and VoiceOver order\n- Testing: unit-test the filtering function independent of UI\n\n## Code Example\n```swift\nstruct Recipe {\n  let name: String\n  let ingredients: [String]\n}\n\nfunc filtered(_ recipes: [Recipe], by selected: Set<String>) -> [Recipe] {\n  guard !selected.isEmpty else { return recipes }\n  return recipes.filter { selected.isSubset(of: Set($0.ingredients)) }\n}\n```\n\n## Follow-up Questions\n- How would you scale this if the dataset grows to thousands of recipes?\n- How would you adapt this to SwiftUI and compare the data flow with UIKit?","diagram":"flowchart TD\n  A[Load dataset] --> B[Render chips]\n  B --> C{Chip tapped?}\n  C -->|Yes| D[Update selected set]\n  D --> E[Apply filter]\n  E --> F[Update results view]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Databricks","DoorDash"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T17:00:06.297Z","createdAt":"2026-01-13T17:00:06.297Z"},{"id":"q-1573","question":"Design a beginner iOS feature: a SwiftUI-based **Favorites** screen for a recipe app. It should load a predefined array of Recipe objects from a local JSON file, display in a single-column list, allow tapping to mark/unmark as favorite, persist favorites in **UserDefaults**, and provide a search bar to filter by name **case-insensitively**. Explain how you'd structure the model, storage, and UI, and how you'd test search and persistence?","answer":"Use MVVM with a Recipe model, decode JSON into Recipe structs, and store favorites as a Set of ids in @AppStorage (UserDefaults). Bind the list to an @Published filtered array driven by a search strin","explanation":"## Why This Is Asked\\n\\nAssesses ability to combine SwiftUI, local persistence, and simple filtering.\\n\\n## Key Concepts\\n- MVVM with SwiftUI\\n- Data binding and @Published\\n- Local persistence via JSON + UserDefaults\\n- Search filtering with case-insensitive comparison\\n- Testability of filtering and persistence\\n\\n## Code Example\\n```swift\\nstruct Recipe: Codable, Identifiable { let id: String; let name: String; var isFavorite: Bool }\\nclass RecipeViewModel: ObservableObject { @Published var recipes: [Recipe] = []; @Published var search = \\\"\\\"; var filtered: [Recipe] { recipes.filter { $0.name.lowercased().contains(search.lowercased()) } } @AppStorage(\\\"favorites\\\") var favorites: Set<String> = [] }\\n```\\n\\n## Follow-up Questions\\n- How would you scale to a larger dataset?\\n- How would you handle data refresh with a remote source","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Google","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T22:36:50.906Z","createdAt":"2026-01-13T22:36:50.906Z"},{"id":"q-1611","question":"Design and implement an offline-first notes feature for iOS: store locally in SQLite, use a simple CRDT-like merge or last-writer-wins with version vectors for conflict resolution, and sync changes via a WebSocket protocol, all in Swift using async/await. Include data model, conflict handling, and testing strategy?","answer":"Store notes locally in SQLite with per-note revision tracking and a change log; edits increment revision and emit deltas. Sync via WebSocket streaming with note ID, revision, delta, device ID, and timestamp. Resolve conflicts using last-writer-wins based on timestamps, with fallback to manual merge for simultaneous edits.","explanation":"## Why This Is Asked\n\nTests ability to design robust offline-first data synchronization using modern iOS paradigms, with explicit conflict resolution and test planning.\n\n## Key Concepts\n\n- SQLite local persistence with per-note revision and ChangeLog\n- Delta encoding and event streaming over WebSocket\n- Swift concurrency (async/await) for network and DB operations\n- Conflict resolution strategies: Last-Writer-Wins vs CRDT\n- Testing under intermittent connectivity and out-of-order delivery\n\n## Code Example\n\n```swift\nstruct Note: Identifiable, Codable {\n  let id: UUID\n  var content: String\n  var","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["OpenAI","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T05:30:06.361Z","createdAt":"2026-01-14T02:36:55.710Z"},{"id":"q-1681","question":"In an iOS SwiftUI app, build a minimal Notes editor screen: a multiline TextEditor bound to a string. Implement an autosave that triggers 1 second after the user stops typing, saving the draft to UserDefaults under the key 'noteDraft'. Load the draft on view appear. Include a tiny unit test that simulates typing and asserts the draft is saved after the debounce delay?","answer":"Bind a SwiftUI TextEditor to @State text. Implement onChange(text) to cancel a previous DispatchWorkItem and schedule a new one that calls saveDraft after 1 second. saveDraft writes to UserDefaults wi","explanation":"## Why This Is Asked\nTests ability to design simple, observable UI with a practical persistence pattern.\n\n## Key Concepts\n- SwiftUI TextEditor binding\n- Debounce using DispatchWorkItem\n- UserDefaults persistence\n- Lightweight unit testing of async behavior\n\n## Code Example\n```javascript\n// Swift-like pseudocode demonstrating debounce autosave\nclass NoteViewModel: ObservableObject {\n  @Published var text = \"\"\n  private var workItem: DispatchWorkItem?\n  func textChanged(_ newValue: String) {\n    text = newValue\n    workItem?.cancel()\n    let item = DispatchWorkItem { self.saveDraft() }\n    workItem = item\n    DispatchQueue.main.asyncAfter(deadline: .now() + 1.0, execute: item)\n  }\n  func saveDraft() {\n    UserDefaults.standard.set(text, forKey: \"noteDraft\")\n  }\n  func loadDraft() {\n    text = UserDefaults.standard.string(forKey: \"noteDraft\") ?? \"\"\n  }\n}\n```\n\n## Follow-up Questions\n- How would you extend to support multiple notes?  \n- How would you ensure autosave runs if the app goes to background?  \n- How would you test the debounce logic more deterministically?","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T06:53:06.062Z","createdAt":"2026-01-14T06:53:06.063Z"},{"id":"q-1718","question":"In a high-traffic iOS app for autonomous telemetry, describe a robust data pipeline that streams sensor data into local batches and uploads to cloud with offline queueing and crash recovery. Include how to handle backpressure, idempotency, and testing. Provide concrete Swift components and a minimal prototype?","answer":"Design a data pipeline: SensorFeed emits Data chunks; a Batcher groups into fixed-size batches with a batch nonce. UploadService uses URLSession with a background session, writes a persistent queue to","explanation":"## Why This Is Asked\nTests ability to design resilient, testable data pipelines under intermittent connectivity, with proper use of background tasks and on-device persistence.\n\n## Key Concepts\n- Background URLSession\n- Persisted queues and idempotent uploads\n- Backoff strategies with jitter\n- Deterministic testing via mocks\n\n## Code Example\n```swift\nimport Foundation\nclass UploadService {\n  static let shared = UploadService()\n  func enqueue(_ data: Data) { /*...*/ }\n}\n```\n\n## Follow-up Questions\n- How would you handle multiple device types with different background limits?\n- How would you measure battery impact and optimize?","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","NVIDIA","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T07:52:02.313Z","createdAt":"2026-01-14T07:52:02.313Z"},{"id":"q-1951","question":"You're building an **offline-first** image gallery in an iOS app. Describe in detail how you would implement a robust caching and download strategy that supports offline browsing, seamless updates when connectivity returns, and **conflict resolution**. Include data models, caching policy, background downloads, and testing approaches?","answer":"Implement an offline-first image gallery cache: an LRU disk cache plus in-memory NSCache, with a manifest table storing URL, etag, version, and local path. Use URLSession background downloads to fetch","explanation":"## Why This Is Asked\n\nTests practical offline-first data handling, persistence, and background task orchestration in a real iOS app, ensuring candidates address data modeling, consistency, and testing.\n\n## Key Concepts\n\n- Offline-first caching with disk persistence and memory caching\n- Background downloads with URLSession\n- Manifest data model including url, etag, version, localPath, timestamp\n- Conflict resolution via versioning or timestamps\n- Testing approaches for offline mode, eviction, and crash recovery\n\n\n## Code Example\n\n```swift\nstruct ImageManifest: Codable {\n  let url: URL\n  let etag: String?\n  let version: Int\n  let localPath: String\n  let timestamp: Date\n}\n```\n\n## Follow-up Questions\n\n- How would you ensure consistency when multiple images are downloaded in parallel?\n- What testing strategy would you use to validate cache crash recovery and version conflicts?","diagram":"flowchart TD\nA[User opens gallery] --> B[Check manifest]\nB --> C{Cache hit?}\nC -- Yes --> D[Serve from cache]\nC -- No --> E[Download via URLSession BG]\nE --> F[Update manifest]\nF --> D","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Scale Ai","Tesla","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T18:47:46.650Z","createdAt":"2026-01-14T18:47:46.650Z"},{"id":"q-2089","question":"Design an offline-first album sync for iOS that uses a CRDT-based OR-Set to resolve conflicts in PhotoMetadata across devices. Include data model, merge rules with per-album ACLs, and a test plan for intermittent connectivity?","answer":"Offline-first album sync using a CRDT (OR-Set) for PhotoMetadata (id, albumId, caption, tags, location, timestamp). Each device applies local edits, tombstones, and vector-clock-based merges. Enforce per-album ACLs during sync to prevent unauthorized access while maintaining eventual consistency across all devices.","explanation":"## Why This Is Asked\n\nTests ability to architect offline-first data sync with strong convergence guarantees under real-world constraints.\n\n## Key Concepts\n\n- CRDTs (OR-Set) for concurrent edits\n- Conflict resolution with vector clocks and tombstones\n- Data modeling with PhotoMetadata and ACLs\n- Integration with Core Data/CloudKit and offline testing\n\n## Code Example\n\n```swift\nstruct PhotoMetadata {\n  let id: String\n  let albumId: String\n  var caption: String\n  var tags: Set<String>\n  var location: String?\n  var timestamp: Date\n}\n\nfunc merge(_ a: PhotoMetadata, _ b: PhotoMetadata) -> PhotoMetad","diagram":"flowchart TD\n  A[Local Edit] --> B{Conflict?}\n  B -- Yes --> C[Apply OR-Set Merge]\n  B -- No --> D[Push to Server]\n  C --> D","difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","IBM","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T05:03:28.436Z","createdAt":"2026-01-14T23:40:04.038Z"},{"id":"q-2184","question":"Begin with a concrete scenario: You have an iOS app that shows a list of product names. Build a minimal UIKit view controller that renders the list in a `UITableView` with a search bar. Implement a 300ms **debounce** using Swift's async/await to filter results on a background queue, then present them on the main thread. Filter should be case-insensitive and preserve order. Provide the core view controller code and explain cancellation behavior?","answer":"Use Swift concurrency: on text change, cancel any active search Task, start a new one with a 300ms delay, then filter the dataset on a background queue using case-insensitive contains; update the UI o","explanation":"## Why This Is Asked\nTests understanding of concurrency, debouncing, and UI thread safety in a concrete, beginner-friendly scenario.\n\n## Key Concepts\n- Swift concurrency (async/await, Task)\n- Debounce pattern with cancellation\n- Background work vs main thread\n- Case-insensitive filtering\n- UITableView data source updates\n\n## Code Example\n```javascript\n// Swift-like pseudocode illustrating structure\n```\n\n## Follow-up Questions\n- How would you test debounce timing and cancellation?\n- How would you adapt this to a SwiftUI or Combine-based approach?\n","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Google","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T06:51:07.736Z","createdAt":"2026-01-15T06:51:07.737Z"},{"id":"q-2341","question":"Scenario: Build a real-time presence client for an iOS app used by distributed teams (Zoom/Square/PayPal). Use a WebSocket to publish/receive presence events, implement exponential backoff reconnect, background processing, and idempotent event application; provide a minimal Swift prototype and a test plan for intermittent networks. How would you implement this?","answer":"Use a WebSocket (URLSessionWebSocketTask) with automatic reconnect using exponential backoff, a background worker queue for message handling, and Idempotent application of presence events via sequence","explanation":"## Why This Is Asked\nReal-time presence with flaky networks requires robust reconnects and idempotent state application. This tests network resilience, offline handling, and Swift concurrency.\n\n## Key Concepts\n- WebSocket lifecycle and reconnect backoff\n- Idempotent event processing with sequence IDs\n- Background processing and thread safety\n- Local persistence for presence ledger and retry queue\n- Testing strategy for intermittent networks\n\n## Code Example\n```javascript\n// Swift-like skeleton using URLSessionWebSocketTask in Swift-equivalent pseudocode\nimport Foundation\n\nclass PresenceClient {\n  var wsTask: URLSessionWebSocketTask?\n  func connect() { /* backoff logic */ }\n  func receive() { /* handle messages, apply idempotently */ }\n}\n```\n\n## Follow-up Questions\n- How would you design unit tests to simulate network flakiness and out-of-order messages?\n- How would you propagate presence changes to connected peers while avoiding backpressure and storms?","diagram":null,"difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["PayPal","Square","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T13:16:06.351Z","createdAt":"2026-01-15T13:16:06.351Z"},{"id":"q-2355","question":"Design a live-map ETA/route update system for a rideshare app with intermittent connectivity. Describe an architecture using MapKit, CoreData offline persistence, and CloudKit sync with Swift concurrency. Include conflict resolution strategy, data integrity guarantees, and test plan?","answer":"Use MapKit for live routing, CoreData for offline persistence, and a CloudKit sync pipeline. An actor-isolated fetcher batches ETA/route updates, applies optimistic UI, and resolves conflicts with tim","explanation":"## Why This Is Asked\nThis question probes how a senior iOS engineer designs a resilient, offline-capable live-mapping feature.\n\n## Key Concepts\n- MapKit live updates\n- CoreData offline store\n- CloudKit sync and Swift concurrency\n- Conflict resolution and data integrity\n- Test strategies for flaky networks\n\n## Code Example\n```javascript\n// Swift-like pseudocode illustrating an actor-based sync pipeline\nactor RouteSync {\n  func apply(_ updates: [RouteUpdate]) {\n    // merge with local store, resolve conflicts by timestamp\n  }\n}\n```\n\n## Follow-up Questions\n- How would you measure latency vs. consistency in this system?\n- How would you test conflict scenarios with deterministic replay?","diagram":"flowchart TD\n  Start([Start]) --> Fetch[Fetch live updates]\n  Fetch --> Merge[Merge with local data]\n  Merge --> Render[Render on MapUI]\n  Render --> SyncDone[Done]","difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Lyft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T14:42:06.608Z","createdAt":"2026-01-15T14:42:06.609Z"},{"id":"q-2391","question":"Design a high-performance, offline-first photo feed in an iOS app. Render a UICollectionView that shows square image tiles with captions, support infinite scrolling, and prioritize visible cells for image downloads. Implement disk caching (LRU), memory pressure eviction, and offline fallback when network is unavailable. Ensure VoiceOver and Dynamic Type. Provide data model, caching strategy, testing plan, and a concise code sketch for an ImageLoader using async/await?","answer":"Use a two-tier image cache (NSCache + disk) and a Swift async/await loader. Cache key from the URL hash; store images in Caches/Photos. Prefetch upcoming cells, cancel in-flight fetches on reuse, and ","explanation":"## Why This Is Asked\nTests ability to design an offline-first image pipeline with robust caching, memory management, and accessibility in a real UI scenario.\n\n## Key Concepts\n- Two-tier caching (memory + disk)\n- LRU eviction under memory pressure\n- Prefetching and cancellation tied to visible cells\n- Accessibility: Dynamic Type and VoiceOver labels\n- Async/await data loading and main-thread UI updates\n\n## Code Example\n```swift\nimport UIKit\n\nactor ImageLoader {\n    private let memCache = NSCache<NSString, UIImage>()\n    private let fileManager = FileManager.default\n    private let diskDir: URL\n\n    init(diskFolder: URL) { self.diskDir = diskFolder }\n\n    func load(from url: URL) async -> UIImage? {\n        let key = url.absoluteString as NSString\n        if let image = memCache.object(forKey: key) { return image }\n        let path = diskDir.appendingPathComponent(url.lastPathComponent)\n        if let data = try? Data(contentsOf: path), let image = UIImage(data: data) {\n            memCache.setObject(image, forKey: key)\n            return image\n        }\n        guard let (data, _) = try? await URLSession.shared.data(from: url),\n              let image = UIImage(data: data) else { return nil }\n        memCache.setObject(image, forKey: key)\n        try? data.write(to: path)\n        return image\n    }\n}\n```","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Discord","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T15:55:00.634Z","createdAt":"2026-01-15T15:55:00.634Z"},{"id":"q-2570","question":"**iOS Beginner Challenge:** Build a minimal journaling screen where a user types notes, autosaves to a local file atomically, and displays a list of notes. Ensure data is preserved across app restarts, support background/foreground transitions, and debounce saves to avoid thrashing. Use Swift with SwiftUI, Codable Note, and FileManager in the Documents directory. Include a simple test plan?","answer":"Implement a 300ms debounced autosave mechanism that triggers on text changes, serialize the Note model using Codable, perform atomic writes by first saving to a temporary file then replacing the target file, and load existing notes on app launch. Handle app lifecycle transitions using ScenePhase to maintain data integrity during background and foreground states.","explanation":"## Why This Is Asked\nThis question assesses practical iOS development skills including data persistence, SwiftUI fundamentals, and robust file handling—essential competencies for junior iOS developers.\n\n## Key Concepts\n- SwiftUI state management and data binding\n- Codable protocol for data serialization\n- FileManager atomic operations in Documents directory\n- ScenePhase environment for app lifecycle management\n- Debounce pattern to optimize I/O operations\n\n## Code Example\n```swift\nimport SwiftUI\nstruct Note: Codable { let id: UUID; var text: String; let date: Date }\n```\n\n## Follow-up Questions","diagram":"flowchart TD\n  EditorUI(Editor UI) --> AutosaveDebounce(Autosave Debounce)\n  AutosaveDebounce --> TempWrite(Write to Temp File)\n  TempWrite --> AtomicSwap(Atomic Swap to Final File)\n  AtomicSwap --> NotesList(Notes List UI)","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T05:19:43.075Z","createdAt":"2026-01-15T23:32:15.321Z"},{"id":"q-2776","question":"Build a SwiftUI screen that loads a local JSON array of flashcards (id, question, answer) from the app bundle, displays one card at a time with a tap to flip, and includes a Next button. Persist the current index and per-card view counts to a local file atomically so the session resumes where left off on restart. Ensure Dynamic Type and Dark Mode compatibility; keep it beginner-friendly and testable?","answer":"Load JSON from bundle into [Flashcard] Codable; currentIndex and viewCount per card stored in Documents/flashcards_state.json. SwiftUI view shows a card with question; tapping flips to show answer; Ne","explanation":"## Why This Is Asked\nTests practical data loading, simple UI with state, and robust local persistence—core iOS basics for a junior role.\n\n## Key Concepts\n- Codable data models and JSON parsing\n- Local file persistence with atomic writes\n- SwiftUI state management and view updates\n- Dynamic Type and Dark Mode compatibility\n\n## Code Example\n```swift\nstruct Flashcard: Codable, Identifiable { let id: String; let question: String; let answer: String }\nclass FlashcardVM: ObservableObject {\n    @Published var cards: [Flashcard] = []\n    @Published var index: Int = 0\n    func load() { /* decode from bundle */ }\n    func saveState() {\n        // write to temp file, then replace final file\n    }\n}\n```\n\n## Follow-up Questions\n- How would you add unit tests to verify atomic write behavior?\n- How would you handle data migration if the JSON schema changes later?","diagram":"flowchart TD\nLoadJSON[Load JSON from bundle] --> ShowCard[Show current card]\nShowCard --> FlipCard[Tap to flip to reveal answer]\nFlipCard --> NextCard[Next card]\nNextCard --> Persist[Persist index and counts]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","OpenAI","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T11:35:22.978Z","createdAt":"2026-01-16T11:35:22.978Z"},{"id":"q-2805","question":"Design an offline-first, conflict-aware sync for an iOS chat feature using Core Data for local storage and a REST API. Describe the Change Journal you'd implement, incremental pull using a since timestamp, an upsert push queue for new/edited messages, and a deterministic conflict resolution policy (e.g., last-updated-wins with timestamps). Include data structures, synchronization flow, backoff strategy, and a minimal test plan?","answer":"Leverage a Core Data-backed Change Journal to track inserts/edits/deletes for Message(id, content, author, createdAt, updatedAt, localVersion). Sync loop pulls /messages?since=serverMax and pushes loc","explanation":"## Why This Is Asked\nTests ability to design robust offline sync, conflict resolution, and test strategy under real-world mobile constraints.\n\n## Key Concepts\n- Offline-first data model\n- Change Journal and per-item updatedAt\n- Incremental synchronization with since tokens\n- Conflict resolution: last-writer-wins with server vs local\n- Backoff and retry policy\n- Test plan: simulate offline/online churn, partial failures, and race conditions\n\n## Code Example\n```javascript\n// Pseudo-code: diff/merge function outline\nfunction mergeRemote(localItem, remoteItem) {\n  if (remoteItem.updatedAt > localItem.updatedAt) { return remoteItem; }\n  return localItem;\n}\n```\n\n## Follow-up Questions\n- How would you test the Change Journal under heavy-write scenarios?\n- How do you handle deletions and tombstones?\n","diagram":"flowchart TD\n  A[Local Change Journal] --> B[Sync Loop]\n  B --> C{Server Response}\n  C -- Conflicts --> D[Resolve by Last-Writer-Wins]\n  C -- No Conflicts --> E[Apply Updates]\n","difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","Twitter","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T13:09:29.478Z","createdAt":"2026-01-16T13:09:29.478Z"},{"id":"q-2859","question":"Design and implement a high-throughput annotation queue in an iOS app used for labeling image datasets. Build a per-image task manager using Swift Concurrency (actors, AsyncSequence) to assign image slices to workers, enforce in-order UI updates, backpressure when the back-end lags, and automatic retries with exponential backoff. Provide API surface, a minimal SwiftUI view demo, and explain trade-offs?","answer":"Leverage a per-image annotation queue implemented as an Actor to serialize state, with a TaskGroup dispatching annotation tasks to workers and streaming results via an AsyncSequence. UI updates on Mai","explanation":"## Why This Is Asked\nThis probes Swift Concurrency mastery (actors, TaskGroups), deterministic UI ordering, and robust back-end latency handling in a data-labeling workflow.\n\n## Key Concepts\n- Swift Concurrency: actors, TaskGroup\n- AsyncSequence and backpressure\n- MainActor UI updates\n- Local persistence (SQLite/GRDB)\n- Exponential backoff and cancellation\n\n## Code Example\n```javascript\n// Swift-concurrency sketch (illustrative)\nactor AnnotationQueue {\n  private var queue: [ImageTask] = []\n  func enqueue(_ t: ImageTask) { queue.append(t) }\n  func run() async {\n    for await task in tasks() {\n      // process\n    }\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test under memory pressure and flaky network?\n- How do you ensure deterministic UI ordering if tasks complete out of order?\n- How would you swap in a different persistence backend without changing the API surface?","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","NVIDIA","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T14:53:26.408Z","createdAt":"2026-01-16T14:53:26.408Z"},{"id":"q-2976","question":"Implement a local-first photo uploader in an iOS app: when users select multiple photos for upload, queue them in a disk-backed manifest, process with a bounded concurrency worker, upload via URLSession background tasks, retry with exponential backoff on failures, and expose progress to the UI. How would you implement and test this to ensure persistence across relaunch and background/foreground transitions?","answer":"Implement a local-first uploader: queue selected photos to a disk-backed manifest written atomically; drive processing with a bounded worker pool (semaphore-limited) that uses URLSession background up","explanation":"## Why This Is Asked\n\nInterview focus: robust offline-first upload pipeline with persistence and lifecycle resilience.\n\n## Key Concepts\n\n- Local persistence with atomic writes\n- URLSession background uploads\n- Bounded concurrency\n- Exponential backoff\n- Progress reporting\n- Lifecycle resilience\n\n## Code Example\n\n```swift\nstruct PhotoUpload: Codable { let id: UUID; let fileURL: URL; var status: Status }\nenum Status: String, Codable { case queued, uploading, done, failed, retrying }\n```\n\n## Follow-up Questions\n\n- How would you test the retry/backoff behavior?\n- How would you extend to support paused/resumed uploads and offline queuing?\n","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Netflix","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T19:39:07.994Z","createdAt":"2026-01-16T19:39:07.994Z"},{"id":"q-3149","question":"Build a tiny iOS 'Task Timer' app: create tasks each with a duration, run per-task timers that pause on background, resume on foreground, and persist elapsed time to disk atomically via a Codable Task model stored in the Documents directory. Use SwiftUI and Combine; debounce saves to avoid thrashing; provide per-task accessibility labels and a filter for Active/Completed. How would you implement this end-to-end?","answer":"Approach: define Task: id, title, duration, elapsed, isCompleted. Persist as [Task] to a JSON file in Documents; atomically replace file with a temp write. Use SwiftUI List, per-task Timer via Combine","explanation":"## Why This Is Asked\nTests practical iOS basics (SwiftUI, Combine, persistence), plus testing readiness and accessibility. It exercises timer logic, background/foreground handling, and robust file writes.\n\n## Key Concepts\n- SwiftUI, Combine timers, and scene phase for backgrounding\n- Codable data model and atomic disk writes\n- FileManager Documents storage and JSON encoding/decoding\n- Accessibility labeling and dynamic filtering\n\n## Code Example\n```swift\nstruct Task: Codable {\n  let id: UUID\n  var title: String\n  var duration: TimeInterval\n  var elapsed: TimeInterval\n  var isCompleted: Bool\n}\n```\n\n## Follow-up Questions\n- How would you test persistence across process termination?\n- How would you handle timer drift if the app is suspended for long periods?","diagram":"flowchart TD\n  A[Create Task] --> B[Start Timer]\n  B --> C{Background?}\n  C -- Yes --> D[Pause Timer]\n  C -- No --> E[Tick Elapsed]\n  D --> F[Foregrounded?]\n  F -- Yes --> G[Resume Timer]\n  G --> E\n  E --> H[Persist Elapsed]\n  H --> I[Filter: Active/Completed]\n  I --> J[UI reflects state]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Salesforce","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T04:47:05.280Z","createdAt":"2026-01-17T04:47:05.281Z"},{"id":"q-3326","question":"Design a real-time collaborative note editor for iOS that works offline and syncs via CloudKit. Describe architecture for a sequence CRDT text model with per-note version vectors, deterministic merges, and offline persistence in CoreData. Explain testing with simulated disconnects, concurrent edits, and data integrity checks?","answer":"Implement offline-first notes with CoreData storage and a sequence CRDT for text edits, each operation carrying a vector timestamp. Sync via CloudKit records; apply deterministic merges based on vecto","explanation":"## Why This Is Asked\n\nTests ability to design offline-first sync, CRDT concepts, and iOS persistence.\n\n## Key Concepts\n\n- Offline-first data model\n- CRDT/sequence CRDT for text\n- CloudKit + CoreData integration\n- Version vectors and deterministic conflict resolution\n- End-to-end testing with network partitions\n\n## Code Example\n\n```swift\n// Pseudo-code sketch\nstruct TextOp { let index: Int; let char: Character }\nclass NoteCRDT {\n  var ops: [TextOp] = []\n  func apply(_ op: TextOp) { /* apply */ }\n  func merge(with other: NoteCRDT) { /* merge */ }\n}\n```\n\n## Follow-up Questions\n\n- How would you model concurrent inserts at the same index?\n- What test strategies ensure merges are idempotent across devices?","diagram":null,"difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T11:34:40.851Z","createdAt":"2026-01-17T11:34:40.851Z"},{"id":"q-3357","question":"Design a secure offline-first vault feature for iOS that stores sensitive notes and attachments encrypted at rest with per-note keys, deriving keys from a user passphrase using a KDF, storing metadata in CoreData, and syncing encrypted blobs via CloudKit. Explain key management, rotation, and a testing plan including device loss, passphrase changes, and offline use?","answer":"Derive a 256-bit key from the user passphrase with HKDF-SHA256 and a per-note salt, then encrypt each note using AES-GCM. Store ciphertexts and nonces in CoreData; keep the envelope in a Secure Enclav","explanation":"## Why This Is Asked\nAssesses secure offline-first data vault design, practical crypto in Swift, and testability across device loss and passphrase changes.\n\n## Key Concepts\n- CryptoKit: AES-GCM, HKDF-SHA256\n- KDF with per-note salt; envelope key in Secure Enclave\n- CoreData for local metadata; CloudKit for encrypted blob sync\n- Key rotation and re-wrapping strategies\n- Testing: offline scenarios, passphrase rotation, data integrity\n\n## Code Example\n```swift\nimport CryptoKit\n\nfunc deriveKey(password: String, salt: Data) -> SymmetricKey {\n  let ikm = SymmetricKey(data: Data(password.utf8))\n  let key = HKDF<SHA256>.deriveKey(inputKeyMaterial: ikm, salt: salt, info: Data(), outputByteCount: 32)\n  return key\n}\n```\n\n```swift\n// Encryption\nfunc encrypt(plaintext: Data, key: SymmetricKey) throws -> Data {\n  let sealed = try AES.GCM.seal(plaintext, using: key)\n  return sealed.combined!\n}\n```\n\n```swift\n// Decryption\nfunc decrypt(data: Data, key: SymmetricKey) throws -> Data {\n  let box = try AES.GCM.SealedBox(combined: data)\n  return try AES.GCM.open(box, using: key)\n}\n```","diagram":"flowchart TD\n  A[User enters passphrase] --> B[Derive envelope key (HKDF-SHA256)]\n  B --> C[Unlock Secure Enclave key]\n  C --> D[Derive per-note keys]\n  D --> E[Decrypt notes and attachments]\n  E --> F[CloudKit sync of encrypted blobs]\n  F --> G[Conflict resolution & metadata updates]","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["OpenAI","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T13:14:43.641Z","createdAt":"2026-01-17T13:14:43.641Z"},{"id":"q-3696","question":"As a module for a rideshare delivery dashboard, implement a map-based order tracker that consumes live updates over a WebSocket. The app must survive offline: persist last-known Orders in Core Data, deduplicate updates by eventId, and replay queued events on reconnect with exponential backoff. Also handle out-of-order messages and debounce UI updates. Use Swift, MapKit, Core Data; prefer URLSessionWebSocketTask?","answer":"I would implement a WebSocketManager using URLSessionWebSocketTask that maintains a single live connection, deduplicates incoming events by eventId, and persists them as Order entities in Core Data. U","explanation":"## Why This Is Asked\nTests architecture for real-time data with offline resilience, data integrity, and a clean UI path.\n\n## Key Concepts\n- WebSocket lifecycle with URLSessionWebSocketTask\n- Offline-first Core Data schema and conflict-free merges\n- Event deduplication via eventId and replay strategy\n- MapKit annotations and debounced UI refresh\n- Backoff, reachability, and offline queue testing\n\n## Code Example\n```swift\n// Minimal sketch: WebSocket manager\nclass WSManager {\n  // connect, receive, dedupe, persist\n}\n```\n\n## Follow-up Questions\n- How would you test out-of-order events?  \n- What metrics would you monitor in production? ","diagram":"flowchart TD\n  A[WebSocket Connect] --> B[Receive Event]\n  B --> C{Deduplicate}\n  C -- unique--> D[Persist in Core Data]\n  B --> E[Queue if Offline]\n  E --> F[Replay on Reconnect]\n  D --> G[Update Map Annotations]\n  G --> H[Debounced UI Refresh]","difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T05:43:53.830Z","createdAt":"2026-01-18T05:43:53.830Z"},{"id":"q-3796","question":"Design a beginner-friendly iOS SwiftUI screen: a note editor with a live word count. Debounce user input with Combine (300ms) before updating the count, and persist the last note to disk across restarts. Include handling of background/foreground transitions and a basic test plan?","answer":"Implement a SwiftUI note editor that shows a live word count. Drive it with Combine: feed the field into a CurrentValueSubject<String,Never>, debounce 300ms on RunLoop.main, then update a @Published w","explanation":"## Why This Is Asked\nTests SwiftUI, Combine, and simple disk persistence in a beginner-friendly way, plus lifecycle handling.\n\n## Key Concepts\n- SwiftUI state management and data binding\n- Combine debounce to throttle rapid changes\n- Lightweight persistence to disk (Documents) with Codable or plain text\n- Lifecycle considerations (background/foreground)\n\n## Code Example\n```swift\nimport SwiftUI\nimport Combine\n\nclass NoteViewModel: ObservableObject {\n  @Published var text: String = \"\"\n  @Published var wordCount: Int = 0\n\n  private var cancellables = Set<AnyCancellable>()\n\n  init() {\n    $text\n      .debounce(for: .milliseconds(300), scheduler: RunLoop.main)\n      .map { $0.split(whereSeparator: { $0 == \" \" || $0 == \"\\n\" }).count }\n      .assign(to: \\.wordCount, on: self)\n      .store(in: &cancellables)\n  }\n\n  func saveToDisk() {\n    // write to Documents/notes.txt\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test that debounce correctly throttles rapid input?\n- How would you handle a save failure and retry strategy?","diagram":"flowchart TD\n  A[Text input] --> B[Combine pipeline]\n  B --> C{Debounced update}\n  C --> D[Update wordCount]\n  C --> E[Persist to disk]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Scale Ai","Stripe","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T09:42:59.881Z","createdAt":"2026-01-18T09:42:59.881Z"},{"id":"q-3921","question":"Design an iOS data pipeline for a live analytics feed. The app connects to a WebSocket to receive events (JSON per event), decodes them into a Codable Event, and renders a live, diffable list. Requirements: (1) use URLSessionWebSocketTask for the socket, (2) an in-memory buffer capped at 1,000 events with oldest drops, (3) on-disk queue preserving order with atomic writes, (4) a deterministic replay API for offline mode, (5) UI stays responsive; discuss concurrency, error handling, backpressure, and testing?","answer":"Use a structured concurrency pipeline with an actor-owned buffer and a separate I/O layer. Run the WebSocket on a background Task, decode to Event with JSONDecoder, push to an in-memory ring buffer (m","explanation":"## Why This Is Asked\nThis prompt probes end-to-end data pipeline correctness, including concurrency, backpressure, and offline replay, which are real-world pains in live dashboards.\n\n## Key Concepts\n- URLSessionWebSocketTask, Async/Await, actor model\n- Codable decoding, JSON streaming\n- In-memory buffering with bounded capacity and backpressure\n- Atomic disk writes and ordered replay (queue on disk)\n- DiffableDataSource, main-thread UI updates, testability\n\n## Code Example\n```javascript\n// Swift-like pseudocode for the event pipeline\nactor EventStore {\n  private var buffer: [Event] = []\n  private let maxBuffer = 1000\n  func append(_ e: Event) {\n    buffer.append(e)\n    if buffer.count > maxBuffer {\n      buffer.removeFirst(buffer.count - maxBuffer)\n    }\n  }\n}\n```\n\n## Follow-up Questions\n- How would you simulate bursty event streams in tests and measure latency?\n- How would you ensure exactly-once delivery semantics if the WebSocket reconnects?","diagram":"flowchart TD\n  WS[WebSocket] --> D[Decoder]\n  D --> B[Buffer 1000]\n  B --> Disk[DiskQueue]\n  D --> UIUpdate[UI Update]\n  UIUpdate --> Replay[Offline Replay]","difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Google","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T15:37:34.044Z","createdAt":"2026-01-18T15:37:34.044Z"},{"id":"q-3953","question":"Design and implement an offline-first, multi-device to-do collaboration feature for an iOS app. It should store locally in Core Data, sync with a REST API, and reconcile conflicts using a versioned record with last-writer-wins strategy. Use SwiftUI, async/await, and an Actor-based SyncManager to serialize cross-device updates. Provide an outline of data models, a minimal SwiftUI view, and a test plan?","answer":"Architect offline-first multi-device to-do sharing: local Core Data store, REST sync, and a versioned Task model. Use an Actor-based SyncManager to serialize network updates; resolve conflicts via las","explanation":"## Why This Is Asked\nReal-world problem of offline collaboration and conflict resolution on iOS, testing concurrency, data modeling, and testability.\n\n## Key Concepts\n- Core Data offline storage\n- Swift concurrency: async/await and actors\n- Conflict resolution: last-writer-wins with versioning\n- Background networking with URLSession\n\n## Code Example\n```javascript\n// Pseudo-Swift: SyncManager sketch\nactor SyncManager {\n  func enqueue(_ op: @Sendable () async -> Void) {}\n  func flush() async {}\n}\n```\n\n## Follow-up Questions\n- How would you test conflict scenarios with simulated latency?\n- How would you scale to thousands of concurrent users without server bottlenecks?","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T16:49:46.121Z","createdAt":"2026-01-18T16:49:46.121Z"},{"id":"q-3975","question":"Design an offline-first PDF annotation workflow for iOS: use PDFKit to render and annotate PDFs, persist annotation state in Core Data with per-document versioning, and implement a sync to a remote REST API that merges edits using last-modified timestamps. Include optimistic UI updates, conflict handling when the same annotation is edited offline across devices, and a test strategy for offline edits, conflict cases, and relaunch integrity?","answer":"Design for an offline-first PDF annotation flow: render PDFs with PDFKit, persist Annotations in Core Data with documentVersion; sync via REST using a SyncManager that handles idempotent PUTs and delt","explanation":"## Why This Is Asked\nExplores real-world offline-first sync with PDFs, requiring data modeling, conflict handling, and test planning.\n\n## Key Concepts\n- PDFKit rendering and annotation model\n- Core Data relationships and versioning\n- REST-based sync with delta diffs and idempotency\n- Conflict resolution and testing in flaky networks\n\n## Code Example\n```swift\n// Pseudo-models: Document, Annotation, SyncManager\n```\n\n## Follow-up Questions\n- How would you test eventual consistency across devices?\n- How would you handle large PDFs to avoid memory pressure?","diagram":null,"difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Google","Hashicorp"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T17:47:57.881Z","createdAt":"2026-01-18T17:47:57.881Z"},{"id":"q-4019","question":"Design an on-device analytics module for an iOS app that preserves user privacy. The module should: record lightweight events locally; batch and aggregate them into daily buckets; upload via a background URLSession with exponential backoff and jitter; honor a user opt-in/opt-out toggle and per-event consent; persist across restarts. Explain data model (Core Data or SQLite), storage lifecycle, encryption, and a test plan that simulates offline, partial writes, and data corruption?","answer":"Use Core Data with entities Event and DailyBucket, storing per-event consent and a payloadHash. Persist lightweight events locally, accumulate into daily buckets, and upload in a background URLSession","explanation":"## Why This Is Asked\n\nAssess ability to design privacy-conscious analytics with on-device processing and reliable background uploads.\n\n## Key Concepts\n\n- On-device data collection and consent management\n- Core Data vs SQLite schema design for Events and Aggregates\n- Encryption in transit and at rest, Keychain storage\n- Background transfers with URLSession, backoff and jitter\n- Data integrity: retries, deduping, corruption handling\n\n## Code Example\n\n```swift\n// Core Data model sketch\n@objc(Event)\nclass Event: NSManagedObject {\n  @NSManaged var id: String\n  @NSManaged var name: String\n  @NSManaged var timestamp: Date\n  @NSManaged var payloadHash: String\n  @NSManaged var consent: Bool\n}\n```\n\n## Follow-up Questions\n\n- How would you test for opt-in/opt-out changes affecting pending batches?\n- How would you detect and recover from partial writes or data corruption in the store?\n","diagram":"flowchart TD\n  A[Start] --> B[Capture Event]\n  B --> C[Hash Payload]\n  C --> D[Store Event in Core Data]\n  D --> E{Ready to Upload?}\n  E -->|Yes| F[Batch Daily Buckets]\n  F --> G[Background URLSession Upload]\n  G --> H[Retry with Backoff/Jitter]\n  H --> E","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","LinkedIn","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T19:38:53.127Z","createdAt":"2026-01-18T19:38:53.127Z"},{"id":"q-4135","question":"Implement a small flashcard quiz in iOS using SwiftUI: load questions from a bundled JSON (title, prompt, answer, category). Show a card with the prompt; tap to flip and reveal the answer; add Next/Prev to navigate; persist last index across restarts via UserDefaults; debounce taps; ensure accessibility by labeling the card and using VoiceOver hints. Include a basic unit test for JSON decoding and scoring?","answer":"Approach: Create a Card model Codable to parse; build a SwiftUI CardView with 3D flip animation; load questions from bundled JSON into a @Published array; track currentIndex in @State and persist to U","explanation":"## Why This Is Asked\nTests a beginner's ability to combine SwiftUI, Codable JSON loading, simple persistence, input debouncing, and accessibility in a tangible feature.\n\n## Key Concepts\n- SwiftUI state management\n- Codable and JSON loading\n- UserDefaults persistence\n- Debouncing taps\n- Accessibility labels\n\n## Code Example\n```swift\nstruct Card: Codable { let id: String; let prompt: String; let answer: String; let category: String }\n```\n\n```swift\nstruct CardView: View {\n  let card: Card\n  @State private var flipped = false\n  var body: some View {\n    ZStack {\n      if flipped { Text(card.answer) } else { Text(card.prompt) }\n    }\n    .rotation3DEffect(.degrees(flipped ? 180 : 0), axis: (0,1,0))\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test debouncing behavior in UI tests?\n- How would you adapt the data loading for a large deck (pagination or streaming)?","diagram":"flowchart TD\n  LoadJSON[Load questions from bundled JSON] --> CardView[Display card]\n  CardView --> Flip[Flip to reveal answer]\n  Flip --> Nav[Navigate Next/Prev]\n  Nav --> Persist[Persist index to UserDefaults]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T04:39:13.058Z","createdAt":"2026-01-19T04:39:13.059Z"},{"id":"q-4204","question":"Build a lightweight audio memo feature: in a SwiftUI app, allow recording a 15–60 second memo using AVAudioRecorder, save to the app's Documents directory with an atomic write, and display a list of memos with duration and date. Enable playback via AVAudioPlayer, persist memos across launches, and handle background/foreground transitions. Provide a minimal test plan focusing on file I/O integrity and playback reliability. Use Swift/SwiftUI?","answer":"Record audio memos using AVAudioRecorder, save to Documents as a unique file, and write to a temp path first then move for atomic save. Build a Codable Memo struct with id, date, duration, path; list ","explanation":"## Why This Is Asked\n- Introduces AVFoundation in a practical UI flow, offline storage, and lifecycle handling.\n- Exercises safe file writes and persistent metadata for a beginner-friendly scenario.\n\n## Key Concepts\n- AVAudioRecorder / AVAudioPlayer, SwiftUI, FileManager atomic writes\n- Documents directory, Codable model, and simple persistence\n- Accessibility labeling for media controls\n\n## Code Example\n```swift\nfunc atomicallySave(data: Data, to url: URL) throws {\n  let tempURL = url.appendingPathExtension(\"temp\")\n  try data.write(to: tempURL)\n  try FileManager.default.moveItem(at: tempURL, to: url)\n}\n```\n\n## Follow-up Questions\n- How would you test for audio corruption during a power loss or app termination?\n- How would you handle recording while the app moves to the background?","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Coinbase","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T08:44:02.388Z","createdAt":"2026-01-19T08:44:02.388Z"},{"id":"q-4298","question":"Build a beginner iOS SwiftUI FAQ viewer: load a bundled JSON of FAQs (id, question, answer, category), display a searchable list with a debounced search (Combine) that filters on question or answer, a tap expands to show the answer, and persist the last search query to UserDefaults. Include a basic unit test for JSON decoding and search filtering?","answer":"Decode FAQs with Codable from bundled JSON into FAQ models. Show a SwiftUI List with expandable rows. Add a debounced search using Combine that filters by question or answer. Persist last search query","explanation":"## Why This Is Asked\n\nAssesses ability to model data with Codable, design a lightweight SwiftUI UI, and implement debounced search with Combine. It also checks practical local persistence patterns and basic test coverage without network complexity.\n\n## Key Concepts\n\n- SwiftUI List and expandable rows\n- Codable decoding from a local JSON bundle\n- Combine-based debounced search and state binding\n- UserDefaults persistence for simple state\n\n## Code Example\n\n```swift\nstruct FAQ: Codable {\n  let id: Int\n  let question: String\n  let answer: String\n  let category: String?\n}\n```\n\n## Follow-up Questions\n\n- How would you scale the search to support fuzzy matching?\n- How would you add localization for questions and answers?","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Meta","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T11:52:07.770Z","createdAt":"2026-01-19T11:52:07.770Z"},{"id":"q-4369","question":"Design offline-first iOS chat feature: drafts are queued locally and synced to the server when online. Describe the CoreData data model (fields: id, convoId, localSeq, serverId, status, timestamp), the background sync pipeline using URLSession, and the conflict resolution strategy (per-convo ordering, idempotent upserts). Include a test plan for disconnects, message reordering, and partial failures?","answer":"Design offline-first chat: store drafts and sent messages in CoreData with fields id (UUID), convoId (UUID), localSeq (Int64), serverId (String?), status (pending/sent/delivered), timestamp, and conte","explanation":"## Why This Is Asked\n\nAssess ability to design offline-first data sync with robust conflict handling and test planning.\n\n## Key Concepts\n\n- CoreData modeling for messages and conversations\n- Local queue and optimistic UI updates\n- Background sync with URLSession\n- Conflict resolution using per-conversation ordering, serverSeq, and idempotent upserts\n- Testing offline scenarios, reordering, and partial failures\n\n## Code Example\n\n```swift\n// CoreData model sketch\n// Entities: Conversation(id: UUID), Message(id: UUID, convoId: UUID, localSeq: Int64, serverId: String?, status: String, timestamp: Date, content: String)\n```\n\n## Follow-up Questions\n\n- How would you simulate out-of-order deliveries in tests?\n- How would you scale per-convo queues for large datasets?\n","diagram":null,"difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Two Sigma","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T15:59:29.744Z","createdAt":"2026-01-19T15:59:29.744Z"},{"id":"q-4442","question":"Build a beginner SwiftUI iOS Gallery screen that loads image URLs from a bundled JSON, displays a grid, downloads images via URLSession, and caches each image on disk atomically in the Documents directory so it persists across restarts. Include a manual Refresh to re-fetch metadata and a basic unit test verifying disk write/read of a cached image?","answer":"Use a small MVVM SwiftUI gallery. Load image metadata from a bundled JSON into a model, then for each item check a disk cache dir for a local file; if missing, fetch with URLSession, write to a temp f","explanation":"## Why This Is Asked\n\nTests offline-first caching, atomic disk writes, and SwiftUI grid rendering with a testable data layer.\n\n## Key Concepts\n\n- SwiftUI LazyVGrid for gallery\n- URLSession data tasks for image fetch\n- FileManager and atomic writes to Documents cache\n- Codable parsing of bundled JSON\n- Persistence across restarts and simple unit tests\n\n## Code Example\n\n```swift\nimport Foundation\nimport SwiftUI\n\nstruct ImageItem: Decodable { let id: String; let url: String }\n\nclass GalleryVM: ObservableObject {\n    @Published var items: [ImageItem] = []\n    let cacheDir: URL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0].appendingPathComponent(\"imageCache\")\n\n    init() { loadMetadata() }\n\n    func loadMetadata() {\n        // load from Bundle JSON (omitted for brevity)\n    }\n\n    func localPath(for id: String) -> URL {\n        cacheDir.appendingPathComponent(\"\\(id).jpg\")\n    }\n\n    func fetchIfNeeded(item: ImageItem) async {\n        let path = localPath(for: item.id)\n        if FileManager.default.fileExists(atPath: path.path) { return }\n        guard let url = URL(string: item.url) else { return }\n        let (data, _) = try! await URLSession.shared.data(from: url)\n        // write atomically\n        let tmp = path.appendingPathExtension(\"tmp\")\n        try! data.write(to: tmp)\n        try! FileManager.default.moveItem(at: tmp, to: path)\n        await MainActor.run { self.objectWillChange.send() }\n    }\n}\n```\n\n## Follow-up Questions\n\n- How would you add a basic cache eviction policy?\n- How would you test network failure scenarios in this flow?","diagram":"flowchart TD\n  A[Bundled JSON loaded] --> B[Parse ImageItem list]\n  B --> C{Cached on disk?}\n  C -->|Yes| D[Display from disk]\n  C -->|No| E[URLSession fetch]\n  E --> F[Write temp file]\n  F --> G[Atomic move to final path]\n  G --> H[Update UI]\n  H --> I[Manual Refresh triggers reload]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","LinkedIn","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T19:04:47.086Z","createdAt":"2026-01-19T19:04:47.086Z"},{"id":"q-4535","question":"Design offline-first iOS feature: a 'Comments Console' for a document collaboration app. Users draft comments offline; changes persist in Core Data and are synced as delta patches when the network becomes available. Describe the data model, patch format, conflict resolution, and a test plan for offline edits, concurrent edits, and reconnect scenarios?","answer":"To implement an offline-first Comments Console, model Comment with id, documentId, authorId, text, createdAt, updatedAt, and a patch version. Persist locally in Core Data; compute deltas as patch objects containing baseVersion, changes, and timestamps. Apply patches using a reconciliation strategy that handles conflicts through either latest-writer-wins or server-validated merges. Ensure data consistency by maintaining version history and implementing rollback capabilities for failed sync operations.","explanation":"## Why This Is Asked\n\nAssesses offline-first design, delta-based syncing, and conflict handling under intermittent connectivity, which are critical in collaboration apps used by teams.\n\n## Key Concepts\n\n- Core Data data model for Comment and Patch objects\n- Delta/patch format including baseVersion, changes, and timestamps\n- Reconciliation strategy (latest-writer-wins or server-validated merges)\n- Robust test plan for offline edits, re-connect, and concurrency\n\n## Code Example\n\n```javascript\n// Swift-like pseudocode: apply a patch to a Comment\nfunc apply(patch: Patch, to comment: inout Comment) {\n    // Validate base version matches current state\n    guard patch.baseVersion == comment.version else {\n        // Handle conflict resolution\n        resolveConflict(patch: patch, comment: &comment)\n        return\n    }\n    \n    // Apply delta changes\n    for change in patch.changes {\n        switch change.type {\n        case .insert:\n            comment.text.insert(change.text, at: change.position)\n        case .delete:\n            comment.text.removeSubrange(change.range)\n        case .replace:\n            comment.text.replaceSubrange(change.range, with: change.text)\n        }\n    }\n    \n    // Update version and timestamps\n    comment.version += 1\n    comment.updatedAt = Date()\n}\n```","diagram":null,"difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Hugging Face"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T06:28:13.161Z","createdAt":"2026-01-19T22:45:20.221Z"},{"id":"q-464","question":"How would you implement a custom UICollectionViewFlowLayout that supports dynamic cell heights and sticky headers while maintaining smooth scrolling performance?","answer":"Override `prepare()` to pre-calculate and cache layout attributes in a dictionary for efficient access. Implement `shouldInvalidateLayout(forBoundsChange:)` to handle sticky header positioning, and use `estimatedItemSize` with automatic height calculation. Cache the results to avoid expensive recalculations during scrolling.","explanation":"## Key Implementation Steps\n\n- Override `prepare()` to calculate and cache layout attributes for all elements\n- Implement `layoutAttributesForElements(in:)` to return cached attributes for visible elements\n- Use `shouldInvalidateLayout(forBoundsChange:)` to manage sticky header behavior during scroll\n- Set `estimatedItemSize` to enable dynamic height calculation for variable content\n\n## Performance Optimizations\n\n- Cache calculations in memory to avoid repeated expensive operations\n- Use `UICollectionViewFlowLayoutInvalidationContext` for targeted layout updates instead of full invalidation\n- Implement `targetContentOffset(forProposedContentOffset:)` to ensure smooth scrolling behavior\n\n## Common Pitfalls\n\n- Avoid performing expensive calculations in `layoutAttributesForElements(in:)` as it's called frequently\n- Don't invalidate the entire layout unnecessarily; use targeted invalidation contexts instead\n- Be careful with memory usage when caching large amounts of layout attributes","diagram":"flowchart TD\n  A[prepare() - Calculate Attributes] --> B[Cache in Dictionary]\n  B --> C[layoutAttributesForElements]\n  C --> D[shouldInvalidateLayout]\n  D --> E[Sticky Headers Logic]\n  E --> F[Smooth Scrolling]","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Lyft","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-09T09:00:07.232Z","createdAt":"2025-12-26 12:51:05"},{"id":"q-4648","question":"In an iOS streaming app with offline transcripts per user, implement a secure offline cache that is per-user encrypted at rest, uses keys stored in the Keychain, and automatically re-encrypts on logout; design the data model, pick storage (Core Data vs SQLite), implement background downloads with URLSessionBackgroundTask, and a test plan to verify data isolation, migration, and crash recovery?","answer":"Use per-user envelope encryption: a per-user AES-256-GCM key is wrapped by a Keychain key; transcripts are stored as encrypted binary blobs in Core Data. Downloads run via URLSessionBackgroundTask; on","explanation":"## Why This Is Asked\n\nTests mastery of iOS offline security, per-user data isolation, and production-grade background downloads. It also probes trade-offs between Core Data and SQLite for binary blobs and how to manage key lifecycles across login/logout.\n\n## Key Concepts\n\n- Envelope encryption per user with Keychain-wrapped keys\n- Data-at-rest protections (NSFileProtection, encryption)\n- Storage choice: Core Data vs SQLite for binary blobs\n- Background downloads with URLSessionBackgroundTask\n- Key rotation and logout data purge, crash recovery\n\n## Code Example\n\n```swift\nimport CryptoKit\n\nfunc encrypt(_ payload: Data, with key: SymmetricKey) throws -> Data {\n  let sealed = try AES.GCM.seal(payload, using: key)\n  return sealed.combined!\n}\n\nfunc decrypt(_ data: Data, with key: SymmetricKey) throws -> Data {\n  let box = try AES.GCM.SealedBox(combined: data)\n  return try AES.GCM.open(box, using: key)\n}\n```\n\n## Follow-up Questions\n\n- How would you test cross-user data isolation in unit/integration tests?\n- How would you migrate transcripts if key derivation changes?","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T06:55:14.589Z","createdAt":"2026-01-20T06:55:14.589Z"},{"id":"q-4710","question":"**Offline-First Ledger:** Design an offline-first ledger viewer for a fintech app where data is encrypted end-to-end with keys in Secure Enclave, persisted atomically in a local database, and synced to a central server when online. Include per-user permissions, deterministic conflict resolution, and crash-safe writes. Use Swift, SwiftUI, and async/await; outline architecture, data model, encryption workflow, and a practical test plan; provide a concise code skeleton.**?","answer":"Design an offline-first ledger view for a fintech app: encrypt all local entries with a key stored in Secure Enclave (CryptoKit), persist atomically in a local database, and sync with a central server","explanation":"## Why This Is Asked\n\nTests depth in secure offline data handling, multi-user permissions, and robust sync.\n\n## Key Concepts\n\n- Offline-first data model with atomic writes\n- End-to-end encryption via Secure Enclave (CryptoKit)\n- Per-user permissions and auditability\n- Deterministic conflict resolution for sync\n- Swift Concurrency patterns and testability\n\n## Code Example\n\n```swift\nimport CryptoKit\n\nstruct LedgerEntry: Codable { let id: UUID; let amount: Decimal; let ts: Date }\n\nfinal class CryptoManager {\n  func encrypt(_ data: Data, using key: SymmetricKey) -> Data { /* ... */ }\n  func decrypt(_ data: Data, using key: SymmetricKey) -> Data { /* ... */ }\n  var key: SymmetricKey { /* Secure Enclave-backed key */ get { fatalError() } }\n}\n```\n\n## Follow-up Questions\n\n- How would you test key rotation without user disruption?\n- How would you simulate network partitions and reconciliation? \n","diagram":"flowchart TD\n  A(Local Store) --> B(Encryption & Decryption)\n  B --> C(Sync Engine)\n  C --> D(Server)\n  D --> A","difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Meta","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T09:10:03.477Z","createdAt":"2026-01-20T09:10:03.477Z"},{"id":"q-4751","question":"Implement a minimal To-Read list in SwiftUI: load articles from a bundled JSON (title, author, tag, publishedDate). Display as a list, allow tapping a row to toggle 'read' status, and debounce taps. Persist the array to UserDefaults using JSONEncoder/Decoder so state survives app restarts. Add a search bar that filters by title or tag with a 300ms debounce. Ensure accessibility for VoiceOver and Dynamic Type. What is your test plan?","answer":"Decode a bundled JSON into Article structs, toggle read on tap, and persist the updated array to UserDefaults via JSONEncoder/Decoder so state survives restarts. Implement a 300ms debounce on taps and","explanation":"## Why This Is Asked\n\nAssesses practical data flow and UI responsiveness for iOS: decoding, lightweight persistence, and debounced inputs in SwiftUI.\n\n## Key Concepts\n\n- SwiftUI List and @State/@ObservedObject\n- Codable Article type and UserDefaults persistence\n- Debounce patterns (Combine or DispatchQueue)\n- Accessibility: VoiceOver and Dynamic Type\n- Debounced search filtering\n\n## Code Example\n\n```swift\nstruct Article: Codable {\n  let id: String\n  let title: String\n  let author: String\n  let tag: String\n  let publishedDate: String\n  var read: Bool\n}\n```\n\n## Follow-up Questions\n\n- How would you extend to remote sync with conflict resolution?\n- How would you test persistence across app updates and data migrations?\n","diagram":"flowchart TD\n  A[Bundled JSON] --> B[Decode to [Article]]\n  B --> C[List UI with SwiftUI]\n  C --> D[Tap toggles read]\n  D --> E[Persist to UserDefaults]\n  C --> F[Search with debounce]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T10:51:31.724Z","createdAt":"2026-01-20T10:51:31.724Z"},{"id":"q-4792","question":"Build a minimal note-taking screen in iOS (SwiftUI) that lets users create notes with a title and body, assign 0-3 tags, and persist all notes to a single local JSON file in the Documents directory. Add a tag-based filter and a live search bar that debounces input to keep UI snappy. Ensure data persists across restarts, handle app background/foreground transitions, and provide basic accessibility hints?","answer":"I would implement a Codable Note type and a NotesStore class that loads/saves an array of notes to Documents/notes.json using an atomic write (temp file + swap). UI uses SwiftUI with @Published notes ","explanation":"## Why This Is Asked\nTests practical iOS fundamentals: Codable data models, file-based persistence with atomic writes, and SwiftUI data flow. It also exercises UX concerns like debounce for responsiveness and accessibility considerations.\n\n## Key Concepts\n- Codable data model for Note with title, body, tags, and date\n- File I/O in Documents with atomic write pattern\n- SwiftUI state management using @Published and binding for filters\n- Combine debouncing for search input\n- Tag-based filtering logic and accessibility labeling\n\n## Code Example\n```javascript\nimport Foundation\n\nstruct Note: Codable, Identifiable {\n  var id: UUID = UUID()\n  var title: String\n  var body: String\n  var tags: [String]\n  var date: Date = Date()\n}\n\nfinal class NotesStore: ObservableObject {\n  @Published var notes: [Note] = []\n  private let fileURL: URL = FileManager.default\n    .urls(for: .documentDirectory, in: .userDomainMask)[0]\n    .appendingPathComponent(\"notes.json\")\n\n  init() { load() }\n\n  func load() {\n    guard let data = try? Data(contentsOf: fileURL) else { return }\n    if let loaded = try? JSONDecoder().decode([Note].self, from: data) {\n      notes = loaded\n    }\n  }\n\n  func save() {\n    let tempURL = fileURL.appendingPathExtension(\"tmp\")\n    guard let data = try? JSONEncoder().encode(notes) else { return }\n    try? data.write(to: tempURL)\n    try? FileManager.default.replaceItemAtURL(fileURL, withItemAtURL: tempURL)\n  }\n}\n```\n\n## Follow-up Questions\n- How would you scale this to thousands of notes while keeping memory usage low?\n- How would you test atomic write correctness and debounce behavior?\n- How would you migrate to Core Data or add cloud sync later?","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Microsoft","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T13:14:40.687Z","createdAt":"2026-01-20T13:14:40.687Z"},{"id":"q-4895","question":"Build a beginner-friendly iOS SwiftUI feature: a draggable TaskList where items can be reordered via long-press drag, persisted locally in UserDefaults as a Codable array, and restored on app restart. Include a search bar to filter tasks and ensure VoiceOver announces drag-reorder actions. Provide a minimal test plan and a code skeleton?","answer":"To implement: define a Codable Task { let id: UUID; var title: String; var completed: Bool }. Persist via JSON in UserDefaults using Data, encode/decode on save and on app launch. Use a SwiftUI List w","explanation":"## Why This Is Asked\nTests ability to design a small, interactive UI with local persistence and accessibility considerations.\n\n## Key Concepts\n- SwiftUI List with onMove\n- Codable + UserDefaults/AppStorage\n- Searchable/filtering and dynamic type\n- VoiceOver drag feedback\n\n## Code Example\n```swift\nstruct Task: Codable, Identifiable { let id: UUID; var title: String; var completed: Bool }\nclass TaskVM: ObservableObject { @Published var tasks:[Task] = []; func save(){...} func load(){...} }\n```\n\n## Follow-up Questions\n- How would you scale for many items? \n- How handle schema changes? \n- How to write UI tests for reordering?","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["NVIDIA","Snowflake","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T17:52:00.808Z","createdAt":"2026-01-20T17:52:00.808Z"},{"id":"q-495","question":"How would you implement a simple UITableView with custom cells in iOS using Swift?","answer":"Create a UITableViewCell subclass, register it using tableView.register(CustomCell.self, forCellReuseIdentifier: \"cell\"), and implement the required UITableViewDataSource methods: numberOfRowsInSection and cellForRowAt.","explanation":"## Implementation Steps\n- Create a custom UITableViewCell class with IBOutlet connections\n- Register the cell class or nib with the table view\n- Implement the UITableViewDataSource protocol methods\n- Configure cell content in the cellForRowAt method\n- Handle cell selection and data updates\n\n## Key Concepts\n- Reusable cell pattern for optimal performance\n- Delegation pattern for table view event handling\n- Auto Layout for dynamic cell sizing\n- Efficient data source management","diagram":"flowchart TD\n  A[Create Custom Cell] --> B[Register Cell]\n  B --> C[Implement DataSource]\n  C --> D[Configure Cell]\n  D --> E[Handle Selection]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Oracle","Snowflake","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-08T11:59:05.660Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-5124","question":"iOS Beginner Challenge: Build a SwiftUI settings screen that lets a user choose a theme color from a small palette and adjust font size with a slider. Persist selections with @AppStorage so they survive app restarts; apply changes in real time to a live text preview; ensure accessibility labels for both color choices and the font size slider; include a concise test plan?","answer":"Use SwiftUI with two @AppStorage keys: one for themeColor (store as a hex or string) and one for fontSize (Double). Build a palette of color options; render them as tappable chips and reflect the sele","explanation":"## Why This Is Asked\nTests basic SwiftUI state management, on-device persistence, live UI updates, and accessibility considerations in a beginner-friendly setting.\n\n## Key Concepts\n- SwiftUI @AppStorage for lightweight persistence\n- Color theming and dynamic UI updates\n- Accessibility labeling and dynamic type considerations\n- Basic test planning: persistence, accessibility, UI consistency\n\n## Code Example\n```swift\n@AppStorage(\"themeColor\") private var themeColorHex: String = \"#4285F4\"\n@AppStorage(\"fontSize\") private var fontSize: Double = 14.0\n\nvar body: some View {\n  VStack {\n    // color palette and font size slider UI here\n    Text(\"Preview text\").font(.system(size: CGFloat(fontSize)))\n      .foregroundColor(Color(hex: themeColorHex))\n  }\n}\n```\n\n## Follow-up Questions\n- How would you validate edge cases like invalid saved color values?\n- How would you extend this to support dark mode vs light mode themes?","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T07:12:19.989Z","createdAt":"2026-01-21T07:12:19.989Z"},{"id":"q-5196","question":"In an offline-first iOS note app, design and implement a CRDT-based synchronization layer to merge edits across devices, using Core Data for local storage and a delta-based sync over WebSocket. Describe the data model, conflict resolution strategy, and convergence guarantees; outline a minimal Swift CRDT example and a test plan to validate correctness?","answer":"Design and implement a CRDT-based sync layer for an offline-first iOS note app. Store documents in Core Data; edits as per-character sequence CRDT with tombstones; delta-based sync over WebSocket; det","explanation":"## Why This Is Asked\nOffline collaboration on mobile requires robust conflict resolution and efficient synchronization. CRDTs provide convergence guarantees but are nuanced on iOS memory and serialization. This question tests data modeling, multithreading, and network resilience.\n\n## Key Concepts\n- CRDT design for text edits (sequence CRDT)\n- Core Data integration for local persistence\n- Delta-based synchronization and tombstones\n- Causality with vector clocks and deterministic merge\n- Testing offline/online scenarios\n\n## Code Example\n\n```swift\n// Minimal CRDT element\nstruct TextOp: Codable {\n  let id: UUID\n  let pos: Int\n  let ch: Character\n  let tombstone: Bool\n}\n```\n\n```swift\n// Pseudo-merge function signature\nfunc apply(_ op: TextOp, to doc: inout String) { /* deterministic insert/delete */ }\n```\n\n## Follow-up Questions\n- How to size and compress delta payloads?\n- How to test convergence under latency and reordering?\n- How to handle conflicts when edits arrive out-of-order?","diagram":"flowchart TD\n  A[Local Edit] --> B[CRDT Merge]\n  B --> C[Delta Sync over WebSocket]\n  C --> D[Remote Edits Applied]\n  D --> A","difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","NVIDIA","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T10:38:46.407Z","createdAt":"2026-01-21T10:38:46.409Z"},{"id":"q-5244","question":"Build a minimal iOS app named 'HuntList' with a grocery items list loaded from a bundled JSON. Allow adding items via a text field and persist the updated list to a local JSON file atomically in the Documents directory. Implement Dynamic Type and per-row VoiceOver hints; ensure the Add button is accessible. Debounce taps to avoid duplicates. Data must persist across restarts and respond to foreground/background transitions. Use SwiftUI; include a basic test plan for JSON decoding and atomic writes?","answer":"Load initial items from bundled JSON into a published array and display them in a SwiftUI List. Add items with a debounced tap to prevent duplicates. Persist updates with FileManager.default.write(to:","explanation":"## Why This Is Asked\nTests practical basics: SwiftUI, data persistence, debounced input, and accessibility, plus basic testing. It avoids the previous patterns and emphasizes correctness and UX.\n\n## Key Concepts\n- SwiftUI data flow; @Published; URL in Documents\n- JSON encoding/decoding; atomic file writes\n- Debounce input; accessibility labels/hints; Dynamic Type\n- ScenePhase changes and simple test planning\n\n## Code Example\n```javascript\n// Pseudo Swift-like snippet omitted for brevity\n```\n\n## Follow-up Questions\n- How would you handle large JSON files or synchronization across devices?\n- How would you test accessibility for VoiceOver in this flow?","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Google","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T11:57:35.926Z","createdAt":"2026-01-21T11:57:35.926Z"},{"id":"q-525","question":"You're building a food delivery app like DoorDash. How would you implement background location updates to track delivery drivers while balancing battery life and accuracy?","answer":"Use CLLocationManager with significantLocationChangeMonitoring for battery efficiency, switching to standard location updates during active deliveries. Implement region-based geofencing for restaurant and destination zones to trigger location updates only when necessary.","explanation":"## Background Location Strategy\n\n- **significantLocationChangeMonitoring**: Battery-efficient for idle drivers\n- **Standard location updates**: High accuracy during active deliveries\n- **Geofencing**: CLRegion for restaurant/destination zones\n- **Deferred updates**: Batch location data to reduce wake-ups\n\n## Implementation Details\n\n```swift\nlet locationManager = CLLocationManager()\nlocationManager.allowsBackgroundLocationUpdates = true\nlocationManager.pausesLocationUpdatesAutomatically = true\nlocationManager.activityType = .otherNavigation\n```\n\n## Battery Optimization\n\n- Use desiredAccuracy = kCLLocationAccuracyHundredMeters for monitoring\n- Switch to kCLLocationAccuracyBestForNavigation during deliveries\n- Implement adaptive update frequency based on speed and proximity\n- Leverage iOS motion detection to pause updates when stationary","diagram":"flowchart TD\n  A[Driver Idle] --> B[Significant Location Change]\n  B --> C{Delivery Accepted?}\n  C -->|Yes| D[Standard Location Updates]\n  C -->|No| B\n  D --> E[Active Navigation]\n  E --> F{Near Destination?}\n  F -->|Yes| G[Geofence Trigger]\n  F -->|No| E\n  G --> H[Delivery Complete]\n  H --> A","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Microsoft","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-09T08:42:22.344Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-5287","question":"Design and implement a beginner iOS SwiftUI app that tracks daily habits: add/edit a list, mark completion for today, show a 7-day streak, and persist data to a local JSON file in the Documents directory using Codable and FileManager. Debounce saves to avoid thrashing, handle background/foreground transitions, and provide a minimal test plan?","answer":"Implement a small Habit model with id, name, color, and completedDates [Date]. Use a single habits.json file in Documents. Compute the current streak by counting consecutive days with completion up to","explanation":"## Why This Is Asked\nThis question probes practical, beginner-friendly iOS skills with offline persistence, basic data modeling, and UI state management.\n\n## Key Concepts\n- SwiftUI list and state\n- Codable models and FileManager\n- Debounce/save-on-delta techniques\n- ScenePhase background/foreground handling\n- Simple streak calculation\n\n## Code Example\n```swift\nstruct Habit: Codable {\n  let id: UUID\n  var name: String\n  var colorHex: String\n  var completedDates: [Date]\n}\n```\n\n## Follow-up Questions\n- How would you test edge cases with time zones and DST shifts?\n- How would you extend to multi-user on a single device or cloud backup?","diagram":"flowchart TD\n  A[Open app] --> B[Display habits]\n  B --> C[Toggle today]\n  C --> D[Debounced save]\n  D --> E[Streak shown]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Snap","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T15:04:06.596Z","createdAt":"2026-01-21T15:04:06.596Z"},{"id":"q-5304","question":"Design a collaborative checklist feature for an iOS app where multiple users can co-edit a shared project offline and later sync with CloudKit. Requirements: per-item versioning, offline queue, deterministic merging, and conflict resolution that favors user intent. Explain the data model (CKRecord hierarchy or CoreData mirroring), the sync flow using Swift Concurrency, and a test plan including simulated network partitions and concurrent edits?","answer":"Use a Project CKRecord with child Item records, each containing a version and lastModified. Maintain a local CoreData store and an offline mutation queue. On sync, pull remote diffs, apply per-item me","explanation":"## Why This Is Asked\n\nTests ability to design offline-first collaborative features with per-item versioning and conflict resolution in iOS apps, which is realistic for consumer platforms.\n\n## Key Concepts\n\n- CloudKit CKRecord model and CoreData mirroring\n- Per item version and deterministic merge\n- Offline queue and idempotent sync\n- Conflict resolution strategies and testing\n\n## Code Example\n\n```swift\nstruct Item {\n  let id: String\n  var text: String\n  var version: Int\n  var lastModified: Date\n}\n```\n\n## Follow-up Questions\n\n- How would you simulate network partitions in tests?\n- How would you handle deletion reconciliation and tombstones?\n","diagram":"flowchart TD\n  A[Offline queue] --> B[CloudKit sync]\n  B --> C{Conflicts?}\n  C -- Yes --> D[Per-item merge]\n  C -- No --> E[Apply updates]","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Netflix","Snap","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T15:48:28.169Z","createdAt":"2026-01-21T15:48:28.169Z"},{"id":"q-5440","question":"Design and implement a non-destructive, GPU-accelerated filter graph in an iOS photo-editing app: each filter is a node; edits propagate using Swift concurrency; final image is base image plus ordered passes; support undo/redo by graph state snapshots; memory pressure handled via tile-based rendering and lazy recomputation; export via CIContext. Provide data model, API surface, and testing approach?","answer":"Implement a non-destructive FilterGraph using Swift actors: each filter is a node with input/output CIImage; edits propagate asynchronously via async/await; base image plus ordered passes render the f","explanation":"## Why This Is Asked\nEvaluates design of a scalable, non-destructive editing pipeline, leveraging Swift concurrency, Core Image, and memory-aware rendering. Also tests undo/redo, testability, and accessibility considerations in a production-like feature.\n\n## Key Concepts\n- Swift concurrency and actors for safe state sharing\n- Core Image for GPU-accelerated filters\n- Non-destructive editing via composable filter passes\n- Undo/redo through graph state snapshots\n- Memory management with tile-based rendering and lazy recomputation\n- Testability: unit tests for graph evaluation; integration tests for export\n- Accessibility hooks for UI feedback\n\n## Code Example\n```swift\n// Skeleton: Filter protocol and graph actor\nactor FilterGraph {\n  struct Node { var id: String; var filter: CIFilter }\n  var nodes: [Node] = []\n  func applyAll(base: CIImage) async -> CIImage {\n    var current = base\n    for n in nodes {\n      n.filter.setValue(current, forKey: kCIInputImageKey)\n      if let out = n.filter.outputImage {\n        current = out\n      }\n    }\n    return current\n  }\n}\n```\n\n## Follow-up Questions\n- How would you adapt this to handle very large images on memory-constrained devices?\n- What trade-offs exist between tile-based rendering vs full-image compositing, and how would you test them?","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T22:38:25.492Z","createdAt":"2026-01-21T22:38:25.492Z"},{"id":"q-5499","question":"Design a JSON-driven dynamic form renderer for iOS: fetch a schema, render fields at runtime, validate per field type, persist partial responses in CoreData, and sync via a background URLSession when online. Include schema versioning, per-field migrations, and a concrete test plan?","answer":"Design a JSON-driven dynamic form renderer for iOS: fetch a schema, render fields at runtime, validate per field type, persist partial responses in CoreData, and sync via a background URLSession when online. Include schema versioning, per-field migrations, and a concrete test plan.","explanation":"## Why This Is Asked\nThis question evaluates real-world expertise in dynamic form handling, offline-first architecture, and robust data synchronization in iOS applications.\n\n## Key Concepts\n- Dynamic UI generation from JSON schemas with runtime field rendering\n- CoreData data models with lightweight migration strategies\n- Background URLSession uploads implementing retry mechanisms and exponential backoff\n- Schema evolution patterns: backward/forward compatibility and field-level migrations\n- Comprehensive testing approaches: offline editing scenarios, partial save validation, and conflict resolution\n\n## Code Example\n```javascript\nfunction validateField(field, value) {\n  switch(field.type){\n    case 'string': return typeof value === 'string'\n```","diagram":"flowchart TD\n  A[Schema Loaded] --> B[Render Form]\n  B --> C[Validate Input]\n  C --> D[Store Locally]\n  D --> E[Background Sync]\n  E --> F[Schema Evolution]","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Salesforce","Twitter","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T05:09:14.141Z","createdAt":"2026-01-22T02:42:07.342Z"},{"id":"q-5519","question":"Design a beginner iOS SwiftUI app named FocusTimer that lets a user create 3 Pomodoro-style timers (25/5/15 minutes). It must be accessible (VoiceOver labels, Dynamic Type, color contrast) and fit on a single screen: a timer list, a prominent Start/Pause button, and a simple progress ring. Implement the timer with Timer.publish, persist remaining seconds and active timer to UserDefaults, debounce taps, and provide a concise test plan?","answer":"An ideal answer outlines a small MVVM SwiftUI app with three presets (25, 5, 15). Timer uses Timer.publish(every: 1). The active timer updates a ProgressRing; accessibility: labels for timer, Dynamic ","explanation":"## Why This Is Asked\nTests familiarity with SwiftUI basics, timer handling, accessibility, and simple persistence in a beginner-friendly scenario.\n\n## Key Concepts\n- SwiftUI TimerPublisher and state management\n- MVVM pattern with @ObservableObject and @Published\n- UserDefaults for minimal persistence\n- Accessibility: VoiceOver labels, Dynamic Type, color contrast\n- Debouncing user input to prevent thrashing\n\n## Code Example\n```swift\nclass FocusTimerViewModel: ObservableObject {\n  @Published var remaining: Int = 0\n  @Published var isRunning: Bool = false\n  private var cancellable: AnyCancellable?\n  func start(duration: Int) {\n    remaining = duration * 60\n    isRunning = true\n    cancellable = Timer.publish(every: 1, on: .main, in: .common)\n      .autoconnect()\n      .sink { [weak self] _ in\n        guard let self = self else { return }\n        if self.remaining > 0 { self.remaining -= 1 } else { self.isRunning = false }\n      }\n  }\n}\n```\n\n## Follow-up Questions\n- How would you handle timer accuracy when the app is backgrounded?\n- How would you scale to more than 3 presets and persist per-preset state?","diagram":"flowchart TD\n  A[Open FocusTimer] --> B[Display timers]\n  B --> C[Tap Start]\n  C --> D[Timer ticks every second]\n  D --> E[Update progress ring]\n  E --> F[On finish]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Snap","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T04:20:50.554Z","createdAt":"2026-01-22T04:20:50.554Z"},{"id":"q-5544","question":"Design a beginner iOS SwiftUI app named FocusFlow that starts a 25-minute focus timer, shows a circular progress indicator, and saves remaining seconds to UserDefaults on every app lifecycle change. On relaunch, restore the previous state (remaining time and running/paused). The app should resume automatically if it was running. Include a minimal test plan for persistence and state restoration?","answer":"To implement FocusFlow, create a FocusSession model with duration, remaining, isRunning, and lastUpdated; encode/decode to UserDefaults. Use a Circle progress view driven by (duration-remaining)/durat","explanation":"## Why This Is Asked\n\nAssesses practical SwiftUI state management, lifecycle handling, and simple persistence for a timer use case.\n\n## Key Concepts\n\n- SwiftUI state and ObservableObject patterns\n- App lifecycle (scenePhase) and backgrounding\n- Codable persistence to UserDefaults\n- Timer/Combine integration for UI updates\n\n## Code Example\n\n```swift\nimport Foundation\n\nstruct FocusSession: Codable {\n    var duration: Int // seconds\n    var remaining: Int // seconds\n    var isRunning: Bool\n    var lastUpdated: Date?\n}\n```\n\n## Follow-up Questions\n\n- How would you handle timer accuracy across background/foreground transitions?\n- How would you unit test persistence and relaunch restoration without UI tests?","diagram":"flowchart TD\n  A[Start Focus] --> B[Timer running]\n  B --> C[Pause/Resume]\n  C --> D[Background Save]\n  D --> E[Restart on Relaunch]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Hugging Face"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T05:42:46.273Z","createdAt":"2026-01-22T05:42:46.274Z"},{"id":"q-5631","question":"Design an offline-first analytics event pipeline for iOS: collect user interactions, persist them to a durable on-disk queue, batch-upload via URLSession background tasks, deduplicate events, and provide idempotent processing on the server. Describe data model, concurrency model, error handling, and a test plan for network changes and app restarts?","answer":"Design an offline-first analytics pipeline: collect events, persist to a durable on-disk queue (CoreData/SQLite), batch them and upload via a URLSession background task, and ensure idempotent processi","explanation":"## Why This Is Asked\nThis question probes building robust on-device data pipelines, balancing persistence, background work, and server-side idempotency under connectivity churn.\n\n## Key Concepts\n- Offline persistence: durable on-disk queue (CoreData/SQLite)\n- Batch uploads: URLSession background transfers and queue flushing\n- Idempotent server API: dedup by event ID; safe retries\n- Testing: simulate disconnects, restarts, partial failures\n\n## Code Example\n```swift\nstruct AnalyticsEvent: Codable {\n  let id: String\n  let name: String\n  let timestamp: Date\n  let payload: [String: String]\n}\n```\n\n## Follow-up Questions\n- How would you guarantee at-least-once delivery while avoiding duplicates on the server?\n- How would you test resilience to app termination mid-upload?\n","diagram":"flowchart TD\n  A[Collect Event] --> B[Persist to Disk Queue]\n  B --> C[Batch Flush Triggered]\n  C --> D[URLSession Background Upload]\n  D --> E[Server Ack / Retry]","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","MongoDB","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T09:03:14.999Z","createdAt":"2026-01-22T09:03:15.000Z"},{"id":"q-578","question":"What's the difference between weak and unowned references in Swift, and when would you use each?","answer":"Weak references are optional and automatically become nil when the referenced object is deallocated. Unowned references are non-optional and assume the referenced object will always exist. Use weak for optional relationships where the referenced object might be deallocated first.","explanation":"## Memory Management\n\nSwift uses ARC (Automatic Reference Counting) to manage memory automatically. Strong references can create retain cycles, so we use weak and unowned references to break them.\n\n## Weak References\n\n- Always optional (automatically set to nil on deallocation)\n- Use for optional relationships\n- Common patterns: delegates, outlets\n\n```swift\nweak var delegate: MyDelegate?\n```\n\n## Unowned References\n\n- Non-optional (assumes reference always exists)\n- Use when you know the reference will outlive the holder\n- Common patterns: parent-child relationships\n\n```swift\nunowned let parent: ParentClass\n```\n\n## Key Differences\n\nChoose weak when the reference might become nil during execution. Choose unowned when you're certain the reference will always exist throughout the object's lifetime.","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-08T11:52:32.417Z","createdAt":"2025-12-27T01:13:27.377Z"},{"id":"q-5807","question":"Design and implement an iOS feature to capture short video annotations tied to notes in a local-first app: persist metadata and thumbnails in Core Data with atomic writes, encrypt media files on disk using CryptoKit, and build a CRDT-based sync layer over WebSocket for cross-device consistency; ensure background indexing, accessibility, and provide a concrete test plan?","answer":"I'd implement a local-first path: Core Data for metadata, a file-backed media store with atomic writes, and CryptoKit AES-GCM to encrypt on-disk media. Sync uses a CRDT (e.g., LWW-Element-Set variant)","explanation":"## Why This Is Asked\n\nTests end-to-end ownership of offline-first design, secure storage, and cross-device sync.\n\n## Key Concepts\n\n- Local-first data model with Core Data and a file-backed media store\n- On-disk encryption with CryptoKit (AES-GCM)\n- Atomic writes and safe background indexing\n- CRDT-based conflict resolution over WebSockets\n- Accessibility and testability in SwiftUI/UIKit\n\n## Code Example\n\n```swift\n// Simple CRDT merge sketch\nstruct NoteCRDT: Codable {\n  var id: UUID\n  var payload: String\n  var tombstone: Bool\n  var clock: UInt64\n}\nfunc merge(_ a: NoteCRDT, _ b: NoteCRDT) -> NoteCRDT {\n  return a.clock > b.clock ? a : b\n}\n```\n\n## Follow-up Questions\n\n- How would you ensure media type handling and deduplication?\n- How would you test CRDT merge correctness and offline resilience?","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Coinbase","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T17:39:15.992Z","createdAt":"2026-01-22T17:39:15.992Z"},{"id":"q-5874","question":"Design and implement an iOS feature: a live, streaming activity feed where the client consumes a line-delimited JSON stream, applies updates to a local Core Data store, and keeps UI in sync with offline support. Use Swift async/await, a private Core Data queue, and a per-record version for conflict resolution. Include a minimal test plan and accessibility considerations?","answer":"Proposed approach: stream line-delimited JSON via URLSession, parse each line, and apply updates on a private Core Data queue. Use a per-record version for conflict resolution and optimistic UI update","explanation":"## Why This Is Asked\n\nTests real-time streaming, offline-first data integrity, and conflict-resolution strategies in a production-like iOS feature; also emphasizes testability and accessibility.\n\n## Key Concepts\n\n- Swift async/await and URLSession data delegation for line-delimited streaming\n- Core Data on a private queue; background context merging to UI context\n- Conflict resolution via per-record version numbers; vector clocks considered\n- Offline-first UX: local cache, queued mutations, retry with backoff\n- Accessibility and tested edge cases (dynamic content, VoiceOver)\n\n## Code Example\n\n```swift\n// Streaming parser sketch\nclass Streamer: NSObject, URLSessionDataDelegate {\n  var buffer = Data()\n  func urlSession(_ s: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {\n    buffer.append(data)\n    while let nl = buffer.firstIndex(of: 0x0A) {\n      let line = buffer.prefix(nl)\n      buffer.removeFirst(nl + 1)\n      // decode and apply to Core Data on private queue\n    }\n  }\n}\n```\n\n## Follow-up Questions\n\n- How would you handle schema changes in the stream and migrations?\n- How would you test offline queue handling and conflict resolution?","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Netflix","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T19:52:03.540Z","createdAt":"2026-01-22T19:52:03.540Z"},{"id":"q-6004","question":"Design a beginner iOS SwiftUI app named TagNote that lets users create notes with a title, body, and optional tag. Persist locally with Core Data; implement tag-based filtering and a debounced search bar. Ensure data remains across restarts, and handle app lifecycle events (foreground/background). Include a basic test plan?","answer":"Build a beginner iOS SwiftUI app called TagNote: create notes with title, body, and an optional tag. Persist via Core Data locally; implement tag-based filtering and a debounced search. Use MVVM, fetc","explanation":"## Why This Is Asked\nAssesses practical iOS data modeling, SwiftUI wiring, and offline persistence with Core Data.\n\n## Key Concepts\n- SwiftUI MVVM data flow\n- Core Data persistence\n- @FetchRequest and predicates for filtering\n- Debounced search with Combine/DispatchQueue\n- Background vs main thread work and lifecycle handling\n- Accessibility and basic testing\n\n## Code Example\n```swift\n// Minimal Core Data save helper\nfunc saveNote(context: NSManagedObjectContext, title: String, body: String, tag: String?) {\n  let note = NoteEntity(context: context)\n  note.id = UUID()\n  note.title = title\n  note.body = body\n  note.tag = tag\n  try? context.save()\n}\n```\n\n## Follow-up Questions\n- How would you add full-text search across title and body?\n- How would you test debounced search behavior in unit tests?","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Instacart","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T04:20:23.987Z","createdAt":"2026-01-23T04:20:23.988Z"},{"id":"q-6121","question":"Design and implement an iPad-friendly command palette in Swift that opens with Cmd+K, supports live search, keyboard shortcuts, and accessibility (VoiceOver, Dynamic Type). The palette should be driven by a JSON manifest (no recompilation) and capable of invoking app actions safely with undo. Describe data model, UI flow, manifest loading strategy, and a practical test plan?","answer":"Propose a CommandItem with id, title, shortcut, image, action. Use UIKeyCommand for shortcuts; wire to a bridge that maps titles to selectors. Load manifest from documents and cache parsed results; De","explanation":"## Why This Is Asked\nAssess ability to design keyboard-driven UX, accessibility, and offline-driven config while bridging SwiftUI and UIKit.\n\n## Key Concepts\n- UIKeyCommand and keyboard navigation\n- SwiftUI/UIKit bridging, command pattern\n- JSON manifest-driven UI\n- Accessibility and localization\n\n## Code Example\n```javascript\n// Pseudo-code: mapping manifest to commands\ntype CommandItem = {\n  id: string\n  title: string\n  shortcut?: string\n  action: string\n}\n```\n\n## Follow-up Questions\n- How would you handle localization of command titles?\n- How would you test with VoiceOver and different Dynamic Type settings?","diagram":null,"difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Hugging Face","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T09:47:05.537Z","createdAt":"2026-01-23T09:47:05.537Z"},{"id":"q-6169","question":"Create an offline-first iOS chat client: messages stored in Core Data, encrypted with CryptoKit before persistence, and decrypted in memory for display. When online, sync with REST backend; ensure idempotent delivery, respect message order within a thread, handle edits/deletes with conflict resolution, and implement exponential backoff retries. Outline data model, key management, and a test plan?","answer":"Store Message as encrypted blob in Core Data; use CryptoKit AES.GCM with a per-user key in the Keychain; encrypt on send, decrypt on fetch. Local queue for outgoing messages; on network, post to REST ","explanation":"## Why This Is Asked\nEvaluates practical offline-first sync, encryption, and data integrity under flaky networks.\n\n## Key Concepts\n- Core Data persistence of encrypted blobs\n- CryptoKit AES-GCM key management in Keychain\n- Idempotent REST sync with delivery markers\n- Conflict resolution with per-message versioning\n- Robust test strategies for offline/online transitions\n\n## Code Example\n```swift\nimport CryptoKit\nlet key = SymmetricKey(size: .bits256)\nlet data = Data(\"hello\".utf8)\nlet sealed = try AES.GCM.seal(data, using: key)\n```\n\n## Follow-up Questions\n- How would you rotate keys with minimal user impact?\n- How to test race conditions in concurrent UI sends?","diagram":"flowchart TD\nA[Offline storage] --> B[Encrypt with AES-GCM]\nB --> C[Persist in Core Data]\nC --> D[On connect: Sync to REST]\nD --> E[Mark delivered / merge edits]","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","MongoDB","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T11:38:35.382Z","createdAt":"2026-01-23T11:38:35.382Z"},{"id":"q-6261","question":"Build a beginner iOS SwiftUI app called QuickNotes that lets users create notes (title and body), saves them locally using a lightweight SQLite store via GRDB, and displays a searchable list with date filtering. Add accessibility: Dynamic Type, VoiceOver labels, and high-contrast mode. Outline data migrations and provide a minimal test plan?","answer":"Persist notes using GRDB with a DatabaseQueue. Model NoteRecord(id, title, body, date). Expose a NotesViewModel with @Published notes, searchQuery, and dateFilter. Use a SwiftUI List with .searchable;","explanation":"## Why This Is Asked\n\nTests practical iOS basics: SwiftUI data flow, SQLite persistence with GRDB, and accessibility concerns. It also touches migrations and basic testing, which beginners can implement with guidance.\n\n## Key Concepts\n\n- SwiftUI data binding and state management\n- GRDB/SQLite data persistence and migrations\n- Searchable lists and date filtering\n- Accessibility: Dynamic Type, VoiceOver, high-contrast\n- Lightweight unit/UI testing strategies\n\n## Code Example\n\n```swift\nstruct Note: Identifiable {\n  let id: UUID\n  var title: String\n  var body: String\n  var date: Date\n}\n\nfunc notesForQuery(_ query: String, in notes: [Note]) -> [Note] {\n  let q = query.lowercased()\n  return notes.filter { $0.title.lowercased().contains(q) || $0.body.lowercased().contains(q) }\n}\n```\n\n## Follow-up Questions\n\n- How would you implement migrations and versioning in GRDB for evolving schemas?\n- How would you optimize search performance for large note datasets on-device?","diagram":"flowchart TD\n  A[User creates note] --> B[NoteRecord stored in GRDB]\n  B --> C[NotesViewModel updates notes list]\n  C --> D[SwiftUI List renders with search and date filters]\n  D --> E[Accessibility: Dynamic Type and VoiceOver labels enabled]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Snap","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T16:48:49.756Z","createdAt":"2026-01-23T16:48:49.756Z"},{"id":"q-6300","question":"Design and implement a real-time stock watchlist screen that consumes a simulated WebSocket price feed, renders a grid with per-item sparkline charts, persists last prices locally (CoreData) and recovers on restart, and uses SwiftUI with Async/Await and a dedicated Actor to serialize updates. Describe data flow, error handling, and a concise test plan?","answer":"Use URLSessionWebSocketTask to connect to a mock feed delivering symbol, price, and timestamp. Implement a PriceFeedActor that parses updates and updates a StockStore (@MainActor) which writes to Core","explanation":"## Why This Is Asked\n\nAssesses real-time data streaming, concurrency with Swift actors, persistent state recovery, and UI performance under frequent updates—common in finance apps.\n\n## Key Concepts\n\n- WebSocket streaming with URLSessionWebSocketTask\n- Swift concurrency: actors and Async/Await\n- Local persistence: CoreData with recovery on restart\n- SwiftUI: grid layouts and sparkline visualizations\n- Testing: WS mocks, latency/ordering, persistence checks\n\n## Code Example\n\n```swift\nactor PriceFeedActor {\n  func receive(_ update: PriceUpdate) {\n    // parse and forward to StockStore\n  }\n}\n```\n\n## Follow-up Questions\n\n- How would you handle reconnection backoff and out-of-order messages?\n- What strategies ensure deterministic UI rendering during burst updates?","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T18:05:17.228Z","createdAt":"2026-01-23T18:05:17.228Z"},{"id":"q-6409","question":"In an iOS app for streaming video, implement an offline-first download queue: allow selecting multiple videos for download in parallel with multiple resolutions; ensure atomic file writes, resume after relaunch, support pause/resume and cancel, and report per-video progress. Outline data models (download record, video metadata, progress), caching strategy (disk storage + NSCache), background transfers (URLSession with background configuration), crash-safe resume logic, and a concise test plan?","answer":"Implement a robust offline-first download queue using Swift concurrency with a DownloadManager actor coordinating a TaskGroup of URLSessionBackgroundDownloadTasks. Write files to temporary locations, then atomically move them into per-video folders using FileManager. Utilize CoreData for persistence with DownloadRecord entities (id, videoId, resolution, status, progress, localPath) and VideoMetadata. Implement NSCache for in-memory progress tracking. Configure URLSession with a background identifier and discretionary flag. On app launch, query incomplete downloads and resume tasks. Support pause/resume through task cancellation and recreation, with proper cleanup on cancellation.","explanation":"## Why This Is Asked\nAssess mastery of offline-first design, concurrency, persistence, and robust background transfers in iOS at scale.\n\n## Key Concepts\n- Offline-first downloads with background URLSession\n- Data modeling with CoreData and per-video metadata\n- Concurrency safety via actors and TaskGroup\n- Crash-safe resume and cancellation\n- Testing strategy for persistence and race conditions\n\n## Code Example\n```swift\n// Swift data models\nclass DownloadRecord {\n    let id: UUID\n    let videoId: String\n    let resolution: VideoResolution\n    var status: DownloadStatus\n    var progress: Double\n    var localPath: String?\n}\n\nactor DownloadManager {\n    private let session: URLSession\n    private let cache = NSCache<NSString, NSNumber>()\n    \n    func startDownload(videoId: String, resolution: VideoResolution) async {\n        // Implementation details\n    }\n}\n```","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Netflix","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T05:10:48.612Z","createdAt":"2026-01-23T22:40:32.385Z"},{"id":"q-6435","question":"Design and implement an advanced iOS offline-first chat component: end-to-end encrypted messages via CryptoKit, local storage with SQLite (GRDB), and CloudKit synchronization with per-device conflict resolution. Use Swift Concurrency (actors) to serialize state; outline data models, key management, offline queue, and a concrete test plan?","answer":"I'd implement an offline-first chat component using GRDB for local SQLite storage and CloudKit for synchronization. The data model would include: Message(id, conversationId, senderId, timestamp, nonce, ciphertext). End-to-end encryption would be handled via CryptoKit with per-user key pairs stored in the Secure Enclave. Swift actors would serialize all state access to prevent race conditions, while CloudKit's per-device timestamp vectors would enable conflict resolution during sync.","explanation":"## Why This Is Asked\n\nThis question evaluates advanced iOS development skills including concurrency, security, offline-first architecture, and CloudKit data synchronization.\n\n## Key Concepts\n\n- End-to-end encryption using CryptoKit\n- Local persistence with SQLite via GRDB\n- Swift actors for race-free state management\n- CloudKit conflict resolution using per-device logical clocks\n- Secure key management in the Secure Enclave\n- Offline message queuing and sync orchestration\n\n## Code Example\n\n```swift\n// Swift data model\nstruct Message {\n    let id: UUID\n    let conversationId: UUID\n    let senderId: UUID\n    let timestamp: Date\n    let nonce: Data\n    let ciphertext: Data\n}\n```\n\n## Follow-up Questions\n\n- How would you handle key rotation for existing conversations?\n- What strategies would you use for efficient CloudKit batch operations?\n- How would you implement message deletion policies across devices?","diagram":"flowchart TD\n  A[Message Compose] --> B[Encrypt with CryptoKit]\n  B --> C[Store in SQLite]\n  C --> D[Queue for Send]\n  D --> E[CloudKit Sync]","difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","MongoDB","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T04:01:22.317Z","createdAt":"2026-01-23T23:52:25.523Z"},{"id":"q-6649","question":"In an iOS enterprise app used by field agents to collect asset inspection data, design an offline-first data capture module that syncs with a REST backend when online and supports per-record versioning, delta payloads, audit trails, optimistic UI, and field validation with conflict resolution?","answer":"Design an offline-first form data capture module for field agents. Use Core Data for local persistence, per-record versioning, and JSON deltas for REST sync. Implement optimistic UI, batched uploads, ","explanation":"## Why This Is Asked\nThis question probes practical offline-first data capture with versioning, delta sync, and conflict resolution in enterprise iOS apps.\n\n## Key Concepts\n- Core Data persistence and change tracking\n- Per-record versioning and delta payloads\n- Conflict resolution strategies and audit trails\n- REST API design, validation, and offline-first UX\n\n## Code Example\n```javascript\n// Pseudo-code for delta merge between remote and local records\nfunction mergeDelta(remote, local) {\n  if (remote.version > local.version) return remote\n  if (remote.version < local.version) return local\n  // tie-breaker using serverTimestamp\n  return remote.serverTimestamp > local.serverTimestamp ? remote : local\n}\n```\n\n## Follow-up Questions\n- How would you test conflict scenarios across devices?\n- How would you implement offline form validation and field-level constraints?","diagram":"flowchart TD\n  A[Start] --> B[Persist locally in Core Data]\n  B --> C[Validate forms]\n  C --> D[Enqueue changes in sync queue]\n  D --> E{Online?}\n  E -- Yes --> F[Push deltas to REST]\n  F --> G[Mark as synced]\n  E -- No --> H[Retry later]\n  G --> I[End]","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Salesforce","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T11:38:39.999Z","createdAt":"2026-01-24T11:38:40.000Z"},{"id":"q-6708","question":"Design and implement a beginner iOS SwiftUI app named AudioNotes that lets users record short audio notes, automatically saves each recording to the app's Documents directory with a UUID filename, stores metadata (id, timestamp, duration, filename) in a local JSON file using Codable, lists notes in a scrollable view, and allows playback of selected notes. Include basic permission handling and a simple test plan?","answer":"Request microphone permissions via AVAudioSession, initialize AVAudioRecorder with a UUID-based file URL in Documents, and start recording. On stop, compute duration, append a Codable Note to notes.js","explanation":"## Why This Is Asked\nTests practical iOS audio APIs, simple data persistence, and SwiftUI state management without heavy frameworks.\n\n## Key Concepts\n- AVFoundation: AVAudioRecorder, AVAudioPlayer\n- File persistence: Documents directory, Codable\n- Data model: Note(id, timestamp, duration, filename)\n- SwiftUI: List, playback controls\n- Permissions: requestRecordPermission and error handling\n- Testing: unit tests for JSON IO; UI tests for record/list/playback\n\n## Code Example\n```swift\nstruct Note: Codable {\n  let id: String\n  let timestamp: Date\n  let duration: TimeInterval\n  let filename: String\n}\n```\n\n```swift\nfunc notesFileURL() -> URL {\n  let dir = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!\n  return dir.appendingPathComponent(\"notes.json\")\n}\n```\n\n```\nNote: id = UUID().uuidString\n```\n## Follow-up Questions\n- How would you handle background recording interruptions and resume?\n- How would you mock AVAudioSession in tests?","diagram":"flowchart TD\n  A[User taps Record] --> B[Start AVAudioRecorder]\n  B --> C{Stop?}\n  C -->|Stop| D[Save to Documents with UUID]\n  D --> E[Append to notes.json]\n  E --> F[Refresh List]\n  F --> G[Tap note to Play]\n  G --> H[Play with AVAudioPlayer]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Cloudflare","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T14:13:55.156Z","createdAt":"2026-01-24T14:13:55.157Z"},{"id":"q-6739","question":"In an iOS video streaming app, design a resilient offline preview cache that supports seamless retry, prefetching, and resume after relaunch. You will prefetch upcoming segments, implement TTL eviction, cache keyframes, and resume playback after relaunch. Use AVPlayer with a custom resource loader, URLSession background downloads, and a manifest with segment offsets. Outline data models, caching strategy, testing plan, and trade-offs?","answer":"Design and implement an offline preview cache for a live-streaming iOS app. Prefetch upcoming segments, cache keyframes with a TTL-based eviction policy, and resume playback after relaunch. Implement ","explanation":"## Why This Is Asked\n\nTests ability to design a robust offline cache around streaming, focusing on prefetching, eviction, and crash-safe resume.\n\n## Key Concepts\n\n- AVPlayer and custom resource loading\n- Disk caching with TTL\n- Background downloads (URLSession)\n- State persistence for resume\n\n## Code Example\n\n```javascript\n// pseudo-code: prefetch loop outline\nfunction prefetchNextSegments(manifest, currentIndex) {\n  // fetch next N segments to disk cache\n}\n```\n\n## Follow-up Questions\n\n- How would you secure the cache against tampering?\n- How would you measure perf and cache hit rate in production?","diagram":"flowchart TD\n  A[App Start] --> B[Read manifest]\n  B --> C[Prefetch ahead]\n  C --> D[Cache segments]\n  D --> E[AVPlayer playback]\n  E --> F[On relaunch, restore lastPosition]","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Cloudflare","LinkedIn"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T15:32:32.771Z","createdAt":"2026-01-24T15:32:32.771Z"},{"id":"q-6887","question":"Design a beginner iOS SwiftUI app that fetches a small JSON feed from a public API and displays it in a list; implement a local cache in Documents with a 1-hour TTL, and fall back to cached data when offline. Use URLSession with async/await and Codable; include a minimal test plan?","answer":"Design a minimal SwiftUI app that fetches a JSON feed using URLSession with async/await, decodes the response with Codable, displays the data in a List view, and implements a local cache in the Documents directory with a 1-hour TTL. When network requests fail or the device is offline, the app seamlessly falls back to cached data, ensuring offline resilience.","explanation":"## Why This Is Asked\nThis question tests the ability to combine network I/O with offline resilience in a beginner iOS app—a common mobile development pattern that demonstrates practical understanding of data persistence and error handling.\n\n## Key Concepts\n- SwiftUI List views and state management with @State\n- async/await patterns with URLSession\n- Codable protocol for JSON parsing and serialization\n- FileManager for Documents directory caching\n- Time-to-live (TTL) cache implementation\n- Offline fallback strategies and robust error handling\n\n## Code Example\n```swift\nstruct Item: Codable, Identifiable { \n    let id: String \n    let title: String \n}\n\n@MainActor\nclass ContentViewModel: ObservableObject {\n    @Published var items: [Item] = []\n    \n    func fetchItems() async throws {\n        // Implementation with network call and caching\n    }\n}\n```\n\n## Follow-up Questions\n- How would you test TTL expiry and cache invalidation?\n- What strategies would you use for cache size management?\n- How would you handle data synchronization when coming back online?","diagram":"flowchart TD\n  A[App Launch] --> B{Network available?}\n  B -- Yes --> C[Fetch JSON via URLSession (async/await)]\n  C --> D[Decode with Codable]\n  D --> E[Display in List]\n  B -- No --> F[Load cache from file]\n  F --> E","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","PayPal","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T06:14:40.371Z","createdAt":"2026-01-24T21:39:07.501Z"},{"id":"q-6904","question":"In an iOS trading app, implement a price ticker module that subscribes to a live WebSocket feed for multiple assets. Requirements: per-asset state managed by actors; cap UI updates to 10 Hz; use a small in-memory cache with on-disk persistence; ensure crash-safe resume; handle network interruptions with exponential backoff; provide a test plan and discuss trade-offs?","answer":"For each asset, create a PriceActor to serialize updates. Buffer bursts and emit UI changes at 10 Hz. Maintain a lightweight in-memory cache plus on-disk persistence of the last price and timestamp using Codable.","explanation":"## Why This Is Asked\nThis question probes knowledge of Swift concurrency, actors, and robust networking for live data.\n\n## Key Concepts\n- Swift Concurrency, actors for per-item isolation\n- WebSocket resilience and backoff\n- Local persistence and crash recovery\n- UI throttling and data consistency\n\n## Code Example\n```swift\nactor PriceActor {\n    private var price: Double = 0\n    private var timestamp: Date = Date()\n    \n    func update(price: Double, timestamp: Date) {\n        self.price = price\n        self.timestamp = timestamp\n    }\n}\n```\n\n## Follow-up Questions\n- How would you test throttling behavior?\n- What strategies would you use for memory management with thousands of assets?\n- How would you handle schema evolution for persisted data?","diagram":null,"difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Meta","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T05:57:41.463Z","createdAt":"2026-01-24T22:29:11.774Z"},{"id":"q-6927","question":"Advanced iOS design: Build a real-time document scanner using the camera feed, Vision OCR, and CoreML for layout detection. Requirements: 60fps processing budget, multi-threaded pipeline, keep memory under 200MB, export to searchable PDF with embedded metadata, respect privacy (no persistent originals), include a robust test plan?","answer":"Implement a high-throughput camera pipeline: configure an AVCaptureSession with video data output, process frames through Vision OCR on dedicated queues, maintain a circular buffer to bound memory under 200MB, export searchable PDFs with embedded metadata, and ensure privacy by never persisting original frames.","explanation":"## Why This Is Asked\nAssesses on-device image processing, concurrency, and privacy-aware export in a realistic scanner app.\n\n## Key Concepts\n- AVCaptureSession and VideoDataOutput\n- Vision OCR and text observation handling\n- Multithreading queues and memory budgeting\n- PDFKit with metadata; privacy-by-default (no raw frames stored)\n- Testing: latency, memory, OCR accuracy across lighting\n\n## Code Example\n```swift\n// Minimal skeleton showing capture session and Vision request setup\nimport AVFoundation\nimport Vision\n\nclass Scanner {\n  let session = AVCaptureSession()\n  func setup() {\n    // Configure session for 60fps processing\n    session.sessionPreset = .high\n    \n    // Setup video data output with delegate\n    let output = AVCaptureVideoDataOutput()\n    output.setSampleBufferDelegate(self, queue: processingQueue)\n    session.addOutput(output)\n  }\n}\n```","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T05:51:39.852Z","createdAt":"2026-01-24T23:29:14.180Z"},{"id":"q-7069","question":"Design and implement an offline-first iOS module called RelayFeed that streams a live GraphQL feed, caches items in SQLite via GRDB, and uses Swift Concurrency (actors) to serialize access. It must support optimistic edits with per-item versioning conflict resolution and run background refresh via BGAppRefreshTask with battery-aware throttling. Include data models, persistence schema, and a concrete test plan. Provide a minimal Swift code sketch showing the Actor-based cache and a paginated GraphQL fetch. How would you approach this?","answer":"Outline an architecture with an Actor-based RelayCache, a GraphQL pagination fetch, per-item versioning conflict resolution, and background refresh via BGAppRefreshTask. Describe data models, SQLite p","explanation":"## Why This Is Asked\n\nThis question probes the ability to design an offline-first iOS module with strong concurrency guarantees, persistent storage, and background behavior. It touches data modeling, conflict resolution, and testability in a realistic, production-like setting.\n\n## Key Concepts\n\n- iOS offline persistence with SQLite (GRDB)\n- GraphQL pagination and live streaming\n- Swift Concurrency: actors for serialized access\n- Conflict resolution via per-item versioning and optimistic updates\n- Background tasks: BGAppRefreshTask, battery-aware throttling\n\n## Code Example\n\n```swift\n// Minimal actor-based cache for RelayFeed items\nactor RelayCache {\n  private var items: [String: FeedItem] = [:]\n  func upsert(_ item: FeedItem) { items[item.id] = item }\n  func all() -> [FeedItem] { Array(items.values) }\n}\n```\n\n```swift\n// Sketch: paginated GraphQL fetch (pseudo)\nfunc fetchPage(cursor: String?) async throws -> (items: [FeedItem], nextCursor: String?) {\n  // construct GraphQL request with cursor, parse response, return page\n}\n```\n\n## Follow-up Questions\n\n- How would you test race conditions between network fetch and local updates?\n- How would you handle schema changes and migration in SQLite with GRDB?\n- What battery/perf trade-offs exist with background refresh frequency?","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Salesforce","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T07:49:33.612Z","createdAt":"2026-01-25T07:49:33.612Z"},{"id":"q-7258","question":"Design an offline-first note system for iOS: notes stored locally in Core Data with a Note entity (id UUID, title, body, tags, updatedAt), synced to CloudKit via NSPersistentCloudKitContainer. Implement a PendingChange queue for offline edits, and a per-record versioning strategy (last-writer-wins with timestamp, plus user prompt on conflicts). Outline data flow, code paths, and a concrete test plan?","answer":"Store notes in Core Data with a Note entity: id UUID, title, body, tags, updatedAt. Enable NSPersistentCloudKitContainer for CloudKit sync. Add a local PendingChange queue to handle offline writes; us","explanation":"## Why This Is Asked\nAssess real-world offline sync with Core Data + CloudKit, conflict resolution, and test coverage.\n\n## Key Concepts\n- Core Data models and CloudKit integration\n- Offline write queue and conflict resolution\n- Versioning and user-facing conflict flow\n- Test strategies for Multi-Device sync\n\n## Code Example\n```javascript\n// Swift-like pseudo-model for Note\nclass Note: NSManagedObject {\n  @NSManaged var id: UUID\n  @NSManaged var title: String?\n  @NSManaged var body: String?\n  @NSManaged var updatedAt: Date\n  @NSManaged var tags: [String]?\n}\n```\n\n## Follow-up Questions\n- How would you test conflict resolution deterministically?\n- What telemetry would you add to monitor sync health across devices?","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Meta","PayPal"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T15:37:53.564Z","createdAt":"2026-01-25T15:37:53.564Z"},{"id":"q-7290","question":"Design a beginner iOS SwiftUI app named MealPlanner that lets users add meals with a name, date, category (breakfast/lunch/dinner/snack), and an optional photo from camera or gallery. Persist locally using Codable and FileManager in the Documents directory; show a searchable, date-grouped list; ensure data persists across launches; include a minimal test plan and accessibility considerations?","answer":"Store meals as Codable struct Meal { id UUID; name String; date Date; category String; photoData Data? }. Persist as [Meal] to meals.json in Documents using JSONEncoder/Decoder. Build a MealViewModel ","explanation":"## Why This Is Asked\nExplores practical local persistence, model design, and simple UI features with photos, debounced saves, and accessibility—core beginner iOS skills.\n\n## Key Concepts\n- Codable data modeling and FileManager storage\n- SwiftUI lists, search, and sectioning\n- PhotosUI integration and optional image data\n- Basic accessibility labeling and test planning\n\n## Code Example\n```javascript\n// Implementation notes omitted for brevity\n```\n## Follow-up Questions\n- How would you handle large image data and memory pressure?\n- How would you add unit tests for file I/O and image encoding?","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Hugging Face","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T17:01:31.014Z","createdAt":"2026-01-25T17:01:31.014Z"},{"id":"q-7408","question":"Design a dynamic form engine for iOS that renders UI from a JSON schema, including field types, constraints, conditional visibility, live validation, offline save (Core Data), and batch REST submission with idempotent retries. How would you implement this?","answer":"Implement a SwiftUI-based dynamic form engine that consumes a JSON schema to render adaptive forms with real-time validation, conditional field visibility, and robust offline persistence using Core Data.","explanation":"## Why This Is Asked\n\nThis question evaluates your ability to translate a data-driven schema into a production-ready iOS application with offline resilience, dynamic UI generation, and enterprise-grade networking patterns.\n\n## Key Concepts\n\n- Dynamic SwiftUI UI generation from JSON schema definitions\n- Reactive state management with Combine for live validation\n- Offline-first architecture using Core Data with conflict resolution\n- Idempotent REST operations with exponential backoff retry logic\n- Field-level dependency management for conditional visibility\n\n## Code Example\n\n```swift\nstruct FieldDefinition: Codable {\n    let id: String\n    let type: FieldType\n    let label: String\n    let validation: ValidationRules?\n    let visibility: VisibilityRules?\n    let dependencies: [String]?\n}\n\nenum FieldType: String, Codable {\n    case text, email, number, date, picker, toggle\n}\n\nstruct ValidationRules: Codable {\n    let required: Bool?\n    let minLength: Int?\n    let maxLength: Int?\n    let pattern: String?\n    let customRules: [String]?\n}\n\nclass DynamicFormEngine: ObservableObject {\n    @Published var formState: [String: Any]\n    @Published var validationErrors: [String: String]\n    @Published var visibleFields: Set<String>\n    \n    private let schema: FormSchema\n    private let persistenceManager: CoreDataManager\n    private let networkManager: NetworkManager\n    \n    init(schema: FormSchema) {\n        self.schema = schema\n        self.formState = [:]\n        self.validationErrors = [:]\n        self.visibleFields = Set(schema.fields.map { $0.id })\n        self.persistenceManager = CoreDataManager()\n        self.networkManager = NetworkManager()\n        \n        setupFieldDependencies()\n        loadOfflineData()\n    }\n    \n    func updateValue(for fieldId: String, value: Any) {\n        formState[fieldId] = value\n        validateField(fieldId)\n        updateFieldVisibility()\n        saveOffline()\n    }\n    \n    private func validateField(_ fieldId: String) {\n        guard let field = schema.fields.first(where: { $0.id == fieldId }),\n              let validation = field.validation else {\n            validationErrors.removeValue(forKey: fieldId)\n            return\n        }\n        \n        let value = formState[fieldId]\n        var errors: [String] = []\n        \n        if validation.required == true && (value == nil || value as? String == \"\") {\n            errors.append(\"This field is required\")\n        }\n        \n        if let stringValue = value as? String {\n            if let minLength = validation.minLength, stringValue.count < minLength {\n                errors.append(\"Minimum length is \\(minLength) characters\")\n            }\n            \n            if let maxLength = validation.maxLength, stringValue.count > maxLength {\n                errors.append(\"Maximum length is \\(maxLength) characters\")\n            }\n            \n            if let pattern = validation.pattern {\n                let regex = try? NSRegularExpression(pattern: pattern)\n                let range = NSRange(location: 0, length: stringValue.utf16.count)\n                if regex?.firstMatch(in: stringValue, options: [], range: range) == nil {\n                    errors.append(\"Invalid format\")\n                }\n            }\n        }\n        \n        validationErrors[fieldId] = errors.isEmpty ? nil : errors.first\n    }\n    \n    private func updateFieldVisibility() {\n        var newVisibleFields = Set<String>()\n        \n        for field in schema.fields {\n            if let visibility = field.visibility {\n                if shouldShowField(field: field, rules: visibility) {\n                    newVisibleFields.insert(field.id)\n                }\n            } else {\n                newVisibleFields.insert(field.id)\n            }\n        }\n        \n        visibleFields = newVisibleFields\n    }\n    \n    private func shouldShowField(field: FieldDefinition, rules: VisibilityRules) -> Bool {\n        guard let conditions = rules.conditions else { return true }\n        \n        for condition in conditions {\n            let dependentValue = formState[condition.fieldId]\n            let expectedValue = condition.value\n            \n            switch condition.operator {\n            case .equals:\n                if \"\\(dependentValue ?? \"\")\" != \"\\(expectedValue)\" {\n                    return false\n                }\n            case .notEquals:\n                if \"\\(dependentValue ?? \"\")\" == \"\\(expectedValue)\" {\n                    return false\n                }\n            case .contains:\n                if let stringValue = dependentValue as? String {\n                    if !stringValue.contains(expectedValue) {\n                        return false\n                    }\n                }\n            }\n        }\n        \n        return true\n    }\n    \n    func submitForm() async throws {\n        let submissionData = FormSubmission(\n            id: UUID().uuidString,\n            timestamp: Date(),\n            formData: formState,\n            schemaVersion: schema.version\n        )\n        \n        try await networkManager.submitForm(submissionData)\n        persistenceManager.markAsSubmitted(submissionData.id)\n    }\n}\n\nclass CoreDataManager {\n    func saveOffline(_ data: FormSubmission) {\n        let context = persistentContainer.viewContext\n        let entity = FormSubmissionEntity(context: context)\n        entity.id = data.id\n        entity.timestamp = data.timestamp\n        entity.formData = try? JSONEncoder().encode(data.formData)\n        entity.isSubmitted = false\n        \n        try? context.save()\n    }\n    \n    func getPendingSubmissions() -> [FormSubmission] {\n        let context = persistentContainer.viewContext\n        let request: NSFetchRequest<FormSubmissionEntity> = FormSubmissionEntity.fetchRequest()\n        request.predicate = NSPredicate(format: \"isSubmitted == false\")\n        \n        return (try? context.fetch(request))?.compactMap { entity in\n            guard let data = entity.formData,\n                  let formData = try? JSONDecoder().decode([String: Any].self, from: data) else {\n                return nil\n            }\n            \n            return FormSubmission(\n                id: entity.id ?? \"\",\n                timestamp: entity.timestamp ?? Date(),\n                formData: formData,\n                schemaVersion: \"1.0\"\n            )\n        } ?? []\n    }\n}\n\nclass NetworkManager {\n    func submitForm(_ data: FormSubmission) async throws {\n        let url = URL(string: \"https://api.example.com/forms\")!\n        var request = URLRequest(url: url)\n        request.httpMethod = \"POST\"\n        request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n        request.setValue(data.id, forHTTPHeaderField: \"X-Idempotency-Key\")\n        \n        let jsonData = try JSONEncoder().encode(data)\n        request.httpBody = jsonData\n        \n        try await executeWithRetry(request: request)\n    }\n    \n    private func executeWithRetry(request: URLRequest, maxRetries: Int = 3) async throws {\n        var delay: TimeInterval = 1.0\n        \n        for attempt in 0...maxRetries {\n            do {\n                let (_, response) = try await URLSession.shared.data(for: request)\n                \n                if let httpResponse = response as? HTTPURLResponse {\n                    if httpResponse.statusCode == 200 || httpResponse.statusCode == 201 {\n                        return\n                    } else if httpResponse.statusCode == 409 {\n                        return\n                    } else if httpResponse.statusCode >= 500 {\n                        throw NetworkError.serverError\n                    } else {\n                        throw NetworkError.clientError(httpResponse.statusCode)\n                    }\n                }\n            } catch {\n                if attempt == maxRetries {\n                    throw error\n                }\n                \n                try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))\n                delay *= 2\n            }\n        }\n    }\n}\n```\n\n## Architecture Benefits\n\n- **Schema-driven**: UI adapts automatically to schema changes without code modifications\n- **Offline-first**: Core Data ensures data persistence and sync when connectivity restores\n- **Reactive validation**: Combine framework provides real-time feedback as users type\n- **Idempotent operations**: Retry logic prevents duplicate submissions during network issues\n- **Conditional rendering**: Complex field dependencies handled through declarative rules","diagram":"flowchart TD\n  A[JSON Schema] --> B(Renderer)\n  B --> C(Validation)\n  B --> D(Offline Save)\n  D --> E(Batch Sync)\n  E --> F(Retry with backoff)","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T06:45:28.592Z","createdAt":"2026-01-25T21:43:39.819Z"},{"id":"q-7435","question":"Design and implement an offline-first, multi-user collaborative drawing module for iPad: enable concurrent strokes from multiple devices, store strokes locally in SQLite via GRDB, and sync with CloudKit using a CRDT-like approach with per-stroke tombstones and version vectors. Use Swift Concurrency (actors) to serialize state and render with SwiftUI. Include data models, identity management, and a compact test plan?","answer":"The Stroke model includes: id (UUID), color (RGBA), points: [CGPoint], timestamp, author, and a per-stroke version vector. The CanvasActor maintains application state and serializes mutations; on each stroke change, the actor pushes to a local operation log and persists to SQLite via GRDB. The SyncActor handles CloudKit synchronization using CRDT-like merging with tombstones and version vectors for conflict resolution.","explanation":"## Why This Is Asked\nRealistic multi-device collaboration is fundamental in modern design tools; this question assesses CRDT reasoning, conflict resolution strategies, and offline-first persistence without requiring a central server infrastructure.\n\n## Key Concepts\n- CRDT-like merging algorithms for drawing data\n- Vector clocks and version vectors for distributed state\n- SQLite/GRDB for local offline storage\n- Swift Concurrency actors for state serialization\n- CloudKit integration for cloud synchronization\n\n## Code Example\n```swift\nactor Canvas {\n  private var strokes: [Stroke] = []\n  func app","diagram":"flowchart TD\n  A[User draws stroke] --> B[Encode & log stroke]\n  B --> C[Persist to SQLite (GRDB)]\n  C --> D[Add to sync queue]\n  D --> E[CloudKit patch sync]\n  E --> F[Merge with version vectors]","difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Meta","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T06:00:07.309Z","createdAt":"2026-01-25T22:49:14.885Z"},{"id":"q-7621","question":"Design a beginner iOS SwiftUI app named LearnWords that lets users add a word, its definition, an example sentence, and part of speech; optionally attach a photo. Persist locally using Codable and FileManager in Documents; provide search and filter by part of speech; implement a simple spaced-repetition reminder that nudges the user to review a word after a set interval, with a basic test plan and accessibility notes?","answer":"Implement LearnWords with a Word struct: id, word, definition, example, partOfSpeech, imageData, nextReview. Persist as a JSON array in Documents/words.json via FileManager; load on startup. UI: searc","explanation":"## Why This Is Asked\nTests ability to model simple local data with Codable, build a SwiftUI UI, and add a lightweight spaced-repetition feature. It also covers search, filtering, and accessibility without requiring network code.\n\n## Key Concepts\n- Codable persistence to a file\n- FileManager Documents directory\n- SwiftUI List with searchable and filters\n- Simple spaced repetition using dates\n- Accessibility: dynamic type, labels\n\n## Code Example\n```swift\nstruct Word: Codable, Identifiable {\n  let id: UUID\n  var word: String\n  var definition: String\n  var example: String\n  var partOfSpeech: String\n  var imageData: Data?\n  var nextReview: Date\n}\n```\n\n## Follow-up Questions\n- How would you unit test encoding/decoding of Word objects?\n- How would you optimize image data storage to avoid memory pressure?","diagram":null,"difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Databricks","LinkedIn"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T10:03:42.807Z","createdAt":"2026-01-26T10:03:42.807Z"},{"id":"q-7873","question":"Design and implement a crash-resilient PhotoUploader module in an iOS app: persist a local upload queue in GRDB, upload via URLSessionBackground with resumable transfers, compute a SHA-256 digest per photo before uploading, attach a UUID as the upload id, and recover cleanly after app termination, ensuring exactly-once delivery. Provide API surface, data models, error handling, and a concrete test plan?","answer":"Propose a PhotoUploader in Swift that uses URLSessionBackground with a persistent queue stored in GRDB. Each photo is enqueued with a UUID, computes a SHA-256 digest before upload for integrity, and u","explanation":"## Why This Is Asked\n\nTests resilience of background work across terminations, memory pressure, and network changes. Assesses persistence, idempotency, and proper use of background sessions in production iOS apps.\n\n## Key Concepts\n\n- URLSessionConfiguration.background and URLSessionUploadTask\n- Persistence with GRDB (SQLite) for a durable queue\n- Data integrity via SHA-256 digest (CryptoKit)\n- Exactly-once delivery and idempotency keys\n- Robust error handling, exponential backoff, and termination recovery\n- Testing: queue recovery, retry behavior, and race conditions\n\n## Code Example\n\n```swift\nstruct PhotoUpload: Codable {\n  let id: String\n  let fileURL: URL\n  var bytesUploaded: Int64\n  var totalBytes: Int64\n  var status: UploadStatus\n}\n```\n\n## Follow-up Questions\n\n- How would you simulate network interruptions in tests?\n- How would you extend to multi-file batch uploads with per-file priorities?\n","diagram":null,"difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T21:00:28.284Z","createdAt":"2026-01-26T21:00:28.284Z"},{"id":"q-7883","question":"Design a beginner iOS SwiftUI app named ExpenseTrack that lets users log daily expenses with fields: amount (decimal), category (Food, Transport, Housing, Utilities, Other), date, and an optional receipt image from camera or gallery. Persist locally using Codable and FileManager in the Documents directory; provide a searchable list grouped by date, a one-click CSV export, and proper currency formatting. Include a minimal test plan and accessibility considerations?","answer":"Implement ExpenseTrack with an Expense Codable model (id, amount, currency, date, category, receiptURL). Persist data as a JSON file in the Documents directory using FileManager with Codable encoding/decoding. Build a SwiftUI interface with forms for expense entry, camera/gallery integration via PhotosUI, a searchable list grouped by date, and one-click CSV export. Apply locale-aware currency formatting throughout.","explanation":"## Why This Is Asked\nThis question evaluates core iOS development skills including data modeling, local persistence, and practical UI implementation for a finance tracking application.\n\n## Key Concepts\n- Codable models for JSON serialization and persistence\n- FileManager for Documents directory storage\n- SwiftUI forms, searchable lists, and data grouping\n- CSV export functionality and locale-aware currency formatting\n- Accessibility implementation and basic testing strategies\n\n## Code Example\n```swift\nenum Category: String, Codable, CaseIterable {\n    case food, transport, housing, utilities, other\n}\n\nstruct Expense: Identifiable, Codable {\n    let id = UUID()\n    let amount: Decimal\n    let currency: String\n    let date: Date\n    let category: Category\n    let receiptURL: URL?\n}\n```","diagram":"flowchart TD\n  A[Expense] --> B[CodableJSON]\n  B --> C[Documents/FileManager]\n  C --> D[SwiftUI List grouped by date]\n  D --> E[CSV Export]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","MongoDB","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T06:42:21.858Z","createdAt":"2026-01-26T21:39:38.889Z"},{"id":"q-7970","question":"Design and implement an advanced iOS background media uploader: users select large media files (up to 2 GB) to upload to a remote endpoint. Persist per-file metadata in a JSON file, compute a checksum, use BGTaskScheduler with a URLSessionBackground configuration to support resumable uploads, implement pause/resume, exponential backoff, and a test plan?","answer":"Implement an UploadItem model with properties for id, localPath, remoteURL, totalBytes, uploadedBytes, checksum, and upload state. Persist items as JSON in Library/Application Support. Use BGTaskScheduler with URLSessionBackground configuration to manage resumable uploads, implement pause/resume functionality, and incorporate exponential backoff for retry logic. Include data integrity verification through checksum computation and maintain upload progress tracking.","explanation":"## Why This Is Asked\nTests mastery of iOS background processing, file I/O, and resilient networking under power constraints.\n\n## Key Concepts\n- BGTaskScheduler, URLSessionBackground\n- Codable persistence to Library/Application Support\n- State machine for upload lifecycle\n- Resumable transfers and backoff\n- Data integrity via checksum\n\n## Code Example\n```swift\nstruct UploadItem: Codable {\n    let id: UUID\n    let localPath: String\n    let remoteURL: URL\n    let totalBytes: Int64\n    var uploadedBytes: Int64\n    let checksum: String\n    var state: UploadState\n    \n    enum UploadState: String, C","diagram":"flowchart TD\n  A[User selects media] --> B[Create UploadItem]\n  B --> C[Persist metadata JSON]\n  C --> D[Enqueue upload]\n  D --> E[BGTaskScheduler triggers]\n  E --> F[URLSession background upload]\n  F --> G[Progress update]\n  G --> H[Checksum verify]\n  H --> I[Mark completed and cleanup]","difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T05:36:54.945Z","createdAt":"2026-01-27T02:52:37.553Z"},{"id":"q-8030","question":"In an iOS financial news app, design a client-side prefetch engine that predicts which articles the user will read next while scrolling a feed. Requirements: prefetch 3-5 items ahead, fetch via background URLSession, deduplicate concurrent fetches by articleID, cache in SQLite with per-article expiry and eviction, crash-safe resume on relaunch, and expose progress/report hooks for the UI. Include a concrete test plan?","answer":"Design a 3-5 item speculative prefetch queue backed by SQLite for durable cache and a small in-memory map for fast checks. Use URLSession background fetch to retrieve articles, deduplicate by articleI","explanation":"## Why This Is Asked\n\nTests practical offline/prefetch patterns, durable caching, and resilience to app termination.\n\n## Key Concepts\n\n- Background fetch, URLSession, deduping; SQLite caching; crash-safe state; UI observability; test strategy\n\n## Code Example\n\n```javascript\n// Placeholder: not actual iOS code in patch\n```\n\n## Follow-up Questions\n\n- How would you adapt the queue under memory pressure?\n- How would you measure effectiveness of predictions during A/B testing?","diagram":"flowchart TD\n  A[Scroll feed] --> B[Predict next articles]\n  B --> C[Start background fetches]\n  C --> D[Write to SQLite cache]\n  D --> E[UI observes progress]","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","LinkedIn","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T06:52:02.885Z","createdAt":"2026-01-27T06:52:02.885Z"},{"id":"q-8092","question":"Design and implement an offline-first iOS media sync feature: users capture photos in an album on one device and expect them to appear on all devices with conflict-aware CloudKit sync. Outline the Core Data model, CloudKit integration, conflict resolution (per-record versioning), and a robust background transfer plan (URLSession background tasks or BGTaskScheduler) that supports partial uploads and offline queuing. Include a concrete test plan?","answer":"Use Core Data to model Album and Photo with id, assetURL, timestamp, isSynced, cloudRecordID, and version. Sync via CloudKit with per-record versioning; apply last-write-wins on conflicts but preserve","explanation":"## Why This Is Asked\nTests skills in offline-first design, distributed data sync, and iOS background processing across devices using Core Data and CloudKit. It checks conflict handling, performance, and test coverage.\n\n## Key Concepts\n- Core Data relational modeling for albums and photos\n- CloudKit integration patterns and per-record versioning\n- Conflict resolution strategies with user-visible edits preserved\n- Background transfers with URLSession/BGTaskScheduler and offline queues\n- Observability and test plans for multi-device sync\n\n## Code Example\n```swift\nstruct PhotoVersioned {\n  let id: UUID\n  let version: Int\n  let timestamp: Date\n}\n```\n\n## Follow-up Questions\n- How would you handle very large assets with partial transfers?\n- How would you measure and optimize cross-device sync latency?","diagram":"flowchart TD\n  A[Device A] -->|Metadata Sync| CloudKit\n  CloudKit --> B[Device B]\n  A --> C[Asset Transfer Server]\n  C --> D[Device B]","difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Databricks","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T09:08:35.311Z","createdAt":"2026-01-27T09:08:35.311Z"},{"id":"q-8145","question":"Design an iOS feature: a client-side event tracer for SwiftUI that records per-view render timings and potential bottlenecks locally, stores them in secure SQLite with deterministic IDs, and batches uploads on background tasks when on Wi‑Fi and battery above threshold; ensure privacy by redacting PII and provide a deterministic QA replay payload. Explain architecture, data model, concurrency, and a concrete test plan?","answer":"Implement a client-side tracer for SwiftUI that records viewName, timestamp, renderMs, memory delta, and a privacyMask to a secure SQLite store (GRDB). Use Actors to serialize writes, and a background","explanation":"## Why This Is Asked\nAdvanced iOS systems require robust in‑app telemetry with privacy controls and production‑grade reliability. This question probes data modeling, concurrency, and background behavior under real constraints.\n\n## Key Concepts\n- Swift Concurrency, Actors for serialized writes\n- SQLite-based event store with deterministic IDs\n- Background uploads with BGTaskScheduler and batching\n- Privacy: redaction rules and deterministic replay payloads\n\n## Code Example\n```javascript\n// Implementation sketch: data model and writer outline\nstruct TracerEvent {\n  let id: String\n  let viewName: String\n  let timestamp: TimeInterval\n  let renderMs: Double\n  let memoryDelta: Int64\n  let privacyMask: String\n}\n```\n\n## Follow-up Questions\n- How would you test battery/network constraints in CI?\n- How would you handle data schema migrations without breaking native clients?","diagram":"flowchart TD\n  A[ViewRender] --> B[RecordEvent]\n  B --> C[SQLiteStore]\n  C --> D[QueueForUpload]\n  D --> E[BGTaskSchedulerUpload]\n  E --> F[Server]\n","difficulty":"advanced","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T11:31:59.018Z","createdAt":"2026-01-27T11:31:59.018Z"},{"id":"q-8171","question":"In an iOS app that streams live market data, implement a client-side data retention policy: store minute-level price history per symbol for 60 days in SQLite, archive tick events in a separate table, ensure crash-safe resume, background pruning via BGAppRefreshTask, and a user-initiated export option. Outline data models, pruning algorithm, and provide a minimal Swift sketch using GRDB and Swift Concurrency?","answer":"Design a prune module that keeps 60 days of minute-price history per symbol in SQLite, archives tick events in a separate table, and offers user-export. Ensure crash-safe resume by writing durable mar","explanation":"## Why This Is Asked\nTests practical data retention, crash safety, and background work in a real-world iOS data app.\n\n## Key Concepts\n- SQLite/GRDB data modeling for time-series data\n- Per-symbol retention with separate archives\n- Crash-safe resume and idempotent pruning\n- Background tasks (BGAppRefreshTask) and battery awareness\n- User-initiated export of pruned data\n\n## Code Example\n```swift\n// Minimal sketch\nactor PricePruner {\n  func prunePrices(for symbol: String, limitDays: Int) async {\n    // read history, delete old rows, write export blob if requested\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test pruning under simulated network outages?\n- What schema migrations are needed for changing retention policy?","diagram":"flowchart TD\n  A[Symbol] --> B[PriceHistory (minute data)]\n  A --> C[TickEvents (raw ticks)]\n  B --> D[Prune Task]\n  D --> E[Export Module]","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Discord","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T13:14:57.682Z","createdAt":"2026-01-27T13:14:57.682Z"},{"id":"q-8370","question":"Scenario: An iOS field-inspection app must work offline and sync securely. Design a **LocationAudit** module that records geo-tagged notes and photos offline, persists versioned records locally, and delta-syncs with a REST backend when online. Include data models, conflict-resolution strategy, and a minimal Swift sketch using SQLite and URLSessionBackgroundTask. How would you architect and test this?","answer":"Proposed solution: local SQLite with AuditRecord (id UUID, version Int, timestamp Date, geo String, note String, photoPath String, uploaded Bool) and PhotoAsset (path String, checksum String) tables. DeltaSet of changed records generated locally using version comparison, then batch-synced via URLSessionBackgroundTask when connectivity returns. Conflict resolution follows last-writer-wins with version bump and audit trail preservation.","explanation":"## Why This Is Asked\nTests offline-first data integrity, delta-based synchronization, and robust conflict handling in a field-inspection scenario where network reliability is uncertain.\n\n## Key Concepts\n- Offline persistence with per-record versioning\n- Delta payload generation to minimize network usage\n- Background transfers and media handling\n- Conflict resolution strategy with audit trails\n\n## Code Example\n```swift\n// Minimal sketch: data models and delta generator\nstruct AuditRecord {\n    let id: UUID\n    var version: Int\n    let timestamp: Date\n    let geo: String\n    let note: String\n    let photoPath: String\n    var uploaded: Bool\n}\n```\n\n## Follow-up Questions\n- How would you handle photo compression and storage quotas?\n- What encryption measures would you implement for sensitive data?","diagram":"flowchart TD\n  A[Start] --> B[Local SQLite store]\n  B --> C{Online?}\n  C -- No --> D[Queue deltas]\n  C -- Yes --> E[Background upload delta]\n  E --> F[Server applies delta]\n  F --> G[Conflict resolution]\n  G --> H[Audit trail]\n  H --> I[Done]","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Square","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-28T05:26:20.302Z","createdAt":"2026-01-27T21:46:52.919Z"},{"id":"q-8391","question":"Design an offline-capable live comment feed for a streaming app: implement a WebSocket-based live feed that delivers comments in-order, caches them locally in SQLite (GRDB) with a per-comment sequence ID, and persists on app restart. Support offline mode by serving cached comments, handle reconnection to fetch missed messages, deduplicate, and ensure atomic writes. Outline data models, persistence schema, and a practical test plan?","answer":"Use URLSessionWebSocketTask for a live comment feed; persist with SQLite via GRDB using a Comment table(id TEXT PRIMARY KEY, seq INTEGER NOT NULL, author TEXT, content TEXT, created_at DATETIME). Perform inserts within a single transaction for atomic writes. During offline mode, serve cached comments sorted by sequence ID. On reconnection, request missed messages since the last received sequence ID, deduplicate by ID, and merge new comments with existing data. Implement proper WebSocket lifecycle management with exponential backoff for reconnection attempts.","explanation":"## Why This Is Asked\nAssesses ability to design a robust real-time feature with offline resilience, data integrity, and testability in iOS, leveraging URLSessionWebSocketTask, GRDB, and atomic writes. Includes reconnect, deduplication, and replay logic.\n\n## Key Concepts\n- WebSocket lifecycle and backpressure management\n- SQLite/GRDB transactions and schema design\n- In-order delivery via sequence IDs\n- Crash-safe resume and offline fallback\n- Testing strategies for network faults and edge cases\n\n## Code Example\n```swift\n// Sketch: minimal types and persistence\nstruct Comment: Codable { \n    let id: String \n    let seq: Int \n    let author: String\n    let content: String\n    let createdAt: Date\n}\n\n// GRDB persistence\nclass CommentStore {\n    func insert(_ comments: [Comment]) throws {\n        try dbQueue.write { db in\n            for comment in comments {\n                try comment.insert(db)\n            }\n        }\n    }\n}\n```","diagram":null,"difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","LinkedIn","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-28T05:04:05.501Z","createdAt":"2026-01-27T22:48:40.361Z"},{"id":"q-181","question":"Explain the difference between weak and unowned references in Swift and provide practical use cases for each?","answer":"Weak references are optional and automatically become nil when the referenced object is deallocated, while unowned references are non-optional and assume the object will always exist during the reference's lifetime, causing a crash if accessed after deallocation.","explanation":"## Why Asked\nTests memory management understanding and preventing retain cycles in iOS development\n\n## Key Concepts\n- Automatic Reference Counting (ARC)\n- Strong reference cycles\n- Optional vs non-optional references\n- Lifetime expectations\n\n## Code Example\n```\nclass Parent {\n    weak var child: Child?\n    unowned let partner: Parent\n}\n\n// weak: when object might become nil (e.g., delegates)\n// unowned: when object outlives reference (e.g., parent-child)\n```\n\n## Follow-up Questions\n- How do you identify retain cycles?\n- What happens when you access an unowned reference after deallocation?\n- When would you choose weak vs unowned in a real application?","diagram":"flowchart TD\n  A[Object Created] --> B{Reference Type?}\n  B -->|May become nil| C[weak var]\n  B -->|Always exists| D[unowned]\n  C --> E[Becomes nil on deallocation]\n  D --> F[Crashes if accessed after deallocation]","difficulty":"intermediate","tags":["swift","language"],"channel":"ios","subChannel":"swift","sourceUrl":null,"videos":{"shortVideo":"https://www.youtube.com/watch?v=bMNwHNOVdXw","longVideo":"https://www.youtube.com/watch?v=8KQcTDGqQEc"},"companies":["Amazon","Apple","Google","Meta","Microsoft"],"eli5":"Imagine you're playing with building blocks! A 'weak' reference is like saying 'I'm looking at my friend's red block.' If your friend takes their block away, you just shrug and say 'Oh well, no red block anymore!' You don't cry or break anything. An 'unowned' reference is like saying 'I'm holding my friend's blue block and I KNOW it's there!' If your friend secretly takes the block away and you try to grab it, you'll trip and fall because you expected it to be there! Use weak references when you're just watching something that might disappear (like watching a toy car that might drive away). Use unowned references when you're absolutely sure something will stay there (like holding onto your mom's hand while crossing the street).","relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-01T06:41:21.669Z","createdAt":"2025-12-26 12:51:06"},{"id":"q-257","question":"What is optional chaining in Swift and how does it compare to force unwrapping, optional binding, and optional chaining with method calls when accessing nested optional properties?","answer":"Optional chaining (?.) safely unwraps optionals, returning nil if any link fails instead of throwing runtime errors. Unlike force unwrapping (!), it prevents crashes. It's more concise than if-let/guard-let for single access and works with methods, subscripts, and nested optionals like person?.address?.street?.count.","explanation":"## Core Concept\nOptional chaining (?.) provides a safe way to access properties, methods, and subscripts of optional values, returning nil if any part of the chain is nil.\n\n## Key Differences\n- **Force unwrapping (!)**: Crashes if nil\n- **Optional binding**: Requires separate if-let/guard-let blocks\n- **Optional chaining**: Single-line safe access\n\n## Code Examples\n```swift\n// Nested optionals\nlet streetCount = person?.address?.street?.count\n\n// Method calls with optional chaining\nlet result = optionalObject?.method()?.property\n\n// Subscript access\nlet value = dictionary?[key]?.nestedValue\n```\n\n## Performance & Best Practices\n- Slight overhead vs force unwrapping due to nil checks\n- Use when you need single access to deeply nested optionals\n- Prefer optional binding for multiple operations on the same value\n- Avoid excessive chaining that reduces code readability\n\n## Common Pitfalls\n- Forgetting that the result is always optional\n- Mixing with force unwrapping in the same chain\n- Not handling the nil case appropriately","diagram":"graph TD\n    A[person] --> B[residence?]\n    B --> C[address?]\n    C --> D[street: String]\n    \n    E[Optional Chaining ?. ] --> F{Check residence}\n    F -->|nil| G[Return nil]\n    F -->|exists| H{Check address}\n    H -->|nil| G\n    H -->|exists| I[Return street value]\n    \n    style G fill:#ffcccc\n    style I fill:#ccffcc","difficulty":"beginner","tags":["optionals","protocols","generics"],"channel":"ios","subChannel":"swift","sourceUrl":null,"videos":{"shortVideo":"https://www.youtube.com/watch?v=Hfpx494ess8","longVideo":"https://www.youtube.com/watch?v=S8-QO2wUbRg"},"companies":["Amazon","Apple","Google","Meta","Microsoft","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-26T16:39:04.627Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-204","question":"How would you optimize a UITableView with 10,000+ complex cells using Auto Layout while maintaining 60fps scrolling and memory efficiency?","answer":"Use cell reuse, pre-calculate heights, implement heightForRowAt caching, and optimize Auto Layout constraints with manual layout when needed.","explanation":"## Concept Overview\nOptimizing large UITableViews requires balancing memory usage, rendering performance, and smooth scrolling. Auto Layout adds computational overhead that becomes critical at scale.\n\n## Implementation Details\n\n### Cell Reuse Strategy\n```swift\noverride func prepareForReuse() {\n    super.prepareForReuse()\n    // Reset expensive operations\n    imageView.image = nil\n    complexView.resetContent()\n}\n```\n\n### Height Caching System\n```swift\nprivate var heightCache: [IndexPath: CGFloat] = [:]\n\nfunc tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n    if let cached = heightCache[indexPath] {\n        return cached\n    }\n    let height = calculateHeight(for: indexPath)\n    heightCache[indexPath] = height\n    return height\n}\n```\n\n### Auto Layout Optimization\n- Use `setNeedsLayout()` instead of `layoutIfNeeded()`\n- Prefer `intrinsicContentSize` over complex constraints\n- Implement `systemLayoutSizeFitting` for height calculation\n\n### Memory Management\n- Use weak references for cell closures\n- Implement `didEndDisplaying` for cleanup\n- Consider async image loading with placeholder\n\n## Common Pitfalls\n- Not caching heights leads to expensive recalculations\n- Complex Auto Layout in cell configuration blocks\n- Memory leaks from strong reference cycles\n- Ignoring cell reuse lifecycle","diagram":"flowchart LR\n    A[User Scrolls] --> B[dequeueReusableCell]\n    B --> C{Height Cached?}\n    C -->|Yes| D[Use Cached Height]\n    C -->|No| E[Calculate Height]\n    E --> F[Cache Height]\n    F --> G[Configure Cell]\n    G --> H[Apply Constraints]\n    H --> I[Render Cell]\n    I --> J[Display]\n    D --> G","difficulty":"advanced","tags":["autolayout","tableview","collectionview"],"channel":"ios","subChannel":"uikit","sourceUrl":null,"videos":null,"companies":["Airbnb","Apple","Capital One","Lyft","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-26T12:38:17.524Z","createdAt":"2025-12-26 12:51:07"},{"id":"q-232","question":"How does Auto Layout constraint resolution work when creating a UITableView with dynamic cell heights?","answer":"Auto Layout resolves constraints by calculating required cell heights based on content, then UITableView applies these heights during layout.","explanation":"## Concept Overview\nAuto Layout constraint resolution is the process where iOS calculates the size and position of views based on their constraints. For UITableView with dynamic cells, this happens in two phases.\n\n## Implementation Details\n1. **System Layout Size Fitting**: UITableView calls `systemLayoutSizeFitting` on each cell prototype\n2. **Constraint Resolution**: Auto Layout engine resolves all constraints to determine cell height\n3. **Height Caching**: UITableView caches calculated heights for performance\n4. **Layout Application**: Heights are applied during the table view's layout pass\n\n## Code Example\n```swift\n// In UITableViewCell subclass\noverride func awakeFromNib() {\n    super.awakeFromNib()\n    // Enable auto-sizing\n    contentView.translatesAutoresizingMaskIntoConstraints = false\n}\n\n// In UITableViewController\ntableView.rowHeight = UITableView.automaticDimension\ntableView.estimatedRowHeight = 100\n```\n\n## Common Pitfalls\n- Missing `translatesAutoresizingMaskIntoConstraints = false`\n- Incomplete constraint chains leading to ambiguous layouts\n- Performance issues with complex constraint hierarchies\n- Not setting `estimatedRowHeight` causing layout delays","diagram":"graph TD\n    A[UITableView] --> B[Cell Prototype]\n    B --> C[Auto Layout Engine]\n    C --> D[Constraint Resolution]\n    D --> E[Height Calculation]\n    E --> F[Height Caching]\n    F --> G[Layout Application]\n    G --> H[Final Cell Display]","difficulty":"beginner","tags":["autolayout","tableview","collectionview"],"channel":"ios","subChannel":"uikit","sourceUrl":null,"videos":null,"companies":["Airbnb","Apple","Google","Meta","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2025-12-27T04:55:46.823Z","createdAt":"2025-12-26 12:51:07"}],"subChannels":["general","swift","uikit"],"companies":["Adobe","Airbnb","Amazon","Anthropic","Apple","Bloomberg","Capital One","Citadel","Cloudflare","Coinbase","Databricks","Discord","DoorDash","Goldman Sachs","Google","Hashicorp","Hugging Face","IBM","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Netflix","OpenAI","Oracle","PayPal","Robinhood","Salesforce","Scale Ai","Slack","Snap","Snowflake","Square","Stripe","Tesla","Twitter","Two Sigma","Uber","Zoom"],"stats":{"total":87,"beginner":32,"intermediate":26,"advanced":29,"newThisWeek":40}}