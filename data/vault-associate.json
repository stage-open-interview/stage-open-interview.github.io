{"questions":[{"id":"vault-associate-secrets-engines-1768155993079-0","question":"With KV version 2 mounted at path 'secret/', which path reads the latest data for 'myapp/config'?","answer":"[{\"id\":\"a\",\"text\":\"secret/data/myapp/config\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"secret/config/myapp/config\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"secret/metadata/myapp/config\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"secret/data/myapp/config?version=1\",\"isCorrect\":false}]","explanation":"## Correct Answer\n\nThe correct answer is **A**. Reading `secret/data/myapp/config` is the KV v2 data path that returns the latest data stored at that path. The other paths map to different Vault concepts or versions: `secret/config/myapp/config` is a KV v1 path (or a mis-specified v2 path), `secret/metadata/myapp/config` exposes only version metadata, and `secret/data/myapp/config?version=1` uses a version parameter that Vault does not accept for selecting the latest data.\n\n## Why Other Options Are Wrong\n\n- Option B: Uses a KV v1 style path and would not return the latest version data in KV v2.\n- Option C: Returns only metadata about versions, not the actual data.\n- Option D: Attempts to pin to a specific version via query parameter, which is not how to fetch the latest.\n\n## Key Concepts\n\n- KV Secrets Engine version 2 endpoint structure\n- Data vs metadata separation in KV v2\n- Versioning behavior and read paths\n\n## Real-World Application\n\nUsed when an application needs the current configuration while preserving historical versions for rollback auditing.","diagram":null,"difficulty":"intermediate","tags":["HashiCorp Vault","KV-v2","AWS","Kubernetes","Terraform","certification-mcq","domain-weight-20"],"channel":"vault-associate","subChannel":"secrets-engines","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T18:26:33.080Z","createdAt":"2026-01-11 18:26:33"},{"id":"vault-associate-secrets-engines-1768155993079-1","question":"To enable automation that authenticates via AppRole without rotating a SecretID on every login, which AppRole configuration is appropriate?","answer":"[{\"id\":\"a\",\"text\":\"Set secret_id_num_uses to 0 on the AppRole\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"Generate a single SecretID and reuse it for all clients\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"Disable AppRole and use token authentication instead\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Set token_ttl to a fixed 1 year\",\"isCorrect\":false}]","explanation":"## Correct Answer\n\nThe correct answer is **A**. Setting `secret_id_num_uses` to 0 on the AppRole allows a SecretID to be used indefinitely, enabling automation without rotating the SecretID on every login. The other options either reintroduce rotation necessity (B), remove AppRole for a different flow (C), or modify token TTL which does not address SecretID rotation behavior (D).\n\n## Why Other Options Are Wrong\n\n- Option B: Reusing a single SecretID increases risk and defeats per-login uniqueness.\n- Option C: Removes AppRole entirely, switching to a less suitable auth method for automation.\n- Option D: Token TTL does not control SecretID rotation for AppRole.\n\n## Key Concepts\n\n- AppRole authentication model\n- SecretID usage and rotation controls\n- secret_id_num_uses configuration\n\n## Real-World Application\n\nUsed in automated deployments where workloads authenticate via AppRole without human interaction to manage SecretIDs.","diagram":null,"difficulty":"intermediate","tags":["HashiCorp Vault","AppRole","AWS","Kubernetes","Terraform","certification-mcq","domain-weight-20"],"channel":"vault-associate","subChannel":"secrets-engines","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T18:26:33.510Z","createdAt":"2026-01-11 18:26:33"},{"id":"vault-associate-secrets-engines-1768155993079-2","question":"For an application requiring ephemeral, time-bound database credentials, which Vault configuration ensures automatic rotation when the lease TTL expires?","answer":"[{\"id\":\"a\",\"text\":\"Enable the database secrets engine and configure a role with ttl and max_ttl\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"Use the transit secrets engine to rotate credentials\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"Use the KV engine to store static credentials with a long TTL\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Use a cloud secret manager with manual rotation only\",\"isCorrect\":false}]","explanation":"## Correct Answer\n\nThe correct answer is **A**. The database secrets engine dynamically generates credentials and its roles specify `ttl` (time-to-live) and `max_ttl` to control credential lifetime and automatic rotation. The other options do not provide automatic credential rotation for databases: Transit encrypts data, KV stores static data, and manual rotation in a cloud secret manager requires explicit action.\n\n## Why Other Options Are Wrong\n\n- Option B: Transit is for encryption/decryption, not credential provisioning.\n- Option C: KV with static credentials does not rotate credentials automatically.\n- Option D: Manual rotation defeats the purpose of automatic ephemeral credentials.\n\n## Key Concepts\n\n- Database secrets engine for dynamic credentials\n- Role TTL configuration (`ttl`, `max_ttl`)\n- Automatic rotation based on lease TTL\n\n## Real-World Application\n\nUsed to reduce blast radius by issuing short-lived credentials that Vault revokes automatically when TTL expires.","diagram":null,"difficulty":"intermediate","tags":["HashiCorp Vault","DatabaseSecrets","AWS","Kubernetes","Terraform","certification-mcq","domain-weight-20"],"channel":"vault-associate","subChannel":"secrets-engines","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T18:26:33.868Z","createdAt":"2026-01-11 18:26:33"},{"id":"vault-associate-vault-architecture-1768195718187-0","question":"When configuring Vault with auto-unseal using AWS KMS, which statement is true?","answer":"[{\"id\":\"a\",\"text\":\"Vault stores unseal keys in the storage backend and bypasses KMS.\",\"isCorrect\":false},{\"id\":\"b\",\"text\":\"Auto-unseal uses AWS KMS to unwrap the master key, and initialization is still required.\",\"isCorrect\":true},{\"id\":\"c\",\"text\":\"Auto-unseal prevents root token creation.\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Auto-unseal requires a Raft-enabled storage backend.\",\"isCorrect\":false}]","explanation":"## Correct Answer\nb) Auto-unseal uses AWS KMS to unwrap the master key, and initialization is still required.\n\n## Why Other Options Are Wrong\n- A: When auto-unseal is configured, unseal keys are not stored in the storage backend; the KMS key unwraps the master key at startup.\n- C: Root tokens are independent of the unseal mechanism and are not inherently prevented by auto-unseal.\n- D: Auto-unseal is orthogonal to the storage backend; Raft is not a prerequisite for auto-unseal.\n\n## Key Concepts\n- Auto-unseal with external KMS\n- Master key unwrapping process\n- Initialization still required with auto-unseal\n\n## Real-World Application\n- Auto-unseal reduces operational overhead and enables faster restarts, provided the KMS key is accessible and IAM policies permit unseal operations.","diagram":null,"difficulty":"intermediate","tags":["Vault","AWS-KMS","Auto-Unseal","certification-mcq","domain-weight-15"],"channel":"vault-associate","subChannel":"vault-architecture","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T05:28:38.190Z","createdAt":"2026-01-12 05:28:38"},{"id":"vault-associate-vault-architecture-1768195718187-1","question":"Which statement about Vault Integrated Storage (Raft) in a multi-node cluster is true?","answer":"[{\"id\":\"a\",\"text\":\"It requires an external consensus service like Consul.\",\"isCorrect\":false},{\"id\":\"b\",\"text\":\"It stores all data in memory and is not persisted to disk.\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"It provides strong consistency with a single leader and replicates entries across peers.\",\"isCorrect\":true},{\"id\":\"d\",\"text\":\"It does not support disaster recovery across regions.\",\"isCorrect\":false}]","explanation":"## Correct Answer\nc) It provides strong consistency with a single leader and replicates entries across peers.\n\n## Why Other Options Are Wrong\n- A: Integrated Raft storage does not require an external consensus service; it uses Raft for in-cluster consensus.\n- B: Data is persisted to disk as part of the Raft log; it is not purely in memory.\n- D: Vault Raft supports disaster recovery patterns through replication and backup strategies; the statement is false.\n\n## Key Concepts\n- Raft-based integrated storage\n- Leader election and log replication\n- Persistence and consistency guarantees\n\n## Real-World Application\n- For small-to-mid deployments, Raft simplifies operations by removing external storage dependencies while maintaining strong consistency across nodes.","diagram":null,"difficulty":"intermediate","tags":["Vault","Raft-Storage","Kubernetes","certification-mcq","domain-weight-15"],"channel":"vault-associate","subChannel":"vault-architecture","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T05:28:38.553Z","createdAt":"2026-01-12 05:28:38"},{"id":"vault-associate-vault-architecture-1768195718187-2","question":"If Vault's Transit secrets engine is used to encrypt application data and you rotate the encryption key, which statement is true?","answer":"[{\"id\":\"a\",\"text\":\"All previously encrypted data is automatically re-encrypted with the new key.\",\"isCorrect\":false},{\"id\":\"b\",\"text\":\"Previously encrypted data remains decryptable with the old key, rotation affects only new data.\",\"isCorrect\":true},{\"id\":\"c\",\"text\":\"Rotation invalidates old ciphertext and requires manual re-encryption.\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Key rotation is not supported by Transit; you must rekey data manually.\",\"isCorrect\":false}]","explanation":"## Correct Answer\nb) Previously encrypted data remains decryptable with the old key, rotation affects only new data.\n\n## Why Other Options Are Wrong\n- A: Transit uses key versions; rotation does not automatically re-encrypt existing ciphertext.\n- C: Old ciphertext remains decryptable as long as the previous key versions exist; rotation does not force re-encryption.\n- D: Transit supports key rotation by creating a new key version; manual re-encryption is not required for existing data.\n\n## Key Concepts\n- Transit key rotation and versioning\n- Ciphertext carries a key version identifier\n- Impact on existing data\n\n## Real-World Application\n- When rotating Transit keys, plan for key version compatibility and ensure clients fetch or cache the relevant key versions to avoid decryption failures.","diagram":null,"difficulty":"intermediate","tags":["Vault","Transit","Kubernetes","certification-mcq","domain-weight-15"],"channel":"vault-associate","subChannel":"vault-architecture","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T05:28:38.900Z","createdAt":"2026-01-12 05:28:38"}],"subChannels":["secrets-engines","vault-architecture"],"companies":[],"stats":{"total":6,"beginner":0,"intermediate":6,"advanced":0,"newThisWeek":6}}