{"questions":[{"id":"vault-associate-secrets-engines-1768155993079-0","question":"With KV version 2 mounted at path 'secret/', which path reads the latest data for 'myapp/config'?","answer":"[{\"id\":\"a\",\"text\":\"secret/data/myapp/config\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"secret/config/myapp/config\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"secret/metadata/myapp/config\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"secret/data/myapp/config?version=1\",\"isCorrect\":false}]","explanation":"## Correct Answer\n\nThe correct answer is **A**. Reading `secret/data/myapp/config` is the KV v2 data path that returns the latest data stored at that path. The other paths map to different Vault concepts or versions: `secret/config/myapp/config` is a KV v1 path (or a mis-specified v2 path), `secret/metadata/myapp/config` exposes only version metadata, and `secret/data/myapp/config?version=1` uses a version parameter that Vault does not accept for selecting the latest data.\n\n## Why Other Options Are Wrong\n\n- Option B: Uses a KV v1 style path and would not return the latest version data in KV v2.\n- Option C: Returns only metadata about versions, not the actual data.\n- Option D: Attempts to pin to a specific version via query parameter, which is not how to fetch the latest.\n\n## Key Concepts\n\n- KV Secrets Engine version 2 endpoint structure\n- Data vs metadata separation in KV v2\n- Versioning behavior and read paths\n\n## Real-World Application\n\nUsed when an application needs the current configuration while preserving historical versions for rollback auditing.","diagram":null,"difficulty":"intermediate","tags":["HashiCorp Vault","KV-v2","AWS","Kubernetes","Terraform","certification-mcq","domain-weight-20"],"channel":"vault-associate","subChannel":"secrets-engines","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T18:26:33.080Z","createdAt":"2026-01-11 18:26:33"},{"id":"vault-associate-secrets-engines-1768155993079-1","question":"To enable automation that authenticates via AppRole without rotating a SecretID on every login, which AppRole configuration is appropriate?","answer":"[{\"id\":\"a\",\"text\":\"Set secret_id_num_uses to 0 on the AppRole\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"Generate a single SecretID and reuse it for all clients\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"Disable AppRole and use token authentication instead\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Set token_ttl to a fixed 1 year\",\"isCorrect\":false}]","explanation":"## Correct Answer\n\nThe correct answer is **A**. Setting `secret_id_num_uses` to 0 on the AppRole allows a SecretID to be used indefinitely, enabling automation without rotating the SecretID on every login. The other options either reintroduce rotation necessity (B), remove AppRole for a different flow (C), or modify token TTL which does not address SecretID rotation behavior (D).\n\n## Why Other Options Are Wrong\n\n- Option B: Reusing a single SecretID increases risk and defeats per-login uniqueness.\n- Option C: Removes AppRole entirely, switching to a less suitable auth method for automation.\n- Option D: Token TTL does not control SecretID rotation for AppRole.\n\n## Key Concepts\n\n- AppRole authentication model\n- SecretID usage and rotation controls\n- secret_id_num_uses configuration\n\n## Real-World Application\n\nUsed in automated deployments where workloads authenticate via AppRole without human interaction to manage SecretIDs.","diagram":null,"difficulty":"intermediate","tags":["HashiCorp Vault","AppRole","AWS","Kubernetes","Terraform","certification-mcq","domain-weight-20"],"channel":"vault-associate","subChannel":"secrets-engines","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T18:26:33.510Z","createdAt":"2026-01-11 18:26:33"},{"id":"vault-associate-secrets-engines-1768155993079-2","question":"For an application requiring ephemeral, time-bound database credentials, which Vault configuration ensures automatic rotation when the lease TTL expires?","answer":"[{\"id\":\"a\",\"text\":\"Enable the database secrets engine and configure a role with ttl and max_ttl\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"Use the transit secrets engine to rotate credentials\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"Use the KV engine to store static credentials with a long TTL\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Use a cloud secret manager with manual rotation only\",\"isCorrect\":false}]","explanation":"## Correct Answer\n\nThe correct answer is **A**. The database secrets engine dynamically generates credentials and its roles specify `ttl` (time-to-live) and `max_ttl` to control credential lifetime and automatic rotation. The other options do not provide automatic credential rotation for databases: Transit encrypts data, KV stores static data, and manual rotation in a cloud secret manager requires explicit action.\n\n## Why Other Options Are Wrong\n\n- Option B: Transit is for encryption/decryption, not credential provisioning.\n- Option C: KV with static credentials does not rotate credentials automatically.\n- Option D: Manual rotation defeats the purpose of automatic ephemeral credentials.\n\n## Key Concepts\n\n- Database secrets engine for dynamic credentials\n- Role TTL configuration (`ttl`, `max_ttl`)\n- Automatic rotation based on lease TTL\n\n## Real-World Application\n\nUsed to reduce blast radius by issuing short-lived credentials that Vault revokes automatically when TTL expires.","diagram":null,"difficulty":"intermediate","tags":["HashiCorp Vault","DatabaseSecrets","AWS","Kubernetes","Terraform","certification-mcq","domain-weight-20"],"channel":"vault-associate","subChannel":"secrets-engines","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T18:26:33.868Z","createdAt":"2026-01-11 18:26:33"},{"id":"vault-associate-vault-architecture-1768195718187-0","question":"When configuring Vault with auto-unseal using AWS KMS, which statement is true?","answer":"[{\"id\":\"a\",\"text\":\"Vault stores unseal keys in the storage backend and bypasses KMS.\",\"isCorrect\":false},{\"id\":\"b\",\"text\":\"Auto-unseal uses AWS KMS to unwrap the master key, and initialization is still required.\",\"isCorrect\":true},{\"id\":\"c\",\"text\":\"Auto-unseal prevents root token creation.\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Auto-unseal requires a Raft-enabled storage backend.\",\"isCorrect\":false}]","explanation":"## Correct Answer\nb) Auto-unseal uses AWS KMS to unwrap the master key, and initialization is still required.\n\n## Why Other Options Are Wrong\n- A: When auto-unseal is configured, unseal keys are not stored in the storage backend; the KMS key unwraps the master key at startup.\n- C: Root tokens are independent of the unseal mechanism and are not inherently prevented by auto-unseal.\n- D: Auto-unseal is orthogonal to the storage backend; Raft is not a prerequisite for auto-unseal.\n\n## Key Concepts\n- Auto-unseal with external KMS\n- Master key unwrapping process\n- Initialization still required with auto-unseal\n\n## Real-World Application\n- Auto-unseal reduces operational overhead and enables faster restarts, provided the KMS key is accessible and IAM policies permit unseal operations.","diagram":null,"difficulty":"intermediate","tags":["Vault","AWS-KMS","Auto-Unseal","certification-mcq","domain-weight-15"],"channel":"vault-associate","subChannel":"vault-architecture","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T05:28:38.190Z","createdAt":"2026-01-12 05:28:38"},{"id":"vault-associate-vault-architecture-1768195718187-1","question":"Which statement about Vault Integrated Storage (Raft) in a multi-node cluster is true?","answer":"[{\"id\":\"a\",\"text\":\"It requires an external consensus service like Consul.\",\"isCorrect\":false},{\"id\":\"b\",\"text\":\"It stores all data in memory and is not persisted to disk.\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"It provides strong consistency with a single leader and replicates entries across peers.\",\"isCorrect\":true},{\"id\":\"d\",\"text\":\"It does not support disaster recovery across regions.\",\"isCorrect\":false}]","explanation":"## Correct Answer\nc) It provides strong consistency with a single leader and replicates entries across peers.\n\n## Why Other Options Are Wrong\n- A: Integrated Raft storage does not require an external consensus service; it uses Raft for in-cluster consensus.\n- B: Data is persisted to disk as part of the Raft log; it is not purely in memory.\n- D: Vault Raft supports disaster recovery patterns through replication and backup strategies; the statement is false.\n\n## Key Concepts\n- Raft-based integrated storage\n- Leader election and log replication\n- Persistence and consistency guarantees\n\n## Real-World Application\n- For small-to-mid deployments, Raft simplifies operations by removing external storage dependencies while maintaining strong consistency across nodes.","diagram":null,"difficulty":"intermediate","tags":["Vault","Raft-Storage","Kubernetes","certification-mcq","domain-weight-15"],"channel":"vault-associate","subChannel":"vault-architecture","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T05:28:38.553Z","createdAt":"2026-01-12 05:28:38"},{"id":"vault-associate-vault-architecture-1768195718187-2","question":"If Vault's Transit secrets engine is used to encrypt application data and you rotate the encryption key, which statement is true?","answer":"[{\"id\":\"a\",\"text\":\"All previously encrypted data is automatically re-encrypted with the new key.\",\"isCorrect\":false},{\"id\":\"b\",\"text\":\"Previously encrypted data remains decryptable with the old key, rotation affects only new data.\",\"isCorrect\":true},{\"id\":\"c\",\"text\":\"Rotation invalidates old ciphertext and requires manual re-encryption.\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"Key rotation is not supported by Transit; you must rekey data manually.\",\"isCorrect\":false}]","explanation":"## Correct Answer\nb) Previously encrypted data remains decryptable with the old key, rotation affects only new data.\n\n## Why Other Options Are Wrong\n- A: Transit uses key versions; rotation does not automatically re-encrypt existing ciphertext.\n- C: Old ciphertext remains decryptable as long as the previous key versions exist; rotation does not force re-encryption.\n- D: Transit supports key rotation by creating a new key version; manual re-encryption is not required for existing data.\n\n## Key Concepts\n- Transit key rotation and versioning\n- Ciphertext carries a key version identifier\n- Impact on existing data\n\n## Real-World Application\n- When rotating Transit keys, plan for key version compatibility and ensure clients fetch or cache the relevant key versions to avoid decryption failures.","diagram":null,"difficulty":"intermediate","tags":["Vault","Transit","Kubernetes","certification-mcq","domain-weight-15"],"channel":"vault-associate","subChannel":"vault-architecture","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T05:28:38.900Z","createdAt":"2026-01-12 05:28:38"},{"id":"vault-associate-vault-tokens-1768224229887-0","question":"A Vault token is issued for a CI job. The token should have an initial TTL of 1 hour but may renew automatically up to 24 hours. Which token attribute should you configure to enforce this max renewal window?","answer":"[{\"id\":\"a\",\"text\":\"ttl\",\"isCorrect\":false},{\"id\":\"b\",\"text\":\"renewable\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"explicit_max_ttl\",\"isCorrect\":true},{\"id\":\"d\",\"text\":\"period\",\"isCorrect\":false}]","explanation":"## Correct Answer\nThe correct answer is explicit_max_ttl because it defines the maximum TTL that a renewable token can be renewed up to. The token can start with 1h TTL and renew up to 24h via the explicit_max_ttl cap.\n\n## Why Other Options Are Wrong\n- ttl: Sets the initial lifetime but does not cap renewal.\n- renewable: Enables renewal but does not impose a hard max renewal window.\n- period: Not a Vault token attribute.\n\n## Key Concepts\n- explicit_max_ttl defines the hard cap for TTL renewal.\n- Initial ttl + renewal capability determine token lifetime.\n\n## Real-World Application\n- Use for CI workloads that need a short-lived token with a bounded renewal window to limit blast radius.","diagram":null,"difficulty":"intermediate","tags":["HashiCorp Vault","AWS","Kubernetes","Terraform","CI/CD","certification-mcq","domain-weight-15"],"channel":"vault-associate","subChannel":"vault-tokens","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T13:23:49.889Z","createdAt":"2026-01-12 13:23:50"},{"id":"vault-associate-vault-tokens-1768224229887-1","question":"You issue a Vault token with renewable set to true, but you want to ensure it cannot be renewed after issuance. Which token setting achieves this behavior?","answer":"[{\"id\":\"a\",\"text\":\"renewable set to false\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"ttl set to 1h\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"explicit_max_ttl set to 24h\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"period\",\"isCorrect\":false}]","explanation":"## Correct Answer\nSetting renewable to false makes the token non-renewable, ensuring it cannot be renewed after issuance.\n\n## Why Other Options Are Wrong\n- ttl controls initial life but does not disable renewal if renewable is enabled.\n- explicit_max_ttl defines a renewal cap only when renewal is allowed.\n- period is not a Vault token parameter.\n\n## Key Concepts\n- renewability governs whether a token can be extended; disable it to enforce single-use lifetime.\n\n## Real-World Application\n- Use for one-off data exports or privileged actions where renewal is not desired.","diagram":null,"difficulty":"intermediate","tags":["HashiCorp Vault","AWS","Kubernetes","Terraform","CI/CD","certification-mcq","domain-weight-15"],"channel":"vault-associate","subChannel":"vault-tokens","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T13:23:50.435Z","createdAt":"2026-01-12 13:23:50"},{"id":"vault-associate-vault-tokens-1768224229887-2","question":"To grant a token access only to secret/data/prod/api, which policy path block correctly restricts access to that path?","answer":"[{\"id\":\"a\",\"text\":\"path \\\"secret/data/prod/api/*\\\" { capabilities = [\\\"read\\\",\\\"list\\\"] }\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"path \\\"secret/data/prod/*\\\" { capabilities = [\\\"read\\\",\\\"list\\\"] }\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"path \\\"secret/data/prod/api\\\" { capabilities = [\\\"read\\\"] }\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"path \\\"secret/data/**\\\" { capabilities = [\\\"read\\\"] }\",\"isCorrect\":false}]","explanation":"## Correct Answer\nOption a correctly narrows access to all subpaths under secret/data/prod/api, using a wildcard to cover the API namespace without leaking other prod data.\n\n## Why Other Options Are Wrong\n- Option b is wider: it grants access to secret/data/prod/*, which includes other prod paths.\n- Option c only grants access to the exact path secret/data/prod/api, missing subpaths like secret/data/prod/api/secret when present.\n- Option d uses an invalid glob pattern for Vault policies and could lead to unintended access.\n\n## Key Concepts\n- Narrow path scoping in Vault policies is essential for least-privilege access.\n\n## Real-World Application\n- Assign tokens to microservices that must read only within a specific secret subtree.","diagram":null,"difficulty":"intermediate","tags":["HashiCorp Vault","AWS","Kubernetes","Terraform","CI/CD","certification-mcq","domain-weight-15"],"channel":"vault-associate","subChannel":"vault-tokens","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T13:23:50.954Z","createdAt":"2026-01-12 13:23:51"},{"id":"vault-associate-vault-tokens-1768224229887-3","question":"Which Vault feature should you use to securely transmit a token to a CI runner without exposing the token in plain text in logs or configuration files?","answer":"[{\"id\":\"a\",\"text\":\"token wrapping\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"AppRole\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"dynamic secrets\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"lease rotation\",\"isCorrect\":false}]","explanation":"## Correct Answer\nToken wrapping provides a one-time, ephemeral wrapper token that unwraps to reveal the underlying secret only to authorized recipients, preventing exposure in logs or config.\n\n## Why Other Options Are Wrong\n- AppRole is for programmatic authentication but not a secure transmission wrapper.\n- Dynamic secrets are generated on demand but do not address token transport security.\n- Lease rotation is about rotating credentials, not securely transport-wrapping a token.\n\n## Key Concepts\n- Wrapping tokens are one-time-use payloads with a TTL.\n\n## Real-World Application\n- Use wrapping to hand off credentials to CI systems without exposing them in version control or logs.","diagram":null,"difficulty":"intermediate","tags":["HashiCorp Vault","AWS","Kubernetes","Terraform","CI/CD","certification-mcq","domain-weight-15"],"channel":"vault-associate","subChannel":"vault-tokens","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T13:23:51.136Z","createdAt":"2026-01-12 13:23:51"},{"id":"vault-associate-vault-tokens-1768224229887-4","question":"In Vault Kubernetes authentication, which role parameter binds a Vault role to a specific Kubernetes service account, ensuring only that service account can assume the role?","answer":"[{\"id\":\"a\",\"text\":\"bound_service_account_names\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"bound_service_account_namespaces\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"kubernetes_host\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"audience\",\"isCorrect\":false}]","explanation":"## Correct Answer\nbound_service_account_names binds the Vault Kubernetes auth role to a specific service account, limiting role assumption to that account.\n\n## Why Other Options Are Wrong\n- bound_service_account_namespaces narrows by namespace but does not bind to a specific service account.\n- kubernetes_host is the API server address, not a binding parameter.\n- audience is used for certain token formats, not service-account binding.\n\n## Key Concepts\n- Precise service account binding is essential for least privilege in Kubernetes auth.\n\n## Real-World Application\n- Use when exposing Vault roles to specific pods tied to a single service account.","diagram":null,"difficulty":"intermediate","tags":["HashiCorp Vault","AWS","Kubernetes","Terraform","CI/CD","certification-mcq","domain-weight-15"],"channel":"vault-associate","subChannel":"vault-tokens","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T13:23:51.444Z","createdAt":"2026-01-12 13:23:51"}],"subChannels":["secrets-engines","vault-architecture","vault-tokens"],"companies":[],"stats":{"total":11,"beginner":0,"intermediate":11,"advanced":0,"newThisWeek":11}}