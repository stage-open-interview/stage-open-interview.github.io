{"questions":[{"id":"q-682","question":"In a service handling image uploads, each file triggers a resize and thumbnail generation pipeline. Design a bounded producer-consumer queue in Python using asyncio. Use a Queue with maxsize, a fixed number of worker coroutines, and backpressure so producers await when full. Include clean shutdown and error handling. Provide a runnable minimal example showing enqueue, worker loop, and cancellation?","answer":"Use an asyncio.Queue(maxsize=128) with 4 worker coroutines. Producers await queue.put(task) to apply backpressure. Each worker pops tasks, processes image transforms, then calls queue.task_done(). On ","explanation":"## Why This Is Asked\n\nAssesses practical concurrency skills: bounded queues, worker pools, backpressure, and robust shutdown in a real feature like image processing.\n\n## Key Concepts\n\n- asyncio.Queue(maxsize) and backpressure\n- fixed-size worker pool\n- graceful shutdown and cancellation\n- error handling and observability\n\n## Code Example\n\n```python\n# Minimal outline of the pattern (not a full solution)\nimport asyncio\n\nclass Task:\n    def __init__(self, data): self.data = data\n\nasync def worker(q):\n    while True:\n        t = await q.get()\n        try:\n            # process t\n            pass\n        finally:\n            q.task_done()\n\nasync def main():\n    q = asyncio.Queue(maxsize=128)\n    workers = [asyncio.create_task(worker(q)) for _ in range(4)]\n    # enqueue tasks\n    for item in range(10):\n        await q.put(Task(item))\n    await q.join()\n    for w in workers: w.cancel()\n\nasyncio.run(main())\n```\n\n## Follow-up Questions\n\n- How would you adjust for burst traffic without starving producers?\n- How can you monitor queue depth and worker latency in production?","diagram":null,"difficulty":"beginner","tags":["concurrency"],"channel":"concurrency","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Lyft","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T15:58:30.388Z","createdAt":"2026-01-11T15:58:30.388Z"},{"id":"q-687","question":"Write a small Python snippet: create a shared counter initialized to 0, spawn 4 threads that increment it 1000 times each, using a Lock to protect the increment. After joining, print the final value. Explain what happens if the lock is removed and how atomicity is ensured. What value do you expect and why?","answer":"Use a Lock around the increment: with lock: counter += 1 in each thread. Spawn 4 threads, each loops 1000 times. Final value should be 4000. Without the lock, race conditions may yield a final value l","explanation":"## Why This Is Asked\n\nThis checks understanding of race conditions, mutual exclusion, and practical use of locks in a tiny concurrency exercise.\n\n## Key Concepts\n\n- Race conditions and protection via locks\n- Atomicity in read-modify-write sequences\n- Trade-offs of locks vs lock-free structures\n\n## Code Example\n\n```python\nimport threading\ncounter = 0\nlock = threading.Lock()\ndef worker():\n    global counter\n    for _ in range(1000):\n        with lock:\n            counter += 1\nthreads = [threading.Thread(target=worker) for _ in range(4)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(counter)\n```\n\n## Follow-up Questions\n\n- What happens if a thread raises an exception inside the critical section?\n- How would you test this under CPU-bound vs I/O-bound workloads?","diagram":"flowchart TD\n  A[Start] --> B[Create 4 threads]\n  B --> C[Each thread increments 1000x]\n  C --> D[Acquire lock for increment]\n  D --> E[Increment counter]\n  E --> F[Join threads]\n  F --> G[Print final value]\n  G --> H[End]","difficulty":"beginner","tags":["concurrency"],"channel":"concurrency","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Tesla","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T16:22:26.189Z","createdAt":"2026-01-11T16:22:26.189Z"}],"subChannels":["general"],"companies":["Discord","Google","Lyft","Snap","Tesla","Two Sigma"],"stats":{"total":2,"beginner":2,"intermediate":0,"advanced":0,"newThisWeek":2}}