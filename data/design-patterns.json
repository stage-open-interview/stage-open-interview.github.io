{"questions":[{"id":"q-1146","question":"You're building a data ingestion service that validates JSON records before persisting them. Validation steps include NonEmpty fields, Email format, and PasswordStrength. Validators must be pluggable: new validators can be added at runtime by registering them into a Registry without touching the core pipeline. Design a minimal interface and registry, and show how to compose and execute the pipeline with a sample config. Include how to add a new validator and run the pipeline, returning the first failure?","answer":"Implement a Validator interface with validate(record) -> {ok:boolean, error?:string}. Maintain a Registry<string, () => Validator> extendable at runtime. ValidationPipeline reads a list of keys from c","explanation":"## Why This Is Asked\n\nTests ability to design a pluggable validation system that can be extended without touching core logic, a common real-world requirement in ingestion pipelines.\n\n## Key Concepts\n\n- Registry/Factory pattern for runtime extensibility\n- Pipeline that composes validators by config\n- Early exit on first failure for efficient feedback\n\n## Code Example\n\n```javascript\n// Minimal interface and registry\nclass Validator {\n  validate(record) { return { ok: true }; }\n}\nclass EmailValidator extends Validator {\n  validate(record) {\n    const ok = /^[^@]+@[^@]+\\.[^@]+$/.test(record.email || '');\n    return ok ? { ok: true } : { ok: false, error: 'Invalid email' };\n  }\n}\nconst Registry = new Map();\nfunction register(name, factory) { Registry.set(name, factory); }\nfunction createValidator(name) { const f = Registry.get(name); return f ? f() : null; }\n\nclass ValidationPipeline {\n  constructor(registry, keys) {\n    this.registry = registry;\n    this.keys = keys;\n  }\n  validate(record) {\n    for (const k of this.keys) {\n      const v = this.registry.get(k) ? this.registry.get(k)() : null;\n      if (!v) continue;\n      const res = v.validate(record);\n      if (!res.ok) return res;\n    }\n    return { ok: true };\n  }\n}\n\n// Usage\nregister('Email', () => new EmailValidator());\nregister('NonEmpty', () => new Validator());\nconst keys = ['Email'];\nconst pipeline = new ValidationPipeline(Registry, keys);\nconst result = pipeline.validate({ email: 'a@b.com' });\n```\n\n## Follow-up Questions\n\n- How would you handle async validators?\n- How would you test the registry and pipeline separately?\n- How would you version validators and roll back if a validator changes semantics?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Square","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T01:32:17.318Z","createdAt":"2026-01-13T01:32:17.318Z"},{"id":"q-1201","question":"Design a runtime-pluggable per-message transformation system for a streaming pipeline. Messages include metadata that determines the transformation strategy (e.g., enrich, normalize, validate). Implement with a design pattern that lets you add new strategies without modifying the pipeline core. Provide minimal interfaces, a registry, and a usage example?","answer":"Interface: Transformation { apply(msg): Msg }. Implementations: EnrichTransformation, NormalizeTransformation, ValidateTransformation. Registry maps string -> TransformationFactory; pipeline uses reso","explanation":"## Why This Is Asked\nThis tests depth in plug-in style pattern design for real-time data processing, ensuring new transformers can be added without mutating core code, a common need in SaaS pipelines.\n\n## Key Concepts\n- Plugin/Registry pattern for runtime extensibility\n- Lightweight interfaces and factories\n- Thread-safety and hot-reload considerations\n\n## Code Example\n```javascript\nclass Transformation {\n  apply(msg) { throw new Error('not implemented') }\n}\nclass EnrichTransformation extends Transformation {\n  apply(msg) { /* enrich */ return msg }\n}\nclass NormalizeTransformation extends Transformation {\n  apply(msg) { /* normalize */ return msg }\n}\nclass ValidateTransformation extends Transformation {\n  apply(msg) { /* validate */ return msg }\n}\nclass TransformationRegistry {\n  constructor() { this._factories = new Map() }\n  register(name, factory) { this._factories.set(name, factory) }\n  create(name) { const f = this._factories.get(name); return f ? f() : null }\n}\n// Usage\nconst registry = new TransformationRegistry()\nregistry.register('enrich', () => new EnrichTransformation())\nconst t = registry.create('enrich')\nconst out = t?.apply(msg)\n```\n\n## Follow-up Questions\n- How would you handle thread-safety and hot-reload of strategies at runtime?\n- How would you test the registry and individual strategies?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Plaid","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T04:48:59.080Z","createdAt":"2026-01-13T04:48:59.080Z"},{"id":"q-1236","question":"Design a runtime-pluggable, per-route transformer and throttling policy system for a real-time event router. Each route maps an event type to a transformer and a rate-limit policy; new transformers (enrich, redact, normalize) and new policies (token-bucket, fixed-window, leaky-bucket) must be addable at runtime without touching the router core. Which pattern would you adopt and how would you structure the minimal interfaces and registry?","answer":"Use a Plugin Registry with the Strategy pattern. Define Transformer { transform(Event): Event } and Policy { allow(Event, rate): boolean }. Router stores RouteKey -> (TransformerName, PolicyName) and ","explanation":"## Why This Is Asked\n\nThis tests designing for open-closed, runtime extensibility, and safe plugin loading in high-throughput systems like those at scale. It also probes trade-offs between reflection, isolation, and static typing.\n\n## Key Concepts\n\n- Plugin Registry\n- Strategy\n- Open/Closed Principle\n- Dynamic loading and sandboxing\n\n## Code Example\n\n```javascript\nclass Transformer { transform(event){return event} }\nclass Policy { allow(event, rate){return true} }\n```\n\n## Follow-up Questions\n\n- How to version plugins and rollback\n- How to enforce plugin isolation and security in a multi-tenant environment","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Oracle","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T06:33:28.616Z","createdAt":"2026-01-13T06:33:28.616Z"},{"id":"q-1258","question":"Design a runtime-extensible notification dispatch system that handles multiple channels (email, SMS, push) where new transports and their backoff strategies can be added at runtime via a registry without touching the core dispatcher. Specify the minimal interfaces, how you register a new transport and a new backoff policy, and show a usage example including adding a WhatsApp transport and a geometric backoff?","answer":"Implement a Dispatcher that routes by channel to a pluggable Transport. Each Transport exposes send(event, payload) and a factory for instantiation. A Registry holds transports and backoff policies; n","explanation":"## Why This Is Asked\n\nTests ability to design plugin architecture with runtime extension, isolation, and versioning.\n\n## Key Concepts\n\n- Plugin registry\n- Strategy/Factory patterns\n- Thread-safety and hot-reload\n- Backoff policy composition\n\n## Code Example\n\n```javascript\n// Minimal interfaces and registry (pseudo)\ninterface Transport { send(event, payload): Promise<void> }\ninterface TransportFactory { create(config?: any): Transport }\nclass Registry {\n  private transports = new Map<string, TransportFactory>();\n  register(name, factory) { this.transports.set(name, factory); }\n  create(name, config) { return this.transports.get(name).create(config); }\n}\ninterface BackoffPolicy { nextDelay(attempt:number): number }\nclass GeometricBackoff implements BackoffPolicy { nextDelay(a){ return Math.pow(2, a) * 100; } }\n```\n\n## Follow-up Questions\n\n- How would you ensure thread-safety and avoid memory leaks when plugins are loaded/unloaded?\n- How would you test the registry and dynamic loading?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","DoorDash","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T07:23:57.353Z","createdAt":"2026-01-13T07:23:57.353Z"},{"id":"q-1300","question":"Design a feature-flag evaluation engine for a large SaaS product. Flags support boolean, percentage rollout, user-segment, and A/B bucket strategies. Create a pluggable evaluator where new strategies can be added at runtime via a Registry without touching the core evaluator. Provide interfaces, a thread-safe registry, and a usage example with versioned strategy lookup?","answer":"Use Strategy pattern: FlagEvaluationStrategy with evaluate(user, flag) and a factory-based Registry. The core evaluator queries registry with key flagName|version, creates a strategy, and calls evalua","explanation":"## Why This Is Asked\nTests runtime extensibility and correctness of flag evaluation, including versioning and thread-safety.\n\n## Key Concepts\n- Strategy pattern for evaluation logic\n- Registry/Factory for runtime additions\n- Thread-safety and version-keying\n- Performance implications of dynamic dispatch\n\n## Code Example\n```typescript\ninterface User { id: string; segments: string[]; }\ninterface Flag { name: string; version: string; defaultValue?: boolean; }\n\ninterface FlagEvaluationStrategy {\n  evaluate(user: User, flag: Flag): boolean;\n}\ntype StrategyFactory = () => FlagEvaluationStrategy;\n\nclass FlagRegistry {\n  private map = new Map<string, StrategyFactory>();\n  register(key: string, factory: StrategyFactory) { this.map.set(key, factory); }\n  get(key: string): FlagEvaluationStrategy {\n    const f = this.map.get(key);\n    if (!f) throw new Error(`No strategy registered for ${key}`);\n    return f();\n  }\n}\nclass FlagEvaluator {\n  constructor(private registry: FlagRegistry) {}\n  eval(flag: Flag, user: User): boolean {\n    const strat = this.registry.get(`${flag.name}|${flag.version}`);\n    return strat.evaluate(user, flag);\n  }\n}\nclass PercentStrategy implements FlagEvaluationStrategy {\n  constructor(private percent: number) {}\n  evaluate(user: User, flag: Flag): boolean {\n    const r = (parseInt(user.id.slice(-4), 10) % 100) < this.percent;\n    return r;\n  }\n}\n```","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Google","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T08:45:51.433Z","createdAt":"2026-01-13T08:45:51.433Z"},{"id":"q-681","question":"You're building a multi-tenant API gateway for a Stripe-like payments service, backed by MongoDB storage and a Twitter-like feed. Each tenant has a per-minute rate limit. Describe a concrete solution using the Decorator pattern to enforce quotas, show how you'd implement atomic Redis updates, discuss burst handling and clock drift, and outline a minimal wrapper skeleton in code?","answer":"Design a multi-tenant rate limiter by wrapping the core service with a Decorator that enforces per-tenant quotas stored in Redis. On each call, the decorator does an atomic INCR for the tenant’s windo","explanation":"## Why This Is Asked\nThis question probes practical design-pattern reasoning under real constraints (tenancy, rate limits, distributed cache).\n\n## Key Concepts\n- Decorator pattern for cross-cutting concerns\n- Atomic Redis updates and Lua scripting\n- Burst handling strategies and clock drift trade-offs\n- Testing under failure and partial outages\n\n## Code Example\n\n```javascript\nclass RateLimitedService {\n  constructor(next) { this.next = next; }\n  async call(req){ return this.next.call(req); }\n}\n\nclass RateLimiterDecorator {\n  constructor(next, redis, quota, windowSec){\n    this.next = next; this.redis = redis; this.quota = quota; this.windowSec = windowSec; }\n  async call(req){\n    const key = `rate:${req.tenant}:${Math.floor(Date.now()/this.windowSec)}`;\n    const count = await this.redis.incr(key);\n    if (count === 1) await this.redis.expire(key, this.windowSec);\n    if (count > this.quota) throw new Error('rate limit');\n    return this.next.call(req);\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test edge bursts or clock skew?\n- How would you evolve to a distributed token bucket?\n- How do you monitor and alert on quota breaches?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Stripe","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T15:58:03.426Z","createdAt":"2026-01-11T15:58:03.426Z"},{"id":"q-688","question":"You're building a feature flag system where flags can be evaluated as a hard boolean, a percentage rollout, or a targeted user segment. Design the architecture using a design pattern that lets you add new evaluation strategies without changing the caller. Which pattern would you choose and how would you implement it in code? Provide a minimal interface and usage example?","answer":"Use the Strategy pattern: define an IFlagStrategy with evaluate(user, flag) -> boolean. Implement concrete strategies: BooleanFlag, PercentFlag, UserSegmentFlag. The Evaluator holds a strategy referen","explanation":"## Why This Is Asked\nUnderstanding extensibility and testability in pattern choices.\n\n## Key Concepts\n- Strategy pattern\n- Dependency injection\n- Runtime swapping\n- Testability and trade-offs\n\n## Code Example\n```javascript\ninterface FlagStrategy {\n  evaluate(user, flag): boolean;\n}\nclass BooleanFlagStrategy implements FlagStrategy {\n  evaluate(user, flag) { return flag.value; }\n}\nclass PercentFlagStrategy implements FlagStrategy {\n  evaluate(user, flag) { return (user.id % 100) < flag.percent; }\n}\nclass UserSegmentFlagStrategy implements FlagStrategy {\n  evaluate(user, flag) { return flag.segments.includes(user.segment); }\n}\n\nclass FlagEvaluator {\n  constructor(strategy) { this.strategy = strategy; }\n  evaluate(user, flag) { return this.strategy.evaluate(user, flag); }\n  setStrategy(s) { this.strategy = s; }\n}\n```\n\n## Follow-up Questions\n- How would you test each strategy in isolation?\n- How would you design the Flag object for efficient evaluation?\n","diagram":"flowchart TD\n  Evaluator --> Strategy\n  Strategy --> BooleanFlagStrategy\n  Strategy --> PercentFlagStrategy\n  Strategy --> UserSegmentFlagStrategy","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Hashicorp"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T16:22:55.337Z","createdAt":"2026-01-11T16:22:55.337Z"},{"id":"q-695","question":"You're building a real-time data ingestion pipeline that must apply a sequence of transformations to each record. New transforms (normalization, enrichment, validation, anomaly detection) should be added as plugins without touching producer/consumer code. Design a pluggable Transform pipeline with per-tenant routing and hot-reload of configuration. Provide minimal interface and a usage example, including how to configure a few plugins and compose them for a stream?","answer":"Use a pluggable Transform pipeline. Define interface Transform { String name(); Record apply(Record); }. Pipeline holds an immutable List<Transform> steps; process r = steps.reduce via apply. Per-tena","explanation":"## Why This Is Asked\nAssess ability to design a modular, runtime-configurable data pipeline with per-tenant customization.\n\n## Key Concepts\n- Plugin architecture and the Pipeline pattern\n- Immutable pipelines and copy-on-write config\n- Per-tenant routing and hot-reload\n- Stateless transforms and fault tolerance\n\n## Code Example\n```javascript\nclass Transform { constructor(name){this.name=name} apply(rec){return rec}}\nclass NormalizeTransform extends Transform { apply(r){ /* normalize */ return r} }\nclass Pipeline { constructor(steps){ this.steps=Object.freeze(steps)} process(r){ return this.steps.reduce((acc,t)=>t.apply(acc), r) } }\n```\n\n## Follow-up Questions\n- How would you test per-tenant hot reload without downtime?\n- How do you handle a failing plugin without aborting the whole record?","diagram":"flowchart TD\n  A[Record Arrives] --> B{Tenant Exists?}\n  B -->|Yes| C[Fetch Tenant Pipeline]\n  C --> D[Process Through Transforms]\n  D --> E[Store Result]\n  B -->|No| F[Default Pipeline] --> E","difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T17:16:37.061Z","createdAt":"2026-01-11T17:16:37.061Z"},{"id":"q-706","question":"You're building an extensible data ingestion framework where new data formats (JSON, Parquet, ORC) must be supported without touching the core ingestion logic. Design the architecture using a pattern that decouples format parsing from the caller and lets you add new format handlers without changing the caller. Which pattern would you choose and how would you implement it in code? Provide a minimal interface and usage example?","answer":"Use the Strategy pattern: define a FormatHandler interface and a registry mapping formats to concrete handlers. Ingestor delegates parsing to the appropriate handler, so adding a new format requires o","explanation":"## Why This Is Asked\nThis question tests choosing an architecture that stays Open-Closed, supports runtime extension of handlers, and keeps the ingestion core simple and testable.\n\n## Key Concepts\n- Strategy/Polymorphism\n- Open-Closed Principle\n- Registry-based dispatch\n\n## Code Example\n```javascript\ninterface FormatHandler { parse(input) }\nclass JsonHandler implements FormatHandler { parse(input) { /* parse JSON */ } }\nclass Ingestor { constructor(registry) { this.registry = registry } ingest(format, data) { return this.registry[format].parse(data) } }\n```\n\n## Follow-up Questions\n- How would you handle unknown formats at runtime?\n- How would you test individual handlers and end-to-end ingestion?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T18:29:21.416Z","createdAt":"2026-01-11T18:29:21.416Z"},{"id":"q-714","question":"You're building a small HTTP client wrapper that fetches a user profile, but the server occasionally fails. The caller selects a retry policy by name (linear, exponential, jitter) and fetchUser should retry using that policy without changing fetchUser's code. Design the architecture using a design pattern that lets you add new retry strategies without modifying the caller. Provide a minimal interface and a usage example?","answer":"Pattern: Strategy. Define interface RetryPolicy { shouldRetry(attempt:number, err:any): boolean; nextDelay(attempt:number, err?:any): number }. Implement LinearPolicy, ExponentialPolicy, and JitterPol","explanation":"## Why This Is Asked\nTests understanding of how to decouple variability in behavior using design patterns. It shows how to extend functionality without touching call sites, a common real-world need.\n\n## Key Concepts\n- Strategy pattern for interchangeable retry logic\n- Dependency injection to supply policies\n- Clear separation of fetch logic from retry strategy\n- Testability by swapping mock policies\n\n## Code Example\n```javascript\ninterface RetryPolicy {\n  shouldRetry(attempt: number, err: any): boolean;\n  nextDelay(attempt: number, err?: any): number;\n}\nclass LinearPolicy implements RetryPolicy {\n  constructor(private delay: number, private max: number) {}\n  shouldRetry(attempt: number) { return attempt < this.max; }\n  nextDelay(_attempt: number) { return this.delay; }\n}\nclass ExponentialPolicy implements RetryPolicy {\n  constructor(private base: number, private factor: number, private cap: number) {}\n  shouldRetry(attempt: number) { return attempt * this.factor < this.cap; }\n  nextDelay(attempt: number) { return Math.min(this.base * Math.pow(this.factor, attempt - 1), this.cap); }\n}\n```\n\n```javascript\nconst policy = new ExponentialPolicy(100, 2, 1000);\nfetchUser('alice', policy);\n```\n\n## Follow-up Questions\n- How would you test retry behavior without real network calls?\n- How would you share a policy across multiple fetchers without duplication?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Lyft","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T19:17:55.052Z","createdAt":"2026-01-11T19:17:55.052Z"},{"id":"q-717","question":"You're building a real-time event processing pipeline that validates, enriches, and filters events before persisting. New validators, enrichers, and filters must be added at runtime without altering the core processor. Which design pattern enables this extensibility and how would you implement it? Provide minimal interfaces and a usage example?","answer":"Adopt a pluggable pipeline implemented as a Chain of Responsibility / Pipeline pattern. Keep a registry of steps (validators, enrichers, filters) and a runner that applies them in sequence. New steps ","explanation":"## Why This Is Asked\n\nTests ability to design extensible, maintainable data processing. Candidates should show how to decouple orchestration from behavior and support runtime extensibility.\n\n## Key Concepts\n\n- Pipeline / Chain of Responsibility\n- Dynamic step registration\n- Order preservation and error propagation\n- Stateless, composable steps\n\n## Code Example\n\n```javascript\nclass Pipeline {\n  constructor() {\n    this.steps = [];\n  }\n  register(step) {\n    this.steps.push(step);\n  }\n  run(event) {\n    return this.steps.reduce((e, s) => s(e), event);\n  }\n}\n\n// Usage: extend without touching core\nconst p = new Pipeline();\np.register(e => ({ ...e, enriched: true }));\np.register(e => (e.valid ? e : { ...e, error: 'invalid' }));\nconst event = { payload: { id: 1 } };\nconst result = p.run(event);\n```\n\n## Follow-up Questions\n\n- How would you handle async steps or errors within steps?\n- How would you enforce step ordering guarantees and versioning of pipelines?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Snowflake","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T20:21:02.325Z","createdAt":"2026-01-11T20:21:02.326Z"},{"id":"q-729","question":"You're building an image-processing pipeline that applies a sequence of filters (blur, brighten, sharpen) to images. The pipeline must run on both CPU and GPU backends, and new backends must be pluggable without touching filter implementations or orchestration code. Design an architecture that decouples filters from backends using a design pattern, enabling adding a backend such as Vulkan without modifying core code. Provide a minimal interface and usage example?","answer":"Use the Bridge pattern: Filters depend on a Backend API, not a concrete backend. Define Backend{apply(image, opSpec)} and concrete backends CPUBackend, GPUBackend. Filters call backend.apply(...) and ","explanation":"## Why This Is Asked\n\nThis task tests the ability to decouple algorithmic filters from execution backends, enabling runtime backend swapping and new backend integration without touching core logic.\n\n## Key Concepts\n\n- Bridge pattern for decoupling abstraction (filters) from implementation (backends)\n- Backend interface and concrete backends (CPU, GPU)\n- Extensibility and testability with pluggable backends\n\n## Code Example\n\n```javascript\n// Minimal illustrative code (not production-ready)\nclass Backend {\n  apply(image, opSpec) { throw new Error('not implemented') }\n}\nclass CPUBackend extends Backend {\n  apply(image, opSpec) { /* CPU path */ return image }\n}\nclass GPUBackend extends Backend {\n  apply(image, opSpec) { /* GPU path, e.g., CUDA/Vulkan */ return image }\n}\nclass Filter {\n  constructor(opSpec) { this.opSpec = opSpec }\n  render(image, backend) { return backend.apply(image, this.opSpec) }\n}\nclass Pipeline {\n  constructor() { this.filters = []; }\n  setBackend(b) { this.backend = b }\n  addFilter(f) { this.filters.push(f) }\n  run(image) { let out = image; for (const f of this.filters) out = f.render(out, this.backend); return out }\n}\n```\n\n## Follow-up Questions\n\n- How would you add backends with different precision or memory constraints?\n- How would you test backends in isolation and measure performance trade-offs?","diagram":"flowchart TD\nP[Pipeline] --> B[BackendBridge]\nP --> F[Filters]\nB --> CPU[CPUBackend]\nB --> GPU[GPUBackend]\nF --> Blur[BlurFilter]\nF --> Brighten[BrightenFilter]","difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T21:18:19.757Z","createdAt":"2026-01-11T21:18:19.757Z"},{"id":"q-737","question":"In a messaging pipeline used by Zoom and Hugging Face, the system tokenizes, normalizes, and stores messages. You want to support swapping in different normalization strategies (lowercasing, diacritic removal, profanity filtering) without changing the pipeline code. Design the architecture using a design pattern that lets you add new normalization strategies without modifying the pipeline. Provide a minimal interface and a usage example. How would you implement this pattern to make additions painless?","answer":"Use the Strategy pattern by modeling the normalization as a pluggable Normalizer with a normalize(text) method, then inject a concrete Normalizer into the pipeline. New strategies (Lowercase, AccentRe","explanation":"## Why This Is Asked\nTests knowledge of a clean extension point and practical DI. It avoids altering core pipeline logic when introducing new behaviors.\n\n## Key Concepts\n- Strategy pattern for interchangeable behaviors\n- Dependency injection for runtime flexibility\n- Open-closed principle and testability\n\n## Code Example\n```javascript\n// Minimal interface\ninterface Normalizer {\n  normalize(text: string): string;\n}\nclass LowercaseNormalizer implements Normalizer {\n  normalize(text: string) { return text.toLowerCase(); }\n}\nclass AccentRemover implements Normalizer {\n  normalize(text: string) { return text.normalize('NFD').replace(/[\\u0300-\\u036f]/g, ''); }\n}\nclass MessageProcessor {\n  constructor(private normalizer: Normalizer) {}\n  process(text: string) { return this.normalizer.normalize(text); }\n}\n```\n\n## Follow-up Questions\n- How would you choose between construction-time vs per-message normalization strategy?\n- How would you test each strategy in isolation and within the pipeline?","diagram":"flowchart TD\n  P[MessageProcessor] --> N[NormalizationContext]\n  N --> L[LowercaseNormalization]\n  N --> A[AccentRemoval]\n  L --> S[StoreMessage]\n  A --> S","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T22:20:11.913Z","createdAt":"2026-01-11T22:20:11.914Z"},{"id":"q-741","question":"In a telemetry alerting system for autonomous fleets, each customer needs a custom alert-threshold strategy for metrics like speed or battery: static value, percentile-based, or rolling window. The aggregator should surface alerts without depending on a concrete strategy. Design the architecture using a design pattern that lets you add new threshold strategies without modifying the aggregator. Provide a minimal interface and a usage example?","answer":"Use Strategy pattern: define interface ThresholdStrategy { compute(values: number[]): number }, implement StaticThreshold, PercentileThreshold, RollingWindowThreshold, and a ThresholdContext that dele","explanation":"## Why This Is Asked\nTests ability to plug in new algorithms without touching the orchestrator, a common interview scenario.\n\n## Key Concepts\n- Strategy pattern for interchangeable thresholds\n- Thin interface and per-customer configuration\n- Factory to instantiate strategies from config\n\n## Code Example\n```javascript\nclass ThresholdStrategy { compute(values) { throw new Error('not implemented') } }\nclass StaticThreshold extends ThresholdStrategy {\n  constructor(v){ super(); this.v=v }\n  compute(_){ return this.v }\n}\nclass PercentileThreshold extends ThresholdStrategy {\n  constructor(p){ super(); this.p=p }\n  compute(values){ if (!values.length) return 0; values.sort((a,b)=>a-b); const idx=Math.floor((this.p/100)*(values.length-1)); return values[idx]; }\n}\nclass RollingWindowThreshold extends ThresholdStrategy {\n  constructor(size){ super(); this.size=size }\n  compute(values){ const win = values.slice(-this.size); win.sort((a,b)=>a-b); const idx=Math.floor(0.95*(win.length-1)); return win[idx]; }\n}\nclass ThresholdContext {\n  constructor(strategy){ this.strategy=strategy }\n  compute(values){ return this.strategy.compute(values) }\n}\n\n// usage\nconst t = new ThresholdContext(new PercentileThreshold(95));\nconst threshold = t.compute(window);\n```\n\n## Follow-up Questions\n- How would you test adding a new strategy in isolation?\n- How would you persist per-customer strategy config and migrate existing customers?","diagram":"flowchart TD\n  A[Aggregator] --> B[ThresholdStrategy]\n  B --> C[StaticThreshold]\n  B --> D[PercentileThreshold]\n  B --> E[RollingWindowThreshold]","difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Tesla","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T23:17:28.525Z","createdAt":"2026-01-11T23:17:28.525Z"},{"id":"q-750","question":"You’re building a data export utility that must support multiple formats. New formats can come from external libraries with different APIs. Design an architecture using a pattern that lets you add new formats without changing the core exporter. Which pattern would you use and how would you implement it? Provide a minimal interface and a usage example?","answer":"Pattern: Adapter. Wrap external serializers behind a common Serializer interface to let the exporter support new formats without modifying its code. Define Serializer { serialize(data) string }. Imple","explanation":"## Why This Is Asked\n\nTests ability to map real-world library integration to a classic pattern without touching core logic.\n\n## Key Concepts\n\n- Adapter pattern\n- Interfaces and thin wrappers\n- Extending functionality without modifying clients\n\n## Code Example\n\n```javascript\n// Minimal interface\nclass Serializer { serialize(data) { throw new Error('Not implemented') } }\nclass JsonAdapter extends Serializer {\n  constructor(jsonLib) { this.jsonLib = jsonLib }\n  serialize(data) { return this.jsonLib.stringify(data) }\n}\n```\n\n## Follow-up Questions\n\n- How would you test adapters in isolation?\n- What are trade-offs vs Bridge when formats have evolving schemas?\n","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Cloudflare","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T01:28:32.744Z","createdAt":"2026-01-12T01:28:32.744Z"},{"id":"q-763","question":"You're designing a data ingestion pipeline where raw inputs pass through optional enhancers (encryption, compression, watermarking) implemented as decorators around a base DataSource. You must add new decorators without touching the core pipeline or existing decorators. Which pattern would you use and how would you implement minimal interfaces to compose them? Provide a usage example?","answer":"Use the Decorator pattern. Define DataSource { read(): Buffer }. Implement a base FileSource. Create DataSourceDecorator wrapping a DataSource. Add concrete decorators EncryptDecorator, CompressDecora","explanation":"## Why This Is Asked\nThis tests the ability to extend behavior without modifying existing code, a hallmark of robust design.\n\n## Key Concepts\n- Decorator pattern\n- Runtime composition\n- Open/Closed Principle\n\n## Code Example\n```javascript\ninterface DataSource { read(): Buffer }\nclass FileSource implements DataSource { constructor(path) { this.path = path } read() { /* read file */ } }\nclass DataSourceDecorator implements DataSource { constructor(protected source: DataSource) {} read() { return this.source.read() } }\nclass EncryptDecorator extends DataSourceDecorator { read() { const data = super.read(); return encrypt(data) } }\nclass CompressDecorator extends DataSourceDecorator { read() { const data = super.read(); return compress(data) } }\n```\n\n## Follow-up Questions\n- How would you test a decorator stack with different orders?\n- How to handle streaming data and backpressure in decorator chains?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Microsoft","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T03:50:59.836Z","createdAt":"2026-01-12T03:50:59.836Z"},{"id":"q-769","question":"In a log analytics pipeline, you must support multiple formats (JSON, CSV, Protobuf) and multiple sinks (Elasticsearch, BigQuery, S3). Design an architecture using a design pattern that allows adding new formats or sinks without touching the producer. Provide minimal interfaces and a usage example?","answer":"Use the Strategy pattern to decouple event formatting from producers and sinks. Define a Formatter interface with format(Event) -> []byte and a Publisher interface with publish([]byte, Sink). Implemen","explanation":"## Why This Is Asked\nTests understanding of decoupling using a pattern that lets new formats/sinks be added without producer changes.\n\n## Key Concepts\n- Strategy pattern\n- Registry/Factory for runtime selection\n- Dependency injection\n\n## Code Example\n```javascript\n// Formatter interface\nclass Formatter { format(event) { /*...*/ } }\n// Publisher interface\nclass Publisher { publish(data, sink) { /*...*/ } }\n\nclass JSONFormatter { format(e){ return JSON.stringify(e.payload) } }\nclass ElasticsearchPublisher { publish(bytes, sink){ /* send to sink */ } }\n\n// usage\nconst registry = new Map();\nregistry.set('json', { formatter: new JSONFormatter(), publisher: new ElasticsearchPublisher() });\nconst { formatter, publisher } = registry.get('json');\nconst data = formatter.format({ payload: { x: 1 } });\npublisher.publish(data, 'elasticsearch');\n```\n\n## Follow-up Questions\n- How would you test the registry and ensure new formats don't require producer changes?\n- How would you handle versioned schemas when formats evolve?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","MongoDB","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T04:48:36.490Z","createdAt":"2026-01-12T04:48:36.490Z"},{"id":"q-781","question":"You're building a CLI tool that supports commands and subcommands, forming a tree (e.g., 'git remote add'). Design a Command interface that treats leaves (actual actions) and composites (groups of commands) uniformly. Implement LeafCommand and CommandGroup using the Composite pattern so a single call can execute a command or print help for a whole subtree without changing client code. Provide a minimal interface and usage example?","answer":"Use the Composite pattern. Define a Command interface with execute(args) and help(). Implement LeafCommand for concrete actions and CommandGroup for commands that contain children. The group delegates","explanation":"Why This Is Asked\n- Demonstrates modeling hierarchical command structures with a single interface.\n- Shows uniform treatment of leaves and composites, enabling recursive execution.\n- Tests understanding of registration and delegation without touching client logic.\n\nKey Concepts\n- Composite pattern\n- Uniform interface for leaves/composites\n- Recursive command resolution\n- Lightweight plugin-friendly design\n\nCode Example\n```javascript\nclass Command {\n  execute(args) { throw new Error('not implemented'); }\n  help() { throw new Error('not implemented'); }\n}\nclass LeafCommand extends Command {\n  constructor(name, action){ super(); this.name = name; this.action = action; }\n  execute(args){ this.action(args); }\n  help(){ return this.name; }\n}\nclass CommandGroup extends Command {\n  constructor(name){ super(); this.name = name; this.children = []; }\n  add(cmd){ this.children.push(cmd); }\n  execute(args){ const [sub] = args; const found = this.children.find(c => c.help() === sub);\n    if(found) found.execute(args.slice(1));\n  }\n  help(){ return this.name + ' (' + this.children.map(c => c.help()).join(', ') + ')'; }\n}\n\n// Usage\nconst root = new CommandGroup('root');\nconst status = new LeafCommand('status', () => console.log('ok'));\nconst repo = new CommandGroup('repo');\nrepo.add(status);\nroot.add(repo);\n```\n","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T05:32:43.572Z","createdAt":"2026-01-12T05:32:43.572Z"},{"id":"q-785","question":"You're building a pluggable HTTP request/response transformer pipeline inside a reverse proxy. Each Transformer can add, redact, or modify headers/body. The gateway must load new Transformers at runtime by name without redeploying. Design a minimal interface and registry-driven architecture that supports adding new transformer types without touching the gateway core. Provide a usage example?","answer":"Use the Strategy pattern with a runtime Transformer registry. Define Transformer { apply(req, res) error }; concrete types like HeaderAdder, BodyRedactor implement it. Pipeline stores []Transformer. A","explanation":"## Why This Is Asked\n\nThis question probes runtime extensibility and plugin architecture for a high-availability gateway, emphasizing decoupling, dynamic discovery, and safe wiring of new behavior without redeploys.\n\n## Key Concepts\n\n- Strategy pattern for interchangeable transformers\n- Registry/Plugin mechanism for dynamic loading\n- Runtime extensibility with minimal core impact\n\n## Code Example\n\n```javascript\n// Minimal interface and wiring\ninterface Transformer {\n  apply(req, res): void\n}\nclass HeaderAdder implements Transformer { apply(req, res) { /* ... */ } }\nclass BodyRedactor implements Transformer { apply(req, res) { /* ... */ } }\n\nclass Registry {\n  register(name, factory) { /* ... */ }\n  create(name, config) { /* ... */ }\n}\n```\n\n## Follow-up Questions\n\n- How do you guarantee transformer execution order and error handling in the pipeline?\n- How would you test hot-plug transformers and rollback on failure in CI/CD?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Cloudflare","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T06:37:47.273Z","createdAt":"2026-01-12T06:37:47.273Z"},{"id":"q-793","question":"You're designing a streaming data processing framework where each record passes through a configurable pipeline of transformation steps. New transformations must be added at runtime without touching the orchestrator, and jobs select steps by name. Which design pattern and minimal interfaces would you use to register, compose, and execute transformations, ensuring type-safety and low churn when adding new steps? Provide a concise usage example?","answer":"Use a Registry-Driven Strategy pattern: define a Transformation<T> { apply(input: T): T }, a Factory<T> to instantiate by name, and a Pipeline<T> that composes steps. Elements register at runtime in a","explanation":"## Why This Is Asked\nA runtime-extendable transformation system tests open-closed principle, type-safety, and runtime composition without touching orchestration.\n\n## Key Concepts\n- Registry: maps names to transformation factories.\n- Strategy: each transformation is a pluggable strategy.\n- Pipeline: sequences transformations into a single pass.\n- Runtime extensibility: add new steps without modifying core.\n- Type-safety: leverage generics for input/output consistency.\n\n## Code Example\n```typescript\ninterface Transformation<T> { apply(input: T): T; }\n\ntype Factory<T> = () => Transformation<T>;\n\nclass Pipeline<T> {\n  constructor(private steps: Transformation<T>[]) {}\n  run(input: T): T {\n    return this.steps.reduce((acc, s) => s.apply(acc), input);\n  }\n}\n\nconst registry = new Map<string, Factory<any>>();\n\nfunction register<T>(name: string, factory: Factory<T>) {\n  registry.set(name, factory);\n}\n\nfunction create<T>(name: string): Transformation<T> {\n  const f = registry.get(name);\n  if (!f) throw new Error(`Unknown transformation: ${name}`);\n  return f();\n}\n```\n\n## Follow-up Questions\n- How would you handle versioning of transformations and ensure backward compatibility?\n- How would you test pipelines with dynamic registries and ensure deterministic ordering?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","LinkedIn","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T07:28:39.620Z","createdAt":"2026-01-12T07:28:39.620Z"},{"id":"q-802","question":"Design a unit-test framework runner that supports multiple assertion styles (classic, fluent, should). The goal is to add a new assertion style (e.g., expect) at runtime without modifying the runner core. Which design pattern would be chosen and how would the minimal interfaces and a registry be structured? Provide a usage example?","answer":"Use the Strategy pattern. The runner defines an AssertionStyle interface with a method assert(actual, expected). A registry maps style names to concrete styles and the runner delegates to the selected","explanation":"## Why This Is Asked\n\nTests often need new assertion styles without changing the runner. This probes understanding of decoupling via Strategy and a registry-based plug-in model.\n\n## Key Concepts\n\n- Strategy pattern\n- Open/Closed principle\n- Registry/Plug-in architecture\n- Lightweight interfaces\n\n## Code Example\n\n```javascript\nclass AssertionStyle {\n  assert(actual, expected) { throw new Error('not implemented') }\n}\nclass ClassicAssert extends AssertionStyle {\n  assert(actual, expected) { if (actual !== expected) throw new Error('mismatch') }\n}\nclass Runner {\n  constructor() { this.styles = new Map() }\n  register(name, style) { this.styles.set(name, style) }\n  assert(styleName, actual, expected) {\n    const style = this.styles.get(styleName)\n    style.assert(actual, expected)\n  }\n}\n```\n\n## Follow-up Questions\n\n- How to handle asynchronous assertions? \n- How to ensure thread safety in the registry? \n- How to provide a sensible default when a style is missing?","diagram":"flowchart TD\n  Runner[Runner] --> Style[AssertionStyle]\n  Style --> Classic[ClassicAssert]\n  Style --> Fluent[FluentAssert]\n  Style --> Should[ShouldAssert]","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Salesforce","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T08:33:41.435Z","createdAt":"2026-01-12T08:33:41.435Z"},{"id":"q-809","question":"Design a health-check framework for a fleet-management service. The system aggregates health from multiple subsystems (database, message broker, geolocation API). New checks (checkDiskSpace, checkApiLatency) must be added at runtime without touching the aggregator. Which pattern supports this, and how would you implement minimal interfaces and a usage example?","answer":"Use Composite with a runtime registry. Define IHealthCheck { string name; HealthStatus check(); }. Implement SimpleCheck and CheckGroup that aggregates children. HealthAggregator treats the group as a","explanation":"## Why This Is Asked\nThis tests pattern selection for runtime extensibility without touching core.\n\n## Key Concepts\n- Composite for hierarchical checks\n- Registry for dynamic extension\n- Lightweight HealthStatus aggregation\n\n## Code Example\n```javascript\ninterface IHealthCheck { name: string; check(): HealthStatus }\nclass SimpleCheck implements IHealthCheck { constructor(name, fn){...} check(){return new HealthStatus(...)}}\nclass CheckGroup implements IHealthCheck { constructor(name){this.children=[]} add(c){this.children.push(c)} check(){return aggregate(this.children)}}\n```\n\n## Follow-up Questions\n- How would you test a newly added check in isolation?\n- How would you report partial health vs. critical failure to a dashboard?","diagram":"flowchart TD\n  HealthAggregator[Health Aggregator] --> DB[Database Health]\n  HealthAggregator --> Broker[Broker Health]\n  HealthAggregator --> Geo[Geolocation API Health]\n  Registry[Runtime Registry] --> DiskSpace[Disk Space Check]\n","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T09:34:35.011Z","createdAt":"2026-01-12T09:34:35.011Z"},{"id":"q-819","question":"You are designing a log export module for a distributed service. It must support exporting archives to multiple backends (S3, GCS, and an on-prem object store). New backends should be addable at runtime without touching the exporter or consumer code. Design the architecture using a design pattern that lets you plug in new backends via a registry. Provide a minimal interface and usage example?","answer":"Implement a Plugin-style archival backend with a common interface Archiver { archive(batch: LogBatch): Promise<void> }. Create a Registry mapping keys ('s3','gcs','onprem') to factory callbacks. The e","explanation":"## Why This Is Asked\nTests a candidate's ability to design extensible, decoupled systems using pluggable backends and runtime registration. It requires a concrete interface, a registry, and a usage example showing how to add a new backend without modifying the exporter.\n\n## Key Concepts\n- Plugin/Registry pattern for extensibility\n- Dependency Inversion: exporter depends on Archiver abstraction, not concrete backends\n- Factory callbacks to instantiate backends at runtime\n\n## Code Example\n```javascript\n// Minimal interface\nclass Archiver {\n  async archive(batch) { throw new Error('Not implemented') }\n}\n\n// Registry\nconst Registry = {\n  _constructors: new Map(),\n  register(key, factory) { Registry._constructors.set(key, factory) },\n  create(key) { const f = Registry._constructors.get(key); return f ? f() : null }\n}\n\n// Usage\n// Backend implementation\nclass S3Archiver extends Archiver {\n  async archive(batch) { /* push to S3 */ }\n}\nRegistry.register('s3', () => new S3Archiver())\n\n// Exporter uses registry\nconst archiver = Registry.create('s3')\narchiver.archive({/* batch */})\n```\n\n## Follow-up Questions\n- How would you handle lifecycle, retries, and backpressure when a backend is down?\n- How would you verify at compile-time that a backend implements the Archiver interface?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Netflix","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T10:28:02.394Z","createdAt":"2026-01-12T10:28:02.395Z"},{"id":"q-824","question":"Design a pluggable text-formatting pipeline for a CLI tool. The pipeline should allow new transforms to be added at runtime via a registry, without touching the core pipeline. Use a suitable pattern to compose these transforms in order; provide a minimal interface and a usage example?","answer":"Pattern: a pluggable text-formatting pipeline (pipeline/chain). Each transform is a small unit registered by name; the Pipeline composes them in order at runtime. Minimal interface exposes apply(text)","explanation":"## Why This Is Asked\n\nTests ability to design extensible text processing with runtime plugins, without touching core; demonstrates a clean separation of concerns and Open/Closed compliance.\n\n## Key Concepts\n- Pipeline/Chain of Responsibility pattern\n- Runtime registry for extensibility\n- Minimal transform interface and composition order\n- Deterministic, idempotent transforms\n\n## Code Example\n\n```javascript\nclass Transform {\n  constructor(name, fn) { this.name = name; this.fn = fn; }\n  apply(text) { return this.fn(text); }\n}\nclass Registry {\n  constructor(){ this.factories = new Map(); }\n  register(name, factory){ this.factories.set(name, factory); }\n  create(name){ const f = this.factories.get(name); return f ? f() : null; }\n}\nclass Pipeline {\n  constructor(registry, names){ this.transforms = names.map(n => registry.create(n)).filter(t => t); }\n  run(input){ return this.transforms.reduce((acc, t) => t.apply(acc), input); }\n}\n\nconst registry = new Registry();\nregistry.register('trim', () => new Transform('trim', s => s.trim()));\nregistry.register('collapseSpaces', () => new Transform('collapseSpaces', s => s.replace(/\\s+/g, ' ')));\nregistry.register('toUpper', () => new Transform('toUpper', s => s.toUpperCase()));\n\nconst names = ['trim','collapseSpaces','toUpper'];\nconst pipeline = new Pipeline(registry, names);\nconsole.log(pipeline.run('  hello   world  ')); // 'HELLO WORLD'\n```\n\n## Follow-up Questions\n- How would you handle asynchronous transforms in this pipeline?\n- How would you order or deduplicate transforms registered at runtime to guarantee deterministic results?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Hashicorp","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T11:20:58.692Z","createdAt":"2026-01-12T11:20:58.692Z"},{"id":"q-833","question":"You're building a streaming analytics dashboard where widgets render different metrics. New chart renderers can be added at runtime by third-party teams without modifying core widgets. Design the architecture using a design pattern that supports pluggable renderers via a registry. Provide a minimal interface and a usage example?","answer":"Use a Plugin Registry with a Strategy-like Renderer interface. Define a Renderer interface with render(data, container). Maintain a Registry<string, RendererFactory> that creates concrete renderers (C","explanation":"## Why This Is Asked\nTests ability to design an extensible UI plugin system without touching core widgets, a common Netflix/Tesla/Nvidia scenario.\n\n## Key Concepts\n- Plugin registry for runtime extensibility\n- Strategy/Factory for pluggable renderers\n- Loose coupling between Widget and Renderer\n- Runtime loading and versioning considerations\n\n## Code Example\n```javascript\ninterface Renderer {\n  render(data: any, container: HTMLElement): void\n}\nclass SvgRenderer implements Renderer {\n  render(data: any, container: HTMLElement) { /* draw SVG */ }\n}\nclass Registry {\n  private map = new Map<string, (ctx?: any) => Renderer>()\n  register(name: string, factory: (ctx?: any) => Renderer) { this.map.set(name, factory) }\n  create(name: string, ctx?: any) { return this.map.get(name)!(ctx) }\n}\n```\n\n## Follow-up Questions\n- How would you secure the plugin loading to avoid untrusted code?\n- How would you handle renderer versioning compatibility?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["NVIDIA","Netflix","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T12:44:13.123Z","createdAt":"2026-01-12T12:44:13.123Z"}],"subChannels":["general"],"companies":["Adobe","Airbnb","Amazon","Anthropic","Apple","Bloomberg","Citadel","Cloudflare","Coinbase","Discord","DoorDash","Google","Hashicorp","Hugging Face","IBM","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Netflix","Oracle","Plaid","Robinhood","Salesforce","Scale Ai","Snowflake","Square","Stripe","Tesla","Twitter","Uber","Zoom"],"stats":{"total":25,"beginner":11,"intermediate":7,"advanced":7,"newThisWeek":25}}