{"questions":[{"id":"q-1146","question":"You're building a data ingestion service that validates JSON records before persisting them. Validation steps include NonEmpty fields, Email format, and PasswordStrength. Validators must be pluggable: new validators can be added at runtime by registering them into a Registry without touching the core pipeline. Design a minimal interface and registry, and show how to compose and execute the pipeline with a sample config. Include how to add a new validator and run the pipeline, returning the first failure?","answer":"Implement a Validator interface with validate(record) -> {ok:boolean, error?:string}. Maintain a Registry<string, () => Validator> extendable at runtime. ValidationPipeline reads a list of keys from c","explanation":"## Why This Is Asked\n\nTests ability to design a pluggable validation system that can be extended without touching core logic, a common real-world requirement in ingestion pipelines.\n\n## Key Concepts\n\n- Registry/Factory pattern for runtime extensibility\n- Pipeline that composes validators by config\n- Early exit on first failure for efficient feedback\n\n## Code Example\n\n```javascript\n// Minimal interface and registry\nclass Validator {\n  validate(record) { return { ok: true }; }\n}\nclass EmailValidator extends Validator {\n  validate(record) {\n    const ok = /^[^@]+@[^@]+\\.[^@]+$/.test(record.email || '');\n    return ok ? { ok: true } : { ok: false, error: 'Invalid email' };\n  }\n}\nconst Registry = new Map();\nfunction register(name, factory) { Registry.set(name, factory); }\nfunction createValidator(name) { const f = Registry.get(name); return f ? f() : null; }\n\nclass ValidationPipeline {\n  constructor(registry, keys) {\n    this.registry = registry;\n    this.keys = keys;\n  }\n  validate(record) {\n    for (const k of this.keys) {\n      const v = this.registry.get(k) ? this.registry.get(k)() : null;\n      if (!v) continue;\n      const res = v.validate(record);\n      if (!res.ok) return res;\n    }\n    return { ok: true };\n  }\n}\n\n// Usage\nregister('Email', () => new EmailValidator());\nregister('NonEmpty', () => new Validator());\nconst keys = ['Email'];\nconst pipeline = new ValidationPipeline(Registry, keys);\nconst result = pipeline.validate({ email: 'a@b.com' });\n```\n\n## Follow-up Questions\n\n- How would you handle async validators?\n- How would you test the registry and pipeline separately?\n- How would you version validators and roll back if a validator changes semantics?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Square","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T01:32:17.318Z","createdAt":"2026-01-13T01:32:17.318Z"},{"id":"q-1201","question":"Design a runtime-pluggable per-message transformation system for a streaming pipeline. Messages include metadata that determines the transformation strategy (e.g., enrich, normalize, validate). Implement with a design pattern that lets you add new strategies without modifying the pipeline core. Provide minimal interfaces, a registry, and a usage example?","answer":"Interface: Transformation { apply(msg): Msg }. Implementations: EnrichTransformation, NormalizeTransformation, ValidateTransformation. Registry maps string -> TransformationFactory; pipeline uses reso","explanation":"## Why This Is Asked\nThis tests depth in plug-in style pattern design for real-time data processing, ensuring new transformers can be added without mutating core code, a common need in SaaS pipelines.\n\n## Key Concepts\n- Plugin/Registry pattern for runtime extensibility\n- Lightweight interfaces and factories\n- Thread-safety and hot-reload considerations\n\n## Code Example\n```javascript\nclass Transformation {\n  apply(msg) { throw new Error('not implemented') }\n}\nclass EnrichTransformation extends Transformation {\n  apply(msg) { /* enrich */ return msg }\n}\nclass NormalizeTransformation extends Transformation {\n  apply(msg) { /* normalize */ return msg }\n}\nclass ValidateTransformation extends Transformation {\n  apply(msg) { /* validate */ return msg }\n}\nclass TransformationRegistry {\n  constructor() { this._factories = new Map() }\n  register(name, factory) { this._factories.set(name, factory) }\n  create(name) { const f = this._factories.get(name); return f ? f() : null }\n}\n// Usage\nconst registry = new TransformationRegistry()\nregistry.register('enrich', () => new EnrichTransformation())\nconst t = registry.create('enrich')\nconst out = t?.apply(msg)\n```\n\n## Follow-up Questions\n- How would you handle thread-safety and hot-reload of strategies at runtime?\n- How would you test the registry and individual strategies?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Plaid","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T04:48:59.080Z","createdAt":"2026-01-13T04:48:59.080Z"},{"id":"q-1236","question":"Design a runtime-pluggable, per-route transformer and throttling policy system for a real-time event router. Each route maps an event type to a transformer and a rate-limit policy; new transformers (enrich, redact, normalize) and new policies (token-bucket, fixed-window, leaky-bucket) must be addable at runtime without touching the router core. Which pattern would you adopt and how would you structure the minimal interfaces and registry?","answer":"Use a Plugin Registry with the Strategy pattern. Define Transformer { transform(Event): Event } and Policy { allow(Event, rate): boolean }. Router stores RouteKey -> (TransformerName, PolicyName) and ","explanation":"## Why This Is Asked\n\nThis tests designing for open-closed, runtime extensibility, and safe plugin loading in high-throughput systems like those at scale. It also probes trade-offs between reflection, isolation, and static typing.\n\n## Key Concepts\n\n- Plugin Registry\n- Strategy\n- Open/Closed Principle\n- Dynamic loading and sandboxing\n\n## Code Example\n\n```javascript\nclass Transformer { transform(event){return event} }\nclass Policy { allow(event, rate){return true} }\n```\n\n## Follow-up Questions\n\n- How to version plugins and rollback\n- How to enforce plugin isolation and security in a multi-tenant environment","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Oracle","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T06:33:28.616Z","createdAt":"2026-01-13T06:33:28.616Z"},{"id":"q-1258","question":"Design a runtime-extensible notification dispatch system that handles multiple channels (email, SMS, push) where new transports and their backoff strategies can be added at runtime via a registry without touching the core dispatcher. Specify the minimal interfaces, how you register a new transport and a new backoff policy, and show a usage example including adding a WhatsApp transport and a geometric backoff?","answer":"Implement a Dispatcher that routes by channel to a pluggable Transport. Each Transport exposes send(event, payload) and a factory for instantiation. A Registry holds transports and backoff policies; n","explanation":"## Why This Is Asked\n\nTests ability to design plugin architecture with runtime extension, isolation, and versioning.\n\n## Key Concepts\n\n- Plugin registry\n- Strategy/Factory patterns\n- Thread-safety and hot-reload\n- Backoff policy composition\n\n## Code Example\n\n```javascript\n// Minimal interfaces and registry (pseudo)\ninterface Transport { send(event, payload): Promise<void> }\ninterface TransportFactory { create(config?: any): Transport }\nclass Registry {\n  private transports = new Map<string, TransportFactory>();\n  register(name, factory) { this.transports.set(name, factory); }\n  create(name, config) { return this.transports.get(name).create(config); }\n}\ninterface BackoffPolicy { nextDelay(attempt:number): number }\nclass GeometricBackoff implements BackoffPolicy { nextDelay(a){ return Math.pow(2, a) * 100; } }\n```\n\n## Follow-up Questions\n\n- How would you ensure thread-safety and avoid memory leaks when plugins are loaded/unloaded?\n- How would you test the registry and dynamic loading?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","DoorDash","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T07:23:57.353Z","createdAt":"2026-01-13T07:23:57.353Z"},{"id":"q-1300","question":"Design a feature-flag evaluation engine for a large SaaS product. Flags support boolean, percentage rollout, user-segment, and A/B bucket strategies. Create a pluggable evaluator where new strategies can be added at runtime via a Registry without touching the core evaluator. Provide interfaces, a thread-safe registry, and a usage example with versioned strategy lookup?","answer":"Use Strategy pattern: FlagEvaluationStrategy with evaluate(user, flag) and a factory-based Registry. The core evaluator queries registry with key flagName|version, creates a strategy, and calls evalua","explanation":"## Why This Is Asked\nTests runtime extensibility and correctness of flag evaluation, including versioning and thread-safety.\n\n## Key Concepts\n- Strategy pattern for evaluation logic\n- Registry/Factory for runtime additions\n- Thread-safety and version-keying\n- Performance implications of dynamic dispatch\n\n## Code Example\n```typescript\ninterface User { id: string; segments: string[]; }\ninterface Flag { name: string; version: string; defaultValue?: boolean; }\n\ninterface FlagEvaluationStrategy {\n  evaluate(user: User, flag: Flag): boolean;\n}\ntype StrategyFactory = () => FlagEvaluationStrategy;\n\nclass FlagRegistry {\n  private map = new Map<string, StrategyFactory>();\n  register(key: string, factory: StrategyFactory) { this.map.set(key, factory); }\n  get(key: string): FlagEvaluationStrategy {\n    const f = this.map.get(key);\n    if (!f) throw new Error(`No strategy registered for ${key}`);\n    return f();\n  }\n}\nclass FlagEvaluator {\n  constructor(private registry: FlagRegistry) {}\n  eval(flag: Flag, user: User): boolean {\n    const strat = this.registry.get(`${flag.name}|${flag.version}`);\n    return strat.evaluate(user, flag);\n  }\n}\nclass PercentStrategy implements FlagEvaluationStrategy {\n  constructor(private percent: number) {}\n  evaluate(user: User, flag: Flag): boolean {\n    const r = (parseInt(user.id.slice(-4), 10) % 100) < this.percent;\n    return r;\n  }\n}\n```","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Google","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T08:45:51.433Z","createdAt":"2026-01-13T08:45:51.433Z"},{"id":"q-2360","question":"Design a Runtime-Configurable Cache Eviction Engine: build a cache component that supports multiple eviction policies (LRU, LFU, Time-based); policies can be swapped at runtime without restarting the app. Use a pattern that lets you add new eviction strategies via a registry. Provide minimal interfaces, how to register/deregister policies, and an example usage that demonstrates policy switch mid-flight with ongoing hits?","answer":"Use Strategy with a Registry. EvictionStrategy has onAccess(key, value, cache) and evictIfNeeded(cache). Cache holds a concurrent map, capacity, and an AtomicReference<EvictionStrategy> active. A Regi","explanation":"## Why This Is Asked\nThis question tests pragmatic design for runtime pluggability of eviction policies without restart, a common real-world constraint.\n\n## Key Concepts\n- Strategy pattern with a pluggable registry\n- Thread-safe runtime reconfiguration\n- Minimal interfaces and factory-based registries\n- Trade-offs between policy complexity and memory overhead\n\n## Code Example\n```javascript\nclass EvictionStrategy {\n  onAccess(key, value, cache) {}\n  evictIfNeeded(cache) {}\n}\nclass Registry {\n  constructor() { this.factories = new Map(); }\n  register(name, factory) { this.factories.set(name, factory); }\n  create(name) { const f = this.factories.get(name); return f ? f() : null; }\n}\nclass Cache {\n  constructor(capacity) {\n    this.map = new Map();\n    this.capacity = capacity;\n    this.active = null;\n    this.registry = new Registry();\n  }\n  get(key) {\n    const v = this.map.get(key);\n    if (v !== undefined) this.active?.onAccess(key, v, this);\n    return v;\n  }\n  put(key, value) {\n    this.map.set(key, value);\n    if (this.map.size > this.capacity) this.active?.evictIfNeeded(this);\n  }\n  switchPolicy(name) { this.active = this.registry.create(name); }\n}\n```\n\n## Follow-up Questions\n- How to ensure eviction state migrations when changing policies?\n- How to test policy swap without locking performance?\n- How to handle policy-specific metrics and backpressure?","diagram":"flowchart TD\n  Cache(Cache) --> Registry[PolicyRegistry]\n  Registry --> ActivePolicy[ActivePolicy]\n  Cache --> GetPut[Get/Put]\n  GetPut --> Evict[Eviction]","difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T14:48:47.529Z","createdAt":"2026-01-15T14:48:47.529Z"},{"id":"q-2513","question":"Design a runtime-extensible data-format converter: the tool accepts files in JSON, CSV, and XML and should support new formats at runtime without touching the core converter. Which design pattern fits, and how would you structure minimal interfaces and a registry? Provide a usage example?","answer":"Use the Strategy pattern. Create a Format interface with parse(String):Data and serialize(Data):String, plus concrete JsonFormat, CsvFormat, XmlFormat. A FormatRegistry maps file extensions to supplie","explanation":"## Why This Is Asked\n\nDemonstrates open-closed extensibility by adding formats without changing the converter.\n\n## Key Concepts\n\n- Strategy pattern\n- Registry / Plugin pattern\n- Open/Closed Principle\n\n## Code Example\n\n```javascript\ninterface Format {\n  parse(str) \n  serialize(data)\n}\nclass JsonFormat implements Format { /* ... */ }\n```\n\n## Follow-up Questions\n\n- How would you handle format versioning?\n- How to ensure thread-safe registry access in concurrent runs?","diagram":"flowchart TD\n  Converter --> Registry\n  Registry --> JsonFormat\n  Registry --> CsvFormat\n  Registry --> XmlFormat\n  Converter --> JsonFormat","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T20:55:20.154Z","createdAt":"2026-01-15T20:55:20.154Z"},{"id":"q-2603","question":"Design a runtime-pluggable routing layer for a microservice gateway that allows adding new load-balancing and circuit-breaker strategies without touching the gateway core. Endpoints declare a strategy name and optional config; a central registry wires strategy instances to endpoints. Include minimal interfaces, a registry, and a usage example. How would you structure tests for correctness and fault tolerance?","answer":"Leverage the Strategy pattern for load balancing and circuit breakers, combined with a Registry/Factory pattern to map strategy names to concrete implementations. Define minimal interfaces such as `LoadBalancer` with a `next(targets)` method and `CircuitBreaker` with an `allowRequest()` method. The registry maintains strategy factories that create configured instances per endpoint, enabling runtime pluggability without modifying the gateway core.","explanation":"## Why This Is Asked\n\nThis question evaluates your ability to design extensible systems using advanced pattern composition: runtime extension of routing behavior through Strategy + Registry patterns, while ensuring testability and safety in production gateway environments.\n\n## Key Concepts\n\n- Strategy pattern for pluggable algorithms\n- Registry and Factory for dynamic instantiation\n- Composite routing with per-endpoint configuration\n- Observability and comprehensive fault tolerance testing\n\n## Code Example\n\n```javascript\n// Implementation sketch\nclass LoadBalancer { next(targets) {} }\nclass CircuitBreaker { allowRequest() { ... } }\nclass Registry { register(name, factory) ... get(name) ... }\n```\n\n## Follow-up Questions\n\n- How to version strategies for backward compatibility?\n- What observability metrics should each strategy expose?\n- How would you handle strategy hot-reloading in production?","diagram":"flowchart TD\n  Strategy --> Registry\n  Registry --> Endpoint\n  Endpoint --> LoadBalancer\n  Endpoint --> CircuitBreaker","difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Tesla","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T05:02:58.995Z","createdAt":"2026-01-16T02:32:44.699Z"},{"id":"q-2630","question":"In a mobile analytics SDK, events must be emitted in multiple serialization formats (JSON, MessagePack, Protobuf). Design a runtime-pluggable serializer system so new formats can be added without touching the producer. Which design pattern fits, and how would you structure a minimal Serializer interface, a Registry mapping names to serializers, and a usage example?","answer":"Use the Strategy pattern: define a Serializer interface with serialize(event) -> bytes, implement JsonSerializer, MsgPackSerializer, ProtobufSerializer, and build a SerializerRegistry that maps format","explanation":"## Why This Is Asked\nTests open-closed principle and plug-in extension for evolving formats.\n\n## Key Concepts\n- Strategy pattern for interchangeable serializers\n- Minimal interface per formatter\n- Registry/factory for runtime lookup\n- Open extension without modifying producers\n\n## Code Example\n```javascript\ninterface Serializer { serialize(event: Event): Uint8Array }\nclass JsonSerializer implements Serializer { serialize(e){ /*...*/ } }\nclass MsgPackSerializer implements Serializer { serialize(e){ /*...*/ } }\nclass SerializerRegistry {\n  private map = new Map<string, () => Serializer>();\n  register(name: string, ctor: () => Serializer){ this.map.set(name, ctor) }\n  get(name: string){ const c = this.map.get(name); return c ? c() : null }\n}\n```\n\n## Follow-up Questions\n- How would you handle versioned formats?\n- How to test the registry and serializers without real data?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Netflix","Robinhood","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T04:14:07.267Z","createdAt":"2026-01-16T04:14:07.267Z"},{"id":"q-2798","question":"Design a runtime-pluggable access-control system for a cloud storage service. The core stores resources; you must support multiple policy types (RBAC, ABAC, and custom dynamic policies) added at runtime without recompiling. Explain the minimal interfaces, a Registry, and how policies are evaluated per operation; include an example usage involving uploading a file with user attributes and resource metadata?","answer":"Design a runtime-pluggable access-control system for a cloud storage service. Define a Policy interface with evaluate(context) -> allow/deny; a Registry to register RBAC, ABAC, and custom dynamic poli","explanation":"## Why This Is Asked\nTests ability to design a plugin-based policy engine with runtime extensibility, cross-cutting concerns (authorization and auditing), and clear integration points in a scalable system.\n\n## Key Concepts\n- Plugin registry for policy modules\n- Policy interface and evaluation semantics\n- Policy composition (Chain/AllOf) and short-circuiting\n- Enforcement point placement and auditing\n\n## Code Example\n```javascript\nclass Policy {\n  evaluate(ctx) { throw new Error('not implemented') }\n}\nclass Registry {\n  constructor(){ this._map = new Map() }\n  register(name, factory){ this._map.set(name, factory) }\n  create(name, opts){ return this._map.get(name)(opts) }\n}\nclass PolicyChain {\n  constructor(policies){ this.policies = policies }\n  evaluate(ctx){\n    for (const p of this.policies){ if (!p.evaluate(ctx)) return false }\n    return true\n  }\n}\n```\n\n## Follow-up Questions\n- How handle conflicting decisions between policies? \n- How to test performance and correctness under load? \n- How to evolve policy schemas without breaking existing ones?","diagram":"flowchart TD\n  A[Client Request] --> B[Enforcement Point]\n  B --> C[PolicyChain]\n  C --> D[Policy1]\n  C --> E[Policy2]\n  D --> F[Decision]\n  E --> F\n  F --> G[Audit Log]\n  G --> H[Access Granted/Denied]","difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T13:04:33.166Z","createdAt":"2026-01-16T13:04:33.166Z"},{"id":"q-2992","question":"Design a runtime-extensible data-mapping system for a real-time event ingestion pipeline used by Stripe, Two Sigma, and Discord. Incoming events vary by source; implement a pluggable FieldMapper pattern that supports PassThrough, RenameFields, ComputedFields (expressions), and FlattenNested. Mappers must be addable at runtime via a registry without touching core. Describe minimal interfaces, registry structure, and a concrete usage scenario?","answer":"Define a FieldMapper interface with transform(input: Record) -> Record. Implement concrete mappers: PassThrough, RenameFields(config: {old: new}), ComputedFields(config: 'total = price * qty'), Flatte","explanation":"## Why This Is Asked\n\nTests ability to design a runtime-extensible plugin system for data transformation where new mappers can be added without touching core pipelines, a common need in data-heavy products.\n\n## Key Concepts\n\n- Strategy/Plugin pattern\n- Registry/Factory for runtime extensibility\n- Lightweight data modeling with minimal interfaces\n- Expression-based field computation and safe evaluation\n\n## Code Example\n\n```javascript\n// Minimal interface and sample mappers\nclass FieldMapper {\n  transform(input) { throw new Error('Not implemented'); }\n}\nclass PassThrough extends FieldMapper { transform(i) { return i; } }\nclass RenameFields extends FieldMapper { constructor(cfg){ super(); this.map = cfg; } transform(i){ const out={}; for(const k in i){ out[this.map[k]||k]=i[k]; } return out; } }\nclass ComputedFields extends FieldMapper { constructor(expr){ super(); this.expr=expr; } transform(i){ // naive eval\n  const out={...i}; out.total = i.price * i.qty; return out; } }\nclass FlattenNested extends FieldMapper { constructor(cfg){ super(); this.path=cfg.path; } transform(i){ const v = i[this.path] || {}; return { ...i, ...v }; } }\n```\n\n## Follow-up Questions\n\n- How would you handle security and sandboxing for ComputedFields expressions?\n- How would you version and migrate mapper configurations across deployments?","diagram":"flowchart TD\n  A[Event] --> B{Mapper Registry}\n  B --> C[Mapper: PassThrough]\n  B --> D[Mapper: RenameFields]\n  B --> E[Mapper: ComputedFields]\n  B --> F[Mapper: FlattenNested]\n  C --> G[OutputEvent]\n  D --> G\n  E --> G\n  F --> G","difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Stripe","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T20:34:00.524Z","createdAt":"2026-01-16T20:34:00.524Z"},{"id":"q-3085","question":"Design a small undoable text editor using the Command pattern. The editor supports insert and delete operations; each action should be a Command with execute and undo, and a History stack should manage undo/redo. How would you structure the interfaces and a minimal example showing inserting 'A' at position 0 and then undoing?","answer":"Use the Command pattern: define a Command interface with execute() and undo() methods. Implement InsertCommand and DeleteCommand that operate on a TextEditor receiver and capture the necessary state for undo operations (position and content).","explanation":"## Why This Is Asked\n\nThis question tests understanding of the Command pattern, undo/redo implementation, and state management in a minimal system.\n\n## Key Concepts\n\n- Command pattern with execute/undo methods\n- Receiver (TextEditor) and Command objects\n- History stack for undo/redo operations\n- State capture for reversible operations\n- Edge cases: boundary checking, no-op commands\n\n## Code Example\n\n```javascript\nclass Editor {\n  constructor() { this.text = ''; }\n  \n  insert(pos, ch) {\n    this.text = this.text.slice(0, pos) + ch + this.text.slice(pos);\n  }\n  \n  delete(pos, len) {\n    const removed = this.text.slice(pos, pos + len);\n    this.text = this.text.slice(0, pos) + this.text.slice(pos + len);\n    return removed;\n  }\n}\n\nclass InsertCommand {\n  constructor(editor, pos, ch) {\n    this.editor = editor;\n    this.pos = pos;\n    this.ch = ch;\n  }\n  \n  execute() {\n    this.editor.insert(this.pos, this.ch);\n  }\n  \n  undo() {\n    this.editor.delete(this.pos, 1);\n  }\n}\n\nclass History {\n  constructor() {\n    this.undoStack = [];\n    this.redoStack = [];\n  }\n  \n  execute(command) {\n    command.execute();\n    this.undoStack.push(command);\n    this.redoStack = [];\n  }\n  \n  undo() {\n    if (this.undoStack.length === 0) return;\n    const command = this.undoStack.pop();\n    command.undo();\n    this.redoStack.push(command);\n  }\n}\n\n// Example: Insert 'A' at position 0, then undo\nconst editor = new Editor();\nconst history = new History();\nconst insertA = new InsertCommand(editor, 0, 'A');\n\nhistory.execute(insertA); // text = 'A'\nhistory.undo(); // text = ''\n```\n\n## Implementation Notes\n\n- Commands capture all state needed for undo\n- History maintains separate undo/redo stacks\n- Each operation is atomic and reversible\n- Position validation ensures safe operations","diagram":"flowchart TD\nA[Start] --> B[Execute Command]\nB --> C[Push to History]\nC --> D[Undo/Redo]\nD --> E[End]","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Scale Ai","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T05:06:49.949Z","createdAt":"2026-01-17T02:08:45.601Z"},{"id":"q-3153","question":"Design a runtime-extensible request-validation engine for an API gateway: validators for JSON schema, business rules, and anti-abuse checks should be addable at runtime without touching the gateway core. Describe the architecture using a design pattern that supports pluggable validators via a registry, minimal interfaces, and a runtime usage example?","answer":"Use a Plugin/Registry pattern. Define Validator with validate(req): ValidationResult. The Registry provides an ordered list per route. Validators loadable at runtime from a secure plugin store; on con","explanation":"## Why This Is Asked\n\nThis question probes how to extend gateway behavior without redeploys, focusing on runtime plugin loading, ordering, and failure handling.\n\n## Key Concepts\n\n- Plugin/Registry pattern\n- Composite/short-circuit validation\n- Runtime configuration reload\n- Security and isolation of plugins\n\n## Code Example\n\n```javascript\n// Minimal interfaces\nclass Validator { validate(req) { } }\nclass Registry { getValidatorsForRoute(route) { return []; } }\n```\n\n## Follow-up Questions\n\n- How would you version validators and roll back a faulty one?\n- How do you test the registry-driven pipeline end-to-end?","diagram":"flowchart TD\n  G(API_Gateway) --> R[Validator Registry]\n  R --> P{Validators}\n  P -->|pass| S[Route to Service]\n  P -->|fail| E[Error Response]","difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Netflix","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T04:48:54.183Z","createdAt":"2026-01-17T04:48:54.184Z"},{"id":"q-3180","question":"Design a runtime-extensible authorization policy engine that supports multiple policy languages (RBAC, ABAC, ACL) and allows new languages to be added at runtime without touching the core. Describe the minimal interfaces and a registry mechanism; show how evaluation proceeds for a given user, resource, and action. Provide a concrete usage example registering a new language and evaluating a request?","answer":"Use a PolicyLanguage interface with evaluate(user, resource, action) -> boolean and a PolicyEngine that holds a Registry<string, () => PolicyLanguage>. New languages (RBAC, ABAC, ACL) are added by reg","explanation":"## Why This Is Asked\nAsks how to extend authorization without touching core, using a plugin/strategy approach to support multiple policy languages at runtime.\n\n## Key Concepts\n- Plugin architecture\n- Registry and factories\n- Strategy-like policy evaluation\n- Runtime extensibility and isolation\n\n## Code Example\n```javascript\n// Minimal TypeScript-like sketch\ninterface PolicyLanguage {\n  evaluate(user: any, resource: any, action: string): boolean;\n}\nclass RBACPolicy implements PolicyLanguage {\n  constructor(defs: any) {}\n  evaluate(user: any, resource: any, action: string): boolean { /*RBAC logic*/ return true; }\n}\nclass ABACPolicy implements PolicyLanguage {\n  constructor(attrs: any) {}\n  evaluate(user: any, resource: any, action: string): boolean { /*ABAC logic*/ return true; }\n}\n\nclass PolicyEngine {\n  private registry: any = {};\n  register(lang: string, factory: () => PolicyLanguage) { this.registry[lang] = factory; }\n  evaluate(user: any, resource: any, action: string, lang?: string): boolean {\n    const factory = lang ? this.registry[lang] : this.registry['default'];\n    const policy = factory();\n    return policy.evaluate(user, resource, action);\n  }\n}\n```\n\n## Follow-up Questions\n- How would you handle conflicting policies across languages?\n- How would you hot-swap policies without restart and ensure thread safety?","diagram":"flowchart TD\n  A[PolicyEngine] --> B{Language registry}\n  B --> C[RBACPolicy]\n  B --> D[ABACPolicy]\n  A --> E[Evaluate(user, resource, action)]","difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Meta","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T05:41:10.098Z","createdAt":"2026-01-17T05:41:10.098Z"},{"id":"q-3234","question":"Design a runtime-pluggable authentication mechanism for an API gateway that must support multiple methods: API key, OAuth2 bearer token, and HMAC signatures. The gateway should be able to add new methods at runtime without modifying core logic. Provide a minimal interface, a registry of strategies, and a usage example?","answer":"Use the Strategy pattern: define an AuthStrategy interface with an authenticate(req) method; implement ApiKeyStrategy, OAuthStrategy, etc. Maintain a registry mapping method name to strategy factories","explanation":"## Why This Is Asked\n\nThis question tests open-closed principle discipline and practical extensibility in a security-critical path by requiring a clean interface and a small registry. It demonstrates how to grow capabilities without touching core logic.\n\n## Key Concepts\n\n- Strategy pattern\n- Registry (factory/DI) for runtime extensibility\n- Dependency management and testing considerations\n- Performance and error handling trade-offs\n\n## Code Example\n\n```javascript\ninterface AuthStrategy {\n  authenticate(req: any): boolean\n}\nclass ApiKeyStrategy implements AuthStrategy {\n  authenticate(req: any) { /* validate key in header */ return true }\n}\nclass OAuthStrategy implements AuthStrategy {\n  authenticate(req: any) { /* validate bearer token */ return true }\n}\n\nclass AuthRegistry {\n  private map = new Map<string, AuthStrategy>()\n  register(name: string, s: AuthStrategy) { this.map.set(name, s) }\n  get(name: string): AuthStrategy { return this.map.get(name)! }\n}\n\n// usage\nconst registry = new AuthRegistry()\nregistry.register('apiKey', new ApiKeyStrategy())\nregistry.register('oauth', new OAuthStrategy())\n\nfunction handleRequest(req: any) {\n  const name = req.authMode // 'apiKey' or 'oauth'\n  const strat = registry.get(name)\n  if (strat.authenticate(req)) { /* proceed */ } else { /* reject */ }\n}\n```\n\n## Follow-up Questions\n\n- How would you test adding a new strategy without touching existing ones?\n- How would you manage lifecycle and DI for strategies in a multi-instance server?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","LinkedIn","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T07:44:38.774Z","createdAt":"2026-01-17T07:44:38.774Z"},{"id":"q-3436","question":"Design a runtime-pluggable rate limiter for a multi-tenant API gateway. It should support strategies like Token Bucket, Fixed Window, and Sliding Window, registerable at runtime and swappable per-tenant without recompiling core. Specify minimal interfaces, a registry, and how hot-swap is achieved, with a code-like usage example?","answer":"Use Strategy pattern with a RuntimeRegistry. Core: RateLimitStrategy interface; concrete: TokenBucket, FixedWindow, SlidingWindow. RateLimiter maintains Map<Tenant, RateLimitStrategy> and a Registry<S","explanation":"## Why This Is Asked\nReal-world systems need hot-swappable policies without redeploys; this tests patterns, thread-safety, and eviction strategies.\n\n## Key Concepts\n- Strategy, Registry, Atomic swap, Per-tenant policy\n- Thread-safety, hot-swapping, migration\n- Trade-offs: memory vs flexibility\n\n## Code Example\n```javascript\n// pseudo\ninterface RateLimitStrategy { allow(req): boolean }\nclass TokenBucket implements RateLimitStrategy {...}\nclass RateLimiter { Map tenants->RateLimitStrategy; Registry<String,Supplier<RateLimitStrategy>> registry }\n```\n\n## Follow-up Questions\n- How would you ensure atomic swaps during traffic spikes?\n- How to persist tenant policies across restarts?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["NVIDIA","Netflix","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T16:33:40.800Z","createdAt":"2026-01-17T16:33:40.801Z"},{"id":"q-3523","question":"Design a runtime-extensible API gateway policy engine where routing decisions, auth, and rate-limiting are driven by pluggable policies that can be registered at runtime without redeploying. Each policy implements a minimal interface and is discovered via a registry. Show minimal interfaces, a registry shape, and an example of adding a new 'geo-aware' rate-limiting policy. How would you ensure thread-safety and downtime-free hot reload during policy updates?","answer":"Use the Strategy pattern for policies and a runtime Registry to register policy definitions by name. Define a Policy interface: apply(ctx) returns decision data. Implement PolicyFactory to instantiate","explanation":"## Why This Is Asked\nTests ability to design a pluggable, runtime-extensible policy system for high-signal services like API gateways, focusing on lifecycle, concurrency, and hot-reload.\n\n## Key Concepts\n- Strategy pattern for interchangeable policies\n- Runtime registry for dynamic policy discovery\n- Thread-safety and hot-reload considerations\n\n## Code Example\n```typescript\ninterface RequestContext { route: string; user: User; metadata: any }\ninterface PolicyDecision { allow: boolean; reason?: string; quotas?: any }\ninterface Policy { apply(ctx: RequestContext): PolicyDecision }\nclass PolicyFactory { create(config: any): Policy }\n```\n\n## Follow-up Questions\n- How would you version policies and rollback safely?\n- How would you isolate policies across tenants and credentials?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","MongoDB","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T19:36:36.229Z","createdAt":"2026-01-17T19:36:36.230Z"},{"id":"q-3611","question":"Design a tiny logging framework with pluggable backends (console, file, remote). The core should not depend on concrete backends; instead, a registry maps names to backend factories and allows runtime extension. Provide interfaces, a minimal registry, and a usage example showing adding a 'syslog' backend and selecting backend via config?","answer":"Core exposes Backend interface and a Registry. Logger queries Registry for a backend by name and delegates log calls. Registry stores name->factory; new backends register themselves without touching L","explanation":"## Why This Is Asked\nTests the ability to design a simple plugin system using a registry and interface-based design, useful for extensibility in microservices.\n\n## Key Concepts\n- Registry pattern\n- Dependency inversion and interface-based design\n- Runtime extensibility with plugins\n- Minimal, testable API surface\n\n## Code Example\n```javascript\n// Minimal interfaces and wiring\nclass Backend {\n  log(level, msg) { throw new Error('not implemented') }\n}\nclass Registry {\n  constructor() { this._map = new Map() }\n  register(name, factory) { this._map.set(name, factory) }\n  get(name) { return this._map.get(name)() }\n}\nclass Logger { constructor(registry) { this._r = registry } log(level, msg) { this._r.get(level).log(level, msg) } }\n```\n\n## Follow-up Questions\n- How would you handle backend failures and fallback strategies?\n- How would you ensure thread-safety or process-wide singleton backends in a multi-process environment?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Slack","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T23:35:22.415Z","createdAt":"2026-01-17T23:35:22.415Z"},{"id":"q-3736","question":"Design a runtime-extensible log writer that outputs records in different formats. At runtime, the caller specifies the format by name (JSONL, CSV, NDJSON). The core writer must remain unchanged when adding new formats. Describe the architecture using a design pattern, provide minimal interfaces and a registry, and show a usage snippet?","answer":"Use the Strategy pattern for serializers plus a small Registry/Factory to map format names to concrete serializers. Define a Serializer interface with serialize(record) -> string, and implement JSONLS","explanation":"## Why This Is Asked\nTests knowledge of extending behavior without modifying core code (Open/Closed). It also assesses choosing a clean extension point (Strategy) and a simple registry to map runtime options to implementations.\n\n## Key Concepts\n- Strategy pattern\n- Registry/Factory\n- Open/Closed principle\n- Dependency injection\n\n## Code Example\n```javascript\nclass Serializer {\n  serialize(record) { throw new Error('Not implemented'); }\n}\nclass JSONLSerializer extends Serializer {\n  serialize(record) { return JSON.stringify(record) + '\\n'; }\n}\nclass CSVSerializer extends Serializer {\n  serialize(record) { /* minimal CSV escaping omitted for brevity */ return Object.values(record).join(','); }\n}\nclass NDJSONSerializer extends Serializer {\n  serialize(record) { return JSON.stringify(record) + '\\n'; }\n}\n```\n\n```javascript\n// Registry / factory\nconst Registry = {\n  jsonl: () => new JSONLSerializer(),\n  csv: () => new CSVSerializer(),\n  ndjson: () => new NDJSONSerializer()\n};\n\nfunction createWriter(format) {\n  const serializer = Registry[format]?.();\n  if (!serializer) throw new Error('Unknown format');\n  return {\n    write: (record) => serializer.serialize(record)\n  };\n}\n```\n\n## Follow-up Questions\n- How would you handle format-specific options (delimiter, headers)?\n- How would you test the registry and serializers in isolation?","diagram":"flowchart TD\n  W[Writer] --> SFactory[Serializer Factory/Registry]\n  SFactory --> JSONL[JSONLSerializer]\n  SFactory --> CSV[CSVSerializer]\n  SFactory --> NDJSON[NDJSONSerializer]\n  W --> S[Serializer instance]\n","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Snap","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T07:34:31.501Z","createdAt":"2026-01-18T07:34:31.501Z"},{"id":"q-3826","question":"Design a runtime-extensible feature-flag evaluation system for a multi-tenant platform. The system must support multiple evaluation strategies: boolean flags, context-aware rules (e.g., region and plan), and experiment-based A/B tests. New strategies should be pluggable at runtime via a registry without touching the core evaluator. Provide a minimal interface, a registry, and a usage example?","answer":"Use the Strategy pattern with a Registry. Core engine stores Map<string, EvaluatorFactory> and delegates evaluation to an Evaluator created by the factory. Evaluator implements boolean evaluate(Contex","explanation":"## Why This Is Asked\nTests ability to design extensible, runtime-extendable components with minimal coupling using Strategy + Registry patterns.\n\n## Key Concepts\n- Strategy: encapsulate evaluation logic per flag\n- Registry/Plugin: dynamic, runtime-extensible factories\n- Dependency Injection: decouples engine from evaluators\n- Thread-safety and versioning considerations for runtime extensions\n\n## Code Example\n```typescript\ninterface Context { tenantId: string; userId: string; region?: string; [key: string]: any }\ninterface Evaluator { evaluate(ctx: Context): boolean }\ninterface EvaluatorFactory { create(): Evaluator }\nclass Registry { private map = new Map<string, EvaluatorFactory>(); register(n: string, f: EvaluatorFactory) { this.map.set(n, f) } getFactory(n: string): EvaluatorFactory | undefined { return this.map.get(n) } }\nclass FlagEngine { constructor(private registry: Registry) {} isEnabled(flag: string, ctx: Context): boolean { const f = this.registry.getFactory(flag); if (!f) throw new Error(`Unknown flag: ${flag}`); return f.create().evaluate(ctx); } }\n```\n\n## Follow-up Questions\n- How would you handle hot-reload of strategies without restarting the service?\n- How would you version/evolve evaluator interfaces while keeping backward compatibility?","diagram":"flowchart TD\n  Engine[FlagEngine] --> Registry[Registry]\n  Registry -->|getFactory| Factory[EvaluatorFactory]\n  Factory --> Evaluator[Evaluator]\n  Evaluator --> Result[boolean]","difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Instacart","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T11:24:19.288Z","createdAt":"2026-01-18T11:24:19.289Z"},{"id":"q-3945","question":"Design a system where a base DataSource can be wrapped by any number of processing decorators (e.g., Logging, Masking, Compression). The decorators are registered by name at runtime and can be applied to a data source chain without changing the core. Implement minimal interfaces, a registry, and a usage example?","answer":"Approach: implement the Decorator pattern with a small Registry. Define DataSource { read() }, DataSourceDecorator implements DataSource and holds a DataSource; concrete decorators (Logging, Masking, ","explanation":"## Why This Is Asked\nTests ability to extend behavior without touching core logic, using Decorator and a runtime registry.\n\n## Key Concepts\n- Decorator pattern\n- Lightweight registry for runtime extension\n- Dynamic composition of wrappers\n\n## Code Example\n```javascript\n// Pseudocode showing interfaces and composition\n```\n## Follow-up Questions\n- How to guarantee decorator application order?\n- How to handle decorator errors without breaking the chain?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Slack","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T16:43:26.510Z","createdAt":"2026-01-18T16:43:26.510Z"},{"id":"q-3956","question":"Design a runtime-extensible resource pool that supports multiple eviction strategies (LRU, LFU, TTL). Each pool entry uses a policy selected by name at runtime, and new eviction strategies can be added without touching the pool core. Provide a minimal IPolicy interface, a PolicyRegistry, and a usage example showing how to plug a new policy for a given connection without recompiling the pool?","answer":"Use the Strategy pattern. Define IPolicy with onAccess and onEvict; implement LRUPolicy, LFUPolicy, TTLPolicy. PolicyRegistry registers and resolves by name; pool delegates eviction to the resolved po","explanation":"## Why This Is Asked\n\nTests ability to design runtime-extensible behavior via a registry and strategy-like eviction policies, with testable components and clear extension points.\n\n## Key Concepts\n\n- Strategy pattern\n- Registry for dynamic policy binding\n- Runtime extensibility without core changes\n- Testable policy interactions\n\n## Code Example\n\n```typescript\ntype Entry = { id: string; lastAccess: number; size: number };\n\ninterface IPolicy {\n  onAccess(entry: Entry): void;\n  onEvict(entries: Entry[]): boolean;\n}\n\nclass LRUPolicy implements IPolicy {\n  onAccess(_e: Entry) { /* update recency */ }\n  onEvict(_entries: Entry[]): boolean { /* evict oldest */ return true; }\n}\n\nclass TTLPolicy implements IPolicy {\n  constructor(private ttl: number) {}\n  onAccess(_e: Entry) { /* refresh */ }\n  onEvict(_entries: Entry[]): boolean { /* compare now - lastAccess > ttl */ return true; }\n}\n\nclass PolicyRegistry {\n  private map = new Map<string, IPolicy>();\n  register(name: string, p: IPolicy) { this.map.set(name, p); }\n  resolve(name: string): IPolicy { return this.map.get(name)!; }\n}\n```\n\n## Follow-up Questions\n\n- How would you test race conditions when policies are registered concurrently?\n- What are the tradeoffs of per-entry policy resolution vs a single global policy for performance?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Cloudflare","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T17:26:21.684Z","createdAt":"2026-01-18T17:26:21.686Z"},{"id":"q-4119","question":"Design a runtime-extensible transport layer for a data ingestion service that can route data to HTTP, Kafka, or gRPC transports. New transports should be pluggable at runtime without changing core; design a minimal interface and a registry to support this. Which design pattern would you choose and how would you implement it? Provide a usage example?","answer":"Use the Strategy pattern with a pluggable TransportRegistry. Define interface Transport { send(data: Data): Promise<Status> }. Core holds a Transport strategy and delegates. TransportRegistry maps names to factory functions for dynamic instantiation. New transports register at runtime via the registry, enabling hot-swapping without core changes.","explanation":"## Why This Is Asked\nRuntime pluggability enables changing transports without redeployment, critical in latency-sensitive data pipelines.\n\n## Key Concepts\n- Strategy pattern for transport behavior abstraction\n- Registry/plugin architecture for dynamic loading\n- Lazy loading and dependency injection\n\n## Code Example\n```javascript\nclass TransportRegistry {\n  constructor() { this.map = new Map(); }\n  register(name, factory) { this.map.set(name, factory); }\n  get(name) { const f = this.map.get(name); return f ? f() : null; }\n}\nclass HttpTransport { /*...*/ }\nclass KafkaTransport { /*...*/ }\n```\n\n## Follow-up Questions\n- How would you handle transport failures and retries?\n- What metrics would you monitor for transport performance?\n- How would you ensure thread safety in concurrent environments?","diagram":"flowchart TD\n  Core[Core] --> Registry[Transport Registry]\n  Core --> Strategy[Current Transport]\n  Registry -->|load| TransportImpl[NewTransport]\n  Strategy --> TransportImpl","difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Stripe","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T04:07:37.723Z","createdAt":"2026-01-19T02:51:28.909Z"},{"id":"q-681","question":"You're building a multi-tenant API gateway for a Stripe-like payments service, backed by MongoDB storage and a Twitter-like feed. Each tenant has a per-minute rate limit. Describe a concrete solution using the Decorator pattern to enforce quotas, show how you'd implement atomic Redis updates, discuss burst handling and clock drift, and outline a minimal wrapper skeleton in code?","answer":"Design a multi-tenant rate limiter by wrapping the core service with a Decorator that enforces per-tenant quotas stored in Redis. On each call, the decorator does an atomic INCR for the tenants windo","explanation":"## Why This Is Asked\nThis question probes practical design-pattern reasoning under real constraints (tenancy, rate limits, distributed cache).\n\n## Key Concepts\n- Decorator pattern for cross-cutting concerns\n- Atomic Redis updates and Lua scripting\n- Burst handling strategies and clock drift trade-offs\n- Testing under failure and partial outages\n\n## Code Example\n\n```javascript\nclass RateLimitedService {\n  constructor(next) { this.next = next; }\n  async call(req){ return this.next.call(req); }\n}\n\nclass RateLimiterDecorator {\n  constructor(next, redis, quota, windowSec){\n    this.next = next; this.redis = redis; this.quota = quota; this.windowSec = windowSec; }\n  async call(req){\n    const key = `rate:${req.tenant}:${Math.floor(Date.now()/this.windowSec)}`;\n    const count = await this.redis.incr(key);\n    if (count === 1) await this.redis.expire(key, this.windowSec);\n    if (count > this.quota) throw new Error('rate limit');\n    return this.next.call(req);\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test edge bursts or clock skew?\n- How would you evolve to a distributed token bucket?\n- How do you monitor and alert on quota breaches?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Stripe","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T15:58:03.426Z","createdAt":"2026-01-11T15:58:03.426Z"},{"id":"q-688","question":"You're building a feature flag system where flags can be evaluated as a hard boolean, a percentage rollout, or a targeted user segment. Design the architecture using a design pattern that lets you add new evaluation strategies without changing the caller. Which pattern would you choose and how would you implement it in code? Provide a minimal interface and usage example?","answer":"Use the Strategy pattern: define an IFlagStrategy with evaluate(user, flag) -> boolean. Implement concrete strategies: BooleanFlag, PercentFlag, UserSegmentFlag. The Evaluator holds a strategy referen","explanation":"## Why This Is Asked\nUnderstanding extensibility and testability in pattern choices.\n\n## Key Concepts\n- Strategy pattern\n- Dependency injection\n- Runtime swapping\n- Testability and trade-offs\n\n## Code Example\n```javascript\ninterface FlagStrategy {\n  evaluate(user, flag): boolean;\n}\nclass BooleanFlagStrategy implements FlagStrategy {\n  evaluate(user, flag) { return flag.value; }\n}\nclass PercentFlagStrategy implements FlagStrategy {\n  evaluate(user, flag) { return (user.id % 100) < flag.percent; }\n}\nclass UserSegmentFlagStrategy implements FlagStrategy {\n  evaluate(user, flag) { return flag.segments.includes(user.segment); }\n}\n\nclass FlagEvaluator {\n  constructor(strategy) { this.strategy = strategy; }\n  evaluate(user, flag) { return this.strategy.evaluate(user, flag); }\n  setStrategy(s) { this.strategy = s; }\n}\n```\n\n## Follow-up Questions\n- How would you test each strategy in isolation?\n- How would you design the Flag object for efficient evaluation?\n","diagram":"flowchart TD\n  Evaluator --> Strategy\n  Strategy --> BooleanFlagStrategy\n  Strategy --> PercentFlagStrategy\n  Strategy --> UserSegmentFlagStrategy","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Hashicorp"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T16:22:55.337Z","createdAt":"2026-01-11T16:22:55.337Z"},{"id":"q-695","question":"You're building a real-time data ingestion pipeline that must apply a sequence of transformations to each record. New transforms (normalization, enrichment, validation, anomaly detection) should be added as plugins without touching producer/consumer code. Design a pluggable Transform pipeline with per-tenant routing and hot-reload of configuration. Provide minimal interface and a usage example, including how to configure a few plugins and compose them for a stream?","answer":"Use a pluggable Transform pipeline. Define interface Transform { String name(); Record apply(Record); }. Pipeline holds an immutable List<Transform> steps; process r = steps.reduce via apply. Per-tena","explanation":"## Why This Is Asked\nAssess ability to design a modular, runtime-configurable data pipeline with per-tenant customization.\n\n## Key Concepts\n- Plugin architecture and the Pipeline pattern\n- Immutable pipelines and copy-on-write config\n- Per-tenant routing and hot-reload\n- Stateless transforms and fault tolerance\n\n## Code Example\n```javascript\nclass Transform { constructor(name){this.name=name} apply(rec){return rec}}\nclass NormalizeTransform extends Transform { apply(r){ /* normalize */ return r} }\nclass Pipeline { constructor(steps){ this.steps=Object.freeze(steps)} process(r){ return this.steps.reduce((acc,t)=>t.apply(acc), r) } }\n```\n\n## Follow-up Questions\n- How would you test per-tenant hot reload without downtime?\n- How do you handle a failing plugin without aborting the whole record?","diagram":"flowchart TD\n  A[Record Arrives] --> B{Tenant Exists?}\n  B -->|Yes| C[Fetch Tenant Pipeline]\n  C --> D[Process Through Transforms]\n  D --> E[Store Result]\n  B -->|No| F[Default Pipeline] --> E","difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T17:16:37.061Z","createdAt":"2026-01-11T17:16:37.061Z"},{"id":"q-706","question":"You're building an extensible data ingestion framework where new data formats (JSON, Parquet, ORC) must be supported without touching the core ingestion logic. Design the architecture using a pattern that decouples format parsing from the caller and lets you add new format handlers without changing the caller. Which pattern would you choose and how would you implement it in code? Provide a minimal interface and usage example?","answer":"Use the Strategy pattern: define a FormatHandler interface and a registry mapping formats to concrete handlers. Ingestor delegates parsing to the appropriate handler, so adding a new format requires o","explanation":"## Why This Is Asked\nThis question tests choosing an architecture that stays Open-Closed, supports runtime extension of handlers, and keeps the ingestion core simple and testable.\n\n## Key Concepts\n- Strategy/Polymorphism\n- Open-Closed Principle\n- Registry-based dispatch\n\n## Code Example\n```javascript\ninterface FormatHandler { parse(input) }\nclass JsonHandler implements FormatHandler { parse(input) { /* parse JSON */ } }\nclass Ingestor { constructor(registry) { this.registry = registry } ingest(format, data) { return this.registry[format].parse(data) } }\n```\n\n## Follow-up Questions\n- How would you handle unknown formats at runtime?\n- How would you test individual handlers and end-to-end ingestion?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T18:29:21.416Z","createdAt":"2026-01-11T18:29:21.416Z"},{"id":"q-714","question":"You're building a small HTTP client wrapper that fetches a user profile, but the server occasionally fails. The caller selects a retry policy by name (linear, exponential, jitter) and fetchUser should retry using that policy without changing fetchUser's code. Design the architecture using a design pattern that lets you add new retry strategies without modifying the caller. Provide a minimal interface and a usage example?","answer":"Pattern: Strategy. Define interface RetryPolicy { shouldRetry(attempt:number, err:any): boolean; nextDelay(attempt:number, err?:any): number }. Implement LinearPolicy, ExponentialPolicy, and JitterPol","explanation":"## Why This Is Asked\nTests understanding of how to decouple variability in behavior using design patterns. It shows how to extend functionality without touching call sites, a common real-world need.\n\n## Key Concepts\n- Strategy pattern for interchangeable retry logic\n- Dependency injection to supply policies\n- Clear separation of fetch logic from retry strategy\n- Testability by swapping mock policies\n\n## Code Example\n```javascript\ninterface RetryPolicy {\n  shouldRetry(attempt: number, err: any): boolean;\n  nextDelay(attempt: number, err?: any): number;\n}\nclass LinearPolicy implements RetryPolicy {\n  constructor(private delay: number, private max: number) {}\n  shouldRetry(attempt: number) { return attempt < this.max; }\n  nextDelay(_attempt: number) { return this.delay; }\n}\nclass ExponentialPolicy implements RetryPolicy {\n  constructor(private base: number, private factor: number, private cap: number) {}\n  shouldRetry(attempt: number) { return attempt * this.factor < this.cap; }\n  nextDelay(attempt: number) { return Math.min(this.base * Math.pow(this.factor, attempt - 1), this.cap); }\n}\n```\n\n```javascript\nconst policy = new ExponentialPolicy(100, 2, 1000);\nfetchUser('alice', policy);\n```\n\n## Follow-up Questions\n- How would you test retry behavior without real network calls?\n- How would you share a policy across multiple fetchers without duplication?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Lyft","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T19:17:55.052Z","createdAt":"2026-01-11T19:17:55.052Z"},{"id":"q-717","question":"You're building a real-time event processing pipeline that validates, enriches, and filters events before persisting. New validators, enrichers, and filters must be added at runtime without altering the core processor. Which design pattern enables this extensibility and how would you implement it? Provide minimal interfaces and a usage example?","answer":"Adopt a pluggable pipeline implemented as a Chain of Responsibility / Pipeline pattern. Keep a registry of steps (validators, enrichers, filters) and a runner that applies them in sequence. New steps ","explanation":"## Why This Is Asked\n\nTests ability to design extensible, maintainable data processing. Candidates should show how to decouple orchestration from behavior and support runtime extensibility.\n\n## Key Concepts\n\n- Pipeline / Chain of Responsibility\n- Dynamic step registration\n- Order preservation and error propagation\n- Stateless, composable steps\n\n## Code Example\n\n```javascript\nclass Pipeline {\n  constructor() {\n    this.steps = [];\n  }\n  register(step) {\n    this.steps.push(step);\n  }\n  run(event) {\n    return this.steps.reduce((e, s) => s(e), event);\n  }\n}\n\n// Usage: extend without touching core\nconst p = new Pipeline();\np.register(e => ({ ...e, enriched: true }));\np.register(e => (e.valid ? e : { ...e, error: 'invalid' }));\nconst event = { payload: { id: 1 } };\nconst result = p.run(event);\n```\n\n## Follow-up Questions\n\n- How would you handle async steps or errors within steps?\n- How would you enforce step ordering guarantees and versioning of pipelines?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Snowflake","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T20:21:02.325Z","createdAt":"2026-01-11T20:21:02.326Z"},{"id":"q-729","question":"You're building an image-processing pipeline that applies a sequence of filters (blur, brighten, sharpen) to images. The pipeline must run on both CPU and GPU backends, and new backends must be pluggable without touching filter implementations or orchestration code. Design an architecture that decouples filters from backends using a design pattern, enabling adding a backend such as Vulkan without modifying core code. Provide a minimal interface and usage example?","answer":"Use the Bridge pattern: Filters depend on a Backend API, not a concrete backend. Define Backend{apply(image, opSpec)} and concrete backends CPUBackend, GPUBackend. Filters call backend.apply(...) and ","explanation":"## Why This Is Asked\n\nThis task tests the ability to decouple algorithmic filters from execution backends, enabling runtime backend swapping and new backend integration without touching core logic.\n\n## Key Concepts\n\n- Bridge pattern for decoupling abstraction (filters) from implementation (backends)\n- Backend interface and concrete backends (CPU, GPU)\n- Extensibility and testability with pluggable backends\n\n## Code Example\n\n```javascript\n// Minimal illustrative code (not production-ready)\nclass Backend {\n  apply(image, opSpec) { throw new Error('not implemented') }\n}\nclass CPUBackend extends Backend {\n  apply(image, opSpec) { /* CPU path */ return image }\n}\nclass GPUBackend extends Backend {\n  apply(image, opSpec) { /* GPU path, e.g., CUDA/Vulkan */ return image }\n}\nclass Filter {\n  constructor(opSpec) { this.opSpec = opSpec }\n  render(image, backend) { return backend.apply(image, this.opSpec) }\n}\nclass Pipeline {\n  constructor() { this.filters = []; }\n  setBackend(b) { this.backend = b }\n  addFilter(f) { this.filters.push(f) }\n  run(image) { let out = image; for (const f of this.filters) out = f.render(out, this.backend); return out }\n}\n```\n\n## Follow-up Questions\n\n- How would you add backends with different precision or memory constraints?\n- How would you test backends in isolation and measure performance trade-offs?","diagram":"flowchart TD\nP[Pipeline] --> B[BackendBridge]\nP --> F[Filters]\nB --> CPU[CPUBackend]\nB --> GPU[GPUBackend]\nF --> Blur[BlurFilter]\nF --> Brighten[BrightenFilter]","difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T21:18:19.757Z","createdAt":"2026-01-11T21:18:19.757Z"},{"id":"q-737","question":"In a messaging pipeline used by Zoom and Hugging Face, the system tokenizes, normalizes, and stores messages. You want to support swapping in different normalization strategies (lowercasing, diacritic removal, profanity filtering) without changing the pipeline code. Design the architecture using a design pattern that lets you add new normalization strategies without modifying the pipeline. Provide a minimal interface and a usage example. How would you implement this pattern to make additions painless?","answer":"Use the Strategy pattern by modeling the normalization as a pluggable Normalizer with a normalize(text) method, then inject a concrete Normalizer into the pipeline. New strategies (Lowercase, AccentRe","explanation":"## Why This Is Asked\nTests knowledge of a clean extension point and practical DI. It avoids altering core pipeline logic when introducing new behaviors.\n\n## Key Concepts\n- Strategy pattern for interchangeable behaviors\n- Dependency injection for runtime flexibility\n- Open-closed principle and testability\n\n## Code Example\n```javascript\n// Minimal interface\ninterface Normalizer {\n  normalize(text: string): string;\n}\nclass LowercaseNormalizer implements Normalizer {\n  normalize(text: string) { return text.toLowerCase(); }\n}\nclass AccentRemover implements Normalizer {\n  normalize(text: string) { return text.normalize('NFD').replace(/[\\u0300-\\u036f]/g, ''); }\n}\nclass MessageProcessor {\n  constructor(private normalizer: Normalizer) {}\n  process(text: string) { return this.normalizer.normalize(text); }\n}\n```\n\n## Follow-up Questions\n- How would you choose between construction-time vs per-message normalization strategy?\n- How would you test each strategy in isolation and within the pipeline?","diagram":"flowchart TD\n  P[MessageProcessor] --> N[NormalizationContext]\n  N --> L[LowercaseNormalization]\n  N --> A[AccentRemoval]\n  L --> S[StoreMessage]\n  A --> S","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T22:20:11.913Z","createdAt":"2026-01-11T22:20:11.914Z"},{"id":"q-741","question":"In a telemetry alerting system for autonomous fleets, each customer needs a custom alert-threshold strategy for metrics like speed or battery: static value, percentile-based, or rolling window. The aggregator should surface alerts without depending on a concrete strategy. Design the architecture using a design pattern that lets you add new threshold strategies without modifying the aggregator. Provide a minimal interface and a usage example?","answer":"Use Strategy pattern: define interface ThresholdStrategy { compute(values: number[]): number }, implement StaticThreshold, PercentileThreshold, RollingWindowThreshold, and a ThresholdContext that dele","explanation":"## Why This Is Asked\nTests ability to plug in new algorithms without touching the orchestrator, a common interview scenario.\n\n## Key Concepts\n- Strategy pattern for interchangeable thresholds\n- Thin interface and per-customer configuration\n- Factory to instantiate strategies from config\n\n## Code Example\n```javascript\nclass ThresholdStrategy { compute(values) { throw new Error('not implemented') } }\nclass StaticThreshold extends ThresholdStrategy {\n  constructor(v){ super(); this.v=v }\n  compute(_){ return this.v }\n}\nclass PercentileThreshold extends ThresholdStrategy {\n  constructor(p){ super(); this.p=p }\n  compute(values){ if (!values.length) return 0; values.sort((a,b)=>a-b); const idx=Math.floor((this.p/100)*(values.length-1)); return values[idx]; }\n}\nclass RollingWindowThreshold extends ThresholdStrategy {\n  constructor(size){ super(); this.size=size }\n  compute(values){ const win = values.slice(-this.size); win.sort((a,b)=>a-b); const idx=Math.floor(0.95*(win.length-1)); return win[idx]; }\n}\nclass ThresholdContext {\n  constructor(strategy){ this.strategy=strategy }\n  compute(values){ return this.strategy.compute(values) }\n}\n\n// usage\nconst t = new ThresholdContext(new PercentileThreshold(95));\nconst threshold = t.compute(window);\n```\n\n## Follow-up Questions\n- How would you test adding a new strategy in isolation?\n- How would you persist per-customer strategy config and migrate existing customers?","diagram":"flowchart TD\n  A[Aggregator] --> B[ThresholdStrategy]\n  B --> C[StaticThreshold]\n  B --> D[PercentileThreshold]\n  B --> E[RollingWindowThreshold]","difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Tesla","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T23:17:28.525Z","createdAt":"2026-01-11T23:17:28.525Z"},{"id":"q-750","question":"Youre building a data export utility that must support multiple formats. New formats can come from external libraries with different APIs. Design an architecture using a pattern that lets you add new formats without changing the core exporter. Which pattern would you use and how would you implement it? Provide a minimal interface and a usage example?","answer":"Pattern: Adapter. Wrap external serializers behind a common Serializer interface to let the exporter support new formats without modifying its code. Define Serializer { serialize(data) string }. Imple","explanation":"## Why This Is Asked\n\nTests ability to map real-world library integration to a classic pattern without touching core logic.\n\n## Key Concepts\n\n- Adapter pattern\n- Interfaces and thin wrappers\n- Extending functionality without modifying clients\n\n## Code Example\n\n```javascript\n// Minimal interface\nclass Serializer { serialize(data) { throw new Error('Not implemented') } }\nclass JsonAdapter extends Serializer {\n  constructor(jsonLib) { this.jsonLib = jsonLib }\n  serialize(data) { return this.jsonLib.stringify(data) }\n}\n```\n\n## Follow-up Questions\n\n- How would you test adapters in isolation?\n- What are trade-offs vs Bridge when formats have evolving schemas?\n","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Cloudflare","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T01:28:32.744Z","createdAt":"2026-01-12T01:28:32.744Z"},{"id":"q-763","question":"You're designing a data ingestion pipeline where raw inputs pass through optional enhancers (encryption, compression, watermarking) implemented as decorators around a base DataSource. You must add new decorators without touching the core pipeline or existing decorators. Which pattern would you use and how would you implement minimal interfaces to compose them? Provide a usage example?","answer":"Use the Decorator pattern. Define DataSource { read(): Buffer }. Implement a base FileSource. Create DataSourceDecorator wrapping a DataSource. Add concrete decorators EncryptDecorator, CompressDecora","explanation":"## Why This Is Asked\nThis tests the ability to extend behavior without modifying existing code, a hallmark of robust design.\n\n## Key Concepts\n- Decorator pattern\n- Runtime composition\n- Open/Closed Principle\n\n## Code Example\n```javascript\ninterface DataSource { read(): Buffer }\nclass FileSource implements DataSource { constructor(path) { this.path = path } read() { /* read file */ } }\nclass DataSourceDecorator implements DataSource { constructor(protected source: DataSource) {} read() { return this.source.read() } }\nclass EncryptDecorator extends DataSourceDecorator { read() { const data = super.read(); return encrypt(data) } }\nclass CompressDecorator extends DataSourceDecorator { read() { const data = super.read(); return compress(data) } }\n```\n\n## Follow-up Questions\n- How would you test a decorator stack with different orders?\n- How to handle streaming data and backpressure in decorator chains?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Microsoft","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T03:50:59.836Z","createdAt":"2026-01-12T03:50:59.836Z"},{"id":"q-769","question":"In a log analytics pipeline, you must support multiple formats (JSON, CSV, Protobuf) and multiple sinks (Elasticsearch, BigQuery, S3). Design an architecture using a design pattern that allows adding new formats or sinks without touching the producer. Provide minimal interfaces and a usage example?","answer":"Use the Strategy pattern to decouple event formatting from producers and sinks. Define a Formatter interface with format(Event) -> []byte and a Publisher interface with publish([]byte, Sink). Implemen","explanation":"## Why This Is Asked\nTests understanding of decoupling using a pattern that lets new formats/sinks be added without producer changes.\n\n## Key Concepts\n- Strategy pattern\n- Registry/Factory for runtime selection\n- Dependency injection\n\n## Code Example\n```javascript\n// Formatter interface\nclass Formatter { format(event) { /*...*/ } }\n// Publisher interface\nclass Publisher { publish(data, sink) { /*...*/ } }\n\nclass JSONFormatter { format(e){ return JSON.stringify(e.payload) } }\nclass ElasticsearchPublisher { publish(bytes, sink){ /* send to sink */ } }\n\n// usage\nconst registry = new Map();\nregistry.set('json', { formatter: new JSONFormatter(), publisher: new ElasticsearchPublisher() });\nconst { formatter, publisher } = registry.get('json');\nconst data = formatter.format({ payload: { x: 1 } });\npublisher.publish(data, 'elasticsearch');\n```\n\n## Follow-up Questions\n- How would you test the registry and ensure new formats don't require producer changes?\n- How would you handle versioned schemas when formats evolve?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","MongoDB","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T04:48:36.490Z","createdAt":"2026-01-12T04:48:36.490Z"},{"id":"q-781","question":"You're building a CLI tool that supports commands and subcommands, forming a tree (e.g., 'git remote add'). Design a Command interface that treats leaves (actual actions) and composites (groups of commands) uniformly. Implement LeafCommand and CommandGroup using the Composite pattern so a single call can execute a command or print help for a whole subtree without changing client code. Provide a minimal interface and usage example?","answer":"Use the Composite pattern. Define a Command interface with execute(args) and help(). Implement LeafCommand for concrete actions and CommandGroup for commands that contain children. The group delegates","explanation":"Why This Is Asked\n- Demonstrates modeling hierarchical command structures with a single interface.\n- Shows uniform treatment of leaves and composites, enabling recursive execution.\n- Tests understanding of registration and delegation without touching client logic.\n\nKey Concepts\n- Composite pattern\n- Uniform interface for leaves/composites\n- Recursive command resolution\n- Lightweight plugin-friendly design\n\nCode Example\n```javascript\nclass Command {\n  execute(args) { throw new Error('not implemented'); }\n  help() { throw new Error('not implemented'); }\n}\nclass LeafCommand extends Command {\n  constructor(name, action){ super(); this.name = name; this.action = action; }\n  execute(args){ this.action(args); }\n  help(){ return this.name; }\n}\nclass CommandGroup extends Command {\n  constructor(name){ super(); this.name = name; this.children = []; }\n  add(cmd){ this.children.push(cmd); }\n  execute(args){ const [sub] = args; const found = this.children.find(c => c.help() === sub);\n    if(found) found.execute(args.slice(1));\n  }\n  help(){ return this.name + ' (' + this.children.map(c => c.help()).join(', ') + ')'; }\n}\n\n// Usage\nconst root = new CommandGroup('root');\nconst status = new LeafCommand('status', () => console.log('ok'));\nconst repo = new CommandGroup('repo');\nrepo.add(status);\nroot.add(repo);\n```\n","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T05:32:43.572Z","createdAt":"2026-01-12T05:32:43.572Z"},{"id":"q-785","question":"You're building a pluggable HTTP request/response transformer pipeline inside a reverse proxy. Each Transformer can add, redact, or modify headers/body. The gateway must load new Transformers at runtime by name without redeploying. Design a minimal interface and registry-driven architecture that supports adding new transformer types without touching the gateway core. Provide a usage example?","answer":"Use the Strategy pattern with a runtime Transformer registry. Define Transformer { apply(req, res) error }; concrete types like HeaderAdder, BodyRedactor implement it. Pipeline stores []Transformer. A","explanation":"## Why This Is Asked\n\nThis question probes runtime extensibility and plugin architecture for a high-availability gateway, emphasizing decoupling, dynamic discovery, and safe wiring of new behavior without redeploys.\n\n## Key Concepts\n\n- Strategy pattern for interchangeable transformers\n- Registry/Plugin mechanism for dynamic loading\n- Runtime extensibility with minimal core impact\n\n## Code Example\n\n```javascript\n// Minimal interface and wiring\ninterface Transformer {\n  apply(req, res): void\n}\nclass HeaderAdder implements Transformer { apply(req, res) { /* ... */ } }\nclass BodyRedactor implements Transformer { apply(req, res) { /* ... */ } }\n\nclass Registry {\n  register(name, factory) { /* ... */ }\n  create(name, config) { /* ... */ }\n}\n```\n\n## Follow-up Questions\n\n- How do you guarantee transformer execution order and error handling in the pipeline?\n- How would you test hot-plug transformers and rollback on failure in CI/CD?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Cloudflare","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T06:37:47.273Z","createdAt":"2026-01-12T06:37:47.273Z"},{"id":"q-793","question":"You're designing a streaming data processing framework where each record passes through a configurable pipeline of transformation steps. New transformations must be added at runtime without touching the orchestrator, and jobs select steps by name. Which design pattern and minimal interfaces would you use to register, compose, and execute transformations, ensuring type-safety and low churn when adding new steps? Provide a concise usage example?","answer":"Use a Registry-Driven Strategy pattern: define a Transformation<T> { apply(input: T): T }, a Factory<T> to instantiate by name, and a Pipeline<T> that composes steps. Elements register at runtime in a","explanation":"## Why This Is Asked\nA runtime-extendable transformation system tests open-closed principle, type-safety, and runtime composition without touching orchestration.\n\n## Key Concepts\n- Registry: maps names to transformation factories.\n- Strategy: each transformation is a pluggable strategy.\n- Pipeline: sequences transformations into a single pass.\n- Runtime extensibility: add new steps without modifying core.\n- Type-safety: leverage generics for input/output consistency.\n\n## Code Example\n```typescript\ninterface Transformation<T> { apply(input: T): T; }\n\ntype Factory<T> = () => Transformation<T>;\n\nclass Pipeline<T> {\n  constructor(private steps: Transformation<T>[]) {}\n  run(input: T): T {\n    return this.steps.reduce((acc, s) => s.apply(acc), input);\n  }\n}\n\nconst registry = new Map<string, Factory<any>>();\n\nfunction register<T>(name: string, factory: Factory<T>) {\n  registry.set(name, factory);\n}\n\nfunction create<T>(name: string): Transformation<T> {\n  const f = registry.get(name);\n  if (!f) throw new Error(`Unknown transformation: ${name}`);\n  return f();\n}\n```\n\n## Follow-up Questions\n- How would you handle versioning of transformations and ensure backward compatibility?\n- How would you test pipelines with dynamic registries and ensure deterministic ordering?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","LinkedIn","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T07:28:39.620Z","createdAt":"2026-01-12T07:28:39.620Z"},{"id":"q-802","question":"Design a unit-test framework runner that supports multiple assertion styles (classic, fluent, should). The goal is to add a new assertion style (e.g., expect) at runtime without modifying the runner core. Which design pattern would be chosen and how would the minimal interfaces and a registry be structured? Provide a usage example?","answer":"Use the Strategy pattern. The runner defines an AssertionStyle interface with a method assert(actual, expected). A registry maps style names to concrete styles and the runner delegates to the selected","explanation":"## Why This Is Asked\n\nTests often need new assertion styles without changing the runner. This probes understanding of decoupling via Strategy and a registry-based plug-in model.\n\n## Key Concepts\n\n- Strategy pattern\n- Open/Closed principle\n- Registry/Plug-in architecture\n- Lightweight interfaces\n\n## Code Example\n\n```javascript\nclass AssertionStyle {\n  assert(actual, expected) { throw new Error('not implemented') }\n}\nclass ClassicAssert extends AssertionStyle {\n  assert(actual, expected) { if (actual !== expected) throw new Error('mismatch') }\n}\nclass Runner {\n  constructor() { this.styles = new Map() }\n  register(name, style) { this.styles.set(name, style) }\n  assert(styleName, actual, expected) {\n    const style = this.styles.get(styleName)\n    style.assert(actual, expected)\n  }\n}\n```\n\n## Follow-up Questions\n\n- How to handle asynchronous assertions? \n- How to ensure thread safety in the registry? \n- How to provide a sensible default when a style is missing?","diagram":"flowchart TD\n  Runner[Runner] --> Style[AssertionStyle]\n  Style --> Classic[ClassicAssert]\n  Style --> Fluent[FluentAssert]\n  Style --> Should[ShouldAssert]","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Salesforce","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T08:33:41.435Z","createdAt":"2026-01-12T08:33:41.435Z"},{"id":"q-809","question":"Design a health-check framework for a fleet-management service. The system aggregates health from multiple subsystems (database, message broker, geolocation API). New checks (checkDiskSpace, checkApiLatency) must be added at runtime without touching the aggregator. Which pattern supports this, and how would you implement minimal interfaces and a usage example?","answer":"Use Composite with a runtime registry. Define IHealthCheck { string name; HealthStatus check(); }. Implement SimpleCheck and CheckGroup that aggregates children. HealthAggregator treats the group as a","explanation":"## Why This Is Asked\nThis tests pattern selection for runtime extensibility without touching core.\n\n## Key Concepts\n- Composite for hierarchical checks\n- Registry for dynamic extension\n- Lightweight HealthStatus aggregation\n\n## Code Example\n```javascript\ninterface IHealthCheck { name: string; check(): HealthStatus }\nclass SimpleCheck implements IHealthCheck { constructor(name, fn){...} check(){return new HealthStatus(...)}}\nclass CheckGroup implements IHealthCheck { constructor(name){this.children=[]} add(c){this.children.push(c)} check(){return aggregate(this.children)}}\n```\n\n## Follow-up Questions\n- How would you test a newly added check in isolation?\n- How would you report partial health vs. critical failure to a dashboard?","diagram":"flowchart TD\n  HealthAggregator[Health Aggregator] --> DB[Database Health]\n  HealthAggregator --> Broker[Broker Health]\n  HealthAggregator --> Geo[Geolocation API Health]\n  Registry[Runtime Registry] --> DiskSpace[Disk Space Check]\n","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T09:34:35.011Z","createdAt":"2026-01-12T09:34:35.011Z"},{"id":"q-819","question":"You are designing a log export module for a distributed service. It must support exporting archives to multiple backends (S3, GCS, and an on-prem object store). New backends should be addable at runtime without touching the exporter or consumer code. Design the architecture using a design pattern that lets you plug in new backends via a registry. Provide a minimal interface and usage example?","answer":"Implement a Plugin-style archival backend with a common interface Archiver { archive(batch: LogBatch): Promise<void> }. Create a Registry mapping keys ('s3','gcs','onprem') to factory callbacks. The e","explanation":"## Why This Is Asked\nTests a candidate's ability to design extensible, decoupled systems using pluggable backends and runtime registration. It requires a concrete interface, a registry, and a usage example showing how to add a new backend without modifying the exporter.\n\n## Key Concepts\n- Plugin/Registry pattern for extensibility\n- Dependency Inversion: exporter depends on Archiver abstraction, not concrete backends\n- Factory callbacks to instantiate backends at runtime\n\n## Code Example\n```javascript\n// Minimal interface\nclass Archiver {\n  async archive(batch) { throw new Error('Not implemented') }\n}\n\n// Registry\nconst Registry = {\n  _constructors: new Map(),\n  register(key, factory) { Registry._constructors.set(key, factory) },\n  create(key) { const f = Registry._constructors.get(key); return f ? f() : null }\n}\n\n// Usage\n// Backend implementation\nclass S3Archiver extends Archiver {\n  async archive(batch) { /* push to S3 */ }\n}\nRegistry.register('s3', () => new S3Archiver())\n\n// Exporter uses registry\nconst archiver = Registry.create('s3')\narchiver.archive({/* batch */})\n```\n\n## Follow-up Questions\n- How would you handle lifecycle, retries, and backpressure when a backend is down?\n- How would you verify at compile-time that a backend implements the Archiver interface?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Netflix","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T10:28:02.394Z","createdAt":"2026-01-12T10:28:02.395Z"},{"id":"q-824","question":"Design a pluggable text-formatting pipeline for a CLI tool. The pipeline should allow new transforms to be added at runtime via a registry, without touching the core pipeline. Use a suitable pattern to compose these transforms in order; provide a minimal interface and a usage example?","answer":"Pattern: a pluggable text-formatting pipeline (pipeline/chain). Each transform is a small unit registered by name; the Pipeline composes them in order at runtime. Minimal interface exposes apply(text)","explanation":"## Why This Is Asked\n\nTests ability to design extensible text processing with runtime plugins, without touching core; demonstrates a clean separation of concerns and Open/Closed compliance.\n\n## Key Concepts\n- Pipeline/Chain of Responsibility pattern\n- Runtime registry for extensibility\n- Minimal transform interface and composition order\n- Deterministic, idempotent transforms\n\n## Code Example\n\n```javascript\nclass Transform {\n  constructor(name, fn) { this.name = name; this.fn = fn; }\n  apply(text) { return this.fn(text); }\n}\nclass Registry {\n  constructor(){ this.factories = new Map(); }\n  register(name, factory){ this.factories.set(name, factory); }\n  create(name){ const f = this.factories.get(name); return f ? f() : null; }\n}\nclass Pipeline {\n  constructor(registry, names){ this.transforms = names.map(n => registry.create(n)).filter(t => t); }\n  run(input){ return this.transforms.reduce((acc, t) => t.apply(acc), input); }\n}\n\nconst registry = new Registry();\nregistry.register('trim', () => new Transform('trim', s => s.trim()));\nregistry.register('collapseSpaces', () => new Transform('collapseSpaces', s => s.replace(/\\s+/g, ' ')));\nregistry.register('toUpper', () => new Transform('toUpper', s => s.toUpperCase()));\n\nconst names = ['trim','collapseSpaces','toUpper'];\nconst pipeline = new Pipeline(registry, names);\nconsole.log(pipeline.run('  hello   world  ')); // 'HELLO WORLD'\n```\n\n## Follow-up Questions\n- How would you handle asynchronous transforms in this pipeline?\n- How would you order or deduplicate transforms registered at runtime to guarantee deterministic results?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Hashicorp","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T11:20:58.692Z","createdAt":"2026-01-12T11:20:58.692Z"},{"id":"q-833","question":"You're building a streaming analytics dashboard where widgets render different metrics. New chart renderers can be added at runtime by third-party teams without modifying core widgets. Design the architecture using a design pattern that supports pluggable renderers via a registry. Provide a minimal interface and a usage example?","answer":"Use a Plugin Registry with a Strategy-like Renderer interface. Define a Renderer interface with render(data, container). Maintain a Registry<string, RendererFactory> that creates concrete renderers (C","explanation":"## Why This Is Asked\nTests ability to design an extensible UI plugin system without touching core widgets, a common Netflix/Tesla/Nvidia scenario.\n\n## Key Concepts\n- Plugin registry for runtime extensibility\n- Strategy/Factory for pluggable renderers\n- Loose coupling between Widget and Renderer\n- Runtime loading and versioning considerations\n\n## Code Example\n```javascript\ninterface Renderer {\n  render(data: any, container: HTMLElement): void\n}\nclass SvgRenderer implements Renderer {\n  render(data: any, container: HTMLElement) { /* draw SVG */ }\n}\nclass Registry {\n  private map = new Map<string, (ctx?: any) => Renderer>()\n  register(name: string, factory: (ctx?: any) => Renderer) { this.map.set(name, factory) }\n  create(name: string, ctx?: any) { return this.map.get(name)!(ctx) }\n}\n```\n\n## Follow-up Questions\n- How would you secure the plugin loading to avoid untrusted code?\n- How would you handle renderer versioning compatibility?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["NVIDIA","Netflix","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T12:44:13.123Z","createdAt":"2026-01-12T12:44:13.123Z"}],"subChannels":["general"],"companies":["Adobe","Airbnb","Amazon","Anthropic","Apple","Bloomberg","Citadel","Cloudflare","Coinbase","Databricks","Discord","DoorDash","Google","Hashicorp","Hugging Face","IBM","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Netflix","Oracle","Plaid","Robinhood","Salesforce","Scale Ai","Slack","Snap","Snowflake","Square","Stripe","Tesla","Twitter","Two Sigma","Uber","Zoom"],"stats":{"total":43,"beginner":18,"intermediate":13,"advanced":12,"newThisWeek":32}}