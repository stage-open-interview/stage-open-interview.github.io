{"questions":[{"id":"q-681","question":"You're building a multi-tenant API gateway for a Stripe-like payments service, backed by MongoDB storage and a Twitter-like feed. Each tenant has a per-minute rate limit. Describe a concrete solution using the Decorator pattern to enforce quotas, show how you'd implement atomic Redis updates, discuss burst handling and clock drift, and outline a minimal wrapper skeleton in code?","answer":"Design a multi-tenant rate limiter by wrapping the core service with a Decorator that enforces per-tenant quotas stored in Redis. On each call, the decorator does an atomic INCR for the tenantâ€™s windo","explanation":"## Why This Is Asked\nThis question probes practical design-pattern reasoning under real constraints (tenancy, rate limits, distributed cache).\n\n## Key Concepts\n- Decorator pattern for cross-cutting concerns\n- Atomic Redis updates and Lua scripting\n- Burst handling strategies and clock drift trade-offs\n- Testing under failure and partial outages\n\n## Code Example\n\n```javascript\nclass RateLimitedService {\n  constructor(next) { this.next = next; }\n  async call(req){ return this.next.call(req); }\n}\n\nclass RateLimiterDecorator {\n  constructor(next, redis, quota, windowSec){\n    this.next = next; this.redis = redis; this.quota = quota; this.windowSec = windowSec; }\n  async call(req){\n    const key = `rate:${req.tenant}:${Math.floor(Date.now()/this.windowSec)}`;\n    const count = await this.redis.incr(key);\n    if (count === 1) await this.redis.expire(key, this.windowSec);\n    if (count > this.quota) throw new Error('rate limit');\n    return this.next.call(req);\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test edge bursts or clock skew?\n- How would you evolve to a distributed token bucket?\n- How do you monitor and alert on quota breaches?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Stripe","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T15:58:03.426Z","createdAt":"2026-01-11T15:58:03.426Z"},{"id":"q-688","question":"You're building a feature flag system where flags can be evaluated as a hard boolean, a percentage rollout, or a targeted user segment. Design the architecture using a design pattern that lets you add new evaluation strategies without changing the caller. Which pattern would you choose and how would you implement it in code? Provide a minimal interface and usage example?","answer":"Use the Strategy pattern: define an IFlagStrategy with evaluate(user, flag) -> boolean. Implement concrete strategies: BooleanFlag, PercentFlag, UserSegmentFlag. The Evaluator holds a strategy referen","explanation":"## Why This Is Asked\nUnderstanding extensibility and testability in pattern choices.\n\n## Key Concepts\n- Strategy pattern\n- Dependency injection\n- Runtime swapping\n- Testability and trade-offs\n\n## Code Example\n```javascript\ninterface FlagStrategy {\n  evaluate(user, flag): boolean;\n}\nclass BooleanFlagStrategy implements FlagStrategy {\n  evaluate(user, flag) { return flag.value; }\n}\nclass PercentFlagStrategy implements FlagStrategy {\n  evaluate(user, flag) { return (user.id % 100) < flag.percent; }\n}\nclass UserSegmentFlagStrategy implements FlagStrategy {\n  evaluate(user, flag) { return flag.segments.includes(user.segment); }\n}\n\nclass FlagEvaluator {\n  constructor(strategy) { this.strategy = strategy; }\n  evaluate(user, flag) { return this.strategy.evaluate(user, flag); }\n  setStrategy(s) { this.strategy = s; }\n}\n```\n\n## Follow-up Questions\n- How would you test each strategy in isolation?\n- How would you design the Flag object for efficient evaluation?\n","diagram":"flowchart TD\n  Evaluator --> Strategy\n  Strategy --> BooleanFlagStrategy\n  Strategy --> PercentFlagStrategy\n  Strategy --> UserSegmentFlagStrategy","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Hashicorp"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T16:22:55.337Z","createdAt":"2026-01-11T16:22:55.337Z"}],"subChannels":["general"],"companies":["Amazon","Google","Hashicorp","MongoDB","Stripe","Twitter"],"stats":{"total":2,"beginner":1,"intermediate":1,"advanced":0,"newThisWeek":2}}