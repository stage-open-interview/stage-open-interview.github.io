{"questions":[{"id":"q-1146","question":"You're building a data ingestion service that validates JSON records before persisting them. Validation steps include NonEmpty fields, Email format, and PasswordStrength. Validators must be pluggable: new validators can be added at runtime by registering them into a Registry without touching the core pipeline. Design a minimal interface and registry, and show how to compose and execute the pipeline with a sample config. Include how to add a new validator and run the pipeline, returning the first failure?","answer":"Implement a Validator interface with validate(record) -> {ok:boolean, error?:string}. Maintain a Registry<string, () => Validator> extendable at runtime. ValidationPipeline reads a list of keys from c","explanation":"## Why This Is Asked\n\nTests ability to design a pluggable validation system that can be extended without touching core logic, a common real-world requirement in ingestion pipelines.\n\n## Key Concepts\n\n- Registry/Factory pattern for runtime extensibility\n- Pipeline that composes validators by config\n- Early exit on first failure for efficient feedback\n\n## Code Example\n\n```javascript\n// Minimal interface and registry\nclass Validator {\n  validate(record) { return { ok: true }; }\n}\nclass EmailValidator extends Validator {\n  validate(record) {\n    const ok = /^[^@]+@[^@]+\\.[^@]+$/.test(record.email || '');\n    return ok ? { ok: true } : { ok: false, error: 'Invalid email' };\n  }\n}\nconst Registry = new Map();\nfunction register(name, factory) { Registry.set(name, factory); }\nfunction createValidator(name) { const f = Registry.get(name); return f ? f() : null; }\n\nclass ValidationPipeline {\n  constructor(registry, keys) {\n    this.registry = registry;\n    this.keys = keys;\n  }\n  validate(record) {\n    for (const k of this.keys) {\n      const v = this.registry.get(k) ? this.registry.get(k)() : null;\n      if (!v) continue;\n      const res = v.validate(record);\n      if (!res.ok) return res;\n    }\n    return { ok: true };\n  }\n}\n\n// Usage\nregister('Email', () => new EmailValidator());\nregister('NonEmpty', () => new Validator());\nconst keys = ['Email'];\nconst pipeline = new ValidationPipeline(Registry, keys);\nconst result = pipeline.validate({ email: 'a@b.com' });\n```\n\n## Follow-up Questions\n\n- How would you handle async validators?\n- How would you test the registry and pipeline separately?\n- How would you version validators and roll back if a validator changes semantics?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Square","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T01:32:17.318Z","createdAt":"2026-01-13T01:32:17.318Z"},{"id":"q-1201","question":"Design a runtime-pluggable per-message transformation system for a streaming pipeline. Messages include metadata that determines the transformation strategy (e.g., enrich, normalize, validate). Implement with a design pattern that lets you add new strategies without modifying the pipeline core. Provide minimal interfaces, a registry, and a usage example?","answer":"Interface: Transformation { apply(msg): Msg }. Implementations: EnrichTransformation, NormalizeTransformation, ValidateTransformation. Registry maps string -> TransformationFactory; pipeline uses reso","explanation":"## Why This Is Asked\nThis tests depth in plug-in style pattern design for real-time data processing, ensuring new transformers can be added without mutating core code, a common need in SaaS pipelines.\n\n## Key Concepts\n- Plugin/Registry pattern for runtime extensibility\n- Lightweight interfaces and factories\n- Thread-safety and hot-reload considerations\n\n## Code Example\n```javascript\nclass Transformation {\n  apply(msg) { throw new Error('not implemented') }\n}\nclass EnrichTransformation extends Transformation {\n  apply(msg) { /* enrich */ return msg }\n}\nclass NormalizeTransformation extends Transformation {\n  apply(msg) { /* normalize */ return msg }\n}\nclass ValidateTransformation extends Transformation {\n  apply(msg) { /* validate */ return msg }\n}\nclass TransformationRegistry {\n  constructor() { this._factories = new Map() }\n  register(name, factory) { this._factories.set(name, factory) }\n  create(name) { const f = this._factories.get(name); return f ? f() : null }\n}\n// Usage\nconst registry = new TransformationRegistry()\nregistry.register('enrich', () => new EnrichTransformation())\nconst t = registry.create('enrich')\nconst out = t?.apply(msg)\n```\n\n## Follow-up Questions\n- How would you handle thread-safety and hot-reload of strategies at runtime?\n- How would you test the registry and individual strategies?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Plaid","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T04:48:59.080Z","createdAt":"2026-01-13T04:48:59.080Z"},{"id":"q-1236","question":"Design a runtime-pluggable, per-route transformer and throttling policy system for a real-time event router. Each route maps an event type to a transformer and a rate-limit policy; new transformers (enrich, redact, normalize) and new policies (token-bucket, fixed-window, leaky-bucket) must be addable at runtime without touching the router core. Which pattern would you adopt and how would you structure the minimal interfaces and registry?","answer":"Use a Plugin Registry with the Strategy pattern. Define Transformer { transform(Event): Event } and Policy { allow(Event, rate): boolean }. Router stores RouteKey -> (TransformerName, PolicyName) and ","explanation":"## Why This Is Asked\n\nThis tests designing for open-closed, runtime extensibility, and safe plugin loading in high-throughput systems like those at scale. It also probes trade-offs between reflection, isolation, and static typing.\n\n## Key Concepts\n\n- Plugin Registry\n- Strategy\n- Open/Closed Principle\n- Dynamic loading and sandboxing\n\n## Code Example\n\n```javascript\nclass Transformer { transform(event){return event} }\nclass Policy { allow(event, rate){return true} }\n```\n\n## Follow-up Questions\n\n- How to version plugins and rollback\n- How to enforce plugin isolation and security in a multi-tenant environment","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Oracle","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T06:33:28.616Z","createdAt":"2026-01-13T06:33:28.616Z"},{"id":"q-1258","question":"Design a runtime-extensible notification dispatch system that handles multiple channels (email, SMS, push) where new transports and their backoff strategies can be added at runtime via a registry without touching the core dispatcher. Specify the minimal interfaces, how you register a new transport and a new backoff policy, and show a usage example including adding a WhatsApp transport and a geometric backoff?","answer":"Implement a Dispatcher that routes by channel to a pluggable Transport. Each Transport exposes send(event, payload) and a factory for instantiation. A Registry holds transports and backoff policies; n","explanation":"## Why This Is Asked\n\nTests ability to design plugin architecture with runtime extension, isolation, and versioning.\n\n## Key Concepts\n\n- Plugin registry\n- Strategy/Factory patterns\n- Thread-safety and hot-reload\n- Backoff policy composition\n\n## Code Example\n\n```javascript\n// Minimal interfaces and registry (pseudo)\ninterface Transport { send(event, payload): Promise<void> }\ninterface TransportFactory { create(config?: any): Transport }\nclass Registry {\n  private transports = new Map<string, TransportFactory>();\n  register(name, factory) { this.transports.set(name, factory); }\n  create(name, config) { return this.transports.get(name).create(config); }\n}\ninterface BackoffPolicy { nextDelay(attempt:number): number }\nclass GeometricBackoff implements BackoffPolicy { nextDelay(a){ return Math.pow(2, a) * 100; } }\n```\n\n## Follow-up Questions\n\n- How would you ensure thread-safety and avoid memory leaks when plugins are loaded/unloaded?\n- How would you test the registry and dynamic loading?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","DoorDash","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T07:23:57.353Z","createdAt":"2026-01-13T07:23:57.353Z"},{"id":"q-1300","question":"Design a feature-flag evaluation engine for a large SaaS product. Flags support boolean, percentage rollout, user-segment, and A/B bucket strategies. Create a pluggable evaluator where new strategies can be added at runtime via a Registry without touching the core evaluator. Provide interfaces, a thread-safe registry, and a usage example with versioned strategy lookup?","answer":"Use Strategy pattern: FlagEvaluationStrategy with evaluate(user, flag) and a factory-based Registry. The core evaluator queries registry with key flagName|version, creates a strategy, and calls evalua","explanation":"## Why This Is Asked\nTests runtime extensibility and correctness of flag evaluation, including versioning and thread-safety.\n\n## Key Concepts\n- Strategy pattern for evaluation logic\n- Registry/Factory for runtime additions\n- Thread-safety and version-keying\n- Performance implications of dynamic dispatch\n\n## Code Example\n```typescript\ninterface User { id: string; segments: string[]; }\ninterface Flag { name: string; version: string; defaultValue?: boolean; }\n\ninterface FlagEvaluationStrategy {\n  evaluate(user: User, flag: Flag): boolean;\n}\ntype StrategyFactory = () => FlagEvaluationStrategy;\n\nclass FlagRegistry {\n  private map = new Map<string, StrategyFactory>();\n  register(key: string, factory: StrategyFactory) { this.map.set(key, factory); }\n  get(key: string): FlagEvaluationStrategy {\n    const f = this.map.get(key);\n    if (!f) throw new Error(`No strategy registered for ${key}`);\n    return f();\n  }\n}\nclass FlagEvaluator {\n  constructor(private registry: FlagRegistry) {}\n  eval(flag: Flag, user: User): boolean {\n    const strat = this.registry.get(`${flag.name}|${flag.version}`);\n    return strat.evaluate(user, flag);\n  }\n}\nclass PercentStrategy implements FlagEvaluationStrategy {\n  constructor(private percent: number) {}\n  evaluate(user: User, flag: Flag): boolean {\n    const r = (parseInt(user.id.slice(-4), 10) % 100) < this.percent;\n    return r;\n  }\n}\n```","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Google","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T08:45:51.433Z","createdAt":"2026-01-13T08:45:51.433Z"},{"id":"q-2360","question":"Design a Runtime-Configurable Cache Eviction Engine: build a cache component that supports multiple eviction policies (LRU, LFU, Time-based); policies can be swapped at runtime without restarting the app. Use a pattern that lets you add new eviction strategies via a registry. Provide minimal interfaces, how to register/deregister policies, and an example usage that demonstrates policy switch mid-flight with ongoing hits?","answer":"Use Strategy with a Registry. EvictionStrategy has onAccess(key, value, cache) and evictIfNeeded(cache). Cache holds a concurrent map, capacity, and an AtomicReference<EvictionStrategy> active. A Regi","explanation":"## Why This Is Asked\nThis question tests pragmatic design for runtime pluggability of eviction policies without restart, a common real-world constraint.\n\n## Key Concepts\n- Strategy pattern with a pluggable registry\n- Thread-safe runtime reconfiguration\n- Minimal interfaces and factory-based registries\n- Trade-offs between policy complexity and memory overhead\n\n## Code Example\n```javascript\nclass EvictionStrategy {\n  onAccess(key, value, cache) {}\n  evictIfNeeded(cache) {}\n}\nclass Registry {\n  constructor() { this.factories = new Map(); }\n  register(name, factory) { this.factories.set(name, factory); }\n  create(name) { const f = this.factories.get(name); return f ? f() : null; }\n}\nclass Cache {\n  constructor(capacity) {\n    this.map = new Map();\n    this.capacity = capacity;\n    this.active = null;\n    this.registry = new Registry();\n  }\n  get(key) {\n    const v = this.map.get(key);\n    if (v !== undefined) this.active?.onAccess(key, v, this);\n    return v;\n  }\n  put(key, value) {\n    this.map.set(key, value);\n    if (this.map.size > this.capacity) this.active?.evictIfNeeded(this);\n  }\n  switchPolicy(name) { this.active = this.registry.create(name); }\n}\n```\n\n## Follow-up Questions\n- How to ensure eviction state migrations when changing policies?\n- How to test policy swap without locking performance?\n- How to handle policy-specific metrics and backpressure?","diagram":"flowchart TD\n  Cache(Cache) --> Registry[PolicyRegistry]\n  Registry --> ActivePolicy[ActivePolicy]\n  Cache --> GetPut[Get/Put]\n  GetPut --> Evict[Eviction]","difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T14:48:47.529Z","createdAt":"2026-01-15T14:48:47.529Z"},{"id":"q-2513","question":"Design a runtime-extensible data-format converter: the tool accepts files in JSON, CSV, and XML and should support new formats at runtime without touching the core converter. Which design pattern fits, and how would you structure minimal interfaces and a registry? Provide a usage example?","answer":"Use the Strategy pattern. Create a Format interface with parse(String):Data and serialize(Data):String, plus concrete JsonFormat, CsvFormat, XmlFormat. A FormatRegistry maps file extensions to supplie","explanation":"## Why This Is Asked\n\nDemonstrates open-closed extensibility by adding formats without changing the converter.\n\n## Key Concepts\n\n- Strategy pattern\n- Registry / Plugin pattern\n- Open/Closed Principle\n\n## Code Example\n\n```javascript\ninterface Format {\n  parse(str) \n  serialize(data)\n}\nclass JsonFormat implements Format { /* ... */ }\n```\n\n## Follow-up Questions\n\n- How would you handle format versioning?\n- How to ensure thread-safe registry access in concurrent runs?","diagram":"flowchart TD\n  Converter --> Registry\n  Registry --> JsonFormat\n  Registry --> CsvFormat\n  Registry --> XmlFormat\n  Converter --> JsonFormat","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T20:55:20.154Z","createdAt":"2026-01-15T20:55:20.154Z"},{"id":"q-2603","question":"Design a runtime-pluggable routing layer for a microservice gateway that allows adding new load-balancing and circuit-breaker strategies without touching the gateway core. Endpoints declare a strategy name and optional config; a central registry wires strategy instances to endpoints. Include minimal interfaces, a registry, and a usage example. How would you structure tests for correctness and fault tolerance?","answer":"Leverage the Strategy pattern for load balancing and circuit breakers, combined with a Registry/Factory pattern to map strategy names to concrete implementations. Define minimal interfaces such as `LoadBalancer` with a `next(targets)` method and `CircuitBreaker` with an `allowRequest()` method. The registry maintains strategy factories that create configured instances per endpoint, enabling runtime pluggability without modifying the gateway core.","explanation":"## Why This Is Asked\n\nThis question evaluates your ability to design extensible systems using advanced pattern composition: runtime extension of routing behavior through Strategy + Registry patterns, while ensuring testability and safety in production gateway environments.\n\n## Key Concepts\n\n- Strategy pattern for pluggable algorithms\n- Registry and Factory for dynamic instantiation\n- Composite routing with per-endpoint configuration\n- Observability and comprehensive fault tolerance testing\n\n## Code Example\n\n```javascript\n// Implementation sketch\nclass LoadBalancer { next(targets) {} }\nclass CircuitBreaker { allowRequest() { ... } }\nclass Registry { register(name, factory) ... get(name) ... }\n```\n\n## Follow-up Questions\n\n- How to version strategies for backward compatibility?\n- What observability metrics should each strategy expose?\n- How would you handle strategy hot-reloading in production?","diagram":"flowchart TD\n  Strategy --> Registry\n  Registry --> Endpoint\n  Endpoint --> LoadBalancer\n  Endpoint --> CircuitBreaker","difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Tesla","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T05:02:58.995Z","createdAt":"2026-01-16T02:32:44.699Z"},{"id":"q-2630","question":"In a mobile analytics SDK, events must be emitted in multiple serialization formats (JSON, MessagePack, Protobuf). Design a runtime-pluggable serializer system so new formats can be added without touching the producer. Which design pattern fits, and how would you structure a minimal Serializer interface, a Registry mapping names to serializers, and a usage example?","answer":"Use the Strategy pattern: define a Serializer interface with serialize(event) -> bytes, implement JsonSerializer, MsgPackSerializer, ProtobufSerializer, and build a SerializerRegistry that maps format","explanation":"## Why This Is Asked\nTests open-closed principle and plug-in extension for evolving formats.\n\n## Key Concepts\n- Strategy pattern for interchangeable serializers\n- Minimal interface per formatter\n- Registry/factory for runtime lookup\n- Open extension without modifying producers\n\n## Code Example\n```javascript\ninterface Serializer { serialize(event: Event): Uint8Array }\nclass JsonSerializer implements Serializer { serialize(e){ /*...*/ } }\nclass MsgPackSerializer implements Serializer { serialize(e){ /*...*/ } }\nclass SerializerRegistry {\n  private map = new Map<string, () => Serializer>();\n  register(name: string, ctor: () => Serializer){ this.map.set(name, ctor) }\n  get(name: string){ const c = this.map.get(name); return c ? c() : null }\n}\n```\n\n## Follow-up Questions\n- How would you handle versioned formats?\n- How to test the registry and serializers without real data?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Netflix","Robinhood","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T04:14:07.267Z","createdAt":"2026-01-16T04:14:07.267Z"},{"id":"q-2798","question":"Design a runtime-pluggable access-control system for a cloud storage service. The core stores resources; you must support multiple policy types (RBAC, ABAC, and custom dynamic policies) added at runtime without recompiling. Explain the minimal interfaces, a Registry, and how policies are evaluated per operation; include an example usage involving uploading a file with user attributes and resource metadata?","answer":"Design a runtime-pluggable access-control system for a cloud storage service. Define a Policy interface with evaluate(context) -> allow/deny; a Registry to register RBAC, ABAC, and custom dynamic poli","explanation":"## Why This Is Asked\nTests ability to design a plugin-based policy engine with runtime extensibility, cross-cutting concerns (authorization and auditing), and clear integration points in a scalable system.\n\n## Key Concepts\n- Plugin registry for policy modules\n- Policy interface and evaluation semantics\n- Policy composition (Chain/AllOf) and short-circuiting\n- Enforcement point placement and auditing\n\n## Code Example\n```javascript\nclass Policy {\n  evaluate(ctx) { throw new Error('not implemented') }\n}\nclass Registry {\n  constructor(){ this._map = new Map() }\n  register(name, factory){ this._map.set(name, factory) }\n  create(name, opts){ return this._map.get(name)(opts) }\n}\nclass PolicyChain {\n  constructor(policies){ this.policies = policies }\n  evaluate(ctx){\n    for (const p of this.policies){ if (!p.evaluate(ctx)) return false }\n    return true\n  }\n}\n```\n\n## Follow-up Questions\n- How handle conflicting decisions between policies? \n- How to test performance and correctness under load? \n- How to evolve policy schemas without breaking existing ones?","diagram":"flowchart TD\n  A[Client Request] --> B[Enforcement Point]\n  B --> C[PolicyChain]\n  C --> D[Policy1]\n  C --> E[Policy2]\n  D --> F[Decision]\n  E --> F\n  F --> G[Audit Log]\n  G --> H[Access Granted/Denied]","difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T13:04:33.166Z","createdAt":"2026-01-16T13:04:33.166Z"},{"id":"q-2992","question":"Design a runtime-extensible data-mapping system for a real-time event ingestion pipeline used by Stripe, Two Sigma, and Discord. Incoming events vary by source; implement a pluggable FieldMapper pattern that supports PassThrough, RenameFields, ComputedFields (expressions), and FlattenNested. Mappers must be addable at runtime via a registry without touching core. Describe minimal interfaces, registry structure, and a concrete usage scenario?","answer":"Define a FieldMapper interface with transform(input: Record) -> Record. Implement concrete mappers: PassThrough, RenameFields(config: {old: new}), ComputedFields(config: 'total = price * qty'), Flatte","explanation":"## Why This Is Asked\n\nTests ability to design a runtime-extensible plugin system for data transformation where new mappers can be added without touching core pipelines, a common need in data-heavy products.\n\n## Key Concepts\n\n- Strategy/Plugin pattern\n- Registry/Factory for runtime extensibility\n- Lightweight data modeling with minimal interfaces\n- Expression-based field computation and safe evaluation\n\n## Code Example\n\n```javascript\n// Minimal interface and sample mappers\nclass FieldMapper {\n  transform(input) { throw new Error('Not implemented'); }\n}\nclass PassThrough extends FieldMapper { transform(i) { return i; } }\nclass RenameFields extends FieldMapper { constructor(cfg){ super(); this.map = cfg; } transform(i){ const out={}; for(const k in i){ out[this.map[k]||k]=i[k]; } return out; } }\nclass ComputedFields extends FieldMapper { constructor(expr){ super(); this.expr=expr; } transform(i){ // naive eval\n  const out={...i}; out.total = i.price * i.qty; return out; } }\nclass FlattenNested extends FieldMapper { constructor(cfg){ super(); this.path=cfg.path; } transform(i){ const v = i[this.path] || {}; return { ...i, ...v }; } }\n```\n\n## Follow-up Questions\n\n- How would you handle security and sandboxing for ComputedFields expressions?\n- How would you version and migrate mapper configurations across deployments?","diagram":"flowchart TD\n  A[Event] --> B{Mapper Registry}\n  B --> C[Mapper: PassThrough]\n  B --> D[Mapper: RenameFields]\n  B --> E[Mapper: ComputedFields]\n  B --> F[Mapper: FlattenNested]\n  C --> G[OutputEvent]\n  D --> G\n  E --> G\n  F --> G","difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Stripe","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T20:34:00.524Z","createdAt":"2026-01-16T20:34:00.524Z"},{"id":"q-3085","question":"Design a small undoable text editor using the Command pattern. The editor supports insert and delete operations; each action should be a Command with execute and undo, and a History stack should manage undo/redo. How would you structure the interfaces and a minimal example showing inserting 'A' at position 0 and then undoing?","answer":"Use the Command pattern: define a Command interface with execute() and undo() methods. Implement InsertCommand and DeleteCommand that operate on a TextEditor receiver and capture the necessary state for undo operations (position and content).","explanation":"## Why This Is Asked\n\nThis question tests understanding of the Command pattern, undo/redo implementation, and state management in a minimal system.\n\n## Key Concepts\n\n- Command pattern with execute/undo methods\n- Receiver (TextEditor) and Command objects\n- History stack for undo/redo operations\n- State capture for reversible operations\n- Edge cases: boundary checking, no-op commands\n\n## Code Example\n\n```javascript\nclass Editor {\n  constructor() { this.text = ''; }\n  \n  insert(pos, ch) {\n    this.text = this.text.slice(0, pos) + ch + this.text.slice(pos);\n  }\n  \n  delete(pos, len) {\n    const removed = this.text.slice(pos, pos + len);\n    this.text = this.text.slice(0, pos) + this.text.slice(pos + len);\n    return removed;\n  }\n}\n\nclass InsertCommand {\n  constructor(editor, pos, ch) {\n    this.editor = editor;\n    this.pos = pos;\n    this.ch = ch;\n  }\n  \n  execute() {\n    this.editor.insert(this.pos, this.ch);\n  }\n  \n  undo() {\n    this.editor.delete(this.pos, 1);\n  }\n}\n\nclass History {\n  constructor() {\n    this.undoStack = [];\n    this.redoStack = [];\n  }\n  \n  execute(command) {\n    command.execute();\n    this.undoStack.push(command);\n    this.redoStack = [];\n  }\n  \n  undo() {\n    if (this.undoStack.length === 0) return;\n    const command = this.undoStack.pop();\n    command.undo();\n    this.redoStack.push(command);\n  }\n}\n\n// Example: Insert 'A' at position 0, then undo\nconst editor = new Editor();\nconst history = new History();\nconst insertA = new InsertCommand(editor, 0, 'A');\n\nhistory.execute(insertA); // text = 'A'\nhistory.undo(); // text = ''\n```\n\n## Implementation Notes\n\n- Commands capture all state needed for undo\n- History maintains separate undo/redo stacks\n- Each operation is atomic and reversible\n- Position validation ensures safe operations","diagram":"flowchart TD\nA[Start] --> B[Execute Command]\nB --> C[Push to History]\nC --> D[Undo/Redo]\nD --> E[End]","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Scale Ai","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T05:06:49.949Z","createdAt":"2026-01-17T02:08:45.601Z"},{"id":"q-3153","question":"Design a runtime-extensible request-validation engine for an API gateway: validators for JSON schema, business rules, and anti-abuse checks should be addable at runtime without touching the gateway core. Describe the architecture using a design pattern that supports pluggable validators via a registry, minimal interfaces, and a runtime usage example?","answer":"Use a Plugin/Registry pattern. Define Validator with validate(req): ValidationResult. The Registry provides an ordered list per route. Validators loadable at runtime from a secure plugin store; on con","explanation":"## Why This Is Asked\n\nThis question probes how to extend gateway behavior without redeploys, focusing on runtime plugin loading, ordering, and failure handling.\n\n## Key Concepts\n\n- Plugin/Registry pattern\n- Composite/short-circuit validation\n- Runtime configuration reload\n- Security and isolation of plugins\n\n## Code Example\n\n```javascript\n// Minimal interfaces\nclass Validator { validate(req) { } }\nclass Registry { getValidatorsForRoute(route) { return []; } }\n```\n\n## Follow-up Questions\n\n- How would you version validators and roll back a faulty one?\n- How do you test the registry-driven pipeline end-to-end?","diagram":"flowchart TD\n  G(API_Gateway) --> R[Validator Registry]\n  R --> P{Validators}\n  P -->|pass| S[Route to Service]\n  P -->|fail| E[Error Response]","difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Netflix","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T04:48:54.183Z","createdAt":"2026-01-17T04:48:54.184Z"},{"id":"q-3180","question":"Design a runtime-extensible authorization policy engine that supports multiple policy languages (RBAC, ABAC, ACL) and allows new languages to be added at runtime without touching the core. Describe the minimal interfaces and a registry mechanism; show how evaluation proceeds for a given user, resource, and action. Provide a concrete usage example registering a new language and evaluating a request?","answer":"Use a PolicyLanguage interface with evaluate(user, resource, action) -> boolean and a PolicyEngine that holds a Registry<string, () => PolicyLanguage>. New languages (RBAC, ABAC, ACL) are added by reg","explanation":"## Why This Is Asked\nAsks how to extend authorization without touching core, using a plugin/strategy approach to support multiple policy languages at runtime.\n\n## Key Concepts\n- Plugin architecture\n- Registry and factories\n- Strategy-like policy evaluation\n- Runtime extensibility and isolation\n\n## Code Example\n```javascript\n// Minimal TypeScript-like sketch\ninterface PolicyLanguage {\n  evaluate(user: any, resource: any, action: string): boolean;\n}\nclass RBACPolicy implements PolicyLanguage {\n  constructor(defs: any) {}\n  evaluate(user: any, resource: any, action: string): boolean { /*RBAC logic*/ return true; }\n}\nclass ABACPolicy implements PolicyLanguage {\n  constructor(attrs: any) {}\n  evaluate(user: any, resource: any, action: string): boolean { /*ABAC logic*/ return true; }\n}\n\nclass PolicyEngine {\n  private registry: any = {};\n  register(lang: string, factory: () => PolicyLanguage) { this.registry[lang] = factory; }\n  evaluate(user: any, resource: any, action: string, lang?: string): boolean {\n    const factory = lang ? this.registry[lang] : this.registry['default'];\n    const policy = factory();\n    return policy.evaluate(user, resource, action);\n  }\n}\n```\n\n## Follow-up Questions\n- How would you handle conflicting policies across languages?\n- How would you hot-swap policies without restart and ensure thread safety?","diagram":"flowchart TD\n  A[PolicyEngine] --> B{Language registry}\n  B --> C[RBACPolicy]\n  B --> D[ABACPolicy]\n  A --> E[Evaluate(user, resource, action)]","difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Meta","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T05:41:10.098Z","createdAt":"2026-01-17T05:41:10.098Z"},{"id":"q-3234","question":"Design a runtime-pluggable authentication mechanism for an API gateway that must support multiple methods: API key, OAuth2 bearer token, and HMAC signatures. The gateway should be able to add new methods at runtime without modifying core logic. Provide a minimal interface, a registry of strategies, and a usage example?","answer":"Use the Strategy pattern: define an AuthStrategy interface with an authenticate(req) method; implement ApiKeyStrategy, OAuthStrategy, etc. Maintain a registry mapping method name to strategy factories","explanation":"## Why This Is Asked\n\nThis question tests open-closed principle discipline and practical extensibility in a security-critical path by requiring a clean interface and a small registry. It demonstrates how to grow capabilities without touching core logic.\n\n## Key Concepts\n\n- Strategy pattern\n- Registry (factory/DI) for runtime extensibility\n- Dependency management and testing considerations\n- Performance and error handling trade-offs\n\n## Code Example\n\n```javascript\ninterface AuthStrategy {\n  authenticate(req: any): boolean\n}\nclass ApiKeyStrategy implements AuthStrategy {\n  authenticate(req: any) { /* validate key in header */ return true }\n}\nclass OAuthStrategy implements AuthStrategy {\n  authenticate(req: any) { /* validate bearer token */ return true }\n}\n\nclass AuthRegistry {\n  private map = new Map<string, AuthStrategy>()\n  register(name: string, s: AuthStrategy) { this.map.set(name, s) }\n  get(name: string): AuthStrategy { return this.map.get(name)! }\n}\n\n// usage\nconst registry = new AuthRegistry()\nregistry.register('apiKey', new ApiKeyStrategy())\nregistry.register('oauth', new OAuthStrategy())\n\nfunction handleRequest(req: any) {\n  const name = req.authMode // 'apiKey' or 'oauth'\n  const strat = registry.get(name)\n  if (strat.authenticate(req)) { /* proceed */ } else { /* reject */ }\n}\n```\n\n## Follow-up Questions\n\n- How would you test adding a new strategy without touching existing ones?\n- How would you manage lifecycle and DI for strategies in a multi-instance server?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","LinkedIn","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T07:44:38.774Z","createdAt":"2026-01-17T07:44:38.774Z"},{"id":"q-3436","question":"Design a runtime-pluggable rate limiter for a multi-tenant API gateway. It should support strategies like Token Bucket, Fixed Window, and Sliding Window, registerable at runtime and swappable per-tenant without recompiling core. Specify minimal interfaces, a registry, and how hot-swap is achieved, with a code-like usage example?","answer":"Use Strategy pattern with a RuntimeRegistry. Core: RateLimitStrategy interface; concrete: TokenBucket, FixedWindow, SlidingWindow. RateLimiter maintains Map<Tenant, RateLimitStrategy> and a Registry<S","explanation":"## Why This Is Asked\nReal-world systems need hot-swappable policies without redeploys; this tests patterns, thread-safety, and eviction strategies.\n\n## Key Concepts\n- Strategy, Registry, Atomic swap, Per-tenant policy\n- Thread-safety, hot-swapping, migration\n- Trade-offs: memory vs flexibility\n\n## Code Example\n```javascript\n// pseudo\ninterface RateLimitStrategy { allow(req): boolean }\nclass TokenBucket implements RateLimitStrategy {...}\nclass RateLimiter { Map tenants->RateLimitStrategy; Registry<String,Supplier<RateLimitStrategy>> registry }\n```\n\n## Follow-up Questions\n- How would you ensure atomic swaps during traffic spikes?\n- How to persist tenant policies across restarts?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["NVIDIA","Netflix","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T16:33:40.800Z","createdAt":"2026-01-17T16:33:40.801Z"},{"id":"q-3523","question":"Design a runtime-extensible API gateway policy engine where routing decisions, auth, and rate-limiting are driven by pluggable policies that can be registered at runtime without redeploying. Each policy implements a minimal interface and is discovered via a registry. Show minimal interfaces, a registry shape, and an example of adding a new 'geo-aware' rate-limiting policy. How would you ensure thread-safety and downtime-free hot reload during policy updates?","answer":"Use the Strategy pattern for policies and a runtime Registry to register policy definitions by name. Define a Policy interface: apply(ctx) returns decision data. Implement PolicyFactory to instantiate","explanation":"## Why This Is Asked\nTests ability to design a pluggable, runtime-extensible policy system for high-signal services like API gateways, focusing on lifecycle, concurrency, and hot-reload.\n\n## Key Concepts\n- Strategy pattern for interchangeable policies\n- Runtime registry for dynamic policy discovery\n- Thread-safety and hot-reload considerations\n\n## Code Example\n```typescript\ninterface RequestContext { route: string; user: User; metadata: any }\ninterface PolicyDecision { allow: boolean; reason?: string; quotas?: any }\ninterface Policy { apply(ctx: RequestContext): PolicyDecision }\nclass PolicyFactory { create(config: any): Policy }\n```\n\n## Follow-up Questions\n- How would you version policies and rollback safely?\n- How would you isolate policies across tenants and credentials?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","MongoDB","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T19:36:36.229Z","createdAt":"2026-01-17T19:36:36.230Z"},{"id":"q-3611","question":"Design a tiny logging framework with pluggable backends (console, file, remote). The core should not depend on concrete backends; instead, a registry maps names to backend factories and allows runtime extension. Provide interfaces, a minimal registry, and a usage example showing adding a 'syslog' backend and selecting backend via config?","answer":"Core exposes Backend interface and a Registry. Logger queries Registry for a backend by name and delegates log calls. Registry stores name->factory; new backends register themselves without touching L","explanation":"## Why This Is Asked\nTests the ability to design a simple plugin system using a registry and interface-based design, useful for extensibility in microservices.\n\n## Key Concepts\n- Registry pattern\n- Dependency inversion and interface-based design\n- Runtime extensibility with plugins\n- Minimal, testable API surface\n\n## Code Example\n```javascript\n// Minimal interfaces and wiring\nclass Backend {\n  log(level, msg) { throw new Error('not implemented') }\n}\nclass Registry {\n  constructor() { this._map = new Map() }\n  register(name, factory) { this._map.set(name, factory) }\n  get(name) { return this._map.get(name)() }\n}\nclass Logger { constructor(registry) { this._r = registry } log(level, msg) { this._r.get(level).log(level, msg) } }\n```\n\n## Follow-up Questions\n- How would you handle backend failures and fallback strategies?\n- How would you ensure thread-safety or process-wide singleton backends in a multi-process environment?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Slack","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T23:35:22.415Z","createdAt":"2026-01-17T23:35:22.415Z"},{"id":"q-3736","question":"Design a runtime-extensible log writer that outputs records in different formats. At runtime, the caller specifies the format by name (JSONL, CSV, NDJSON). The core writer must remain unchanged when adding new formats. Describe the architecture using a design pattern, provide minimal interfaces and a registry, and show a usage snippet?","answer":"Use the Strategy pattern for serializers plus a small Registry/Factory to map format names to concrete serializers. Define a Serializer interface with serialize(record) -> string, and implement JSONLS","explanation":"## Why This Is Asked\nTests knowledge of extending behavior without modifying core code (Open/Closed). It also assesses choosing a clean extension point (Strategy) and a simple registry to map runtime options to implementations.\n\n## Key Concepts\n- Strategy pattern\n- Registry/Factory\n- Open/Closed principle\n- Dependency injection\n\n## Code Example\n```javascript\nclass Serializer {\n  serialize(record) { throw new Error('Not implemented'); }\n}\nclass JSONLSerializer extends Serializer {\n  serialize(record) { return JSON.stringify(record) + '\\n'; }\n}\nclass CSVSerializer extends Serializer {\n  serialize(record) { /* minimal CSV escaping omitted for brevity */ return Object.values(record).join(','); }\n}\nclass NDJSONSerializer extends Serializer {\n  serialize(record) { return JSON.stringify(record) + '\\n'; }\n}\n```\n\n```javascript\n// Registry / factory\nconst Registry = {\n  jsonl: () => new JSONLSerializer(),\n  csv: () => new CSVSerializer(),\n  ndjson: () => new NDJSONSerializer()\n};\n\nfunction createWriter(format) {\n  const serializer = Registry[format]?.();\n  if (!serializer) throw new Error('Unknown format');\n  return {\n    write: (record) => serializer.serialize(record)\n  };\n}\n```\n\n## Follow-up Questions\n- How would you handle format-specific options (delimiter, headers)?\n- How would you test the registry and serializers in isolation?","diagram":"flowchart TD\n  W[Writer] --> SFactory[Serializer Factory/Registry]\n  SFactory --> JSONL[JSONLSerializer]\n  SFactory --> CSV[CSVSerializer]\n  SFactory --> NDJSON[NDJSONSerializer]\n  W --> S[Serializer instance]\n","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Snap","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T07:34:31.501Z","createdAt":"2026-01-18T07:34:31.501Z"},{"id":"q-3826","question":"Design a runtime-extensible feature-flag evaluation system for a multi-tenant platform. The system must support multiple evaluation strategies: boolean flags, context-aware rules (e.g., region and plan), and experiment-based A/B tests. New strategies should be pluggable at runtime via a registry without touching the core evaluator. Provide a minimal interface, a registry, and a usage example?","answer":"Use the Strategy pattern with a Registry. Core engine stores Map<string, EvaluatorFactory> and delegates evaluation to an Evaluator created by the factory. Evaluator implements boolean evaluate(Contex","explanation":"## Why This Is Asked\nTests ability to design extensible, runtime-extendable components with minimal coupling using Strategy + Registry patterns.\n\n## Key Concepts\n- Strategy: encapsulate evaluation logic per flag\n- Registry/Plugin: dynamic, runtime-extensible factories\n- Dependency Injection: decouples engine from evaluators\n- Thread-safety and versioning considerations for runtime extensions\n\n## Code Example\n```typescript\ninterface Context { tenantId: string; userId: string; region?: string; [key: string]: any }\ninterface Evaluator { evaluate(ctx: Context): boolean }\ninterface EvaluatorFactory { create(): Evaluator }\nclass Registry { private map = new Map<string, EvaluatorFactory>(); register(n: string, f: EvaluatorFactory) { this.map.set(n, f) } getFactory(n: string): EvaluatorFactory | undefined { return this.map.get(n) } }\nclass FlagEngine { constructor(private registry: Registry) {} isEnabled(flag: string, ctx: Context): boolean { const f = this.registry.getFactory(flag); if (!f) throw new Error(`Unknown flag: ${flag}`); return f.create().evaluate(ctx); } }\n```\n\n## Follow-up Questions\n- How would you handle hot-reload of strategies without restarting the service?\n- How would you version/evolve evaluator interfaces while keeping backward compatibility?","diagram":"flowchart TD\n  Engine[FlagEngine] --> Registry[Registry]\n  Registry -->|getFactory| Factory[EvaluatorFactory]\n  Factory --> Evaluator[Evaluator]\n  Evaluator --> Result[boolean]","difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Instacart","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T11:24:19.288Z","createdAt":"2026-01-18T11:24:19.289Z"},{"id":"q-3945","question":"Design a system where a base DataSource can be wrapped by any number of processing decorators (e.g., Logging, Masking, Compression). The decorators are registered by name at runtime and can be applied to a data source chain without changing the core. Implement minimal interfaces, a registry, and a usage example?","answer":"Approach: implement the Decorator pattern with a small Registry. Define DataSource { read() }, DataSourceDecorator implements DataSource and holds a DataSource; concrete decorators (Logging, Masking, ","explanation":"## Why This Is Asked\nTests ability to extend behavior without touching core logic, using Decorator and a runtime registry.\n\n## Key Concepts\n- Decorator pattern\n- Lightweight registry for runtime extension\n- Dynamic composition of wrappers\n\n## Code Example\n```javascript\n// Pseudocode showing interfaces and composition\n```\n## Follow-up Questions\n- How to guarantee decorator application order?\n- How to handle decorator errors without breaking the chain?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Slack","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T16:43:26.510Z","createdAt":"2026-01-18T16:43:26.510Z"},{"id":"q-3956","question":"Design a runtime-extensible resource pool that supports multiple eviction strategies (LRU, LFU, TTL). Each pool entry uses a policy selected by name at runtime, and new eviction strategies can be added without touching the pool core. Provide a minimal IPolicy interface, a PolicyRegistry, and a usage example showing how to plug a new policy for a given connection without recompiling the pool?","answer":"Use the Strategy pattern. Define IPolicy with onAccess and onEvict; implement LRUPolicy, LFUPolicy, TTLPolicy. PolicyRegistry registers and resolves by name; pool delegates eviction to the resolved po","explanation":"## Why This Is Asked\n\nTests ability to design runtime-extensible behavior via a registry and strategy-like eviction policies, with testable components and clear extension points.\n\n## Key Concepts\n\n- Strategy pattern\n- Registry for dynamic policy binding\n- Runtime extensibility without core changes\n- Testable policy interactions\n\n## Code Example\n\n```typescript\ntype Entry = { id: string; lastAccess: number; size: number };\n\ninterface IPolicy {\n  onAccess(entry: Entry): void;\n  onEvict(entries: Entry[]): boolean;\n}\n\nclass LRUPolicy implements IPolicy {\n  onAccess(_e: Entry) { /* update recency */ }\n  onEvict(_entries: Entry[]): boolean { /* evict oldest */ return true; }\n}\n\nclass TTLPolicy implements IPolicy {\n  constructor(private ttl: number) {}\n  onAccess(_e: Entry) { /* refresh */ }\n  onEvict(_entries: Entry[]): boolean { /* compare now - lastAccess > ttl */ return true; }\n}\n\nclass PolicyRegistry {\n  private map = new Map<string, IPolicy>();\n  register(name: string, p: IPolicy) { this.map.set(name, p); }\n  resolve(name: string): IPolicy { return this.map.get(name)!; }\n}\n```\n\n## Follow-up Questions\n\n- How would you test race conditions when policies are registered concurrently?\n- What are the tradeoffs of per-entry policy resolution vs a single global policy for performance?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Cloudflare","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T17:26:21.684Z","createdAt":"2026-01-18T17:26:21.686Z"},{"id":"q-4119","question":"Design a runtime-extensible transport layer for a data ingestion service that can route data to HTTP, Kafka, or gRPC transports. New transports should be pluggable at runtime without changing core; design a minimal interface and a registry to support this. Which design pattern would you choose and how would you implement it? Provide a usage example?","answer":"Use the Strategy pattern with a pluggable TransportRegistry. Define interface Transport { send(data: Data): Promise<Status> }. Core holds a Transport strategy and delegates. TransportRegistry maps names to factory functions for dynamic instantiation. New transports register at runtime via the registry, enabling hot-swapping without core changes.","explanation":"## Why This Is Asked\nRuntime pluggability enables changing transports without redeployment, critical in latency-sensitive data pipelines.\n\n## Key Concepts\n- Strategy pattern for transport behavior abstraction\n- Registry/plugin architecture for dynamic loading\n- Lazy loading and dependency injection\n\n## Code Example\n```javascript\nclass TransportRegistry {\n  constructor() { this.map = new Map(); }\n  register(name, factory) { this.map.set(name, factory); }\n  get(name) { const f = this.map.get(name); return f ? f() : null; }\n}\nclass HttpTransport { /*...*/ }\nclass KafkaTransport { /*...*/ }\n```","diagram":"flowchart TD\n  Core[Core] --> Registry[Transport Registry]\n  Core --> Strategy[Current Transport]\n  Registry -->|load| TransportImpl[NewTransport]\n  Strategy --> TransportImpl","difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Stripe","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T05:08:48.348Z","createdAt":"2026-01-19T02:51:28.909Z"},{"id":"q-4323","question":"Design a pluggable policy-based access control (PBAC) system where authorization decisions can be extended at runtime by adding new policy evaluation strategies (e.g., RBAC, ABAC, context-aware) without recompiling services. Describe minimal interfaces, a registry, and how you would ensure consistency across distributed services. Include a concrete usage example showing how a new policy type is registered and evaluated?","answer":"Define a Policy interface with evaluate(ctx) boolean. Implement concrete strategies: RBACPolicy, ABACPolicy, ContextPolicy. Use a PolicyRegistry (string->Policy) loaded at runtime via a PluginLoader o","explanation":"## Why This Is Asked\nTests ability to design runtime-extensible security logic and reason about distribution.\n\n## Key Concepts\n- Strategy and Plugin patterns\n- Registry and versioned policy loading\n- Consistency in distributed decisions\n- Safe hot-swapping and rollback\n\n## Code Example\n```javascript\ninterface Policy { evaluate(ctx: Context): boolean }\nclass RBACPolicy implements Policy { constructor(...){}; evaluate(ctx){ /* ... */ return true } }\n```\n\n## Follow-up Questions\n- How handle conflicting policies?\n- How to audit policy changes?\n","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Stripe","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T13:34:42.862Z","createdAt":"2026-01-19T13:34:42.863Z"},{"id":"q-4513","question":"Design a pluggable file parser system for a data importer: the core imports files and delegates parsing to a Parser backend chosen by file extension (e.g., .csv, .json, .xml). Propose a registry to map extensions to parsers and show how to add a YAML parser at runtime without touching the importer. Which pattern would you use and why? Provide minimal interfaces and a usage example?","answer":"Use the Strategy pattern with a minimal Parser interface and a Registry/Factory to map file extensions to concrete parsers. The importer calls parserFactory.get(ext).parse(file). To add YAML, register a YAMLParser instance for the '.yaml' extension without modifying the core importer.","explanation":"## Why This Is Asked\nTests understanding of the open/closed principle, polymorphism, and runtime extensibility. It also checks the ability to add new parsing backends without touching the core importer.\n\n## Key Concepts\n- Strategy pattern\n- Registry/Plugin registry\n- Open-Closed principle\n- Dependency injection\n\n## Code Example\n```javascript\nclass Parser {\n  parse(input) {\n    throw new Error('not implemented');\n  }\n}\n\nclass CSVParser extends Parser {\n  parse(input) {\n    // CSV parsing logic\n    return [];\n  }\n}\n\nclass YAMLParser extends Parser {\n  parse(input) {\n    // YAML parsing logic\n    return [];\n  }\n}\n\nclass ParserRegistry {\n  constructor() {\n    this.parsers = new Map();\n  }\n  \n  register(extension, parser) {\n    this.parsers.set(extension, parser);\n  }\n  \n  get(extension) {\n    return this.parsers.get(extension);\n  }\n}\n\n// Usage\nconst registry = new ParserRegistry();\nregistry.register('.csv', new CSVParser());\nregistry.register('.yaml', new YAMLParser());\n\n// Core importer (unchanged)\nfunction importFile(filePath) {\n  const ext = path.extname(filePath);\n  const parser = registry.get(ext);\n  return parser.parse(fs.readFileSync(filePath));\n}\n```","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Instacart"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T07:32:23.994Z","createdAt":"2026-01-19T21:53:02.823Z"},{"id":"q-4529","question":"Design a runtime-extensible command interpreter for a distributed task queue. The system receives JSON commands from producers; new command types should be added as plugins without redeploying the interpreter. Explain how to structure interfaces, a plugin registry, and isolation, and how to handle versioned command schemas. Provide minimal interfaces and usage example?","answer":"Implement a runtime plugin registry that maps command types to factories returning concrete handlers. Define a lightweight Command interface with execute(ctx, payload) and a CommandFactory that creates handlers. The registry maintains a nested Map of commandType  version  factory, enabling versioned command schemas and graceful deprecation. Plugins register themselves at startup via reflection or configuration files, with isolation achieved through worker pools or process boundaries. Commands include schema validation before execution, with version negotiation supporting backward compatibility.","explanation":"## Why This Is Asked\nExplores dynamic extensibility and runtime hot-swapping of behavior without redeployments, crucial for scalable data platforms.\n\n## Key Concepts\n- Plugin registry mapping (type, version) to handlers\n- Versioned command schemas and graceful deprecation\n- Isolation via worker pools or process boundaries\n\n## Code Example\n```javascript\n// Minimal interface sketch (TypeScript-like)\ninterface Command {\n  execute(ctx: any, payload: any): Promise<void>;\n}\ninterface PluginFactory {\n  create(payload: any): Command;\n}\nclass Registry {\n  private map = new Map<string, Map<number, PluginFactory>>();\n  \n  register(type: string, version: number, factory: PluginFactory) {\n    if (!this.map.has(type)) {\n      this.map.set(type, new Map());\n    }\n    this.map.get(type)!.set(version, factory);\n  }\n  \n  create(type: string, version: number, payload: any): Command | null {\n    return this.map.get(type)?.get(version)?.create(payload) || null;\n  }\n}\n```","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Hugging Face"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T06:37:11.643Z","createdAt":"2026-01-19T22:41:11.268Z"},{"id":"q-4579","question":"Design a pluggable API gateway authentication framework: the gateway handles per-route authentication using multiple strategies (API key, JWT, mTLS). Allow registering new strategies at runtime without touching the gateway core; must support strategy chaining for routes that require multiple checks. Describe interfaces, a registry, and a concrete usage example?","answer":"Implement a pluggable authentication framework using the Strategy pattern with a dynamic registry. Define an AuthStrategy interface with an authenticate(req) method that returns a Principal or error. Implement concrete strategies: ApiKeyStrategy, JwtStrategy, and MTLSStrategy. Create a Registry that maps strategy names to factory functions for runtime registration. Each route configuration references strategies by name, enabling strategy chaining with short-circuiting behavior. New strategies can be registered at runtime without modifying gateway core code.","explanation":"## Why This Is Asked\nTests runtime extensibility of security policies and how to compose multiple auth checks per route.\n\n## Key Concepts\n- Strategy pattern for individual auth checks\n- Registry pattern for dynamic extension\n- Per-route policy composition with clear short-circuiting\n- Security concerns: token validation, replay protection, clock skew\n\n## Code Example\n```javascript\n// Minimal skeleton showing interfaces and registry usage\ninterface AuthStrategy { authenticate(req): Promise<Principal>; }\nclass ApiKeyStrategy implements AuthStrategy { /*...*/ }\nclass JwtStrategy implements AuthStrategy { /*...*/ }\nclass MTLSStrategy implements AuthStrategy { /*...*/ }\n```","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Netflix","Uber","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T05:57:07.678Z","createdAt":"2026-01-20T02:30:49.463Z"},{"id":"q-4708","question":"Design a runtime-rule engine for a financial transactions platform where new fraud-detection rules can be added without redeploying the engine; each rule computes a risk contribution (e.g., velocity-based spend, IP-geography mismatch, device fingerprint). Implement with a design pattern that lets you register new rules at runtime and apply them in a deterministic order to produce a final risk score and a pass/fail decision. Include minimal interfaces, a registry, and a usage example?","answer":"Use the Strategy pattern for Rule interfaces with a RuntimeRuleRegistry that stores rules by priority and allows dynamic registration. Each rule implements compute(tx): number; the engine aggregates s","explanation":"## Why This Is Asked\nTests runtime extensibility, deterministic composition, and thread-safety in a real fraud-detection context.\n\n## Key Concepts\n- Strategy pattern for individual rules\n- Registry for dynamic, ordered plugins\n- Thread-safety and immutability for runtime changes\n- Deterministic evaluation order\n\n## Code Example\n```javascript\nexport interface FraudRule {\n  priority: number\n  compute(transaction: Transaction): number\n}\n\nexport class RuleRegistry {\n  private rules: FraudRule[] = []\n  register(r: FraudRule) { this.rules.push(r); this.rules.sort((a,b)=>a.priority-b.priority) }\n  evaluate(tx: Transaction): number {\n    let score = 0\n    for (const r of this.rules) score += r.compute(tx)\n    return score\n  }\n}\n```\n\n## Follow-up Questions\n- How would you handle rule validity and versioning when a rule changes?\n- Discuss testing strategies for rule interactions and order sensitivity.","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T09:08:48.900Z","createdAt":"2026-01-20T09:08:48.900Z"},{"id":"q-4734","question":"Design a runtime-extendable deployment strategy engine for a multi-environment CI/CD pipeline. The engine must support blue/green, canary, rolling, and allow new strategies to be added at runtime via a registry, selected based on environment metadata (region, service tier, risk). Provide minimal interfaces and a usage example?","answer":"Use Strategy + Registry patterns. Define DeploymentStrategy with plan(ctx) returning steps. Implement BlueGreen, Canary, Rolling as concrete strategies. Registry loads strategies at runtime (plugin SP","explanation":"## Why This Is Asked\nTests ability to design pluggable deployment logic and reason about runtime extensibility and safety.\n\n## Key Concepts\n- Strategy pattern for deployment plans\n- Registry/plugin mechanism for runtime extensions\n- Metadata-driven selection and safe hot-swapping\n- Testability of dynamic strategies\n\n## Code Example\n```javascript\n// DeploymentStrategy interface\nclass DeploymentStrategy {\n  plan(ctx) { throw new Error('not implemented') }\n}\n\nclass CanaryStrategy extends DeploymentStrategy {\n  plan(ctx){ return ['route 10%', 'monitor', 'full rollout']}\n}\n```\n\n## Follow-up Questions\n- How to ensure backward compatibility when new strategies are added?\n- How would you test dynamic strategies and rollbacks?","diagram":"flowchart TD\nA[API Request] --> B{Env metadata}\nB --> C[Registry.get(strategyName)]\nC --> D[plan(ctx)]\nD --> E[Execute steps]\n","difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Square","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T10:11:22.670Z","createdAt":"2026-01-20T10:11:22.671Z"},{"id":"q-4741","question":"Design a runtime-extendable input validator system for a data ingestion pipeline. Each JSON record has fields like email, age, and country. Create a Validator interface and a Registry so new validators (e.g., phone, ZIP) can be added at runtime without touching ingestion core. Provide minimal interfaces, a registry, and a brief usage example?","answer":"Use a Strategy-style Validator interface and a dynamic Registry. Define Validator{Validate(string) error} and ValidatorFactory{Create():Validator}. Ingest core looks up field-specific Validator by nam","explanation":"## Why This Is Asked\nTests ability to extend behavior without touching core code, a common beginner design task. It also covers decoupling, simple registries, and safe runtime extension.\n\n## Key Concepts\n- Strategy pattern\n- Registry / plugin registry\n- Decoupling of validation logic from ingestion\n- Runtime extensibility\n\n## Code Example\n```javascript\nclass Validator {\n  validate(value) { throw new Error('not implemented') }\n}\n\nconst registry = new Map<string, () => Validator>()\n\nfunction register(field, factory) { registry.set(field, factory) }\n\nfunction validate(field, value) {\n  const factory = registry.get(field)\n  if (!factory) throw new Error('no validator')\n  return factory().validate(value)\n}\n```\n\n## Follow-up Questions\n- How would you handle validator versioning and backward compatibility?\n- How would you expose a runtime reload endpoint for new validators without redeploying? ","diagram":"flowchart TD\n  A[Ingest Record] --> B{Field present?}\n  B -->|Yes| C[Lookup Validator in Registry by Field]\n  C --> D[Validator.Validate(value)]\n  D --> E{Valid?}\n  E -->|Yes| F[Store Record]\n  E -->|No| G[Reject/Error]","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Slack","Snowflake","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T10:40:11.341Z","createdAt":"2026-01-20T10:40:11.341Z"},{"id":"q-4891","question":"Design a runtime-extendable rate-limiting policy engine for an API gateway. It must support pluggable strategies (token bucket, fixed window, sliding window, leaky bucket) and allow new strategies to be registered at runtime via a registry without redeploying. Include per-client and per-endpoint overrides, hierarchical policy loading, and hot-swapping. Provide minimal interfaces, a registry, and a usage example?","answer":"Propose a Strategy+Registry approach: define an abstract RateLimitStrategy { apply(clientId, endpoint, windowMs, events) }, with concrete strategies tokenBucket, fixedWindow, slidingWindow, leakyBucke","explanation":"## Why This Is Asked\nInterviewers want to assess pattern choices for runtime extensibility, hot-swapping, and per-entity overrides in a real API gateway context.\n\n## Key Concepts\n- Strategy pattern for rate-limiting algorithms.\n- Registry/Plugin pattern for runtime extension.\n- Hierarchical policies: global defaults with per-client and per-endpoint overrides.\n- Hot-swapping without restart and safe migration.\n\n## Code Example\n```typescript\ninterface RateLimitStrategy {\n  apply(clientId: string, endpoint: string, windowMs: number, events: number): { allowed: boolean; remaining: number }\n}\n\nclass TokenBucket implements RateLimitStrategy { /* ... */ }\n\ntype Factory = () => RateLimitStrategy;\nclass StrategyRegistry {\n  private map = new Map<string, Factory>();\n  register(name: string, f: Factory) { this.map.set(name, f); }\n  create(name: string): RateLimitStrategy | null { const f = this.map.get(name); return f ? f() : null; }\n}\n```\n\n## Follow-up Questions\n- How would you ensure atomic register/lookup in a distributed gateway?\n- What tests would you add to verify hot-swapping strategies without affecting in-flight requests?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","PayPal","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T17:47:58.834Z","createdAt":"2026-01-20T17:47:58.835Z"},{"id":"q-5094","question":"Design a runtime-extensible policy evaluation engine for access control that supports RBAC, ABAC, and dynamic, attribute-based policies. Policies must be pluggable at runtime without recompiling, added via a registry, and composable in a decision pipeline. Provide minimal interfaces, a registry, and a usage example?","answer":"Use a Policy (Strategy) pattern with a Policy interface: evaluate(user, resource, context) -> bool, plus a PolicyRegistry that maps policy names to implementations and can load new ones at runtime via","explanation":"## Why This Is Asked\nTests ability to design a pluggable security policy system with runtime extensibility, composability, and observability.\n\n## Key Concepts\n- Policy (Strategy) pattern for evaluation core\n- Runtime registry and plugin loading for new policies\n- Policy composition, caching, and explainable decisions\n- Auditing hooks for decision traces\n\n## Code Example\n```java\ninterface Policy {\n  boolean evaluate(User u, Resource r, Context ctx);\n}\ninterface PolicyFactory {\n  Policy create();\n}\nclass PolicyRegistry {\n  PolicyFactory getFactory(String name);\n}\n```\n\n## Follow-up Questions\n- How to resolve conflicts when multiple policies apply?\n- How would you test policy combinations and explainability at scale?","diagram":"flowchart TD\n  Client(Client) --> Resolver[PolicyResolver]\n  Resolver --> Registry[PolicyRegistry]\n  Registry --> Policy[Policy implementations]\n  Policy --> Decision[Decision]","difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T05:53:48.176Z","createdAt":"2026-01-21T05:53:48.177Z"},{"id":"q-5181","question":"Design a runtime-extensible event routing system for a high-throughput ingest service. Events arrive with a type field (e.g., Audit, Alert, Metrics). New handlers must be added without recompiling the core dispatcher. Which pattern fits best, and how would you implement a minimal interface and a registry so a new 'Audit' handler can be registered at runtime and invoked for matching events?","answer":"Use the Strategy pattern with a central Registry. Define EventHandler { void handle(Event e); String type(); } and a HandlerRegistry { void register(String type, Supplier<EventHandler> ctor); EventHan","explanation":"## Why This Is Asked\nTests ability to design a pluggable, runtime-extensible routing system without touching the dispatcher. Emphasizes trade-offs between reflection vs factory-based resolution and thread-safe registries.\n\n## Key Concepts\n- Strategy pattern for per-type behavior\n- Registry/Factory for runtime extensibility\n- Thread-safety, lazy initialization, and lifecycle of handlers\n\n## Code Example\n```javascript\nclass EventHandler {\n  constructor() {}\n  handle(event) { /* implement in subclass */ }\n  type() { return this.constructor.name; }\n}\nclass HandlerRegistry {\n  constructor() { this.map = new Map(); }\n  register(type, ctor) { this.map.set(type, ctor); }\n  resolve(type) { const ctor = this.map.get(type); return ctor ? new ctor() : null; }\n  dispatch(event) { const h = this.resolve(event.type); h && h.handle(event); }\n}\n```\n\n## Follow-up Questions\n- How would you make the registry hot-reloadable without stalling ingestion?\n- What are the performance and memory implications of many dynamically loaded handlers?","diagram":"flowchart TD\n  A[Ingest Server] --> B[Dispatcher]\n  B --> C{Event Type}\n  C -->|Audit| D[AuditHandler]\n  C -->|Alert| E[AlertHandler]\n  C -->|Metrics| F[MetricsHandler]","difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Microsoft","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T09:59:32.643Z","createdAt":"2026-01-21T09:59:32.643Z"},{"id":"q-5293","question":"Design a runtime-pluggable authorization framework: policies (RBAC, ABAC, PBAC) register at runtime and are evaluated by a central AccessController without modifying its core. Each Policy implements bool evaluate(User, Resource, Action). Provide a minimal interface, a registry, and a usage example; discuss policy ordering, conflict resolution, and hot-reload of policies?","answer":"Implement a Policy interface with boolean evaluate(User user, Resource resource, Action action). Build a PolicyRegistry that supports dynamic registration and atomic swaps for hot-reload. AccessContro","explanation":"## Why This Is Asked\nTests the ability to design runtime extensibility for security-critical components, including hot-reload and safe concurrency.\n\n## Key Concepts\n- Runtime pluggability via a policy registry\n- Evaluation order and conflict resolution\n- Thread-safety and atomic swaps for hot-reload\n- RBAC/ABAC/PBAC composition and performance trade-offs\n\n## Code Example\n```java\ninterface Policy {\n  boolean evaluate(User user, Resource resource, Action action);\n  String name();\n}\nclass PolicyRegistry {\n  private final java.util.concurrent.atomic.AtomicReference<java.util.Map<String, Policy>> policies =\n      new java.util.concurrent.atomic.AtomicReference<>(java.util.Collections.emptyMap());\n\n  public void register(String name, Policy p) {\n    var next = new java.util.HashMap<>(policies.get());\n    next.put(name, p);\n    policies.set(java.util.Collections.unmodifiableMap(next));\n  }\n\n  public boolean evaluate(User user, Resource resource, Action action) {\n    for (Policy p : policies.get().values()) {\n      if (p.evaluate(user, resource, action)) return true;\n    }\n    return false;\n  }\n\n  public void reload(java.util.Map<String, Policy> newPolicies) {\n    policies.set(java.util.Collections.unmodifiableMap(new java.util.HashMap<>(newPolicies)));\n  }\n}\n```\n\n## Follow-up Questions\n- How would you determine policy precedence when multiple policies apply with conflicting results?\n- How would you test hot-reload paths without impacting live requests?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","IBM","Slack"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T15:41:05.573Z","createdAt":"2026-01-21T15:41:05.576Z"},{"id":"q-5330","question":"Design a runtime-extensible ad-hoc experiment allocation engine for A/B tests. New allocation strategies (uniform, weighted, percentile, etc.) must be added at runtime without recompiling the engine. Describe the minimal interfaces, a registry, and how the engine selects and applies a strategy per experiment. Provide a usage sketch?","answer":"Use the Strategy pattern with a runtime plugin registry. Define AllocationStrategy { Variant allocate(User, Experiment) }. Core engine selects strategyName from experiment config, asks the Registry fo","explanation":"## Why This Is Asked\n\nTo evaluate ability to extend behavior via composition without touching core, simulating production plugin ecosystems.\n\n## Key Concepts\n\n- Strategy pattern\n- Plugin registry\n- Runtime loading\n- Safety sandboxing\n- Contract tests\n\n## Code Example\n\n```javascript\n// Minimal interfaces\ninterface AllocationStrategy {\n  allocate(userId: string, variants: string[]): string;\n}\nclass UniformStrategy implements AllocationStrategy { allocate(u,v){ /* simple round-robin/hash */ return v[0]; } }\n```\n\n## Follow-up Questions\n\n- How would you handle versioning of strategies?\n- How would you audit/roll back a faulty strategy?","diagram":"flowchart TD\n  Engine[Experiment Engine] --> Registry[Strategy Registry]\n  Registry --> Factory[AllocationStrategyFactory]\n  Factory --> Strategy[AllocationStrategy]\n  Engine --> Strategy","difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Apple","Coinbase"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T17:25:03.905Z","createdAt":"2026-01-21T17:25:03.905Z"},{"id":"q-5405","question":"Design a runtime plugin system for a tiny CLI data processor: the core runner supports load, transform, and save. New transforms and data sources can be added as plugins via a plugins directory and a manifest. Describe the minimal interfaces, a registry discovery mechanism, and how the core selects a plugin at runtime. Include a usage example?","answer":"Define a Plugin interface with init(config), name(), and run(data, context). The Registry scans plugins/, validates a manifest, loads modules, and exposes adapters to the core. The core queries the re","explanation":"## Why This Is Asked\n\nThis tests designing an extensible, runtime plugin system without mutating the core, a common real-world requirement.\n\n## Key Concepts\n\n- Plugin interface design\n- Registry discovery and loading\n- Compatibility/version checks\n- Safe isolation of plugins\n\n## Code Example\n\n```javascript\nexport interface Plugin {\n  init(config: any): void;\n  name(): string;\n  run(data: any, ctx: any): any;\n}\n\nexport class Registry {\n  constructor(private path: string) {}\n  load(): Plugin[] { /* load and validate plugins */ }\n  getFor(op: string): Plugin | null { /* find by op */ }\n}\n```\n\n## Follow-up Questions\n\n- How would you handle plugin versioning and backward compatibility?\n- What strategies would you use to sandbox or limit plugin effects (permissions, memory)?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Slack","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T21:04:19.383Z","createdAt":"2026-01-21T21:04:19.384Z"},{"id":"q-5480","question":"Design a runtime-extendable task-scheduling plugin system for a distributed ride-hailing dispatch service. The dispatcher must support multiple strategies (FIFO, priority-based, deadline-aware) that can be added or swapped at runtime through a **registry** without touching the core dispatcher. Define minimal interfaces, a thread-safe **Registry**, and a concise usage example showing how a new strategy is registered and selected for a ride request near pickup time?","answer":"Use a ScheduleStrategy interface with a `schedule(ride, pool)` method that returns a DispatchCandidate. Implement concrete strategies: FIFO, Priority, and Deadline. Maintain a thread-safe Registry that maps strategy names to StrategyFactory instances for runtime extension.","explanation":"## Why This Is Asked\nTests ability to design pluggable components and runtime extension in a distributed dispatch system.\n\n## Key Concepts\n- Strategy pattern\n- Plugin/Registry pattern\n- Concurrency safety\n- Hot-swapping and versioning\n\n## Code Example\n```javascript\n// Minimal interfaces and registry sketch\ninterface ScheduleStrategy {\n  schedule(ride, pool): DispatchCandidate\n}\nclass StrategyRegistry {\n  register(name, factory) {}\n  get(name) { return factory() }\n}\n```\n\n## Follow-up Questions\n- How would you test hot-swaps without affecting in-flight dispatches?\n- What metrics would you collect?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Anthropic"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T05:33:20.871Z","createdAt":"2026-01-21T23:51:37.352Z"},{"id":"q-5493","question":"Design a runtime-extensible access control system for a multi-tenant app. Each resource has a chain of permission checkers (e.g., role-based, attribute-based, time-based, location-based). The chain can be extended at runtime by adding new checkers via a registry, without modifying the core ACL. Explain how you would implement minimal interfaces, how to resolve the chain for a given request, and give a usage example?","answer":"Implement a runtime-extensible access control system using the Chain of Responsibility pattern. Each permission checker implements a `check(ctx)` method and forwards to the next checker in the chain. A Registry stores checker factories by name with configurable ordering. At runtime, resources dynamically assemble their checker chains from the registry without modifying core ACL logic. New checkers can be registered and injected into existing chains at runtime, ensuring the system remains extensible while maintaining security guarantees.","explanation":"## Why This Is Asked\nThis question evaluates your ability to design dynamically extensible security systems that support plugin-like flexibility while maintaining proper permission ordering under multi-tenant constraints.\n\n## Key Concepts\n- Chain of Responsibility pattern for sequential permission evaluation\n- Registry/Plugin pattern for runtime extensibility\n- Inversion of Control with configurable ordering guarantees\n- Short-circuit semantics for optimal performance\n\n## Code Example\n```javascript\nclass Checker {\n  constructor(next) {\n    this.next = next;\n  }\n  check(ctx) {\n    if (this.next) return this.next.check(ctx);\n    return true;\n  }\n}\n\nclass RoleChecker extends Checker {\n  check(ctx) {\n    return ctx.user.","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T05:28:56.245Z","createdAt":"2026-01-22T02:34:46.411Z"},{"id":"q-5627","question":"Design a runtime-extendable CLI command router: the core dispatch should handle commands by name, but new commands must be addable at runtime via a registry without touching the router. Each command implements an execute(args) method. Provide minimal interfaces and a usage example (e.g., 'build' and 'test' registered, then add 'lint' at runtime)?","answer":"Implement a runtime command router using the Command pattern and a registry. Define interface Command { execute(args: string[]): void }. The Router parses the first arg as commandName, locates it in t","explanation":"## Why This Is Asked\nTests ability to extend behavior without touching core dispatch logic; demonstrates the Command pattern with a runtime registry.\n\n## Key Concepts\n- Command pattern\n- Registry-based extensibility\n- Safe, non-invasive extension\n\n## Code Example\n```javascript\ninterface Command { execute(args: string[]): void; }\nclass Registry { private map = new Map<string, Command>(); register(name: string, c: Command) { this.map.set(name, c); } get(name: string): Command | undefined { return this.map.get(name); } }\nclass Router { constructor(private registry: Registry) {} route(argv: string[]) { const cmd = argv[0]; const command = this.registry.get(cmd); if (command) command.execute(argv.slice(1)); else throw new Error('Unknown command'); } }\n```\n\n## Follow-up Questions\n- How would you handle asynchronous commands? \n- How would you ensure thread-safety in a multi-process CLI?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Netflix","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T08:59:40.434Z","createdAt":"2026-01-22T08:59:40.434Z"},{"id":"q-5675","question":"Design a runtime-extensible CLI command plugin system for a monorepo tool. The core CLI ships with built-in commands, but new commands can be added at runtime via plugins loaded from a registry (local folder or remote source). Each plugin provides a commandName, description, and execute(args) function. Outline the minimal interfaces, plugin registry format, loading strategy with isolation and versioning, and a practical usage example?","answer":"Define a Command interface with name, description, and execute(args): Promise<number>. Each plugin exports a command and registers in a runtime registry: { name, version, entry: './dist/plugin.js' }. ","explanation":"## Why This Is Asked\nEvaluates plugin architecture, isolation, and runtime extensibility in CLI tooling.\n\n## Key Concepts\n- Command pattern in plugins\n- Runtime registry with versioning\n- Sandboxed loading and security\n- Hot reload and fallback semantics\n\n## Code Example\n```javascript\nexport interface Command {\n  name: string;\n  description: string;\n  execute(args: string[]): Promise<number>;\n}\n```\n\n## Follow-up Questions\n- How would you handle dependency conflicts and plugin sandboxing security concerns?\n- What metrics would you collect to monitor plugin health and performance?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","NVIDIA","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T10:59:08.132Z","createdAt":"2026-01-22T10:59:08.132Z"},{"id":"q-5815","question":"Design a runtime-extendable log-processing plugin system: build a small CLI component that reads log lines and applies a chain of plugins to each line. Each plugin must implement a process(line: string): string method and be registered in a central registry by name. The system should support adding new plugins at runtime via a manifest file (no recompilation) and apply them in the order specified. Provide minimal interfaces, a registry, and a usage example?","answer":"Implement a duck-typed Plugin with a single method process(line: string): string, a Registry that maps plugin names to factories, and a manifest-based loader (JSON) that registers plugins at startup. ","explanation":" ## Why This Is Asked\n\nAssess ability to design runtime-extendable components using a simple plugin registry, mirroring real-world maintenance and extension needs.\n\n ## Key Concepts\n\n- Plugin interface and duck typing\n- Runtime registry and manifest loading\n- Execution order and error handling\n- Testing plugin isolation\n\n ## Code Example\n\n```javascript\n// Minimal plugin interface via duck typing\nclass Plugin {\n  process(line) { return line; }\n}\n\nclass RedactPlugin { process(line) { return line.replace(/password=\\S+/g, 'password=REDACTED'); } }\nclass TimestampPlugin { process(line) { return `[${new Date().toISOString()}] ${line}`; } }\n\nclass Registry {\n  constructor() { this.factories = new Map(); }\n  register(name, factory) { this.factories.set(name, factory); }\n  create(name) { const f = this.factories.get(name); return f ? f() : null; }\n}\n\n// Boot: register plugins\nconst registry = new Registry();\nregistry.register('redact', () => new RedactPlugin());\nregistry.register('timestamp', () => new TimestampPlugin());\n\n// Manifest-driven sequence\nconst manifest = ['redact', 'timestamp'];\nlet line = 'user=alice password=hunter';\nfor (const name of manifest) {\n  const plugin = registry.create(name);\n  if (plugin) line = plugin.process(line);\n}\nconsole.log(line);\n```\n\n ## Follow-up Questions\n\n- How would you test plugin isolation and ensure a misbehaving plugin doesn't crash the pipeline?\n- How would you support dynamic reloading of the manifest without restarting the process?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Hashicorp","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T17:47:24.386Z","createdAt":"2026-01-22T17:47:24.386Z"},{"id":"q-5872","question":"Design a pluggable authentication framework for a lightweight API gateway that supports multiple schemes (API Key, JWT, HMAC). The gateway must route to the correct validator based on request headers and path, allow new schemes to be added via a registry without touching gateway core, and provide a minimal interface and usage example?","answer":"Implement an AuthStrategy interface with authenticate(req) -> boolean and identity(req) -> Identity. Concrete classes: ApiKeyAuth, JwtAuth, HmacAuth. A Registry maps schemeName -> factory. Gateway sel","explanation":"## Why This Is Asked\nTests ability to design modular, extensible auth without touching core.\n\n## Key Concepts\n- Strategy pattern\n- Registry/plugin architecture\n- Request-based dispatch\n\n## Code Example\n```javascript\n// Minimal sketch\ninterface AuthStrategy { authenticate(req): boolean; identity(req): Identity }\nclass ApiKeyAuth implements AuthStrategy { authenticate(req) { ... } identity(req) { ... } }\nclass JwtAuth implements AuthStrategy { authenticate(req) { ... } identity(req) { ... } }\nclass HmacAuth implements AuthStrategy { authenticate(req) { ... } identity(req) { ... } }\n\nclass AuthRegistry {\n  constructor() { this.factories = new Map() }\n  register(name, factory) { this.factories.set(name, factory) }\n  getFor(req) {\n    const scheme = parseScheme(req.headers)\n    const factory = this.factories.get(scheme)\n    return factory ? factory() : null\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test a new scheme in CI?\n- How would you safely rotate keys without downtime?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T19:51:04.846Z","createdAt":"2026-01-22T19:51:04.846Z"},{"id":"q-5887","question":"Design a runtime-extensible access-control policy engine for a large SaaS product that supports multiple evaluation strategies (RBAC, ABAC, risk-based, context-aware). The engine must allow adding new strategies at runtime via a registry and compose policies across resources with policy references. Provide minimal interfaces and a usage example?","answer":"Design a pluggable policy engine using Strategy + Registry. Define IPolicy with resources, a conditions set, and an evaluator key; define IPolicyEvaluator with evaluate(user, resource, context, policy","explanation":"## Why This Is Asked\nThis question probes building a runtime-extensible policy engine using design patterns, mirroring real-world needs for multiple policy models and dynamic extensions.\n\n## Key Concepts\n- Strategy pattern for evaluators (RBAC, ABAC, risk-based)\n- Registry/Plugin mechanism for runtime extension\n- Policy graph composition across resources\n- Contextual attributes and performance considerations\n- Safety and determinism in policy evaluation\n\n## Code Example\n```typescript\ninterface Policy {\n  id: string;\n  resources: string[];\n  evaluator: string;\n  conditions?: any;\n  children?: Policy[];\n}\ninterface IPolicyEvaluator {\n  evaluate(user: any, resource: any, context: any, policy: Policy): boolean;\n}\nclass Registry<T> {\n  private map = new Map<string, T>();\n  register(key: string, t: T) { this.map.set(key, t); }\n  get(key: string): T | undefined { return this.map.get(key); }\n}\n```\n\n```typescript\nclass RBACEvaluator implements IPolicyEvaluator {\n  evaluate(user: any, resource: any, context: any, policy: Policy): boolean {\n    // simple role check placeholder\n    return user.roles?.includes(resource.requiredRole ?? policy.conditions?.requiredRole);\n  }\n}\n```\n\n## Follow-up Questions\n- How would you handle conflicts across overlapping policies?\n- How would you audit policy decisions for compliance and debugging?","diagram":"flowchart TD\n  UserRequest --> PolicyEngine\n  PolicyEngine --> Registry\n  Registry --> Evaluator[RBAC/ABAC/Risk]\n  Evaluator --> Result[Allow/Deny]","difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Bloomberg","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T20:55:13.358Z","createdAt":"2026-01-22T20:55:13.358Z"},{"id":"q-6065","question":"Design a high-throughput cache with runtime-extensible eviction policies. The goal is to allow adding new eviction strategies (LRU, LFU, TTL-based, or custom) at runtime without touching cache core code. Outline the architecture using a design pattern that preserves core stability, specify minimal interfaces, a registry, and show how a new policy is registered and activated without downtime. Provide a concrete usage example in your language of choice?","answer":"Use the Strategy pattern with a pluggable EvictionPolicy registry. The cache holds a volatile EvictionPolicy policy; all eviction decisions call policy.evict(entries, maxSize). A Registry maps policyN","explanation":"## Why This Is Asked\n\nTests ability to reason about runtime extensibility, hot-swapping strategies, and concurrency in a performance-critical component. It also probes how to design minimal interfaces and a registry to avoid touching core logic while enabling new eviction policies.\n\n## Key Concepts\n\n- Strategy pattern for eviction decisions\n- Registry and dynamic loading of policies\n- Thread-safe policy swap and atomicity\n- Observability of policy behavior and performance trade-offs\n\n## Code Example\n\n```javascript\nclass EvictionPolicy {\n  onHit(key){ }\n  onMiss(key){ }\n  evict(entries, maxSize){ /* return keys to evict */ }\n}\nclass Registry {\n  constructor(){ this._map = new Map(); }\n  register(name, factory){ this._map.set(name, factory); }\n  create(name){ const f = this._map.get(name); return f ? f() : null; }\n}\nclass Cache {\n  constructor(){ this.policy = null; this.strategyLock = false; }\n  setPolicy(p){ this.policy = p; }\n  // ... onHit, onMiss delegate to policy\n}\n\n// usage\nconst reg = new Registry();\nreg.register('LRU', ()=>new EvictionPolicy());\nconst cache = new Cache();\ncache.setPolicy(reg.create('LRU'));\n```\n\n## Follow-up Questions\n\n- How would you test correctness when swapping policies under load?\n- How would you extend to persist policy choice across restarts?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Plaid","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T07:15:38.435Z","createdAt":"2026-01-23T07:15:38.435Z"},{"id":"q-6099","question":"Design a runtime-pluggable reconciliation strategy system for a payment processor where per-merchant strategies (delta, full, adaptive) can be added at runtime via a registry without recompilation. Describe interfaces, a thread-safe registry, and how you would safely hot-swap strategies in production. Include a usage example?","answer":"Use Strategy pattern with a registry of IReconcileStrategy. Each strategy implements reconcile(orders, ledger). A thread-safe registry (e.g., ConcurrentHashMap) maps merchantId to strategy, enabling a","explanation":"## Why This Is Asked\n\nTests ability to design plug-in systems, thread-safe dynamic behavior, and production-safe hot-swapping for strategies.\n\n## Key Concepts\n\n- Strategy pattern\n- Plugin/ Registry pattern\n- Concurrency control\n- Hot-swapping and rollback\n\n## Code Example\n\n```javascript\ninterface IReconcileStrategy {\n  reconcile(orders: Order[], ledger: Ledger): ReconcileResult;\n}\nclass DeltaStrategy implements IReconcileStrategy {\n  reconcile(orders: Order[], ledger: Ledger): ReconcileResult { /* ... */ }\n}\n```\n\n## Follow-up Questions\n\n- How would you version-strategy compatibility and avoid leaking state across swaps?\n- How would you test strategy isolation and rollback in CI/CD?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Instacart","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T08:49:56.411Z","createdAt":"2026-01-23T08:49:56.411Z"},{"id":"q-6115","question":"Design a runtime-extensible data ingestion pipeline for a distributed service used by Instacart and Twitter-scale. Each data source specifies required pre-processing steps (deduplicate, normalize, enforce schema) and a sink target; new steps and sinks must be added at runtime without recompiling the core ingest service. Provide minimal interfaces, a registry, hot-reload strategy, and a concrete usage showing adding a 'geo-normalize' step and a 'parquet' sink?","answer":"Use Strategy for preprocessors, a Registry for runtime plug-ins, and a chain to apply steps. Load pipelines from config (etcd/ConfigDB) and hot-swap with copy-on-write to avoid downtime. Each source d","explanation":"## Why This Is Asked\nTests ability to design a runtime-extensible pipeline with safe hot-swapping, precise interfaces, and clear plugin lifecycle.\n\n## Key Concepts\n- Strategy pattern for preprocessors\n- Plugin registry for dynamic loading\n- Pipeline/Chain of Responsibility for step sequencing\n- Copy-on-write hot-swaps for zero-downtime reloads\n- Versioning and compatibility handling\n\n## Code Example\n```javascript\n// Minimal interfaces\nclass Preprocessor { process(record) { return record } }\nclass Sink { write(batch) { } }\nclass Registry {\n  constructor(){ this._map = new Map() }\n  register(name, ctor){ this._map.set(name, ctor) }\n  create(name){ const Ctor = this._map.get(name); return Ctor ? new Ctor() : null }\n}\n```\n\n## Follow-up Questions\n- How would you version plugins and support rollback?\n- How would you test plugin isolation and metrics without affecting core ingest?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T09:39:41.508Z","createdAt":"2026-01-23T09:39:41.508Z"},{"id":"q-6150","question":"Design a runtime-extensible event routing engine where new routing policies (hash-based, round-robin, latency-aware) can be plugged in at runtime via a registry, without deploying the core router. The router should pick a policy based on event metadata and support zero-downtime swaps. Provide minimal interfaces, a registry, and a usage example?","answer":"Use a Registry-backed Strategy pattern. Define RoutingPolicy { Destination route(Event) }; RoutingPolicyFactory { RoutingPolicy build(Config) }. The router holds an AtomicReference<RoutingPolicy> curr","explanation":"## Why This Is Asked\n\nTests the ability to design runtime-extensible plug-in architecture with thread-safe swapping and minimal churn. It emphasizes real-world needs: evolving routing logic without redeploys.\n\n## Key Concepts\n\n- Strategy + Registry for plugins\n- Atomic or lock-free policy swap\n- Metadata-driven policy selection\n- Backward-compatible evolution\n\n## Code Example\n\n```java\ninterface RoutingPolicy {\n  Destination route(Event e);\n}\n\nclass EventRouter {\n  private final Registry<RoutingPolicyFactory> registry;\n  private final AtomicReference<RoutingPolicy> current;\n  Destination route(Event e){ return current.get().route(e); }\n}\n```\n\n## Follow-up Questions\n\n- How to test hot-swaps without affecting in-flight events?\n- How to version policies and roll back safely?\n- How to handle policy removal or degradation?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","LinkedIn","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T11:00:00.658Z","createdAt":"2026-01-23T11:00:00.658Z"},{"id":"q-6255","question":"Design a runtime-extensible config serializer system for a distributed config tool. It must support JSON, YAML, TOML, and any new format added at runtime without recompiling the core. Which patterns would you combine (Strategy + Registry + Plugin), and provide a minimal interface, registry structure, and a brief usage example?","answer":"Use a Format interface with serialize(data) and deserialize(bytes) signatures; implement JSON, YAML, TOML, and load new formats at runtime via a PluginLoader. Maintain a Registry<string, Format> to ma","explanation":"## Why This Is Asked\nTests the ability to compose design patterns for runtime extension without touching core logic, simulating real-world config systems.\n\n## Key Concepts\n- Plugin architecture\n- Registry-driven lookup\n- Runtime extension without recompilation\n\n## Code Example\n```javascript\ninterface Format {\n  serialize(obj: any): string;\n  deserialize(text: string): any;\n}\nclass Registry {\n  private formats = new Map<string, Format>();\n  register(name: string, fmt: Format) { this.formats.set(name, fmt); }\n  get(name: string): Format { return this.formats.get(name)!; }\n}\n```\n\n## Follow-up Questions\n- How would you version formats and migrations?\n- How would you sandbox and revoke untrusted plugins?","diagram":"flowchart TD\n  Core[Core System] --> Registry[Format Registry]\n  Registry --> JSON[JSON]\n  JSON --> Serializer\n  Registry --> YAML[YAML]\n  YAML --> Serializer\n  Registry --> TOML[TOML]\n  TOML --> Serializer","difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Google","Hashicorp"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T16:44:25.739Z","createdAt":"2026-01-23T16:44:25.740Z"},{"id":"q-6402","question":"Design a runtime-extendable file importer that handles CSV, JSON, and TSV. The importer core must stay unchanged when new formats are added. Propose minimal interfaces for a Parser, a ParserRegistry, and an Importer factory, and show how to register parsers by extension and instantiate the right parser at load time. How would you implement this?","answer":"Use the Strategy pattern with a lightweight registry. Define an interface Parser { parse(data: string): Record<string, any>[] }, a ParserFactory { create(): Parser }, and a ParserRegistry that maps file extensions to parser factories. The registry decouples the core importer from specific format implementations.","explanation":"## Why This Is Asked\n\nAssesses your ability to design an extensible data pipeline architecture that remains stable as new formats are added, using registries and factories to achieve loose coupling.\n\n## Key Concepts\n\n- Strategy pattern for pluggable parser implementations\n- Registry pattern to map file extensions to appropriate parsers\n- Factory pattern to instantiate parsers at runtime\n- Interface segregation with minimal, focused contracts\n\n## Code Example\n\n```javascript\ninterface Parser {\n  parse(data: string): Record<string, any>[];\n}\n\ninterface ParserFactory {\n  create(): Parser;\n}\n\nclass ParserRegistry {\n  constructor() {\n    this.parsers = new Map();\n  }\n  \n  register(extension, factory) {\n    this.parsers.set(extension, factory);\n  }\n  \n  getParser(extension) {\n    const factory = this.parsers.get(extension);\n    return factory ? factory.create() : null;\n  }\n}\n\nclass Importer {\n  constructor(registry) {\n    this.registry = registry;\n  }\n  \n  async import(filePath, data) {\n    const extension = filePath.split('.').pop();\n    const parser = this.registry.getParser(extension);\n    \n    if (!parser) {\n      throw new Error(`No parser found for .${extension} files`);\n    }\n    \n    return parser.parse(data);\n  }\n}\n\n// Usage\nconst registry = new ParserRegistry();\nregistry.register('csv', () => new CsvParser());\nregistry.register('json', () => new JsonParser());\nregistry.register('tsv', () => new TsvParser());\n\nconst importer = new Importer(registry);\n```\n\n## Implementation Benefits\n\n- **Extensibility**: New formats added without modifying core importer\n- **Decoupling**: Registry isolates format-specific logic\n- **Type Safety**: Interfaces ensure consistent parser contracts\n- **Runtime Flexibility**: Parsers instantiated based on file extension","diagram":"flowchart TD\n  A[Importer.load(filePath)] --> B{ext in registry?}\n  B -->|yes| C[parser = registry.get(ext).create()]\n  C --> D[records = parser.parse(content)]\n  D --> E[return records]\n  B -->|no| F[throw UnsupportedExtension]","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Google","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T05:19:55.774Z","createdAt":"2026-01-23T22:32:16.846Z"},{"id":"q-6509","question":"Design a runtime-extensible data ingestion pipeline for a log analytics platform. The core pipeline supports parse, validate, enrich, and store stages, but new data sources require custom stages. Build a plugin architecture that lets teams drop parsers, validators, and enrichers as modules loaded at runtime without redeploying the core. Provide a minimal interface, a registry mapping source type to a processing chain, and a usage example?","answer":"Use a plugin-based pipeline with a Stage interface and a Registry<SourceType, ProcessorChain>. Each plugin implements Parser, Validator, and Enricher; loadable via a dynamic module system (e.g., Java ","explanation":"## Why This Is Asked\nThe question tests building a flexible, runtime-extensible data ingestion path, mirroring real-world needs to add new data sources without redeploys.\n\n## Key Concepts\n- Plugin architecture and SPI-like registries\n- Runtime module loading and hot-reload\n- Processing chains and per-source specialization\n- Isolation, versioning, and compatibility checks\n\n## Code Example\n```java\ninterface Stage { void process(Record r); }\ninterface Parser { ProcessorChain parse(Record r); }\ninterface Validator { boolean validate(Record r); }\ninterface Enricher { Record enrich(Record r); }\nclass ProcessorChain { List<Stage> steps; void run(Record r); }\nclass Registry { SourceType key; ProcessorChain chain; }\n```\n\n## Follow-up Questions\n- How would you handle versioning and backward-compatibility for plugins?\n- How would you test and roll out new plugins in production without downtime?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","Netflix","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T05:54:42.402Z","createdAt":"2026-01-24T05:54:42.402Z"},{"id":"q-6545","question":"Design a tiny in-memory cache with get/put and a runtime-registrable eviction policy registry. The core must have a fixed capacity and evict on put when full. Eviction strategies (e.g., LRU, FIFO, LFU) are registered by name and instantiated at runtime via a registry. Provide minimal interfaces and a concrete usage example?","answer":"Design a tiny inmemory cache with get/put and runtime-registrable eviction policies. The core has capacity and evicts on put when full. Eviction strategies (LRU, FIFO, LFU) are registered by name and","explanation":"## Why This Is Asked\n\nTests ability to design runtime-extensible components using the Strategy pattern and a lightweight registry. Encourages thinking about a clean surface area, testability, and how policies interact with the core cache.\n\n## Key Concepts\n\n- EvictionPolicy interface: evictKey(store, capacity) and accessed(key) hooks\n- EvictionRegistry: maps names to policy factories\n- Cache core: get/put, fixed capacity, invokes policy to evict when needed\n- Trade-offs: O(1) lookups, eviction latency, policy state maintenance\n\n## Code Example\n\n```javascript\n// Minimal eviction policy interface and implementations\nclass EvictionPolicy {\n  accessed(key) { /* optional */ }\n  evictKey(store, capacity) { throw new Error('not implemented') }\n}\n\nclass LRUPolicy extends EvictionPolicy {\n  constructor() { this.order = new Map(); }\n  accessed(key) { if (this.order.has(key)) this.order.delete(key); this.order.set(key, true); }\n  evictKey(store, capacity) {\n    if (store.size <= capacity) return null;\n    for (let k of this.order.keys()) {\n      if (store.has(k)) return k;\n    }\n    return store.keys().next().value || null;\n  }\n}\n\nclass FIFOPolicy extends EvictionPolicy {\n  constructor() { this.order = new Map(); }\n  accessed(key) { /* FIFO does not update on access */ }\n  evictKey(store, capacity) {\n    if (store.size <= capacity) return null;\n    for (let k of this.order.keys()) {\n      if (store.has(k)) return k;\n    }\n    return store.keys().next().value || null;\n  }\n  registerInsert(key) { if (!this.order.has(key)) this.order.set(key, true); }\n}\n\nclass EvictionRegistry {\n  constructor() { this.factories = new Map(); }\n  register(name, factory) { this.factories.set(name, factory); }\n  create(name) { const f = this.factories.get(name); return f ? f() : null; }\n}\n\nclass Cache {\n  constructor(capacity, registry, policyName='lru') {\n    this.capacity = capacity;\n    this.store = new Map();\n    this.registry = registry;\n    this.policy = registry.create(policyName) || new LRUPolicy();\n  }\n  setPolicy(name) { const p = this.registry.create(name); if (p) this.policy = p; }\n  put(key, value) {\n    this.store.set(key, value);\n    if (this.policy && typeof this.policy.registerInsert === 'function') {\n      this.policy.registerInsert(key);\n    }\n    while (this.store.size > this.capacity) {\n      const k = this.policy.evictKey(this.store, this.capacity);\n      if (k == null) break;\n      this.store.delete(k);\n    }\n  }\n  get(key) {\n    if (!this.store.has(key)) return undefined;\n    const v = this.store.get(key);\n    if (typeof this.policy.accessed === 'function') this.policy.accessed(key);\n    return v;\n  }\n}\n```\n\n## Follow-up Questions\n\n- How would you extend to LFU without degrading performance?\n- How would you test eviction correctness across policies with deterministic inputs?","diagram":"flowchart TD\n  A[EvictionPolicyRegistry] --> B(CacheCore)\n  B --> C[CurrentPolicy]\n  C --> D[Policy.evictKey]\n  D --> E[Store]","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Lyft","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T07:34:32.357Z","createdAt":"2026-01-24T07:34:32.357Z"},{"id":"q-6662","question":"Design a runtime-extendable localization provider registry for a cross-platform app. The core i18n system should request translations for a locale from a registry of providers (e.g., static JSON, database-backed, or remote service). New providers must be swappable at runtime without redeploying. Specify a minimal ILocalizationProvider interface, a ProviderRegistry, and a usage example with locale 'es-ES'?","answer":"Use a Strategy-like interface ILocalizationProvider { string translate(string key, string locale); } with concrete providers StaticJsonProvider, DbProvider, RemoteApiProvider. A ProviderRegistry maint","explanation":"## Why This Is Asked\n\nTests ability to design for runtime extensibility and clean separation between core i18n logic and providers.\n\n## Key Concepts\n\n- Strategy pattern for translation providers\n- Registry for dynamic binding and hot-swapping\n- Lazy resolution and caching to minimize lookups\n\n## Code Example\n\n```javascript\nclass ILocalizationProvider {\n  translate(key, locale) { throw new Error('Not implemented') }\n}\nclass StaticJsonProvider extends ILocalizationProvider {\n  constructor(dict) { this.dict = dict; }\n  translate(key, locale) { return (this.dict[locale] && this.dict[locale][key]) || key; }\n}\nclass ProviderRegistry {\n  constructor() { this.map = new Map(); }\n  register(locale, provider) { this.map.set(locale, provider); }\n  resolve(locale) { return this.map.get(locale) || new StaticJsonProvider({ 'en-GB': { 'hello': 'Hello' } }); }\n}\n```\n\n## Follow-up Questions\n\n- How would you handle missing translations across providers?\n- How would you test adding a new provider without end-to-end tests?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","IBM"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T11:56:31.633Z","createdAt":"2026-01-24T11:56:31.633Z"},{"id":"q-681","question":"You're building a multi-tenant API gateway for a Stripe-like payments service, backed by MongoDB storage and a Twitter-like feed. Each tenant has a per-minute rate limit. Describe a concrete solution using the Decorator pattern to enforce quotas, show how you'd implement atomic Redis updates, discuss burst handling and clock drift, and outline a minimal wrapper skeleton in code?","answer":"Design a multi-tenant rate limiter by wrapping the core service with a Decorator that enforces per-tenant quotas stored in Redis. On each call, the decorator does an atomic INCR for the tenants windo","explanation":"## Why This Is Asked\nThis question probes practical design-pattern reasoning under real constraints (tenancy, rate limits, distributed cache).\n\n## Key Concepts\n- Decorator pattern for cross-cutting concerns\n- Atomic Redis updates and Lua scripting\n- Burst handling strategies and clock drift trade-offs\n- Testing under failure and partial outages\n\n## Code Example\n\n```javascript\nclass RateLimitedService {\n  constructor(next) { this.next = next; }\n  async call(req){ return this.next.call(req); }\n}\n\nclass RateLimiterDecorator {\n  constructor(next, redis, quota, windowSec){\n    this.next = next; this.redis = redis; this.quota = quota; this.windowSec = windowSec; }\n  async call(req){\n    const key = `rate:${req.tenant}:${Math.floor(Date.now()/this.windowSec)}`;\n    const count = await this.redis.incr(key);\n    if (count === 1) await this.redis.expire(key, this.windowSec);\n    if (count > this.quota) throw new Error('rate limit');\n    return this.next.call(req);\n  }\n}\n```\n\n## Follow-up Questions\n- How would you test edge bursts or clock skew?\n- How would you evolve to a distributed token bucket?\n- How do you monitor and alert on quota breaches?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Stripe","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T15:58:03.426Z","createdAt":"2026-01-11T15:58:03.426Z"},{"id":"q-6817","question":"Design a runtime-extensible rule engine for processing financial messages. Messages include metadata such as region, product, and customer tier that determines which validation and transformation steps apply. The engine must support adding new rules at runtime without redeploying core code. Specify minimal interfaces, a registry, and a practical usage example showing how to register and apply a new rule (e.g., FraudCheckRule) in the pipeline?","answer":"Adopt a runtime-plugin architecture using a Rule interface and a Registry. Messages pass through a per-message Pipeline built from metadata; rules are loaded and registered at runtime, then executed i","explanation":"## Why This Is Asked\\nThis question probes real-world extensibility: adding rules without redeploying, and per-message routing based on metadata.\\n\\n## Key Concepts\\n- Runtime plugin architecture with a Registry\\n- Minimal Rule interface: apply(Message) -> Result\\n- Per-message pipeline construction from metadata\\n- Safe dynamic loading and testing\\n\\n## Code Example\\n```javascript\\ninterface Message { region:string; product:string; tier:string; payload:any }\\ninterface Result { ok:boolean; errors?:string[] }\\ninterface Rule { apply(msg:Message):Result }\\nclass Registry { register(name:string, r:Rule):void; get(name:string):Rule | undefined }\\n```\\n\\n## Follow-up Questions\\n- How would you handle rule versioning and rollback?\\n- What are the trade-offs of eager vs lazy loading of rules?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Lyft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T18:50:19.636Z","createdAt":"2026-01-24T18:50:19.636Z"},{"id":"q-688","question":"You're building a feature flag system where flags can be evaluated as a hard boolean, a percentage rollout, or a targeted user segment. Design the architecture using a design pattern that lets you add new evaluation strategies without changing the caller. Which pattern would you choose and how would you implement it in code? Provide a minimal interface and usage example?","answer":"Use the Strategy pattern: define an IFlagStrategy with evaluate(user, flag) -> boolean. Implement concrete strategies: BooleanFlag, PercentFlag, UserSegmentFlag. The Evaluator holds a strategy referen","explanation":"## Why This Is Asked\nUnderstanding extensibility and testability in pattern choices.\n\n## Key Concepts\n- Strategy pattern\n- Dependency injection\n- Runtime swapping\n- Testability and trade-offs\n\n## Code Example\n```javascript\ninterface FlagStrategy {\n  evaluate(user, flag): boolean;\n}\nclass BooleanFlagStrategy implements FlagStrategy {\n  evaluate(user, flag) { return flag.value; }\n}\nclass PercentFlagStrategy implements FlagStrategy {\n  evaluate(user, flag) { return (user.id % 100) < flag.percent; }\n}\nclass UserSegmentFlagStrategy implements FlagStrategy {\n  evaluate(user, flag) { return flag.segments.includes(user.segment); }\n}\n\nclass FlagEvaluator {\n  constructor(strategy) { this.strategy = strategy; }\n  evaluate(user, flag) { return this.strategy.evaluate(user, flag); }\n  setStrategy(s) { this.strategy = s; }\n}\n```\n\n## Follow-up Questions\n- How would you test each strategy in isolation?\n- How would you design the Flag object for efficient evaluation?\n","diagram":"flowchart TD\n  Evaluator --> Strategy\n  Strategy --> BooleanFlagStrategy\n  Strategy --> PercentFlagStrategy\n  Strategy --> UserSegmentFlagStrategy","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Hashicorp"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T16:22:55.337Z","createdAt":"2026-01-11T16:22:55.337Z"},{"id":"q-695","question":"You're building a real-time data ingestion pipeline that must apply a sequence of transformations to each record. New transforms (normalization, enrichment, validation, anomaly detection) should be added as plugins without touching producer/consumer code. Design a pluggable Transform pipeline with per-tenant routing and hot-reload of configuration. Provide minimal interface and a usage example, including how to configure a few plugins and compose them for a stream?","answer":"Use a pluggable Transform pipeline. Define interface Transform { String name(); Record apply(Record); }. Pipeline holds an immutable List<Transform> steps; process r = steps.reduce via apply. Per-tena","explanation":"## Why This Is Asked\nAssess ability to design a modular, runtime-configurable data pipeline with per-tenant customization.\n\n## Key Concepts\n- Plugin architecture and the Pipeline pattern\n- Immutable pipelines and copy-on-write config\n- Per-tenant routing and hot-reload\n- Stateless transforms and fault tolerance\n\n## Code Example\n```javascript\nclass Transform { constructor(name){this.name=name} apply(rec){return rec}}\nclass NormalizeTransform extends Transform { apply(r){ /* normalize */ return r} }\nclass Pipeline { constructor(steps){ this.steps=Object.freeze(steps)} process(r){ return this.steps.reduce((acc,t)=>t.apply(acc), r) } }\n```\n\n## Follow-up Questions\n- How would you test per-tenant hot reload without downtime?\n- How do you handle a failing plugin without aborting the whole record?","diagram":"flowchart TD\n  A[Record Arrives] --> B{Tenant Exists?}\n  B -->|Yes| C[Fetch Tenant Pipeline]\n  C --> D[Process Through Transforms]\n  D --> E[Store Result]\n  B -->|No| F[Default Pipeline] --> E","difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T17:16:37.061Z","createdAt":"2026-01-11T17:16:37.061Z"},{"id":"q-7029","question":"Design a runtime-extensible health-check framework for a microservice ecosystem. Health checks can be extended with new implementations and aggregation strategies (ALL, ANY, WEIGHTED) at runtime via a registry. Show minimal interfaces, a registry for checks and aggregators, and how to register and activate a new strategy without downtime. Include a concrete usage example in your language of choice?","answer":"Implement a HealthCheck interface with a check() returning a status, and a HealthAggregator interface with aggregate([]Status) Status. Use a Registry<Map<String, Factory>> to instantiate checks and ag","explanation":"## Why This Is Asked\nThis question probes the candidate's ability to design a pluggable health-check framework that scales with a changing microservice landscape.\n\n## Key Concepts\n- Strategy/Plugin patterns for checks and aggregators\n- Runtime registries with factories\n- Hot-reload and zero-downtime swaps\n- Per-service overrides and versioned strategies\n\n## Code Example\n```javascript\nclass HealthCheck { async check() { /* return {ok:true} */ } }\nclass Aggregator { aggregate(results) { /* return aggregated status */ } }\nclass Registry { register(name, factory) { /* ... */ } create(name) { return factory(); } }\n```\n\n## Follow-up Questions\n- How would you handle circular dependencies between checks?\n- How would you test a new check without affecting live services?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Netflix","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T06:46:58.334Z","createdAt":"2026-01-25T06:46:58.334Z"},{"id":"q-706","question":"You're building an extensible data ingestion framework where new data formats (JSON, Parquet, ORC) must be supported without touching the core ingestion logic. Design the architecture using a pattern that decouples format parsing from the caller and lets you add new format handlers without changing the caller. Which pattern would you choose and how would you implement it in code? Provide a minimal interface and usage example?","answer":"Use the Strategy pattern: define a FormatHandler interface and a registry mapping formats to concrete handlers. Ingestor delegates parsing to the appropriate handler, so adding a new format requires o","explanation":"## Why This Is Asked\nThis question tests choosing an architecture that stays Open-Closed, supports runtime extension of handlers, and keeps the ingestion core simple and testable.\n\n## Key Concepts\n- Strategy/Polymorphism\n- Open-Closed Principle\n- Registry-based dispatch\n\n## Code Example\n```javascript\ninterface FormatHandler { parse(input) }\nclass JsonHandler implements FormatHandler { parse(input) { /* parse JSON */ } }\nclass Ingestor { constructor(registry) { this.registry = registry } ingest(format, data) { return this.registry[format].parse(data) } }\n```\n\n## Follow-up Questions\n- How would you handle unknown formats at runtime?\n- How would you test individual handlers and end-to-end ingestion?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T18:29:21.416Z","createdAt":"2026-01-11T18:29:21.416Z"},{"id":"q-714","question":"You're building a small HTTP client wrapper that fetches a user profile, but the server occasionally fails. The caller selects a retry policy by name (linear, exponential, jitter) and fetchUser should retry using that policy without changing fetchUser's code. Design the architecture using a design pattern that lets you add new retry strategies without modifying the caller. Provide a minimal interface and a usage example?","answer":"Pattern: Strategy. Define interface RetryPolicy { shouldRetry(attempt:number, err:any): boolean; nextDelay(attempt:number, err?:any): number }. Implement LinearPolicy, ExponentialPolicy, and JitterPol","explanation":"## Why This Is Asked\nTests understanding of how to decouple variability in behavior using design patterns. It shows how to extend functionality without touching call sites, a common real-world need.\n\n## Key Concepts\n- Strategy pattern for interchangeable retry logic\n- Dependency injection to supply policies\n- Clear separation of fetch logic from retry strategy\n- Testability by swapping mock policies\n\n## Code Example\n```javascript\ninterface RetryPolicy {\n  shouldRetry(attempt: number, err: any): boolean;\n  nextDelay(attempt: number, err?: any): number;\n}\nclass LinearPolicy implements RetryPolicy {\n  constructor(private delay: number, private max: number) {}\n  shouldRetry(attempt: number) { return attempt < this.max; }\n  nextDelay(_attempt: number) { return this.delay; }\n}\nclass ExponentialPolicy implements RetryPolicy {\n  constructor(private base: number, private factor: number, private cap: number) {}\n  shouldRetry(attempt: number) { return attempt * this.factor < this.cap; }\n  nextDelay(attempt: number) { return Math.min(this.base * Math.pow(this.factor, attempt - 1), this.cap); }\n}\n```\n\n```javascript\nconst policy = new ExponentialPolicy(100, 2, 1000);\nfetchUser('alice', policy);\n```\n\n## Follow-up Questions\n- How would you test retry behavior without real network calls?\n- How would you share a policy across multiple fetchers without duplication?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Lyft","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T19:17:55.052Z","createdAt":"2026-01-11T19:17:55.052Z"},{"id":"q-717","question":"You're building a real-time event processing pipeline that validates, enriches, and filters events before persisting. New validators, enrichers, and filters must be added at runtime without altering the core processor. Which design pattern enables this extensibility and how would you implement it? Provide minimal interfaces and a usage example?","answer":"Adopt a pluggable pipeline implemented as a Chain of Responsibility / Pipeline pattern. Keep a registry of steps (validators, enrichers, filters) and a runner that applies them in sequence. New steps ","explanation":"## Why This Is Asked\n\nTests ability to design extensible, maintainable data processing. Candidates should show how to decouple orchestration from behavior and support runtime extensibility.\n\n## Key Concepts\n\n- Pipeline / Chain of Responsibility\n- Dynamic step registration\n- Order preservation and error propagation\n- Stateless, composable steps\n\n## Code Example\n\n```javascript\nclass Pipeline {\n  constructor() {\n    this.steps = [];\n  }\n  register(step) {\n    this.steps.push(step);\n  }\n  run(event) {\n    return this.steps.reduce((e, s) => s(e), event);\n  }\n}\n\n// Usage: extend without touching core\nconst p = new Pipeline();\np.register(e => ({ ...e, enriched: true }));\np.register(e => (e.valid ? e : { ...e, error: 'invalid' }));\nconst event = { payload: { id: 1 } };\nconst result = p.run(event);\n```\n\n## Follow-up Questions\n\n- How would you handle async steps or errors within steps?\n- How would you enforce step ordering guarantees and versioning of pipelines?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Snowflake","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T20:21:02.325Z","createdAt":"2026-01-11T20:21:02.326Z"},{"id":"q-7173","question":"Design a runtime-extensible authorization decision engine for a microservices platform. Each request carries user/context attributes. Implement a registry-based strategy that lets you add new authorization strategies (e.g., RBAC, ABAC, policy-as-code) at runtime without touching the core gateway. Include minimal interfaces, a registry, and a usage example in your language of choice?","answer":"Use a Plugin-based Strategy pattern. Define an Authorizer interface: authorize(ctx, user, action, resource) -> boolean. Implement adapters for RBAC, ABAC, and policy-as-code. A Registry loads strategi","explanation":"## Why This Is Asked\nTests ability to design runtime-extensible security policies without redeploys.\n\n## Key Concepts\n- Plugin architecture\n- Strategy pattern\n- Runtime config with hot reload\n- Registry and gateway delegation\n\n## Code Example\n\n```javascript\n// Minimal interfaces\nclass Authorizer {\n  authorize(ctx, user, action, resource) { return false; }\n}\nclass Registry {\n  load(name) { /* load strategy by name */ }\n}\nclass Gateway {\n  setAuthorizer(name) { this.authorizer = Registry.load(name); }\n  authorize(ctx, user, action, res) { return this.authorizer.authorize(ctx, user, action, res); }\n}\n```\n\n## Follow-up Questions\n\n- How would you handle policy conflicts between strategies?\n- How would you test hot-reload behavior without affecting traffic?","diagram":"flowchart TD\n  Gateway[API Gateway] --> AuthEngine\n  AuthEngine --> Registry{Strategy Registry}\n  Registry -->|select| Strategy[Authorizer Strategy]\n  Strategy --> Decision{Authorize}\n  Decision -->|allowed| Allow[Allow]\n  Decision -->|denied| Deny[Deny]","difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["LinkedIn","PayPal","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T12:58:03.614Z","createdAt":"2026-01-25T12:58:03.616Z"},{"id":"q-729","question":"You're building an image-processing pipeline that applies a sequence of filters (blur, brighten, sharpen) to images. The pipeline must run on both CPU and GPU backends, and new backends must be pluggable without touching filter implementations or orchestration code. Design an architecture that decouples filters from backends using a design pattern, enabling adding a backend such as Vulkan without modifying core code. Provide a minimal interface and usage example?","answer":"Use the Bridge pattern: Filters depend on a Backend API, not a concrete backend. Define Backend{apply(image, opSpec)} and concrete backends CPUBackend, GPUBackend. Filters call backend.apply(...) and ","explanation":"## Why This Is Asked\n\nThis task tests the ability to decouple algorithmic filters from execution backends, enabling runtime backend swapping and new backend integration without touching core logic.\n\n## Key Concepts\n\n- Bridge pattern for decoupling abstraction (filters) from implementation (backends)\n- Backend interface and concrete backends (CPU, GPU)\n- Extensibility and testability with pluggable backends\n\n## Code Example\n\n```javascript\n// Minimal illustrative code (not production-ready)\nclass Backend {\n  apply(image, opSpec) { throw new Error('not implemented') }\n}\nclass CPUBackend extends Backend {\n  apply(image, opSpec) { /* CPU path */ return image }\n}\nclass GPUBackend extends Backend {\n  apply(image, opSpec) { /* GPU path, e.g., CUDA/Vulkan */ return image }\n}\nclass Filter {\n  constructor(opSpec) { this.opSpec = opSpec }\n  render(image, backend) { return backend.apply(image, this.opSpec) }\n}\nclass Pipeline {\n  constructor() { this.filters = []; }\n  setBackend(b) { this.backend = b }\n  addFilter(f) { this.filters.push(f) }\n  run(image) { let out = image; for (const f of this.filters) out = f.render(out, this.backend); return out }\n}\n```\n\n## Follow-up Questions\n\n- How would you add backends with different precision or memory constraints?\n- How would you test backends in isolation and measure performance trade-offs?","diagram":"flowchart TD\nP[Pipeline] --> B[BackendBridge]\nP --> F[Filters]\nB --> CPU[CPUBackend]\nB --> GPU[GPUBackend]\nF --> Blur[BlurFilter]\nF --> Brighten[BrightenFilter]","difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T21:18:19.757Z","createdAt":"2026-01-11T21:18:19.757Z"},{"id":"q-7291","question":"Design a runtime-extensible API client library that supports pluggable authentication strategies (API key, OAuth2, mTLS) and retry/backoff strategies (immediate, exponential jitter), selected per-service by metadata (domain, region, risk). The system must allow adding new auth and retry strategies at runtime via a registry without restarting the host. Provide minimal interfaces, a registry, and a usage example in a language of choice?","answer":"Propose a runtime-extensible API client with pluggable AuthStrategy (ApiKey, OAuth2, mTLS) and RetryPolicy (Immediate, ExponentialBackoff, Jitter) resolved per service by metadata. Use a StrategyRegis","explanation":"## Why This Is Asked\n\nThis question checks ability to design a runtime-extensible client using plugin registries and per-service routing. It emphasizes dynamic extension without downtime, thread-safety, and clear interfaces.\n\n## Key Concepts\n\n- Plugin registry\n- Strategy pattern\n- Hot swapping\n- Per-service metadata\n- Concurrency\n\n## Code Example\n\n```javascript\n// Interfaces and registry sketch\ninterface AuthStrategy { applyHeaders(req, meta): void }\ninterface RetryPolicy { nextDelay(attempt, err): number; shouldRetry(attempt, err): boolean }\nclass Registry { registerAuth(key, factory); getAuth(key); registerRetry(key, factory); getRetry(key); }\n\nclass ApiClient { constructor(registry) { this.registry = registry } send(req, meta) { const auth = this.registry.getAuth(meta.serviceKey); auth.applyHeaders(req, meta); const retry = this.registry.getRetry(meta.serviceKey); /* use retry */ }\n}\n```\n\n## Follow-up Questions\n\n- How would you test hot-swapping of strategies?\n- How do you handle versioning and backward compatibility?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","DoorDash","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T17:02:15.742Z","createdAt":"2026-01-25T17:02:15.742Z"},{"id":"q-737","question":"In a messaging pipeline used by Zoom and Hugging Face, the system tokenizes, normalizes, and stores messages. You want to support swapping in different normalization strategies (lowercasing, diacritic removal, profanity filtering) without changing the pipeline code. Design the architecture using a design pattern that lets you add new normalization strategies without modifying the pipeline. Provide a minimal interface and a usage example. How would you implement this pattern to make additions painless?","answer":"Use the Strategy pattern by modeling the normalization as a pluggable Normalizer with a normalize(text) method, then inject a concrete Normalizer into the pipeline. New strategies (Lowercase, AccentRe","explanation":"## Why This Is Asked\nTests knowledge of a clean extension point and practical DI. It avoids altering core pipeline logic when introducing new behaviors.\n\n## Key Concepts\n- Strategy pattern for interchangeable behaviors\n- Dependency injection for runtime flexibility\n- Open-closed principle and testability\n\n## Code Example\n```javascript\n// Minimal interface\ninterface Normalizer {\n  normalize(text: string): string;\n}\nclass LowercaseNormalizer implements Normalizer {\n  normalize(text: string) { return text.toLowerCase(); }\n}\nclass AccentRemover implements Normalizer {\n  normalize(text: string) { return text.normalize('NFD').replace(/[\\u0300-\\u036f]/g, ''); }\n}\nclass MessageProcessor {\n  constructor(private normalizer: Normalizer) {}\n  process(text: string) { return this.normalizer.normalize(text); }\n}\n```\n\n## Follow-up Questions\n- How would you choose between construction-time vs per-message normalization strategy?\n- How would you test each strategy in isolation and within the pipeline?","diagram":"flowchart TD\n  P[MessageProcessor] --> N[NormalizationContext]\n  N --> L[LowercaseNormalization]\n  N --> A[AccentRemoval]\n  L --> S[StoreMessage]\n  A --> S","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T22:20:11.913Z","createdAt":"2026-01-11T22:20:11.914Z"},{"id":"q-7387","question":"You're designing a high-throughput data ingestion service that emits metrics to multiple backends. Design a registry-based, runtime-pluggable MetricsExporter framework that can add new exporters (Prometheus, Datadog, OpenTelemetry) without redeploying or touching the core. Define minimal interfaces, lifecycle hooks, and a usage example. How would you ensure hot-reload safety and fault isolation?","answer":"Implement a MetricsExporter interface with init, emit, and shutdown methods. A MetricsRegistry stores factories by name and can create exporters at runtime. Example: registry.register('prometheus', () => new PrometheusExporter(config)). At runtime, registry.create('prometheus') returns an exporter that emits metrics to Prometheus. Add a new backend without changing core logicjust register a new factory. Ensure hot-reload safety with versioned registrations and atomic swaps. Isolate faults with try-catch per exporter and circuit breakers, preventing a single backend failure from affecting others.","explanation":"## Why This Is Asked\n\nAssesses ability to design a pluggable backend system with runtime extensibility, isolation, and fault tolerance for production-grade telemetry.\n\n## Key Concepts\n\n- Registry pattern for dynamic exporter discovery\n- Strategy/Factory for exporter instantiation\n- Lifecycle management: init, emit, shutdown\n- Hot-reload safety, fault isolation, backpressure handling\n\n## Code Example\n\n```javascript\n// Minimal interfaces (TypeScript-like)\nexport interface Metrics { name: string; value: number; timestamp?: number; }\nexport interface MetricsExporter {\n  init(config?: any): void;\n  emit(metrics: Metrics[]): Promise<void>;\n  shutdown(): Promise<void>;\n}\n\n// Registry and factory\ntype ExporterFactory = (config?: any) => MetricsExporter;\n\nclass MetricsRegistry {\n  private factories = new Map<string, ExporterFactory>();\n  private exporters = new Map<string, MetricsExporter>();\n\n  register(name: string, factory: ExporterFactory): void {\n    this.factories.set(name, factory);\n  }\n\n  create(name: string, config?: any): MetricsExporter | null {\n    const factory = this.factories.get(name);\n    if (!factory) return null;\n    const exporter = factory(config);\n    this.exporters.set(name, exporter);\n    return exporter;\n  }\n\n  // Hot-reload: atomic swap with versioning\n  replace(name: string, factory: ExporterFactory): boolean {\n    const existing = this.factories.get(name);\n    this.factories.set(name, factory);\n    return !!existing;\n  }\n}\n\n// Usage example\nconst registry = new MetricsRegistry();\nregistry.register('prometheus', cfg => new PrometheusExporter(cfg));\nregistry.register('datadog', cfg => new DatadogExporter(cfg));\nregistry.register('otel', cfg => new OpenTelemetryExporter(cfg));\n\n// Runtime creation\nconst exporter = registry.create('prometheus', { port: 9090 });\nawait exporter.init();\nawait exporter.emit([{ name: 'latency', value: 42 }]);\n```\n\n## Hot-Reload Safety & Fault Isolation\n\n- **Atomic swaps**: Replace factories with versioned references to avoid partially updated state\n- **Per-exporter try-catch**: Isolate failures so one backend doesn't bring down others\n- **Circuit breakers**: Temporarily skip failing exporters to reduce noise\n- **Graceful shutdown**: Implement shutdown to flush buffers and release resources\n- **Backpressure**: Queue or batch emissions when downstream is slow, using bounded buffers","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Hashicorp","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T05:18:25.268Z","createdAt":"2026-01-25T21:00:01.458Z"},{"id":"q-741","question":"In a telemetry alerting system for autonomous fleets, each customer needs a custom alert-threshold strategy for metrics like speed or battery: static value, percentile-based, or rolling window. The aggregator should surface alerts without depending on a concrete strategy. Design the architecture using a design pattern that lets you add new threshold strategies without modifying the aggregator. Provide a minimal interface and a usage example?","answer":"Use Strategy pattern: define interface ThresholdStrategy { compute(values: number[]): number }, implement StaticThreshold, PercentileThreshold, RollingWindowThreshold, and a ThresholdContext that dele","explanation":"## Why This Is Asked\nTests ability to plug in new algorithms without touching the orchestrator, a common interview scenario.\n\n## Key Concepts\n- Strategy pattern for interchangeable thresholds\n- Thin interface and per-customer configuration\n- Factory to instantiate strategies from config\n\n## Code Example\n```javascript\nclass ThresholdStrategy { compute(values) { throw new Error('not implemented') } }\nclass StaticThreshold extends ThresholdStrategy {\n  constructor(v){ super(); this.v=v }\n  compute(_){ return this.v }\n}\nclass PercentileThreshold extends ThresholdStrategy {\n  constructor(p){ super(); this.p=p }\n  compute(values){ if (!values.length) return 0; values.sort((a,b)=>a-b); const idx=Math.floor((this.p/100)*(values.length-1)); return values[idx]; }\n}\nclass RollingWindowThreshold extends ThresholdStrategy {\n  constructor(size){ super(); this.size=size }\n  compute(values){ const win = values.slice(-this.size); win.sort((a,b)=>a-b); const idx=Math.floor(0.95*(win.length-1)); return win[idx]; }\n}\nclass ThresholdContext {\n  constructor(strategy){ this.strategy=strategy }\n  compute(values){ return this.strategy.compute(values) }\n}\n\n// usage\nconst t = new ThresholdContext(new PercentileThreshold(95));\nconst threshold = t.compute(window);\n```\n\n## Follow-up Questions\n- How would you test adding a new strategy in isolation?\n- How would you persist per-customer strategy config and migrate existing customers?","diagram":"flowchart TD\n  A[Aggregator] --> B[ThresholdStrategy]\n  B --> C[StaticThreshold]\n  B --> D[PercentileThreshold]\n  B --> E[RollingWindowThreshold]","difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Tesla","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T23:17:28.525Z","createdAt":"2026-01-11T23:17:28.525Z"},{"id":"q-7476","question":"Design a runtime-extensible image processing pipeline where each processing step (resize, crop, color-correct, watermark, format-convert) is a pluggable processor registered at runtime. The engine must allow composing steps with dependencies (e.g., resize before crop), support different pipelines per client, and enable hot-swapping processors without restarting the service. Provide minimal interfaces, a registry, and a runnable usage example in your language of choice?","answer":"Implement a Processor interface and a runtime Registry that maps processor names to factories. Build a Pipeline as a Directed Acyclic Graph (DAG) where nodes represent processing steps and edges define dependencies (e.g., resize must precede crop). Execute the pipeline using a topological sort to ensure correct ordering.","explanation":"## Why This Is Asked\n\nThis question evaluates your ability to design runtime-extensible systems that combine the Registry pattern, graph-based processing (DAG), and the Composite pattern. It tests understanding of hot-swapping capabilities without service restarts and per-client customization requirements.\n\n## Key Concepts\n\n- **Runtime Registry**: Dynamic registration of processor factories\n- **DAG-based Pipeline**: Processing steps as nodes with dependency edges\n- **Topological Execution**: Ensures correct processing order\n- **Hot-Swapping**: Runtime processor replacement without restarts\n- **Per-Client Customization**: Tailored pipelines per client requirements\n- **Versioning Support**: Managing different processor versions\n\n## Code Example\n\n```javascript\n// Minimal API sketch\nclass Registry {\n  constructor() { this.factories = new Map(); }\n  register(name, factory) { this.factories.set(name, factory); }\n  create(name) {","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Robinhood","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T04:23:10.074Z","createdAt":"2026-01-26T02:49:13.166Z"},{"id":"q-750","question":"Youre building a data export utility that must support multiple formats. New formats can come from external libraries with different APIs. Design an architecture using a pattern that lets you add new formats without changing the core exporter. Which pattern would you use and how would you implement it? Provide a minimal interface and a usage example?","answer":"Pattern: Adapter. Wrap external serializers behind a common Serializer interface to let the exporter support new formats without modifying its code. Define Serializer { serialize(data) string }. Imple","explanation":"## Why This Is Asked\n\nTests ability to map real-world library integration to a classic pattern without touching core logic.\n\n## Key Concepts\n\n- Adapter pattern\n- Interfaces and thin wrappers\n- Extending functionality without modifying clients\n\n## Code Example\n\n```javascript\n// Minimal interface\nclass Serializer { serialize(data) { throw new Error('Not implemented') } }\nclass JsonAdapter extends Serializer {\n  constructor(jsonLib) { this.jsonLib = jsonLib }\n  serialize(data) { return this.jsonLib.stringify(data) }\n}\n```\n\n## Follow-up Questions\n\n- How would you test adapters in isolation?\n- What are trade-offs vs Bridge when formats have evolving schemas?\n","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Cloudflare","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T01:28:32.744Z","createdAt":"2026-01-12T01:28:32.744Z"},{"id":"q-7517","question":"Design a runtime-extensible caching layer where eviction policies are plug-ins registered in a policy registry and can be swapped per cache namespace at runtime without restarting the service. Start with at least three policies (LRU, LFU, TTL-based). Explain how to add a new policy (e.g., time-aware LFU) without changing the core cache, with minimal interfaces, a registry, and a usage example?","answer":"Use a Strategy with a Registry. Define EvictionPolicy with onPut/onAccess/evict. Implement LRU, LFU, TTL, and register them by name. Each namespace holds a policy reference and swaps via PolicyRegistr","explanation":"## Why This Is Asked\nTests a runtime-pluggable policy architecture and safe, per-namespace swapping without restart.\n\n## Key Concepts\n- Strategy pattern: EvictionPolicy interface\n- Registry for plugin policies\n- Per-namespace binding and hot-swapping\n- Thread-safety and observability\n\n## Code Example\n```typescript\ninterface EvictionPolicy {\n  onPut(key: any, now?: number): void\n  onAccess(key: any, now?: number): void\n  evict(entries: Map<any, any>): any | undefined\n}\nclass LRU implements EvictionPolicy { /* ... */ }\nclass LFU implements EvictionPolicy { /* ... */ }\nclass TTL implements EvictionPolicy { /* ... */ }\n// Registration\nclass PolicyRegistry {\n  private static registry = new Map<string, () => EvictionPolicy>();\n  static register(name: string, factory: () => EvictionPolicy) { this.registry.set(name, factory) }\n  static getFactory(name: string): (() => EvictionPolicy) | undefined { return this.registry.get(name) }\n}\n// Usage\nconst namespace = 'users:cache';\nconst policyFactory = PolicyRegistry.getFactory('timeAwareLFU');\nif (policyFactory) cache.setPolicy(namespace, policyFactory());\n```\n\n## Follow-up Questions\n- How would you handle metrics and eviction auditing across namespaces?\n- How would you test swapping policies under load and ensure correctness?\n","diagram":"flowchart TD\n  Namespace[Namespace] --> Registry[Policy Registry]\n  Registry --> PolicyInstance[Policy Instance]\n  Namespace --> Cache[Cache]\n  Cache --> Registry\n  Registry --> PolicyInstance","difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T05:42:52.010Z","createdAt":"2026-01-26T05:42:52.011Z"},{"id":"q-763","question":"You're designing a data ingestion pipeline where raw inputs pass through optional enhancers (encryption, compression, watermarking) implemented as decorators around a base DataSource. You must add new decorators without touching the core pipeline or existing decorators. Which pattern would you use and how would you implement minimal interfaces to compose them? Provide a usage example?","answer":"Use the Decorator pattern. Define DataSource { read(): Buffer }. Implement a base FileSource. Create DataSourceDecorator wrapping a DataSource. Add concrete decorators EncryptDecorator, CompressDecora","explanation":"## Why This Is Asked\nThis tests the ability to extend behavior without modifying existing code, a hallmark of robust design.\n\n## Key Concepts\n- Decorator pattern\n- Runtime composition\n- Open/Closed Principle\n\n## Code Example\n```javascript\ninterface DataSource { read(): Buffer }\nclass FileSource implements DataSource { constructor(path) { this.path = path } read() { /* read file */ } }\nclass DataSourceDecorator implements DataSource { constructor(protected source: DataSource) {} read() { return this.source.read() } }\nclass EncryptDecorator extends DataSourceDecorator { read() { const data = super.read(); return encrypt(data) } }\nclass CompressDecorator extends DataSourceDecorator { read() { const data = super.read(); return compress(data) } }\n```\n\n## Follow-up Questions\n- How would you test a decorator stack with different orders?\n- How to handle streaming data and backpressure in decorator chains?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Microsoft","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T03:50:59.836Z","createdAt":"2026-01-12T03:50:59.836Z"},{"id":"q-769","question":"In a log analytics pipeline, you must support multiple formats (JSON, CSV, Protobuf) and multiple sinks (Elasticsearch, BigQuery, S3). Design an architecture using a design pattern that allows adding new formats or sinks without touching the producer. Provide minimal interfaces and a usage example?","answer":"Use the Strategy pattern to decouple event formatting from producers and sinks. Define a Formatter interface with format(Event) -> []byte and a Publisher interface with publish([]byte, Sink). Implemen","explanation":"## Why This Is Asked\nTests understanding of decoupling using a pattern that lets new formats/sinks be added without producer changes.\n\n## Key Concepts\n- Strategy pattern\n- Registry/Factory for runtime selection\n- Dependency injection\n\n## Code Example\n```javascript\n// Formatter interface\nclass Formatter { format(event) { /*...*/ } }\n// Publisher interface\nclass Publisher { publish(data, sink) { /*...*/ } }\n\nclass JSONFormatter { format(e){ return JSON.stringify(e.payload) } }\nclass ElasticsearchPublisher { publish(bytes, sink){ /* send to sink */ } }\n\n// usage\nconst registry = new Map();\nregistry.set('json', { formatter: new JSONFormatter(), publisher: new ElasticsearchPublisher() });\nconst { formatter, publisher } = registry.get('json');\nconst data = formatter.format({ payload: { x: 1 } });\npublisher.publish(data, 'elasticsearch');\n```\n\n## Follow-up Questions\n- How would you test the registry and ensure new formats don't require producer changes?\n- How would you handle versioned schemas when formats evolve?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","MongoDB","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T04:48:36.490Z","createdAt":"2026-01-12T04:48:36.490Z"},{"id":"q-7709","question":"Design a runtime-extensible eviction policy registry for a distributed in-memory cache used by multiple services. Each cache region can specify an eviction policy (LRU, LFU, TTL, or a custom one). How would you implement a plug-in architecture that lets operators add new eviction strategies at runtime without restarting the cache, support per-region policy assignment, and maintain thread-safety and observability? Provide minimal interfaces, a registry, and a usage example?","answer":"Use Strategy together with a dynamic Registry and a plugin loader. Define IEvictionPolicy with onAccess/onPut/onEvict. Maintain a thread-safe Registry<String, Supplier<IEvictionPolicy>> and a per-regi","explanation":"## Why This Is Asked\nThis question probes practical extensibility via patterns, runtime loading, and per-region configurability in a highthroughput cache.\n\n## Key Concepts\n- Strategy pattern for eviction\n- Registry and plugin loading\n- Atomic swaps for thread safety\n- Observability and sandboxed loading\n\n## Code Example\n```typescript\ninterface IEvictionPolicy {\n  onAccess(key: string): void\n  onPut(key: string, value: any): void\n  onEvict(key: string): void\n}\nclass PolicyRegistry {\n  private map = new Map<string, () => IEvictionPolicy>();\n  register(name: string, ctor: () => IEvictionPolicy){ this.map.set(name, ctor) }\n  get(name: string){ return this.map.get(name)!.call(null) }\n}\n```\n\n## Follow-up Questions\n- How would you test atomic region switches without impacting ongoing requests?\n- How would you sandbox/mutate policies without leaking across regions?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Meta","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T14:44:41.176Z","createdAt":"2026-01-26T14:44:41.176Z"},{"id":"q-781","question":"You're building a CLI tool that supports commands and subcommands, forming a tree (e.g., 'git remote add'). Design a Command interface that treats leaves (actual actions) and composites (groups of commands) uniformly. Implement LeafCommand and CommandGroup using the Composite pattern so a single call can execute a command or print help for a whole subtree without changing client code. Provide a minimal interface and usage example?","answer":"Use the Composite pattern. Define a Command interface with execute(args) and help(). Implement LeafCommand for concrete actions and CommandGroup for commands that contain children. The group delegates","explanation":"Why This Is Asked\n- Demonstrates modeling hierarchical command structures with a single interface.\n- Shows uniform treatment of leaves and composites, enabling recursive execution.\n- Tests understanding of registration and delegation without touching client logic.\n\nKey Concepts\n- Composite pattern\n- Uniform interface for leaves/composites\n- Recursive command resolution\n- Lightweight plugin-friendly design\n\nCode Example\n```javascript\nclass Command {\n  execute(args) { throw new Error('not implemented'); }\n  help() { throw new Error('not implemented'); }\n}\nclass LeafCommand extends Command {\n  constructor(name, action){ super(); this.name = name; this.action = action; }\n  execute(args){ this.action(args); }\n  help(){ return this.name; }\n}\nclass CommandGroup extends Command {\n  constructor(name){ super(); this.name = name; this.children = []; }\n  add(cmd){ this.children.push(cmd); }\n  execute(args){ const [sub] = args; const found = this.children.find(c => c.help() === sub);\n    if(found) found.execute(args.slice(1));\n  }\n  help(){ return this.name + ' (' + this.children.map(c => c.help()).join(', ') + ')'; }\n}\n\n// Usage\nconst root = new CommandGroup('root');\nconst status = new LeafCommand('status', () => console.log('ok'));\nconst repo = new CommandGroup('repo');\nrepo.add(status);\nroot.add(repo);\n```\n","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T05:32:43.572Z","createdAt":"2026-01-12T05:32:43.572Z"},{"id":"q-7838","question":"Design a runtime-extensible snapshot policy system for an event-sourced service: policies decide when to capture a read-model snapshot based on criteria such as after N events, on a time interval, or when the event batch size exceeds a threshold. Implement with a design pattern that lets you add new snapshot strategies at runtime without touching the engine. Include minimal interfaces, a policy registry, and a usage example in your language of choice?","answer":"Implement a registry-driven SnapshotPolicy system. Use a Strategy-like interface for policies (e.g., AfterNEvents, TimeWindow, BatchSize). The Registry stores factory functions so new policies can be ","explanation":"## Why This Is Asked\n\nTests how candidates model extensibility, runtime pluggability, and thread safety in a real-world event-sourced system. It also probes how to balance policy expressiveness with simplicity.\n\n## Key Concepts\n\n- Strategy/Policy pattern with a registry\n- Runtime extensibility without core changes\n- Thread-safety and serialization concerns\n\n## Code Example\n```javascript\n// Pseudo-TypeScript\ninterface SnapshotPolicy { shouldSnapshot(state: any, batch: any[]): boolean; name(): string; }\ntype PolicyFactory = () => SnapshotPolicy;\nclass SnapshotPolicyRegistry {\n  private map = new Map<string, PolicyFactory>();\n  register(name: string, factory: PolicyFactory) { this.map.set(name, factory); }\n  create(name: string): SnapshotPolicy { return this.map.get(name)!.call(null); }\n}\nclass AfterNEventsPolicy { constructor(private n: number) {} shouldSnapshot(state: any, batch: any[]) { return batch.length >= this.n; } name() { return `after-${this.n}-events`; } }\n```\n\n## Follow-up Questions\n\n- How would you hot-swap policies in a running cluster?\n- How would you serialize/version policies for migrations?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Microsoft","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T19:46:11.129Z","createdAt":"2026-01-26T19:46:11.129Z"},{"id":"q-785","question":"You're building a pluggable HTTP request/response transformer pipeline inside a reverse proxy. Each Transformer can add, redact, or modify headers/body. The gateway must load new Transformers at runtime by name without redeploying. Design a minimal interface and registry-driven architecture that supports adding new transformer types without touching the gateway core. Provide a usage example?","answer":"Use the Strategy pattern with a runtime Transformer registry. Define Transformer { apply(req, res) error }; concrete types like HeaderAdder, BodyRedactor implement it. Pipeline stores []Transformer. A","explanation":"## Why This Is Asked\n\nThis question probes runtime extensibility and plugin architecture for a high-availability gateway, emphasizing decoupling, dynamic discovery, and safe wiring of new behavior without redeploys.\n\n## Key Concepts\n\n- Strategy pattern for interchangeable transformers\n- Registry/Plugin mechanism for dynamic loading\n- Runtime extensibility with minimal core impact\n\n## Code Example\n\n```javascript\n// Minimal interface and wiring\ninterface Transformer {\n  apply(req, res): void\n}\nclass HeaderAdder implements Transformer { apply(req, res) { /* ... */ } }\nclass BodyRedactor implements Transformer { apply(req, res) { /* ... */ } }\n\nclass Registry {\n  register(name, factory) { /* ... */ }\n  create(name, config) { /* ... */ }\n}\n```\n\n## Follow-up Questions\n\n- How do you guarantee transformer execution order and error handling in the pipeline?\n- How would you test hot-plug transformers and rollback on failure in CI/CD?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Cloudflare","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T06:37:47.273Z","createdAt":"2026-01-12T06:37:47.273Z"},{"id":"q-7882","question":"Design a runtime-extensible data validation system for a data ingestion pipeline: validators for schema conformance, nullability, and domain-specific rules, loaded at runtime via a registry. How would the pipeline select applicable validators based on input metadata (table, data source) and apply them in a defined order? Provide minimal interfaces, a registry, and a usage example showing how a new validator (e.g., URLFormatValidator) is registered and used without restarting the broker?","answer":"Implement an IValidator interface with a validate(record) method that returns a result object containing validation status and any error messages. A ValidatorRegistry serves as a factory that maps string identifiers to validator constructors. The ingestion pipeline selects validators based on input metadata (table name, data source type), loads applicable validators through the registry, and applies them in a predefined sequence. New validators can be dynamically registered and become available immediately without requiring broker restart.","explanation":"## Why This Is Asked\n\nThis question evaluates the ability to design systems that support runtime extensibility without downtimea critical requirement for data platforms at companies like Plaid, Hugging Face, and Apple. It assesses understanding of how design patterns like Strategy, Factory, and Registry work together in live data ingestion systems.\n\n## Key Concepts\n\n- Runtime extensibility through a centralized registry\n- Clear separation of concerns between validation logic, orchestration, and metadata-driven routing\n- Zero-downtime deployment of new validation rules\n- Dynamic validator selection and ordered execution\n\n## Code Example\n\n```javascript\n// Core interfaces and registry\nclass IValidator {\n  validate(record) {\n    throw new Error('validate method must be implemented');\n  }\n}\n\nclass ValidationResult {\n  constructor(isValid, errors = []) {\n    this.isValid = isValid;\n    this.errors = errors;\n  }\n}\n\nclass ValidatorRegistry {\n  constructor() {\n    this.validators = new Map();\n  }\n  \n  register(name, validatorClass) {\n    this.validators.set(name, validatorClass);\n  }\n  \n  create(name, config = {}) {\n    const ValidatorClass = this.validators.get(name);\n    if (!ValidatorClass) {\n      throw new Error(`Validator '${name}' not found`);\n    }\n    return new ValidatorClass(config);\n  }\n}\n```\n\n```javascript\n// Example validator implementation\nclass URLFormatValidator extends IValidator {\n  validate(record) {\n    const urlPattern = /^https?:\\/\\/.+/;\n    if (record.url && !urlPattern.test(record.url)) {\n      return new ValidationResult(false, ['Invalid URL format']);\n    }\n    return new ValidationResult(true);\n  }\n}\n```\n\n```javascript\n// Runtime registration and usage\nconst registry = new ValidatorRegistry();\nregistry.register('url-format', URLFormatValidator);\n\n// New validator can be registered at runtime\nclass EmailFormatValidator extends IValidator {\n  validate(record) {\n    const emailPattern = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (record.email && !emailPattern.test(record.email)) {\n      return new ValidationResult(false, ['Invalid email format']);\n    }\n    return new ValidationResult(true);\n  }\n}\n\n// Register without broker restart\nregistry.register('email-format', EmailFormatValidator);\n```","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Hugging Face","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T06:43:07.129Z","createdAt":"2026-01-26T21:38:36.215Z"},{"id":"q-793","question":"You're designing a streaming data processing framework where each record passes through a configurable pipeline of transformation steps. New transformations must be added at runtime without touching the orchestrator, and jobs select steps by name. Which design pattern and minimal interfaces would you use to register, compose, and execute transformations, ensuring type-safety and low churn when adding new steps? Provide a concise usage example?","answer":"Use a Registry-Driven Strategy pattern: define a Transformation<T> { apply(input: T): T }, a Factory<T> to instantiate by name, and a Pipeline<T> that composes steps. Elements register at runtime in a","explanation":"## Why This Is Asked\nA runtime-extendable transformation system tests open-closed principle, type-safety, and runtime composition without touching orchestration.\n\n## Key Concepts\n- Registry: maps names to transformation factories.\n- Strategy: each transformation is a pluggable strategy.\n- Pipeline: sequences transformations into a single pass.\n- Runtime extensibility: add new steps without modifying core.\n- Type-safety: leverage generics for input/output consistency.\n\n## Code Example\n```typescript\ninterface Transformation<T> { apply(input: T): T; }\n\ntype Factory<T> = () => Transformation<T>;\n\nclass Pipeline<T> {\n  constructor(private steps: Transformation<T>[]) {}\n  run(input: T): T {\n    return this.steps.reduce((acc, s) => s.apply(acc), input);\n  }\n}\n\nconst registry = new Map<string, Factory<any>>();\n\nfunction register<T>(name: string, factory: Factory<T>) {\n  registry.set(name, factory);\n}\n\nfunction create<T>(name: string): Transformation<T> {\n  const f = registry.get(name);\n  if (!f) throw new Error(`Unknown transformation: ${name}`);\n  return f();\n}\n```\n\n## Follow-up Questions\n- How would you handle versioning of transformations and ensure backward compatibility?\n- How would you test pipelines with dynamic registries and ensure deterministic ordering?","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","LinkedIn","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T07:28:39.620Z","createdAt":"2026-01-12T07:28:39.620Z"},{"id":"q-802","question":"Design a unit-test framework runner that supports multiple assertion styles (classic, fluent, should). The goal is to add a new assertion style (e.g., expect) at runtime without modifying the runner core. Which design pattern would be chosen and how would the minimal interfaces and a registry be structured? Provide a usage example?","answer":"Use the Strategy pattern. The runner defines an AssertionStyle interface with a method assert(actual, expected). A registry maps style names to concrete styles and the runner delegates to the selected","explanation":"## Why This Is Asked\n\nTests often need new assertion styles without changing the runner. This probes understanding of decoupling via Strategy and a registry-based plug-in model.\n\n## Key Concepts\n\n- Strategy pattern\n- Open/Closed principle\n- Registry/Plug-in architecture\n- Lightweight interfaces\n\n## Code Example\n\n```javascript\nclass AssertionStyle {\n  assert(actual, expected) { throw new Error('not implemented') }\n}\nclass ClassicAssert extends AssertionStyle {\n  assert(actual, expected) { if (actual !== expected) throw new Error('mismatch') }\n}\nclass Runner {\n  constructor() { this.styles = new Map() }\n  register(name, style) { this.styles.set(name, style) }\n  assert(styleName, actual, expected) {\n    const style = this.styles.get(styleName)\n    style.assert(actual, expected)\n  }\n}\n```\n\n## Follow-up Questions\n\n- How to handle asynchronous assertions? \n- How to ensure thread safety in the registry? \n- How to provide a sensible default when a style is missing?","diagram":"flowchart TD\n  Runner[Runner] --> Style[AssertionStyle]\n  Style --> Classic[ClassicAssert]\n  Style --> Fluent[FluentAssert]\n  Style --> Should[ShouldAssert]","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Salesforce","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T08:33:41.435Z","createdAt":"2026-01-12T08:33:41.435Z"},{"id":"q-8022","question":"Design a runtime-extensible rate-limiter engine for a distributed API gateway. It must support multiple strategies (token bucket, fixed window, sliding window) and allow new strategies to be registered and activated at runtime via a registry without restarting the gateway. Include minimal interfaces, a registry, and a usage example in your language of choice?","answer":"Use a Strategy interface RateLimitStrategy with method tryAcquire(ctx, count). A Registry<String, Factory<RateLimitStrategy>> holds strategy builders. The engine stores an AtomicReference<RateLimitStr","explanation":"## Why This Is Asked\n\nTests ability to design runtime-extensible systems, pattern selection, registry usage, concurrency, observability.\n\n## Key Concepts\n\n- Strategy pattern\n- Registry and dynamic plugin loading\n- Atomic updates and thread-safety\n- Observability\n\n## Code Example\n\n```javascript\n// Minimal interfaces for rate limiter strategies\n```\n\n## Follow-up Questions\n\n- How would you ensure thread-safe strategy swap?\n- How would you handle per-tenant rate limits?\n","diagram":"flowchart TD\n  Request[Request] --> Decide{Strategy}\n  Decide -->|TokenBucket| TB[Token Bucket]\n  Decide -->|FixedWindow| FW[Fixed Window]\n  Decide -->|SlidingWindow| SW[Sliding Window]","difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","DoorDash","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T06:01:35.807Z","createdAt":"2026-01-27T06:01:35.807Z"},{"id":"q-8075","question":"Design a runtime-extensible cache plug-in system where eviction and serialization policies are pluggable per cache region. Build a registry to add new policies without touching the core, support policy composition (e.g., LRU with TTL), and ensure binary compatibility. Provide minimal interfaces, a registry, and a usage snippet in Java, plus a sample policy?","answer":"Create a Policy interface exposing an EvictionPolicy and a Serializer. Implement a PolicyRegistry keyed by region that returns a composite policy. EvictionPolicy supports LRU, TTL, or hybrids; Seriali","explanation":"## Why This Is Asked\n\nExplores a runtime-plugin design for cache behavior, focusing on extensibility, binary compatibility, and per-region customization without touching core code.\n\n## Key Concepts\n\n- Plugin architecture and SPI\n- Registry-based policy lookup\n- Policy composition and region scoping\n- Runtime loading and hot-swapping capabilities\n\n## Code Example\n\n```java\npublic interface EvictionPolicy { void onEvict(Object key, Object value); long ttl(Object key); }\npublic interface Serializer { byte[] serialize(Object obj); Object deserialize(byte[] data); }\npublic interface Policy { EvictionPolicy evictionPolicy(); Serializer serializer(); }\n\npublic class PolicyRegistry {\n  public void register(String region, Policy policy) { /*...*/ }\n  public Policy getPolicy(String region) { /*...*/ }\n}\n```\n\n## Follow-up Questions\n\n- How would you test plugin compatibility and backward-compat SPI changes?\n- How would you handle distributed cache coherence with region-specific policies?","diagram":"flowchart TD\n  A(CacheRegion) --> B(PolicyRegistry)\n  B --> C(Policy)\n  C --> D(Eviction & Serialization)\n  A --> E(ServiceLoader)\n  E --> C","difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Databricks","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T08:43:57.057Z","createdAt":"2026-01-27T08:43:57.057Z"},{"id":"q-809","question":"Design a health-check framework for a fleet-management service. The system aggregates health from multiple subsystems (database, message broker, geolocation API). New checks (checkDiskSpace, checkApiLatency) must be added at runtime without touching the aggregator. Which pattern supports this, and how would you implement minimal interfaces and a usage example?","answer":"Use Composite with a runtime registry. Define IHealthCheck { string name; HealthStatus check(); }. Implement SimpleCheck and CheckGroup that aggregates children. HealthAggregator treats the group as a","explanation":"## Why This Is Asked\nThis tests pattern selection for runtime extensibility without touching core.\n\n## Key Concepts\n- Composite for hierarchical checks\n- Registry for dynamic extension\n- Lightweight HealthStatus aggregation\n\n## Code Example\n```javascript\ninterface IHealthCheck { name: string; check(): HealthStatus }\nclass SimpleCheck implements IHealthCheck { constructor(name, fn){...} check(){return new HealthStatus(...)}}\nclass CheckGroup implements IHealthCheck { constructor(name){this.children=[]} add(c){this.children.push(c)} check(){return aggregate(this.children)}}\n```\n\n## Follow-up Questions\n- How would you test a newly added check in isolation?\n- How would you report partial health vs. critical failure to a dashboard?","diagram":"flowchart TD\n  HealthAggregator[Health Aggregator] --> DB[Database Health]\n  HealthAggregator --> Broker[Broker Health]\n  HealthAggregator --> Geo[Geolocation API Health]\n  Registry[Runtime Registry] --> DiskSpace[Disk Space Check]\n","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T09:34:35.011Z","createdAt":"2026-01-12T09:34:35.011Z"},{"id":"q-8114","question":"Design a runtime-extensible data ingestion pipeline where normalization, validation, and enrichment strategies are pluggable per data source via a registry. Each source specifies a schema version and strategy names (e.g., normalize: canonicalizeKeys, validate: schemaV3, enrich: geoLookup). How would you implement this using design patterns to add new strategies without touching the core pipeline? Provide minimal interfaces and a usage example?","answer":"Use a Registry + Strategy pattern. Define interfaces Normalizer, Validator, Enricher with a PipelineContext, and a SourceRegistry that maps sourceName -> { normalizer, validator, enricher }. The core ","explanation":"## Why This Is Asked\n\nThis question probes runtime extensibility in data pipelines, focusing on plugin registries, strategy composition, and versioned schemas to avoid redeploys.\n\n## Key Concepts\n\n- Registry pattern\n- Strategy pattern\n- Runtime plugin loading\n- Versioned schemas\n- Dependency injection\n\n## Code Example\n\n```typescript\n// Interfaces\ninterface Normalizer { normalize(record: any): any }\ninterface Validator { validate(record: any): ValidationResult }\ninterface Enricher { enrich(record: any): any }\n\ntype StrategySet = { normalizer: string, validator: string, enricher: string }\nclass SourceRegistry {\n  private map = new Map<string, StrategySet>()\n  register(source: string, s: StrategySet) { this.map.set(source, s) }\n  resolve(source: string): StrategySet | undefined { return this.map.get(source) }\n}\n```\n\n## Follow-up Questions\n\n- How to handle version mismatches between source schemas and registered strategies?\n- What strategies ensure zero-downtime updates when swapping implementations?","diagram":"flowchart TD\n  SourceRegistry[Source Registry] --> Resolver[Runtime Resolver]\n  Resolver -->|normalize| Normalizer[Normalization]\n  Resolver -->|validate| Validator[Validation]\n  Resolver -->|enrich| Enricher[Enrichment]","difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Plaid","Twitter","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T10:09:02.822Z","createdAt":"2026-01-27T10:09:02.822Z"},{"id":"q-819","question":"You are designing a log export module for a distributed service. It must support exporting archives to multiple backends (S3, GCS, and an on-prem object store). New backends should be addable at runtime without touching the exporter or consumer code. Design the architecture using a design pattern that lets you plug in new backends via a registry. Provide a minimal interface and usage example?","answer":"Implement a Plugin-style archival backend with a common interface Archiver { archive(batch: LogBatch): Promise<void> }. Create a Registry mapping keys ('s3','gcs','onprem') to factory callbacks. The e","explanation":"## Why This Is Asked\nTests a candidate's ability to design extensible, decoupled systems using pluggable backends and runtime registration. It requires a concrete interface, a registry, and a usage example showing how to add a new backend without modifying the exporter.\n\n## Key Concepts\n- Plugin/Registry pattern for extensibility\n- Dependency Inversion: exporter depends on Archiver abstraction, not concrete backends\n- Factory callbacks to instantiate backends at runtime\n\n## Code Example\n```javascript\n// Minimal interface\nclass Archiver {\n  async archive(batch) { throw new Error('Not implemented') }\n}\n\n// Registry\nconst Registry = {\n  _constructors: new Map(),\n  register(key, factory) { Registry._constructors.set(key, factory) },\n  create(key) { const f = Registry._constructors.get(key); return f ? f() : null }\n}\n\n// Usage\n// Backend implementation\nclass S3Archiver extends Archiver {\n  async archive(batch) { /* push to S3 */ }\n}\nRegistry.register('s3', () => new S3Archiver())\n\n// Exporter uses registry\nconst archiver = Registry.create('s3')\narchiver.archive({/* batch */})\n```\n\n## Follow-up Questions\n- How would you handle lifecycle, retries, and backpressure when a backend is down?\n- How would you verify at compile-time that a backend implements the Archiver interface?","diagram":null,"difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Netflix","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T10:28:02.394Z","createdAt":"2026-01-12T10:28:02.395Z"},{"id":"q-8223","question":"Design a runtime-extensible rate-limiter policy engine for a service mesh. Each service declares a rate-limiting policy by registering new strategies at runtime (e.g., fixed-window, sliding-window, token-bucket). The engine must support adding new strategies without restarting, apply them per service, and switch strategies on the fly using a registry. Provide minimal interfaces, a registry, and a usage example in your language of choice, plus a short rationale on trade-offs?","answer":"Use the Strategy pattern: RateLimitPolicy with allowRequest(key) and reset, plus a PolicyRegistry mapping policy names to factories and supporting runtime plugin loading. Each service holds a RateLimi","explanation":"## Why This Is Asked\n\nTests ability to design a live-extensible policy system, balancing safety, performance, and operability in production.\n\n## Key Concepts\n\n- Strategy pattern for interchangeable rate-limiting algorithms\n- Registry/plugin architecture for runtime extensibility\n- Thread-safety and per-service policy isolation\n- Hot-swap guarantees with minimal disruption\n\n## Code Example\n\n```java\npublic interface RateLimitPolicy {\n  boolean allowRequest(String key);\n  void reset();\n}\n\npublic interface PolicyFactory {\n  RateLimitPolicy create(String config);\n}\n\npublic class PolicyRegistry {\n  private final ConcurrentHashMap<String, PolicyFactory> registry = new ConcurrentHashMap<>();\n  public void register(String name, PolicyFactory factory) { registry.put(name, factory); }\n  public RateLimitPolicy create(String name, String config) {\n    PolicyFactory f = registry.get(name);\n    return (f != null) ? f.create(config) : null;\n  }\n}\n```\n\n## Follow-up Questions\n\n- How would you handle policy migrations without dropping traffic?\n- How to monitor policy performance and detect misconfigurations at runtime?","diagram":"flowchart TD\n  A[Request] --> B[Policy Check]\n  B --> C{Allowed?}\n  C -->|Yes| D[Forward to Service]\n  C -->|No| E[Throttle/Reject]","difficulty":"intermediate","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T15:45:20.951Z","createdAt":"2026-01-27T15:45:20.951Z"},{"id":"q-824","question":"Design a pluggable text-formatting pipeline for a CLI tool. The pipeline should allow new transforms to be added at runtime via a registry, without touching the core pipeline. Use a suitable pattern to compose these transforms in order; provide a minimal interface and a usage example?","answer":"Pattern: a pluggable text-formatting pipeline (pipeline/chain). Each transform is a small unit registered by name; the Pipeline composes them in order at runtime. Minimal interface exposes apply(text)","explanation":"## Why This Is Asked\n\nTests ability to design extensible text processing with runtime plugins, without touching core; demonstrates a clean separation of concerns and Open/Closed compliance.\n\n## Key Concepts\n- Pipeline/Chain of Responsibility pattern\n- Runtime registry for extensibility\n- Minimal transform interface and composition order\n- Deterministic, idempotent transforms\n\n## Code Example\n\n```javascript\nclass Transform {\n  constructor(name, fn) { this.name = name; this.fn = fn; }\n  apply(text) { return this.fn(text); }\n}\nclass Registry {\n  constructor(){ this.factories = new Map(); }\n  register(name, factory){ this.factories.set(name, factory); }\n  create(name){ const f = this.factories.get(name); return f ? f() : null; }\n}\nclass Pipeline {\n  constructor(registry, names){ this.transforms = names.map(n => registry.create(n)).filter(t => t); }\n  run(input){ return this.transforms.reduce((acc, t) => t.apply(acc), input); }\n}\n\nconst registry = new Registry();\nregistry.register('trim', () => new Transform('trim', s => s.trim()));\nregistry.register('collapseSpaces', () => new Transform('collapseSpaces', s => s.replace(/\\s+/g, ' ')));\nregistry.register('toUpper', () => new Transform('toUpper', s => s.toUpperCase()));\n\nconst names = ['trim','collapseSpaces','toUpper'];\nconst pipeline = new Pipeline(registry, names);\nconsole.log(pipeline.run('  hello   world  ')); // 'HELLO WORLD'\n```\n\n## Follow-up Questions\n- How would you handle asynchronous transforms in this pipeline?\n- How would you order or deduplicate transforms registered at runtime to guarantee deterministic results?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Hashicorp","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T11:20:58.692Z","createdAt":"2026-01-12T11:20:58.692Z"},{"id":"q-8263","question":"Design a simple text editor undo/redo using the Memento pattern. The editor stores a single string and supports insert and delete. Define originator and memento interfaces, plus a caretaker that holds history and can step backward/forward. Show how a new operation (e.g., replace) can be added later without modifying the editor core, with a minimal usage example?","answer":"Question describes implementing the Memento pattern for undo/redo in a text editor. It expects an Originator with create/restore state, a Memento encapsulating the state, and a Caretaker managing hist","explanation":"## Why This Is Asked\n\nEvaluates understanding of the Memento pattern for encapsulating state and enabling undo/redo without exposing internals, plus extensibility for new operations.\n\n## Key Concepts\n\n- Memento pattern with Originator, Memento, Caretaker\n- Encapsulation of internal state\n- History navigation (undo/redo) via a caretaker\n- Extensibility to add new operations without modifying the originator\n\n## Code Example\n\n```javascript\nclass EditorOriginator {\n  constructor(text = \"\") { this.text = text; }\n  createMemento() { return new EditorMemento(this.text); }\n  restore(m) { this.text = m.getState(); }\n  insert(pos, ch) { this.text = this.text.slice(0, pos) + ch + this.text.slice(pos); }\n  delete(pos, len) { this.text = this.text.slice(0, pos) + this.text.slice(pos + len); }\n}\nclass EditorMemento { constructor(state) { this._state = state; } getState() { return this._state; } }\nclass Caretaker {\n  constructor() { this.history = []; this.index = -1; }\n  push(m) { this.history = this.history.slice(0, this.index + 1).concat([m]); this.index++; }\n  undo() { if (this.index <= 0) return null; this.index--; return this.history[this.index + 1]; }\n  redo() { if (this.index + 1 >= this.history.length) return null; this.index++; return this.history[this.index]; }\n}\n```\n\n## Follow-up Questions\n\n- How would you test undo/redo behavior across sequences of edits?\n- How would you persist history across sessions and restore state on reload?","diagram":"flowchart TD\n  Editor[Originator: Editor] --> M[Memento: Snapshot]\n  M --> C[Caretaker: History]\n  C -->|undo| Editor\n  C -->|redo| Editor","difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Microsoft","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T17:13:37.332Z","createdAt":"2026-01-27T17:13:37.332Z"},{"id":"q-833","question":"You're building a streaming analytics dashboard where widgets render different metrics. New chart renderers can be added at runtime by third-party teams without modifying core widgets. Design the architecture using a design pattern that supports pluggable renderers via a registry. Provide a minimal interface and a usage example?","answer":"Use a Plugin Registry with a Strategy-like Renderer interface. Define a Renderer interface with render(data, container). Maintain a Registry<string, RendererFactory> that creates concrete renderers (C","explanation":"## Why This Is Asked\nTests ability to design an extensible UI plugin system without touching core widgets, a common Netflix/Tesla/Nvidia scenario.\n\n## Key Concepts\n- Plugin registry for runtime extensibility\n- Strategy/Factory for pluggable renderers\n- Loose coupling between Widget and Renderer\n- Runtime loading and versioning considerations\n\n## Code Example\n```javascript\ninterface Renderer {\n  render(data: any, container: HTMLElement): void\n}\nclass SvgRenderer implements Renderer {\n  render(data: any, container: HTMLElement) { /* draw SVG */ }\n}\nclass Registry {\n  private map = new Map<string, (ctx?: any) => Renderer>()\n  register(name: string, factory: (ctx?: any) => Renderer) { this.map.set(name, factory) }\n  create(name: string, ctx?: any) { return this.map.get(name)!(ctx) }\n}\n```\n\n## Follow-up Questions\n- How would you secure the plugin loading to avoid untrusted code?\n- How would you handle renderer versioning compatibility?","diagram":null,"difficulty":"beginner","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["NVIDIA","Netflix","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T12:44:13.123Z","createdAt":"2026-01-12T12:44:13.123Z"},{"id":"q-8404","question":"Design a runtime-extensible load-balancing strategy system for an edge proxy. Each route can specify a named policy (round_robin, least_connections, consistent_hash). Implement using a registry-based pattern that supports adding new strategies without touching the proxy core. Include minimal interfaces, a registry, and a usage example in your language of choice?","answer":"Use the Strategy pattern combined with a Registry pattern. Define a LoadBalancingStrategy interface with a selectPeer(route, peers, state) method. Maintain a registry mapping policy names to strategy implementations. The proxy resolves the route's policy and delegates peer selection to the appropriate strategy instance.","explanation":"## Why This Is Asked\n\nThis evaluates the ability to design a plugin-friendly, runtime-extensible load balancing system for edge proxies, focusing on decoupling and safe dynamic strategy selection.\n\n## Key Concepts\n\n- Strategy pattern for algorithm abstraction\n- Registry-based plugin architecture\n- Runtime extensibility without core modifications\n- State management for routing decisions\n- Isolated testing of individual strategies\n\n## Code Example\n\n```javascript\ninterface LoadBalancingStrategy {\n  selectPeer(route: any, peers: string[], state: any): string;\n}\n\nclass Registry {\n  private map = new Map<string, LoadBalancingStrategy>();\n  \n  register(name: string, strategy: LoadBalancingStrategy) {\n    this.map.set(name, strategy);\n  }\n  \n  get(name: string): LoadBalancingStrategy {\n    return this.map.get(name);\n  }\n}\n\n// Example usage\nclass RoundRobinStrategy implements LoadBalancingStrategy {\n  selectPeer(route: any, peers: string[], state: any): string {\n    const index = state[route.id] || 0;\n    state[route.id] = (index + 1) % peers.length;\n    return peers[index];\n  }\n}\n\nconst registry = new Registry();\nregistry.register('round_robin', new RoundRobinStrategy());\n```","diagram":null,"difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Goldman Sachs","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-28T06:04:59.436Z","createdAt":"2026-01-27T23:03:19.566Z"},{"id":"q-8425","question":"Design a runtime-extensible optimizer pass system for a distributed SQL query planner. Each pass (PredicatePushDown, JoinOrderReorder, SubqueryUnnest) is a pluggable Strategy registered in a central Registry and loadable at runtime without redeploy. Explain interfaces, lifecycle, version checks, and how to compose passes into a pipeline. Provide a minimal code sketch and usage example?","answer":"Design a runtime-extensible optimizer pass system for a distributed SQL query planner. Each pass (PredicatePushDown, JoinOrderReorder, SubqueryUnnest) is a pluggable strategy registered in a central registry and loadable at runtime without redeployment. The system uses version-aware plugin loading, compatibility checks, and pipeline composition to safely extend optimizer capabilities in distributed environments.","explanation":"## Why This Is Asked\n\nTests ability to design extensible, hot-loading plugin systems without redeploys. Uses Registry + Strategy to decouple optimizer passes from the planner core, with runtime versioning guards and compatibility checks for safety in a distributed environment.\n\n## Key Concepts\n\n- Strategy, Plugin, Registry\n- Dynamic loading and versioning\n- Pipeline composition and determinism\n\n## Code Example\n\n```ts\ninterface Pass { name: string; version: string; apply(plan: Plan, ctx: Context): Plan; }\ntype Factory = (opts?: any) => Pass;\nclass Registry { register(name: string, f: Factory);","diagram":"flowchart TD\n  Registry[Pass Registry] --> A[PredicatePushDown]\n  Registry --> B[JoinOrderReorder]\n  A --> Pipeline[Query Plan Pipeline]\n  B --> Pipeline","difficulty":"advanced","tags":["design-patterns"],"channel":"design-patterns","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","NVIDIA","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-28T05:55:34.188Z","createdAt":"2026-01-27T23:51:35.240Z"}],"subChannels":["general"],"companies":["Adobe","Airbnb","Amazon","Anthropic","Apple","Bloomberg","Citadel","Cloudflare","Coinbase","Databricks","Discord","DoorDash","Goldman Sachs","Google","Hashicorp","Hugging Face","IBM","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Netflix","OpenAI","Oracle","PayPal","Plaid","Robinhood","Salesforce","Scale Ai","Slack","Snap","Snowflake","Square","Stripe","Tesla","Twitter","Two Sigma","Uber","Zoom"],"stats":{"total":89,"beginner":28,"intermediate":28,"advanced":33,"newThisWeek":37}}