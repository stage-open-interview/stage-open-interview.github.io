{"questions":[{"id":"rhcsa-essential-tools-1768166429187-0","question":"During configuration maintenance, you need to replace the string 'listen 8080' with 'listen 80' in all nginx configuration files under /etc/nginx, and you want to keep a backup file for each original. Which command sequence achieves this safely?","answer":"[{\"id\":\"a\",\"text\":\"find /etc/nginx -type f -name '*.conf' -exec sed -i.bak 's/listen 8080/listen 80/' {} +\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"find /etc/nginx -type f -name '*.conf' -exec sed -i 's/listen 8080/listen 80/' {} +\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"sed -i 's/listen 8080/listen 80/' /etc/nginx/*.conf\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"tar -czf /backup/nginx.tar.gz -C /etc/nginx .\",\"isCorrect\":false}]","explanation":"## Correct Answer\nA. Uses find to locate all .conf files under /etc/nginx, and applies sed -i.bak to edit in place while creating a backup for each file. This is safer for bulk changes.\n\n## Why Other Options Are Wrong\n- B: Edits files in place but does not create backups, risking data loss on mistakes.\n- C: Only affects a single directory level and may miss files in subdirectories.\n- D: Creates an archive instead of applying in-file edits.\n\n## Key Concepts\n- find -type f to locate files\n- -exec ... {} + to apply commands to multiple files\n- sed -i.bak to edit in place and create a backup with .bak extension\n\n## Real-World Application\nUsed when performing bulk script-driven config changes across multiple config files while preserving original copies for rollback.","diagram":null,"difficulty":"intermediate","tags":["RHCSA","Linux","CLI","Sed","Find","Nginx","AWS","Kubernetes","Terraform","certification-mcq","domain-weight-20"],"channel":"rhcsa","subChannel":"essential-tools","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T21:20:29.188Z","createdAt":"2026-01-11 21:20:29"},{"id":"rhcsa-essential-tools-1768166429187-1","question":"During maintenance, you want to verify the contents of a gzip-compressed tarball site.tar.gz without extracting it. Which command would you use?","answer":"[{\"id\":\"a\",\"text\":\"tar -tzf site.tar.gz\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"tar -tf site.tar.gz\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"tar -xzf site.tar.gz\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"tar -czf site.tar.gz\",\"isCorrect\":false}]","explanation":"## Correct Answer\nA. tar -tzf site.tar.gz lists the contents of a gzip-compressed tarball without extracting.\n\n## Why Other Options Are Wrong\n- B: tar -tf may not correctly handle gzip compression on some tar implementations unless combined with -z; in many environments, -z is required.\n- C: tar -xzf extracts the archive, not just listing contents.\n- D: tar -czf creates a new archive, not listing contents.\n\n## Key Concepts\n- -t lists contents, -z for gzip, -f specifies archive file\n\n## Real-World Application\nUsed during maintenance to audit archive contents before deployment or extraction.","diagram":null,"difficulty":"intermediate","tags":["RHCSA","Tar","Gzip","Linux","Nginx","AWS","Kubernetes","Terraform","certification-mcq","domain-weight-20"],"channel":"rhcsa","subChannel":"essential-tools","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T21:20:29.967Z","createdAt":"2026-01-11 21:20:30"},{"id":"rhcsa-essential-tools-1768166429187-2","question":"From /etc/passwd, print usernames for accounts with UID >= 1000 and login shells that do not contain the string 'nologin'. Which command achieves this?","answer":"[{\"id\":\"a\",\"text\":\"awk -F: '$3>=1000 && $7 !~ /nologin/ {print $1}' /etc/passwd\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"awk -F: '$3>=1000 && $7 != \\\"/sbin/nologin\\\" {print $1}' /etc/passwd\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"awk -F: '$3>=1000 {print $1}' /etc/passwd\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"awk -F: '$3<1000 {print $1}' /etc/passwd\",\"isCorrect\":false}]","explanation":"## Correct Answer\nA. Uses the UID field (third field) to filter >=1000 and checks that the login shell (seventh field) does not contain the string nologin, printing the username (first field).\n\n## Why Other Options Are Wrong\n- B: Excludes only the exact path /sbin/nologin; many systems use other paths such as /usr/sbin/nologin, which would still be non-login shells.\n- C: Does not filter out non-login shells.\n- D: Filters by UID < 1000, which selects system accounts, not human users.\n\n## Key Concepts\n- Field delimiter -F: for /etc/passwd format (user:pass:uid:gname:home:shell)\n- UID threshold for human users (>=1000)\n- Pattern matching to exclude login shells containing nologin\n\n## Real-World Application\nHelps reduce audit scope to real human users for access reviews and onboarding/offboarding tasks.","diagram":null,"difficulty":"intermediate","tags":["RHCSA","Awk","Passwd","UserManagement","Linux","AWS","Kubernetes","Terraform","certification-mcq","domain-weight-20"],"channel":"rhcsa","subChannel":"essential-tools","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-11T21:20:30.513Z","createdAt":"2026-01-11 21:20:30"},{"id":"rhcsa-operate-systems-1768206719121-0","question":"A server uses LVM with a dedicated logical volume lv_home mounted on /home. The volume group is vg00. You need to extend /home by 10G without rebooting. Which sequence of commands achieves this correctly on a Red Hat system with XFS on /home?","answer":"[{\"id\":\"a\",\"text\":\"lvextend -L +10G /dev/vg00/lv_home; xfs_growfs /home\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"lvextend -L +12G /dev/vg00/lv_home; resize2fs /home\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"lvresize -L +10G /dev/vg00/lv_home; xfs_growfs /home\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"lvextend -L +10G /dev/vg00/lv_home; xfs_growfs /\",\"isCorrect\":false}]","explanation":"## Correct Answer\nA. lvextend -L +10G /dev/vg00/lv_home; xfs_growfs /home\n\nThis extends the LV by 10G and expands the XFS filesystem live. The other options are incorrect: B uses resize2fs on XFS (not supported); C uses lvresize (works, but not the canonical command in this scenario); D grows the wrong filesystem, targeting the root rather than /home.\n\n## Why Other Options Are Wrong\n- B: resize2fs does not support XFS and cannot resize /home in this scenario.\n- C: lvresize is a valid LV operation but uses a different tool; not the standard approach here.\n- D: Attempts to grow the wrong filesystem mountpoint (/ instead of /home).\n\n## Key Concepts\n- LVM lvextend vs lvresize\n- Online filesystem resizing for XFS\n- Mountpoints and filesystem types\n\n## Real-World Application\nEngineers often need to quickly scale storage for user data without rebooting or downtime, relying on LVM and XFS capabilities.\n","diagram":null,"difficulty":"intermediate","tags":["RHCSA","Operate Running Systems","LVM","SELinux","firewalld","systemd","AWS","EC2","Kubernetes","Terraform","certification-mcq","domain-weight-20"],"channel":"rhcsa","subChannel":"operate-systems","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T08:31:59.122Z","createdAt":"2026-01-12 08:31:59"},{"id":"rhcsa-operate-systems-1768206719121-1","question":"An administrator moves the content directory for a web site from /var/www/html to a new mount at /mnt/storage/www. After mounting, the web server cannot serve the content due to SELinux context mismatch. Which sequence ensures the new location has proper persistent SELinux context?","answer":"[{\"id\":\"a\",\"text\":\"semanage fcontext -a -t httpd_sys_content_t '/mnt/storage(/.*)?'; restorecon -R -v /mnt/storage\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"chcon -R -t httpd_sys_content_t /mnt/storage\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"restorecon -R -v /mnt/storage/www\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"setenforce 0\",\"isCorrect\":false}]","explanation":"## Correct Answer\nA. semanage fcontext -a -t httpd_sys_content_t '/mnt/storage(/.*)?'; restorecon -R -v /mnt/storage\n\nThis adds a persistent SELinux file context mapping for the new storage location and applies it recursively. B applies a temporary context change that won’t persist across relabels. C only runs restorecon without a proper persistent mapping, and D disables SELinux entirely, which is insecure.\n\n## Why Other Options Are Wrong\n- B: chcon changes context only temporarily and won’t survive relabels or reboots.\n- C: restorecon without proper fcontext mapping has no lasting effect for the new path.\n- D: Disabling SELinux is insecure and bypasses policy enforcement.\n\n## Key Concepts\n- Persistent SELinux contexts with semanage fcontext\n- httpd_sys_content_t for web content\n- restorecon usage\n\n## Real-World Application\nWeb admins relocate web content and must preserve secure, policy-driven access without disabling security controls.\n","diagram":null,"difficulty":"intermediate","tags":["RHCSA","Operate Running Systems","SELinux","httpd","systemd","AWS","EC2","Kubernetes","Terraform","certification-mcq","domain-weight-20"],"channel":"rhcsa","subChannel":"operate-systems","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T08:31:59.533Z","createdAt":"2026-01-12 08:31:59"},{"id":"rhcsa-operate-systems-1768206719121-2","question":"You need to expose a service on port 8080 to external clients. The server uses firewalld and is in the public zone. Which command sequence opens the port permanently and makes it survive reboot?","answer":"[{\"id\":\"a\",\"text\":\"firewall-cmd --zone=public --add-port=8080/tcp --permanent; firewall-cmd --reload\",\"isCorrect\":true},{\"id\":\"b\",\"text\":\"firewall-cmd --zone=public --add-service=http --permanent; firewall-cmd --reload\",\"isCorrect\":false},{\"id\":\"c\",\"text\":\"firewall-cmd --zone=public --remove-port=8080/tcp; firewall-cmd --reload\",\"isCorrect\":false},{\"id\":\"d\",\"text\":\"firewall-cmd --zone=internal --add-port=8080/tcp --permanent; systemctl restart firewalld\",\"isCorrect\":false}]","explanation":"## Correct Answer\nA. firewall-cmd --zone=public --add-port=8080/tcp --permanent; firewall-cmd --reload\n\nThis permanently opens port 8080 in the public zone and reloads the firewall rules. B opens a different port (HTTP default 80) rather than 8080. C removes the port, defeating the requirement. D uses the wrong zone and an unnecessary restart.\n\n## Why Other Options Are Wrong\n- B: Opens port 80 (HTTP) instead of 8080, not meeting the requirement.\n- C: Removes the port, opposite of the goal.\n- D: Uses the wrong zone and relies on a restart rather than a reload; the zone consistency is wrong.\n\n## Key Concepts\n- firewalld permanent rules\n- Correct zone alignment\n- Persistence across reboots\n\n## Real-World Application\nExposing services securely requires precise firewall configuration that survives system restarts.\n","diagram":null,"difficulty":"intermediate","tags":["RHCSA","Operate Running Systems","firewalld","systemd","AWS","EC2","Kubernetes","Terraform","certification-mcq","domain-weight-20"],"channel":"rhcsa","subChannel":"operate-systems","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T08:31:59.944Z","createdAt":"2026-01-12 08:32:00"}],"subChannels":["essential-tools","operate-systems"],"companies":[],"stats":{"total":6,"beginner":0,"intermediate":6,"advanced":0,"newThisWeek":6}}