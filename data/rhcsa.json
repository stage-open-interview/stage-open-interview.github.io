{"questions":[{"id":"q-1023","question":"Design a centralized, tamper-evident logging pipeline for 6 RHEL hosts. Include: enable persistent journald, forward logs over TLS to a central collector, configure rotation/retention, protect in transit with certificate-based auth, and a rollback/validation plan that proves delivery during outages. Outline testing steps and failure scenarios?","answer":"Enable persistent journald on all six hosts; configure rsyslog to forward logs via TLS to a central collector with certificate-based authentication; enforce rotation/retention (90 days) and archive to","explanation":"## Why This Is Asked\nConcrete, scalable, secure logging is critical in production. This question tests practical setup, TLS, journald/rsyslog integration, retention, and failover planning.\n\n## Key Concepts\n- systemd-journald persistent storage\n- TLS-encrypted log forwarding (rsyslog/omfwd)\n- log rotation and retention policies\n- log integrity and rollback strategies\n- outage/failover validation\n\n## Code Example\n```javascript\n// Simple hash of a log line to simulate tamper-detection\nconst crypto = require('crypto');\nfunction hashLine(line){ return crypto.createHash('sha256').update(line).digest('hex'); }\n```\n\n## Follow-up Questions\n- How would you verify end-to-end delivery during a network outage?\n- How would you rotate encryption certificates without dropping logs?","diagram":"flowchart TD\n  A[Hosts] --> B[Local journald]\n  B --> C[rsyslog forward]\n  C --> D[Central TLS collector]\n  D --> E[Archive/Retention]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Hashicorp"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T19:35:30.051Z","createdAt":"2026-01-12T19:35:30.051Z"},{"id":"q-1118","question":"On a RHEL 9 host, a service named app writes to /srv/app/data. After deployment, SELinux denials prevent writes. Without disabling SELinux, outline exact, implementable steps to restore functionality, including identifying the AVC, creating a targeted policy module with audit2allow, loading it, labeling the data directory, and validating the fix with a controlled write and audit checks?","answer":"Identify AVCs with ausearch -m avc -ts today | tail. Build a policy with: ausearch -m avc -ts today | audit2allow -M app_fix; load: semodule -i app_fix.pp. Label: semanage fcontext -a -t app_data_t '/","explanation":"## Why This Is Asked\nTests SELinux troubleshooting, policy generation, and safe remediation without disabling security controls.\n\n## Key Concepts\n- AVCs and audit2allow\n- Custom SELinux policy modules\n- File context labeling and restorecon\n- Validation via audits and controlled writes\n\n## Code Example\n```bash\n# 1) Identify AVCs from today\nausearch -m avc -ts today | tail\n# 2) Create a policy module\nausearch -m avc -ts today | audit2allow -M app_fix\n# 3) Load the policy\nsemodule -i app_fix.pp\n# 4) Label directory and content\nsemanage fcontext -a -t app_data_t '/srv/app/data(/.*)?'\nrestorecon -R /srv/app/data\n```\n\n## Follow-up Questions\n- How would you adjust this if the data directory is on NFS?\n- How can you troubleshoot if the policy still blocks legitimate writes after labeling?","diagram":"flowchart TD\n  A[App writes to /srv/app/data] --> B{AVC denied}\n  B --> C[Audit log shows AVC]\n  C --> D[Create policy with audit2allow]\n  D --> E[Load policy with semodule]\n  E --> F[Label dir with semanage/restorecon]\n  F --> G[Test write succeeds]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Hugging Face","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T23:27:33.371Z","createdAt":"2026-01-12T23:27:33.371Z"},{"id":"q-1148","question":"On a RHEL 8 server, implement a daily backup of /home/userdata to /backup/userdata-YYYYMMDD.tgz, exclude caches and temp dirs, preserve permissions, and generate a sha256 checksum. Schedule at 02:30 via cron and rotate backups to keep last 7 days. Provide commands and a script outline?","answer":"Use a cron-driven backup with tar -p and excludes, plus a sha256 checksum and a 7-day rotation. Example approach: create /backup if needed, tar czpf /backup/userdata-YYYY-MM-DD.tgz -p --exclude patter","explanation":"## Why This Is Asked\nTests practical backup scripting skills: tar with permissions, exclude patterns, integrity checks, cron scheduling, and simple rotation.\n\n## Key Concepts\n- tar with permission preservation\n- --exclude patterns\n- sha256sum checksums\n- cron scheduling\n- rotation by date\n\n## Code Example\n```bash\n#!/bin/bash\nDATE=$(date +%F)\nSRC=\"/home/userdata\"\nDEST=\"/backup\"\nTAR=\"$DEST/userdata-$DATE.tgz\"\nEXCLUDES=\"--exclude='**/.cache' --exclude='**/tmp'\"\ntar czpf \"$TAR\" -p $EXCLUDES \"$SRC\"\nsha256sum \"$TAR\" > \"$TAR.sha256\"\nfind \"$DEST\" -name 'userdata-*.tgz' -mtime +7 -delete\n```\n\n## Follow-up Questions\n- How would you implement incremental backups?\n- How would you verify restoration from a random backup file?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Instacart","Lyft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T01:33:46.097Z","createdAt":"2026-01-13T01:33:46.097Z"},{"id":"q-1169","question":"Design and implement an encrypted root on LVM for a production RH host. Boot partition remains unencrypted; the root filesystem sits on a LUKS2 container inside an LVM PV, with a keyfile for unattended boot. Provide a concrete, command-level plan including crypttab, fstab, initramfs (dracut) generation, and grub configuration to ensure the system boots automatically after rotation?","answer":"Two-stage layout: /boot unencrypted; root on LUKS2 inside an LVM PV. Create 1G /boot partition and encrypt the rest. Steps: format and open LUKS, set up PV/VG/LV, create filesystem, copy data, update ","explanation":"## Why This Is Asked\nThis question probes practical, production-grade encryption setup, including boot-time unlocking, crypttab/fstab integration, and initramfs/grub changes — skills RHCSA expects for secure deployments.\n\n## Key Concepts\n- LUKS2 on a dedicated partition\n- LVM PV/VG/LV layering on top of a mapped device\n- crypttab and initramfs integration\n- Grub configuration and unattended boot considerations\n- Keyfile management and security\n\n## Code Example\n```javascript\n// Shell commands illustrating the flow\ncryptsetup luksFormat /dev/sdb2 --type luks2\ncryptsetup luksOpen /dev/sdb2 cryptroot --key-file /root/keyfile\npvcreate /dev/mapper/cryptroot\nvgcreate vg0 /dev/mapper/cryptroot\nlvcreate -L 100G -n root vg0\nmkfs.xfs /dev/vg0/root\n```\n\n## Follow-up Questions\n- How would you rotate the LUKS keyfile safely without reboot?\n- How do you verify the encrypted volume opens during boot with a degraded initramfs?","diagram":null,"difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Plaid","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T03:35:27.852Z","createdAt":"2026-01-13T03:35:27.852Z"},{"id":"q-1192","question":"On a RHEL8 host, set up a minimal Python HTTP server listening on port 8080, accessible only from 192.168.100.0/24. Use a non-root user, a systemd service, SELinux port labeling, and firewalld rules. Provide exact commands to create the service, configure semanage for port 8080, apply firewall rules, and test from a client. Address potential SELinux and port conflict caveats?","answer":"Create a non-root user webu; place app.py with a minimal HTTP server listening on 0.0.0.0:8080; a systemd service webserver.service (User=webu, WorkingDirectory=/home/webu, ExecStart=/usr/bin/python3 ","explanation":"## Why This Is Asked\nTests practical sysadmin tasks across users, services, SELinux, and firewall rules.\n\n## Key Concepts\n- systemd service creation\n- semanage port labeling\n- firewalld rich rules for IP ranges\n- binding to 0.0.0.0 and access control\n- testing with curl\n\n## Code Example\n```javascript\n# /etc/systemd/system/webserver.service\n[Unit]\nDescription=Minimal Python HTTP server\nAfter=network-online.target\n[Service]\nUser=webu\nWorkingDirectory=/home/webu\nExecStart=/usr/bin/python3 /home/webu/app.py\nRestart=on-failure\n[Install]\nWantedBy=multi-user.target\n```\n\n```javascript\n# app.py\nimport http.server, socketserver\nPORT=8080\nHandler=http.server.SimpleHTTPRequestHandler\nwith socketserver.TCPServer((\"0.0.0.0\", PORT), Handler) as httpd:\n    httpd.serve_forever()\n```","diagram":"flowchart TD\n  A[Create user and app] --> B[Create systemd service]\n  B --> C[Label port with SELinux]\n  C --> D[Configure firewall]\n  D --> E[Test access]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","LinkedIn"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T04:42:25.489Z","createdAt":"2026-01-13T04:42:25.489Z"},{"id":"q-1247","question":"On a RHEL 8 server, a web service listens on 127.0.0.1:9090. Configure firewalld to expose port 9090 only to the 10.1.0.0/24 management network, log drops, and persist across reboots. Provide exact commands, and describe test steps using curl from an allowed host and from a non-allowed host?","answer":"firewall-cmd --get-default-zone\nfirewall-cmd --permanent --zone=public --add-rich-rule='rule family=\"ipv4\" source address=\"10.1.0.0/24\" port port=\"9090\" protocol=\"tcp\" accept'\nfirewall-cmd --permanent","explanation":"## Why This Is Asked\nTests practical firewall configuration with persistent rules and live-testing.\n\n## Key Concepts\n- firewalld zones and rich rules\n- persistence with --permanent and firewall-cmd reload\n- testing network access with curl\n\n## Code Example\n```javascript\n// Commands illustrating the approach\nfirewall-cmd --get-default-zone\nfirewall-cmd --permanent --zone=public --add-rich-rule='rule family=\"ipv4\" source address=\"10.1.0.0/24\" port port=\"9090\" protocol=\"tcp\" accept'\nfirewall-cmd --permanent --zone=public --add-rich-rule='rule family=\"ipv4\" port port=\"9090\" protocol=\"tcp\" drop'\nfirewall-cmd --reload\n```\n\n## Follow-up Questions\n- How would you audit if the rule is being bypassed by another chain? \n- How would you revert the changes quickly? ","diagram":"flowchart TD\n  A[Define allowed subnet] --> B[Add accept rich rule]\n  B --> C[Add drop rule for others]\n  C --> D[Reload firewalld]\n  D --> E[Test with curl]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T06:42:21.017Z","createdAt":"2026-01-13T06:42:21.017Z"},{"id":"q-1399","question":"You manage a RHEL 8 server running SSH on port 22. To improve security, change SSH to listen on port 2222, disable root SSH login, and require key-based authentication, ensuring no downtime for existing sessions. List the exact commands and steps to implement this, including firewall and SELinux considerations, and how you verify connectivity afterwards?","answer":"Edit /etc/ssh/sshd_config: Port 2222; PermitRootLogin no; PasswordAuthentication no. Reload: systemctl reload sshd. Firewall: firewall-cmd --permanent --add-port=2222/tcp; firewall-cmd --reload. SELin","explanation":"## Why This Is Asked\nTests practical admin tasks across SSH config, firewall, and SELinux with minimal downtime.\n\n## Key Concepts\n- SSH daemon configuration\n- Firewalld management\n- SELinux port labeling\n- Connectivity testing and rollback\n\n## Code Example\n```bash\n# modify ssh config\nsudo sed -i 's/^#?Port .*/Port 2222/' /etc/ssh/sshd_config\nsudo sed -i 's/^Port 22/Port 2222/' /etc/ssh/sshd_config\nsudo sed -i 's/^#?PermitRootLogin.*/PermitRootLogin no/' /etc/ssh/sshd_config\nsudo sed -i 's/^#?PasswordAuthentication.*/PasswordAuthentication no/' /etc/ssh/sshd_config\nsudo systemctl restart sshd\nsudo firewall-cmd --permanent --add-port=2222/tcp\nsudo firewall-cmd --reload\nsudo semanage port -a -t ssh_port_t -p tcp 2222\nsudo restorecon -R /etc/ssh\n# test connectivity from admin host\nssh -p 2222 user@host\n```\n\n## Follow-up Questions\n- How would you revert if something goes wrong during the change?\n- How would you verify there are no lingering insecure access attempts?","diagram":"flowchart TD\n  A[SSH Config] --> B[Restart SSHD]\n  B --> C[Firewall Rule]\n  C --> D[SELinux Port]\n  D --> E[Verification]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","LinkedIn","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T15:40:50.563Z","createdAt":"2026-01-13T15:40:50.563Z"},{"id":"q-1484","question":"On a Red Hat-based host, you must deploy a statically compiled Go web app that runs on port 8080 behind firewalld with SELinux enforcing. The app should auto-start on boot, restart on failure, and log to rsyslog. Propose the concrete steps, files, and exact commands to configure systemd, firewalld, and SELinux contexts, ensuring minimal downtime during deploy?","answer":"Create a systemd unit for /opt/myapp/myapp listening on port 8080. In ExecStart use /opt/myapp/myapp --port 8080; Restart=on-failure; StandardOutput=journal; StandardError=journal. SELinux: semanage f","explanation":"## Why This Is Asked\nTests ability to package a real app with init, SELinux, and firewall integration.\n\n## Key Concepts\n- systemd service files and Restart logic\n- SELinux file context labeling\n- firewalld port management\n- logging through systemd/journald\n\n## Code Example\n```ini\n[Unit]\nDescription=My App\nAfter=network.target\n\n[Service]\nExecStart=/opt/myapp/myapp --port 8080\nRestart=on-failure\nStandardOutput=journal\nStandardError=journal\n\n[Install]\nWantedBy=multi-user.target\n```\n\n## Follow-up Questions\n- How would you roll back if the binary fails to start after deployment?\n- How would you audit SELinux denials for this service?","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T18:57:55.544Z","createdAt":"2026-01-13T18:57:55.544Z"},{"id":"q-1517","question":"On a RHEL 9 host, a custom service started via systemd fails to write logs to /var/www/app/logs after a patch, with SELinux enforcing. Describe a precise, minimal-risk remediation plan to identify and fix the root cause without broad permission grants, including AVC collection, targeted policy generation, and validation under load. What exact commands and steps would you perform?","answer":"Diagnose with SELinux AVCs for the failing service, collect today’s logs, and craft a targeted policy with audit2allow. Steps: 1) ausearch -m avc -ts today -i. 2) audit2allow -w -a -M svc_logfix. 3) s","explanation":"## Why This Is Asked\nSELinux troubleshooting in production is common; it tests practical, precise remediation without broad privileges.\n\n## Key Concepts\n- AVC denials, targeted policy, audit2allow, semodule\n- ausearch for AVCs, ts filtering, and interpreting logs\n- safe relabeling vs. creating a minimal policy module\n\n## Code Example\n```javascript\n# Collect AVCs for today\nausearch -m avc -ts today -i\n# Build a targeted module from logs\naudit2allow -w -a -M svc_logfix\nsemodule -i svc_logfix.pp\n```\n\n## Follow-up Questions\n- How would you verify no regression in other services after applying the module?\n- What are the risks of over-broad policy changes and how to mitigate them?","diagram":"flowchart TD\nA[AVC Denial Detected] --> B[Collect AVCs with ausearch]\nB --> C[Generate module via audit2allow]\nC --> D[Install module with semodule]\nD --> E[Restart service]\nE --> F[Load-test and verify logs]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T20:34:41.210Z","createdAt":"2026-01-13T20:34:41.212Z"},{"id":"q-1577","question":"You must serve a static site from content stored on an NFS mount at /srv/www with SELinux enforcing on a RHEL-based system. The SELinux policy blocks httpd from reading the files. Describe the exact sequence of commands and configurations to allow Apache to serve the site without disabling SELinux or putting the system in permissive mode, including boolean toggles, labeling, and firewall rules?","answer":"Enable httpd to read NFS content: setsebool -P httpd_use_nfs on; semanage fcontext -a -e httpd_sys_content_t '/srv/www(/.*)?'; restorecon -R /srv/www; systemctl restart httpd; firewall-cmd --permanent --add-service=http; firewall-cmd --reload","explanation":"## Why This Is Asked\nEvaluates practical SELinux handling for real-world shared content, not just theory.\n\n## Key Concepts\n- SELinux booleans (httpd_use_nfs)\n- File context labeling for web content\n- restorecon and semanage usage\n- Firewall rules for HTTP\n- Diagnosing and remediating AVCs with audit2allow\n\n## Code Example\n```bash\nsetsebool -P httpd_use_nfs on\nsemanage fcontext -a -e httpd_sys_content_t '/srv/www(/.*)?'\nrestorecon -R /srv/www\nsystemctl restart httpd\nfirewall-cmd --permanent --add-service=http\nfirewall-cmd --reload\n```\n\n## Follow-up Questions\n- How would you verify and remediate","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Meta","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T05:56:45.358Z","createdAt":"2026-01-13T22:44:11.540Z"},{"id":"q-1610","question":"Configure log rotation for a custom web app log path /var/log/myapp/*.log on a live Linux host. The log is written by a root-owned process and must rotate weekly, keep 4 copies, compress old logs, and after rotation reload nginx to reopen its handles. Provide a minimal, working logrotate.conf snippet and explain how this prevents log loss?","answer":"Use a dedicated logrotate stanza:\n\n```\n/var/log/myapp/*.log {\n    weekly\n    rotate 4\n    compress\n    missingok\n    notifempty\n    copytruncate\n    sharedscripts\n    postrotate\n        systemctl reload nginx >/dev/null 2>&1 || true\n    endscript\n}\n```","explanation":"Why This Is Asked\n- Tests practical log management and prevention of log loss in a real service\n- Checks understanding of rotation cadence, backup retention, and service interaction\n\nKey Concepts\n- logrotate stanza syntax and options (weekly, rotate, compress, missingok, notifempty, copytruncate, sharedscripts)\n- Post-rotation actions to refresh services (nginx log file handles)\n- Impact of log rotation on running daemons and data integrity\n\nCode Example\n```bash\n/var/log/myapp/*.log {\n    weekly\n    rotate 4\n    compress\n    missingok\n    notifempty\n    copytruncate\n    sharedscripts\n    postrotate\n        systemctl reload nginx >/dev/null 2>&1 || true\n    endscript\n}\n```\n\nHow This Prevents Log Loss\n- `copytruncate` copies the current log to a new file, then truncates the original, ensuring continuous logging without interruption\n- `sharedscripts` ensures the postrotate command runs only once per rotation, preventing multiple nginx reloads\n- `missingok` and `notifempty` prevent errors if logs don't exist or are empty, avoiding rotation failures\n- `systemctl reload nginx` gracefully reopens log file handles without dropping connections, preventing log loss during rotation","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","IBM","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T05:30:20.445Z","createdAt":"2026-01-14T02:35:40.954Z"},{"id":"q-1649","question":"On a RHEL system with root on an LV named /dev/vg_rhel/root, describe a precise method to test a disruptive system update using an LVM snapshot: create a 20G snapshot, apply the update inside the snapshot, validate service health, and rollback by booting the live system from the original LV if needed. Include exact commands?","answer":"Create a 20G root snapshot: lvcreate -s -n root-snap -L20G vg_rhel/root. Mount it at /mnt/snap, bind /dev /proc /sys, chroot /mnt/snap, run dnf update -y, test services. If healthy, reboot normally. I","explanation":"## Why This Is Asked\nAssesses practical rollback strategy using LVM snapshots for live testing of disruptive updates.\n\n## Key Concepts\n- LVM snapshots\n- chroot testing\n- Rollback via boot path adjustment\n\n## Code Example\n```javascript\nlvcreate -s -n root-snap -L20G vg_rhel/root\nmkdir -p /mnt/snap\nmount /dev/vg_rhel/root-snap /mnt/snap\nfor d in /proc /sys /dev; do mount --bind \"$d\" \"/mnt/snap$d\"; done\nchroot /mnt/snap\ndnf update -y\nsystemctl status httpd\nexit\n```\n\n## Follow-up Questions\n- How would you automate cleanup after a successful rollback?\n- How to secure the test against data inconsistency during the snapshot lifecycle?","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T04:33:32.950Z","createdAt":"2026-01-14T04:33:32.950Z"},{"id":"q-1679","question":"On a RHEL/CentOS host with two NICs (enp0s3 and enp0s8) connected to two switches, configure a 802.3ad (LACP) bond0 using NetworkManager. Bond should have a static IP 192.0.2.100/24, and both NICs must be slaves. Provide exact nmcli commands to create bond0, add slaves, bring it up, and verify; note required switch settings (LACP active on both ports)?","answer":"Configure a 802.3ad LACP bond across two NICs with a static IP on bond0. Use NM to create bond0, assign 192.0.2.100/24, add enp0s3 and enp0s8 as slaves, bring up bond0, and verify via /proc/net/bondin","explanation":"## Why This Is Asked\nReal-world networking reliability requires correct bonding configuration with LACP. This tests practical NM usage, understanding of switch prerequisites, and verification of bond status.\n\n## Key Concepts\n- 802.3ad/LACP bonding\n- NetworkManager nmcli commands\n- Slave interfaces and master bond configuration\n- Switch-side LACP, port-channel settings, MTU consistency\n\n## Code Example\n```bash\n# Create bond with LACP\nnmcli con add type bond ifname bond0 mode 802.3ad\n# Set static IP on bond\nnmcli con modify bond0 ipv4.addresses 192.0.2.100/24 ipv4.method manual\n# Add slaves\nnmcli con add type ethernet ifname enp0s3 master bond0\nnmcli con add type ethernet ifname enp0s8 master bond0\n# Bring interfaces up\nnmcli con up bond0\nnmcli con up enp0s3\nnmcli con up enp0s8\n```\n\n## Follow-up Questions\n- How would you troubleshoot if /proc/net/bonding/bond0 shows inconsistent slave status?\n- What changes are needed if one switch port goes down and the bond remains up?","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Scale Ai","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T06:51:43.330Z","createdAt":"2026-01-14T06:51:43.330Z"},{"id":"q-1738","question":"On a RHEL-based host, configure firewalld to allow SSH access only from 192.0.2.0/24 and deny all other inbound SSH; ensure the changes persist after reboot and can be tested quickly; outline exact commands and verification steps, including revert plan?","answer":"Remove the ssh service from the default zone, then add two permanent rich rules: allow ssh for source 192.0.2.0/24 and drop ssh from all others, then reload. Verify via firewall-cmd --zone=public --li","explanation":"## Why This Is Asked\nTests handling of firewalld, zones, and persistent rules in a concrete admin task.\n\n## Key Concepts\n- firewalld zones and permanent vs runtime rules\n- rich rules for source-based access\n- persistence and verification\n\n## Code Example\n```javascript\nfirewall-cmd --zone=public --permanent --remove-service=ssh\nfirewall-cmd --zone=public --permanent --add-rich-rule='rule family=\"ipv4\" source address=\"192.0.2.0/24\" service name=\"ssh\" accept'\nfirewall-cmd --zone=public --permanent --add-rich-rule='rule family=\"ipv4\" service name=\"ssh\" drop'\nfirewall-cmd --reload\n```\n\n## Follow-up Questions\n- How to mirror this for IPv6?\n- What if the admin needs temporary access from another network during maintenance?","diagram":"flowchart TD\n  A[Identify current rules] --> B[Remove ssh service] \n  B --> C[Add allow rule for 192.0.2.0/24] \n  C --> D[Add drop rule for others] \n  D --> E[Reload firewall] \n  E --> F[Verify rules] \n  F --> G[Revert if needed]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Tesla","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T09:00:00.925Z","createdAt":"2026-01-14T09:00:00.925Z"},{"id":"q-1756","question":"On a freshly provisioned Linux host (RHEL8), configure a new user 'audit' to log in exclusively via SSH key authentication, with a restricted shell rbash so only basic commands are allowed, and grant passwordless sudo to restart the 'auditd' service. Provide exact commands and edits to users, sshd_config, and sudoers, and how you would verify the setup?","answer":"Create user and home; assign rbash as shell; set a restricted PATH; configure SSH: PasswordAuthentication no; create /home/audit/.ssh/authorized_keys; edit /etc/sudoers.d/audit: audit ALL=(ALL) NOPASS","explanation":"## Why This Is Asked\nTests practical provisioning, SSH hardening, and sudo privileges for isolated accounts.\n\n## Key Concepts\n- rbash restrictions\n- SSH key-based auth\n- NOPASSWD sudo rules\n\n## Code Example\n```bash\n# basic provisioning (illustrative)\nuseradd -m audit\nchsh -s /bin/rbash audit\nmkdir -p /home/audit/.ssh\nchmod 700 /home/audit/.ssh\n# put key in authorized_keys\nchmod 600 /home/audit/.ssh/authorized_keys\necho 'audit ALL=(ALL) NOPASSWD: /bin/systemctl restart auditd' > /etc/sudoers.d/audit\n```\n\n## Follow-up Questions\n- How would you audit sudo usage for this user? \n- How would you extend to multiple restricted users with per-command whitelists?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","IBM"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T09:43:07.881Z","createdAt":"2026-01-14T09:43:07.881Z"},{"id":"q-1771","question":"On a RHEL 8 server, you must host a small static site with Nginx, ensure it starts on boot, expose only port 80, and serve content from /var/www/html with correct SELinux context. Provide exact commands to configure Nginx, firewall, and SELinux so SELinux stays enforcing?","answer":"Install nginx and set up a static site, start on boot, expose port 80, and serve /var/www/html with proper SELinux context. Run: dnf install -y nginx; mkdir -p /var/www/html; echo 'Hello' > /var/www/h","explanation":"## Why This Is Asked\nTests practical understanding of systemd service management, firewall configuration, and SELinux contexts for hosting static content on RHEL.\n\n## Key Concepts\n- systemd service enable/start\n- firewall-cmd for port 80\n- SELinux labeling with httpd_sys_content_t\n- restorecon and semanage usage\n\n## Code Example\n```bash\n# install\nsudo dnf install -y nginx\n# firewall\nsudo firewall-cmd --permanent --zone=public --add-service=http\nsudo firewall-cmd --reload\n# SELinux\nsudo semanage fcontext -a -t httpd_sys_content_t '/var/www/html(/.*)?'\nsudo restorecon -R -v /var/www/html\n```\n\n```bash\n# enable and start nginx\nsudo systemctl enable --now nginx\n```\n\n## Follow-up Questions\n- How would you serve content from a subpath like /var/www/html/site?\n- How would you adjust SELinux booleans if you later switch to CGI scripts?","diagram":"flowchart TD\n  A[Start] --> B[Install nginx]\n  B --> C[Configure firewall]\n  C --> D[Set SELinux context]\n  D --> E[Enable and start nginx]\n  E --> F[Validate with curl]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Snap","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T10:34:55.907Z","createdAt":"2026-01-14T10:34:55.909Z"},{"id":"q-1804","question":"On a Red Hat-based host, a Python web app writes to /srv/app/data and /var/log/app. After a system update, SELinux denies these writes. Outline an operational plan to diagnose and restore write access without disabling SELinux, including commands for audit review, context restoration, and persistent policy adjustments?","answer":"1) Inspect AVCs: ausearch -m avc -ts today | aureport -a -i; 2) confirm file contexts: ls -Z /srv/app /var/log/app; 3) set persistent contexts: semanage fcontext -a -t httpd_sys_rw_content_t '/srv/app","explanation":"## Why This Is Asked\nDemonstrates practical SELinux troubleshooting, policy tuning, and safe persistence without disabling security.\n\n## Key Concepts\n- SELinux types and booleans\n- semanage fcontext\n- restorecon\n- audit2why/ausearch\n- persistent policy changes\n\n## Code Example\n```bash\nausearch -m avc -ts today | aureport -a -i\nsemanage fcontext -a -t httpd_sys_rw_content_t '/srv/app(/.*)?'\nrestorecon -R /srv/app\n```\n\n## Follow-up Questions\n- How to roll back if a boolean causes regressions?\n- How to isolate contexts per app with dedicated policy modules?","diagram":"flowchart TD\n  A[SELinux Denial] --> B[Audit Review]\n  B --> C[Update File Contexts]\n  C --> D[Apply Persistently]\n  D --> E[Test Write]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Meta","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T11:39:38.392Z","createdAt":"2026-01-14T11:39:38.392Z"},{"id":"q-1982","question":"On a Linux host, create a project share at /srv/project where Alice can read/write and Bob can read only, with all others denied. Use POSIX permissions plus ACLs so new files created by Alice inherit Bob's read access. Provide exact commands to: 1) create the group, 2) add users, 3) set up the directory with setgid, 4) apply ACLs (explicit for Bob and default for new files), 5) verify with tests?","answer":"sudo groupadd proj\nsudo usermod -aG proj alice\nsudo mkdir -p /srv/project\nsudo chown root:proj /srv/project\nsudo chmod 2770 /srv/project\nsudo setfacl -m u:bob:rx /srv/project\nsudo setfacl -m d:u:bob:r","explanation":"## Why This Is Asked\nTests practical ACL usage and inheritance: combining POSIX permissions, setgid directories, and ACLs for multi-user access. It validates understanding of inheritance for new files and robust verification from non-privileged contexts.\n\n## Key Concepts\n- POSIX permissions and groups\n- Setgid directory inheritance\n- ACLs and default ACLs\n- Testing cross-user access\n- File vs directory permissions\n\n## Code Example\n```bash\n# Example verification (shown in answer above for clarity)\n```\n\n## Follow-up Questions\n- How would you audit and adjust ACLs if Alice creates a deep subdirectory?\n- How would you apply these permissions across a separate mount or NFS share?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Oracle","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T19:36:54.465Z","createdAt":"2026-01-14T19:36:54.466Z"},{"id":"q-2225","question":"On a RHEL 9 server running Apache httpd hosting a custom PHP app, uploads are saved to /srv/app/uploads owned by webuser with SELinux type httpd_sys_content_t. After a denied upload, design and implement a minimal SELinux policy module that lets httpd_t write to that directory and create new files, without broad permissive mode. Include exact commands and testing steps?","answer":"Identify the AVC with ausearch, generate a targeted module with audit2allow, install the module, and adjust file context. Commands: ausearch -m AVC -ts today | audit2allow -M httpd_upload; semodule -i","explanation":"## Why This Is Asked\nTests SELinux troubleshooting and policy crafting in a realistic app deployment.\n\n## Key Concepts\n- SELinux domains and booleans\n- AVC denials and audit2allow workflow\n- Persistent labeling with semanage and restorecon\n- Safe, least-privilege policy design\n\n## Code Example\n```bash\nausearch -m AVC -ts today\naudit2allow -M httpd_upload\nsemodule -i httpd_upload.pp\nsemanage fcontext -a -e '/srv/app/uploads'\nrestorecon -R /srv/app/uploads\n```\n\n## Follow-up Questions\n- How would you test for regressions across relabeled files?\n- How would you roll back the policy if it caused unintended access?","diagram":null,"difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T08:40:50.907Z","createdAt":"2026-01-15T08:40:50.909Z"},{"id":"q-2308","question":"On a fresh RHEL8 host with an unallocated disk at /dev/sdb, describe and implement the steps to (1) create a PV, (2) VG named vg_data, (3) LV named data of 900G, (4) format with XFS, (5) mount at /data with auto-mount in /etc/fstab, and (6) set ownership to user app and proper SELinux context. Provide exact commands?","answer":"pvcreate /dev/sdb; vgcreate vg_data /dev/sdb; lvcreate -L 900G -n data vg_data; mkfs.xfs /dev/vg_data/data; mkdir -p /data; mount /dev/vg_data/data /data; echo '/dev/vg_data/data /data xfs defaults 0 ","explanation":"## Why This Is Asked\n\nTests storage provisioning basics common in RHCSA tasks.\n\n## Key Concepts\n\n- PV/VG/LV lifecycle\n- XFS formatting\n- /etc/fstab persistence\n- SELinux context when mounting new data\n\n## Code Example\n\n```bash\npvcreate /dev/sdb\nvgcreate vg_data /dev/sdb\nlvcreate -L 900G -n data vg_data\nmkfs.xfs /dev/vg_data/data\nmkdir -p /data\nmount /dev/vg_data/data /data\necho '/dev/vg_data/data /data xfs defaults 0 0' >> /etc/fstab\n```\n\n## Follow-up Questions\n\n- How would you extend this to add a separate metadata LV?\n- How would you verify accessibility after reboot?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Hashicorp","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T11:37:43.926Z","createdAt":"2026-01-15T11:37:43.927Z"},{"id":"q-2357","question":"Scenario: You manage a RHEL host where /var/www and /etc live on an LVM-managed XFS volume. Implement a DR restore pipeline: daily incremental backups via rsync to an offsite server, preserving SELinux contexts and ACLs, with integrity verification. Describe the exact commands, systemd timer/unit setup, and restore steps to recover to the latest backup within 60 minutes?","answer":"Back up /etc and /var/www to an offsite server with rsync: rsync -aAXv --delete --link-dest=/backup/prev /etc /var/www host:/backup/daily-$(date +%F). Verify with sha256sums. Restore by rsync -aAXv fr","explanation":"## Why This Is Asked\nTests practical DR planning, SELinux/ACL preservation, incremental rsync backups, and systemd automation—core RHCSA skills for real-world repair.\n\n## Key Concepts\n- DR planning with RPO/RTO\n- rsync options -aAX, --link-dest, --delete\n- SELinux contexts preservation and restorecon\n- ACLs and extended attributes\n- systemd-timers and unit files\n- integrity verification with checksums\n\n## Code Example\n```bash\n# example restore workflow (dry-run)\nrsync -aAXv --dry-run /backup/latest/ /etc/\n```\n\n```bash\n# systemd timer example (simplified)\n[Unit]\nDescription=Daily DR backup\n\n[Timer]\nOnCalendar=daily\nPersistent=true\n\n[Service]\nType=oneshot\nExecStart=/usr/local/bin/run-dr-backup.sh\n```\n\n```bash\n# restore script outline\nrsync -aAXv --delete /backup/latest/ /etc/\nrsync -aAXv --delete /backup/latest/ /var/www/\nrestorecon -R /etc /var/www\nsystemctl restart httpd nginx\n```\n\n## Follow-up Questions\n- How would you handle offsite encryption and key rotation?\n- How would you test DR recovery with minimal downtime?","diagram":null,"difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T14:43:24.786Z","createdAt":"2026-01-15T14:43:24.786Z"},{"id":"q-2415","question":"On a fresh RHEL 9 server, implement a small utility that prints the host name and current date, running it as a non-login user via systemd and logging to a dedicated file with rotation. Provide exact commands for user creation, script, service, and log rotation?","answer":"Create a restricted user 'hello' with no login, place a script at /opt/hello-day/print.sh that appends \"Hello from <date> on <hostname>\" to /var/log/hello-day.log, set proper permissions, and configur","explanation":"## Why This Is Asked\nTests core RHCSA beginner skills: user creation and permissions, small script, systemd service basics, log management with rotation, and boot-time enablement.\n\n## Key Concepts\n- Systemd service fundamentals\n- Non-login user handling\n- File permissions and ownership\n- Log rotation basics\n- Service verification\n\n## Code Example\n```bash\n# Create user\nsudo useradd -r -s /sbin/nologin -d /var/empty hello\n# Prepare script\nsudo mkdir -p /opt/hello-day\nsudo tee /opt/hello-day/print.sh <<'SH'\n#!/bin/bash\necho \"Hello from $(date) on $(hostname)\" >> /var/log/hello-day.log\nSH\nsudo chmod +x /opt/hello-day/print.sh\nsudo mkdir -p /var/log/hello-day\nsudo chown hello:hello /var/log/hello-day.log\n# systemd service\nsudo tee /etc/systemd/system/hello-day.service <<'SERVICE'\n[Unit]\nDescription=Hello Day Service\n[Service]\nType=oneshot\nUser=hello\nExecStart=/opt/hello-day/print.sh\nSERVICE\nsudo systemctl daemon-reload\nsudo systemctl enable --now hello-day.service\n# logrotate\nsudo tee /etc/logrotate.d/hello-day <<'LOG'\n/var/log/hello-day.log {\n  daily\n  rotate 7\n  missingok\n  notifempty\n  create 0640 hello hello\n  copytruncate\n}\nLOG\n```\n\n## Follow-up Questions\n- How would you adapt this for a daemon vs. oneshot?\n- How would you ensure idempotence if the script could run multiple times?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T17:02:13.966Z","createdAt":"2026-01-15T17:02:13.966Z"},{"id":"q-2457","question":"On a Linux host, a Node.js web app runs in a container and connects to Postgres on localhost:5432. After reboot, the web app sometimes starts before Postgres is ready, causing startup failures. Propose a concrete, production-ready systemd-based solution: (1) implement a db-wait.service that blocks until pg_isready reports healthy, (2) make web-app.service depend on and After=db-wait.service, (3) add a lightweight container readiness check for the app, and (4) describe how you would test this reliably?","answer":"Create db-wait.service that blocks until pg_isready reports healthy: ExecStart=/bin/bash -lc 'until pg_isready -h localhost -p 5432; do sleep 1; done'. Web app unit: Wants=db-wait.service After=db-wai","explanation":"## Why This Is Asked\n\nTests the candidate's ability to coordinate startup order between services using systemd, plus practical health/readiness checks to prevent cascading failures.\n\n## Key Concepts\n\n- systemd unit dependencies (After, Wants, Requires)\n- pg_isready and database readiness signals\n- container health checks and readiness probes\n- startup ordering and failure isolation\n- practical testing of startup sequencing\n\n## Code Example\n\n```javascript\n# db-wait.service\n[Unit]\nDescription=Wait for PostgreSQL to be ready\n\n[Service]\nType=oneshot\nExecStart=/bin/bash -lc 'until pg_isready -h localhost -p 5432; do sleep 1; done'\nRemainAfterExit=yes\n```\n\n```javascript\n# web-app.service\n[Unit]\nDescription=Web App\nWants=db-wait.service\nAfter=db-wait.service\n\n[Service]\nRestart=on-failure\nExecStart=/usr/bin/node /opt/app/server.js\n```\n\n```javascript\n# Dockerfile HEALTHCHECK\nHEALTHCHECK --interval=30s --timeout=5s --start-period=5s --retries=3 CMD curl -f http://localhost:3000/health || exit 1\n```\n\n## Follow-up Questions\n\n- How would you adapt if Postgres runs in a separate container?\n- How would you handle timeouts and cascading failures?","diagram":null,"difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Discord"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T18:59:12.556Z","createdAt":"2026-01-15T18:59:12.556Z"},{"id":"q-2479","question":"On a RHEL 9 host, a production service writes logs to /var/app/logs with 0777 perms. You must relocate logs to a dedicated 1 TB LVM-backed XFS volume mounted at /var/app/logs with no downtime, ensure SELinux context, and configure logrotate to compress weekly. Provide exact steps including LV creation, filesystem, fstab, SELinux relabeling, and logrotate config?","answer":"Configure a 1 TB LVM-backed XFS volume mounted at /var/app/logs with zero downtime: create LV, format XFS, mount, update fstab, rsync data, switch mount, relabel SELinux contexts (semanage fcontext -a","explanation":"## Why This Is Asked\nTests storage disruption avoidance, LVM, SELinux contexts, and log management in a realistic migration.\n\n## Key Concepts\n- LVM provisioning and filesystem selection\n- Data migration with minimal downtime\n- SELinux file contexts and relabeling\n- logrotate configuration and permissions\n- FSTAB mounting and idempotent changes\n\n## Code Example\n```bash\n# example: fstab entry\n/dev/mapper/applog-vg/applog /var/app/logs xfs defaults 0 0\n```\n\n```bash\n# data migration\nrsync -aP /var/app/logs/ /mnt/applog/ \n```\n\n## Follow-up Questions\n- How to rollback if migration fails?\n- How would you handle concurrent writes during cutover?\n","diagram":"flowchart TD\n  A[Start] --> B[Create LV and format]\n  B --> C[Mount at /var/app/logs]\n  C --> D[Update /etc/fstab]\n  D --> E[Migrate logs with rsync]\n  E --> F[Relabel SELinux contexts]\n  F --> G[Configure logrotate]\n  G --> H[Validate with test logs]\n  H --> I[End]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Netflix","PayPal","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-15T19:41:12.926Z","createdAt":"2026-01-15T19:41:12.926Z"},{"id":"q-2557","question":"On a fresh RHEL 9 host, configure firewalld to allow SSH only from 203.0.113.0/24 and drop SSH from all other sources. Provide exact permanent commands, reload, and verification steps?","answer":"Enable firewalld and restrict SSH to 203.0.113.0/24. Exact commands: systemctl enable --now firewalld; SUB=203.0.113.0/24; firewall-cmd --permanent --zone=public --add-rich-rule=\"rule family='ipv4' source address='$SUB' port port='22' protocol='tcp' accept\"; firewall-cmd --permanent --zone=public --add-rich-rule=\"rule family='ipv4' port port='22' protocol='tcp' drop\"; firewall-cmd --reload; firewall-cmd --list-all --zone=public","explanation":"## Why This Is Asked\nTests practical firewall configuration and understanding of permanent vs runtime rules, plus idempotence.\n\n## Key Concepts\n- firewalld rich rules\n- permanent vs runtime configuration\n- rule ordering and specificity\n\n## Code Example\n```\nsystemctl enable --now firewalld\nSUB=203.0.113.0/24\nfirewall-cmd --permanent --zone=public --add-rich-rule=\"rule family='ipv4' source address='$SUB' port port='22' protocol='tcp' accept\"\nfirewall-cmd --permanent --zone=public --add-rich-rule=\"rule family='ipv4' port port='22' protocol='tcp' drop\"\nfirewall-cmd --reload\nfirewall-cmd --list-all\n```","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Hashicorp","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T05:26:09.742Z","createdAt":"2026-01-15T22:46:09.878Z"},{"id":"q-2637","question":"On a fresh RHEL 9 host, deploy a tiny Python HTTP health server that binds to 127.0.0.1:9090 and returns 200 OK for GET /health when the file /tmp/healthy exists; otherwise 503. Run this as a non-root systemd service with a dedicated unit file, a startup script, and a log file rotated by logrotate. Provide exact commands to create the non-login user, script, systemd unit, logrotate config, and enable the service. Ensure idempotence?","answer":"Create user healthchk (nologin). Place script at /opt/healthcheck/health_server.py that runs a tiny HTTP server on 127.0.0.1:9090 and returns 200 for /health when /tmp/healthy exists, else 503. System","explanation":"Why This Is Asked\nTests systemd service for non-root processes, health-check patterns, and log management.\n\nKey Concepts\n- systemd unit files (User, WorkingDirectory, ExecStart, StandardOutput)\n- Python HTTP server basics\n- idempotent filesystem setup and permissions\n- logrotate configuration for a dedicated log path\n\nCode Example\n```python\n# health_server.py\nimport http.server, socketserver, os\nclass H(http.server.BaseHTTPRequestHandler):\n  def do_GET(self):\n    if self.path == '/health' and os.path.exists('/tmp/healthy'):\n      self.send_response(200); self.end_headers(); self.wfile.write(b'OK')\n    else:\n      self.send_response(503); self.end_headers(); self.wfile.write(b' unhealthy ')\n\nif __name__ == '__main__':\n  with socketserver.TCPServer(('127.0.0.1',9090), H) as httpd:\n    httpd.serve_forever()\n```\n\nFollow-up Questions\n- How would you monitor this service and alert on failed health checks?\n- How would you harden the service against file tampering?","diagram":"flowchart TD\n  A[Create healthchk user] --> B[Write health_server.py]\n  B --> C[Systemd unit setup]\n  C --> D[Configure logrotate]\n  D --> E[Enable & start service]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Hashicorp","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T04:18:13.926Z","createdAt":"2026-01-16T04:18:13.927Z"},{"id":"q-2647","question":"On a fresh RHEL 9 server, create a non-root user named devops and configure passwordless sudo for only two commands: /bin/systemctl restart httpd and /usr/bin/journalctl -xe. Restrict SSH login for this user to localhost by updating sshd_config. Provide exact commands and file contents to accomplish this?","answer":"Create user devops with a home and bash: useradd -m -s /bin/bash devops; passwd devops. Add sudoers: echo 'devops ALL=(ALL) NOPASSWD: /bin/systemctl restart httpd, /usr/bin/journalctl -xe' > /etc/sudo","explanation":"## Why This Is Asked\nTests practical admin tasks: user provisioning, granular sudo rights, and SSH restrictions, all common on entry-level RHCSA tasks.\n\n## Key Concepts\n- User management with useradd and passwd\n- Fine-grained sudoers with /etc/sudoers.d\n- SSH access control with AllowUsers\n- Service and log viewing with systemctl and journalctl\n\n## Code Example\n```javascript\n# Commands to implement (illustrative, not executed here)\n```\n\n## Follow-up Questions\n- How would you log the sudo usage for this user?\n- How would you extend to allow additional commands safely?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T05:34:54.469Z","createdAt":"2026-01-16T05:34:54.469Z"},{"id":"q-2756","question":"Design and implement an offline, local repository patching workflow for 20 RHEL 9 servers to achieve zero downtime. Outline mirroring steps with reposync, GPG signing, local repo config, a rolling update procedure (kernel first, then user-space), reboot strategy, rollback via dnf history, and auditing. Provide exact commands and a deployment checklist?","answer":"Adopt a rolling patching strategy: mirror updates with reposync to a local repo, sign with the RH key, and configure hosts to use it. Stage patches on a canary group (5 hosts); update kernel first, re","explanation":"## Why This Is Asked\nTests ability to design offline patching pipelines, safety rails, and rollback in production.\n\n## Key Concepts\n- Offline repo mirroring with reposync\n- GPG verification and key management\n- Canary/rolling deployments and batch sizing\n- Kernel-first update strategy and reboot handling\n- Rollback via dnf history; versionlocking\n- Auditing with dnf logs and system audit trails\n\n## Code Example\n```bash\n# Mirror setup (example)\nreposync --repoid=rhel9-server-repo --download-path=/var/www/html/repos/rhel9\ncreaterepo /var/www/html/repos/rhel9/os\n# Host config\ncat > /etc/yum.repos.d/local.repo <<'EOF'\n[Local-RHEL9]\nname=Local RHEL9 Updates\nbaseurl=file:///var/www/html/repos/rhel9/os\nenabled=1\ngpgcheck=1\ngpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release\nEOF\n\ndnf makecache\n```\n\n## Follow-up Questions\n- How would you handle a host that cannot reboot during patching?\n- What monitoring would you add to verify patch integrity and rollback readiness?","diagram":"flowchart TD\n  A[Mirror updates to local repo] --> B[Configure hosts to use local repo]\n  B --> C[Canary patch (5 hosts)]\n  C --> D[Kernel first, reboot, verify]\n  D --> E[Batch patch rest]\n  E --> F[Audit logs; ready for rollback]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","OpenAI","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T10:43:27.554Z","createdAt":"2026-01-16T10:43:27.554Z"},{"id":"q-2838","question":"On a RHEL 9 host exposed to the internet, harden SSH with key-based login only, disable root login, enforce 2FA via pam_google_authenticator for SSH, and configure auditd to log authentication attempts with a daily report; provide exact commands and config snippets to implement this with minimal downtime?","answer":"Set SSH to Protocol 2, PubkeyAuthentication yes, PasswordAuthentication no, PermitRootLogin no, and ChallengeResponseAuthentication yes. Enforce 2FA with PAM using pam_google_authenticator.so and per-","explanation":"## Why This Is Asked\nTests practical hardening of a live system with minimal downtime and verifiable controls.\n\n## Key Concepts\n- SSH hardening: protocol, authentication methods, root login.\n- 2FA integration with PAM.\n- Per-user MFA provisioning.\n- Auditd visibility for authentication.\n- Automated reporting and scheduling.\n\n## Code Example\n```bash\n# /etc/ssh/sshd_config (snip)\nProtocol 2\nPubkeyAuthentication yes\nPasswordAuthentication no\nPermitRootLogin no\nChallengeResponseAuthentication yes\n\n# /etc/pam.d/sshd (snip)\nauth required pam_google_authenticator.so\n```\n\n```bash\n# Minimal audit rules (illustrative)\n-w /var/log/secure -p wa -k ssh-auth\n-a always,exit -F arch=b64 -S execve -k login\n```\n\n## Follow-up Questions\n- How would you rotate and retrain MFA tokens without downtime?\n- How do you verify no authentication bypass occurred after changes?","diagram":"flowchart TD\nA[SSH Hardening] --> B[SSHD Config]\nA --> C[2FA PAM]\nA --> D[Audit Rules]\nD --> E[Reporting]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","LinkedIn","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-16T14:32:39.461Z","createdAt":"2026-01-16T14:32:39.464Z"},{"id":"q-3053","question":"On a fresh RHEL 9 server, implement a minimal nftables-based firewall that permits SSH only from 192.168.1.0/24, allows loopback, and drops all other inbound traffic. Make the rules persistent across reboots and verify. Provide exact commands to install nftables, create /etc/nftables.conf with the rules, enable the nftables service, and test connectivity from an allowed host and a disallowed host?","answer":"Set up a minimal nftables firewall on a fresh RHEL 9 server that allows SSH only from 192.168.1.0/24, permits loopback, and drops all other inbound traffic; persist rules across reboots and verify functionality.","explanation":"## Why This Is Asked\nTests practical firewall configuration skills on RHEL 9, requiring precise rule creation, persistence, and verification—essential for enterprise security administration.\n\n## Key Concepts\n- nftables ruleset syntax and packet flow\n- Rule persistence via /etc/nftables.conf\n- Service management with systemctl\n- Connectivity testing from allowed vs. disallowed sources\n- Verification using nft list ruleset\n\n## Code Example\n```bash\n#!/usr/sbin/nft -f\nflush ruleset\ntable inet filter {\n  chain input {\n    type filter hook input priority 0; policy drop;\n    iifname \"lo\" accept\n    ip saddr 192.168.1.0/24 tcp dport 22 accept\n  }\n  chain forward {\n    type filter hook forward priority 0; policy drop;\n  }\n  chain output {\n    type filter hook output priority 0; policy accept;\n  }\n}\n```\n\n## Implementation Steps\n```bash\n# Install nftables\ndnf install -y nftables\n\n# Create ruleset\ncat > /etc/nftables.conf << 'EOF'\n#!/usr/sbin/nft -f\nflush ruleset\ntable inet filter {\n  chain input {\n    type filter hook input priority 0; policy drop;\n    iifname \"lo\" accept\n    ip saddr 192.168.1.0/24 tcp dport 22 accept\n  }\n  chain forward {\n    type filter hook forward priority 0; policy drop;\n  }\n  chain output {\n    type filter hook output priority 0; policy accept;\n  }\n}\nEOF\n\n# Enable and start services\nsystemctl enable nftables\nsystemctl start nftables\nsystemctl status nftables\n\n# Verify rules\nnft list ruleset\n\n# Test connectivity (from allowed host)\nssh user@server-ip\n\n# Test connectivity (from disallowed host)\nssh user@server-ip  # Should timeout/refuse\n```","diagram":"flowchart TD\n  A[Start] --> B[Create /etc/nftables.conf]\n  B --> C[Enable nftables service]\n  C --> D[Test from allowed host]\n  D --> E[Test from disallowed host]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Microsoft","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T05:19:44.665Z","createdAt":"2026-01-16T22:45:57.038Z"},{"id":"q-3130","question":"You have a running RHEL 9 server hosting an Apache site. The DocumentRoot /var/www/html must move to a dedicated XFS LV mounted at /srv/www, with zero downtime, preserving SELinux contexts and without changing client URLs. Provide exact commands, config changes, and rollback steps to perform the migration safely?","answer":"Create a new XFS LV and mount it at /mnt/www; rsync -aAX /var/www/html/ /mnt/www/; bind mount to the original path: mount --bind /mnt/www /var/www/html; persist with fstab: /dev/webvg/wwwlv /mnt/www x","explanation":"## Why This Is Asked\nNew angle: live data migration using bind mounts to avoid downtime while relocating content to a dedicated LV. Tests LVM provisioning, bind mounts, SELinux labeling, and httpd restart behavior.\n\n## Key Concepts\n- LVM/XFS provisioning and mounting\n- rsync for a-safe data copy\n- bind mounts and fstab persistence\n- SELinux labeling with restorecon\n- Apache DocumentRoot changes with minimal disruption\n\n## Code Example\n```bash\nmount --bind /mnt/www /var/www/html\n```\n\n## Follow-up Questions\n- How would you verify data integrity post-migration?\n- How would you handle future certificate rotations without downtime?","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T04:11:56.028Z","createdAt":"2026-01-17T04:11:56.028Z"},{"id":"q-3216","question":"Devise a three-tenant container deployment on a single RHEL 9 host (advanced RHCSA). Each tenant runs in its own container using non-root user namespaces, isolated network namespace, and defined CPU and memory quotas. Implement per-tenant logging and logrotate, and address SELinux considerations. Provide exact commands and files: UID/GID mappings, subuid/subgid setup, Podman usage, systemd unit files, and a minimal HTTP server container example?","answer":"Plan three tenants (tenant1-tenant3) with non-root users; map UID/GID ranges via /etc/subuid and /etc/subgid; run containers with Podman in user namespaces; create systemd services per tenant with CPU","explanation":"## Why This Is Asked\nTests advanced RHCSA practices: practical isolation using user namespaces, per-tenant quotas, secure container runtimes, and per-tenant logging.\n\n## Key Concepts\n- User namespaces and subuid/subgid mappings\n- Podman/systemd integration with quotas\n- Network namespace isolation per tenant\n- SELinux labeling for containers\n- Per-tenant logging and logrotate\n\n## Code Example\n```ini\n# sample systemd unit for a tenant container (Tenant1)\n[Unit]\nDescription=Tenant1 web container\n[Service]\nExecStart=/usr/bin/podman run --name tenant1 --rm --network=tenant1_net --memory=512M --cpu-quota=25000 --cpu-period=100000\nRestart=on-failure\n```\n\n## Follow-up Questions\n- How would you scale to more tenants while maintaining isolation?\n- How would you ensure persistent storage across container recreations?\n- What monitoring would you add to observe per-tenant resource usage?","diagram":"flowchart TD\n  A[User Namespaces] --> B[Podman Containers]\n  B --> C[Systemd Services]\n  C --> D[Resource Quotas]\n  A --> E[Network Isolation]\n  F[Logs per Tenant] --> G[Logrotate]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T07:29:09.590Z","createdAt":"2026-01-17T07:29:09.590Z"},{"id":"q-3303","question":"On a RHEL 9 host behind Nginx serving a critical API, describe a zero-downtime upgrade path for a Python Flask app using blue/green deployment. Provide exact steps and commands to prepare two virtualenvs, two systemd service units, traffic switch with Nginx, health checks, and rollback plan, including SELinux considerations and verifying in-flight requests are not dropped?","answer":"Use blue/green deployment: two virtualenvs (/opt/api-blue, /opt/api-green) and two systemd units api-blue.service, api-green.service each on distinct ports. Deploy to green, run health checks (curl -f","explanation":"## Why This Is Asked\n\nTests ability to orchestrate zero-downtime upgrades in a production-like RHCSA setting.\n\n## Key Concepts\n\n- Blue/green deployment\n- systemd service management\n- Nginx upstream switching\n- Health checks and drift detection\n- Rollback safety and SELinux considerations\n\n## Code Example\n\n```bash\n# Example setup (illustrative)\nmkdir -p /opt/api-blue /opt/api-green\npython3 -m venv /opt/api-blue\npython3 -m venv /opt/api-green\n# install deps and configure services... \n```\n\n## Follow-up Questions\n\n- How would you automate green health checks and promote/demote automatically?\n- How would you preserve session continuity for in-flight requests during the switch?","diagram":"flowchart TD\n  A[Blue API] --> B[Green API]\n  B --> C{Health OK}\n  C -- Yes --> D[Switch Nginx Upstream]\n  C -- No --> E[Rollback to Blue]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T10:39:50.586Z","createdAt":"2026-01-17T10:39:50.586Z"},{"id":"q-3433","question":"On a fresh RHEL 9 server, set up a minimal local Yum repository mirror to host a subset of packages. Create a non-privileged user reposync, configure httpd to serve /var/www/html/repos, set up reposync -p /var/www/html/repos -r base -n to populate the mirror, and automate with a systemd service and daily timer. Enable GPG verification and log rotation. Provide exact commands for user creation, systemd unit, timer, httpd, and logrotate?","answer":"Create user reposync; install httpd and yum-utils; configure /var/www/html/repos as web root; run reposync -p /var/www/html/repos -r base -n via a systemd service, triggered by a daily timer; import and configure GPG keys for verification; set up logrotate for reposync logs.","explanation":"## Why This Is Asked\nTests the ability to set up a local, secure package mirror with an unprivileged worker, automated scheduling, proper web serving, and log maintenance—core RHCSA skills.\n\n## Key Concepts\n- reposync usage and local mirror layout\n- systemd service and timer for automation\n- httpd configuration and permissions\n- GPG verification and key management\n- logrotate for auditability and disk health\n\n## Code Example\n```bash\n# Example systemd service (reposync.service)\n[Unit]\nDescription=Populate local Yum mirror\nAfter=network.target\n\n[Service]\nType=oneshot\nUser=reposync\nExecStart=/usr/bin/reposync -p /var/www/html/repos -r base -n\nStandardOutput=journal\nStandardError=journal\n```\n\n```bash\n# Example systemd timer (reposync.timer)\n[Unit]\nDescription=Daily reposync for local mirror\nRequires=reposync.service\n\n[Timer]\nOnCalendar=daily\nPersistent=true\n\n[Install]\nWantedBy=timers.target\n```\n\n```bash\n# Example httpd config snippet\nAlias /repos /var/www/html/repos\n<Directory /var/www/html/repos>\n    Options Indexes FollowSymLinks\n    AllowOverride None\n    Require all granted\n    EnableSendfile on\n</Directory>\n```\n\n## Follow-up Questions\n- How would you validate the mirror serves content correctly?\n- How would you add a second repo and handle multiple architectures?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","NVIDIA","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T04:02:01.775Z","createdAt":"2026-01-17T16:31:59.975Z"},{"id":"q-3462","question":"Scenario: A prod RHEL 9 fleet generates app logs at /var/log/myapp; implement a centralized TLS-enabled rsyslog forwarder to log-ops.example.local:6514. Use mutual TLS with a private CA, configure per-host queues to tolerate outages, ensure proper SELinux context, and update firewalld. Provide exact rsyslog.conf fragments, certificate paths, and verification steps?","answer":"Complete implementation:\n\n**1. Certificate Setup (on CA host):**\n```bash\n# Create private CA\nmkdir -p /etc/rsyslog-ca/{certs,private}\nopenssl genrsa -out /etc/rsyslog-ca/private/ca.key 4096\nopenssl req -new -x509 -days 365 -key /etc/rsyslog-ca/private/ca.key \\\n  -out /etc/rsyslog-ca/certs/ca.crt -subj \"/CN=log-ca.example.local\"\n\n# Issue server certificate\nopenssl genrsa -out /etc/rsyslog-ca/private/log-server.key 2048\nopenssl req -new -key /etc/rsyslog-ca/private/log-server.key \\\n  -out /etc/rsyslog-ca/server.csr -subj \"/CN=log-ops.example.local\"\nopenssl x509 -req -in /etc/rsyslog-ca/server.csr \\\n  -CA /etc/rsyslog-ca/certs/ca.crt -CAkey /etc/rsyslog-ca/private/ca.key \\\n  -CAcreateserial -out /etc/rsyslog-ca/certs/log-server.crt -days 365\n\n# Issue client certificates (repeat per host)\nopenssl genrsa -out client01.key 2048\nopenssl req -new -key client01.key -out client01.csr \\\n  -subj \"/CN=$(hostname -f)\"\nopenssl x509 -req -in client01.csr \\\n  -CA /etc/rsyslog-ca/certs/ca.crt -CAkey /etc/rsyslog-ca/private/ca.key \\\n  -CAcreateserial -out client01.crt -days 365\n```\n\n**2. Server Configuration (log-ops.example.local):**\n```ini\n# /etc/rsyslog.d/tls-server.conf\nmodule(load=\"imptcp\")\nmodule(load=\"gtls\")\n\n# TLS settings\nDefaultNetstreamDriver=\"gtls\"\nGTLSCacheFile=\"/var/cache/rsyslog/gtls-cache\"\nGTLSKeyFile=\"/etc/pki/tls/private/log-server.key\"\nGTLSACertificate=\"/etc/pki/tls/certs/log-server.crt\"\nGTLSADirectional(\"server\")\n\n# TCP listener with mutual TLS\ninput(type=\"imptcp\" port=\"6514\" ruleset=\"RemoteLogs\" \\\n  StreamDriver=\"gtls\" StreamDriverMode=\"1\" StreamDriverAuthMode=\"x509/name\" \\\n  PermittedPeer=\"*.example.local\")\n\nruleset(name=\"RemoteLogs\") {\n  action(type=\"omfile\" file=\"/var/log/remote/%HOSTNAME%/myapp.log\" \\\n    dirCreateMode=\"0755\" fileCreateMode=\"0644\")\n}\n```\n\n**3. Client Configuration (each production host):**\n```ini\n# /etc/rsyslog.d/tls-client.conf\nmodule(load=\"omfwd\")\n\n# Per-host queue for reliability\nruleset(name=\"ForwardToOps\") {\n  action(type=\"omfile\" file=\"/var/log/myapp.log\" \\\n    queue.filename=\"myapp_queue\" queue.maxdiskspace=\"100m\" \\\n    queue.saveonshutdown=\"on\" queue.type=\"LinkedList\")\n  action(type=\"omfwd\" target=\"log-ops.example.local\" port=\"6514\" \\\n    protocol=\"tcp\" StreamDriver=\"gtls\" StreamDriverMode=\"1\" \\\n    StreamDriverAuthMode=\"x509/name\" \\\n    TLSCAFile=\"/etc/pki/tls/certs/ca.crt\" \\\n    TLSCertFile=\"/etc/pki/tls/certs/$(hostname -f).crt\" \\\n    TLSKeyFile=\"/etc/pki/tls/private/$(hostname -f).key\" \\\n    RebindInterval=\"30\" queue.filename=\"forward_queue\" \\\n    queue.maxdiskspace=\"50m\" queue.saveonshutdown=\"on\")\n}\n\n# Forward application logs\nif $programname == 'myapp' then {\n  stop\n}\nif $msg contains 'myapp' then {\n  call ForwardToOps\n}\n```\n\n**4. SELinux and Firewall:**\n```bash\n# Set proper contexts\nsemanage fcontext -a -t cert_t \"/etc/pki/tls/certs/.*\\.crt\"\nsemanage fcontext -a -t cert_t \"/etc/pki/tls/private/.*\\.key\"\nrestorecon -Rv /etc/pki/tls/\nsemanage fcontext -a -t var_log_t \"/var/log/remote(/.*)?\"\nrestorecon -Rv /var/log/remote/\n\n# Allow rsyslog network connections\nsetsebool -P rsyslog_can_sendmk 1\n\n# Firewall rules\nfirewall-cmd --permanent --add-port=6514/tcp\nfirewall-cmd --reload\n```\n\n**5. Verification:**\n```bash\n# Test TLS connection\nopenssl s_client -connect log-ops.example.local:6514 -CAfile /etc/pki/tls/certs/ca.crt \\\n  -cert /etc/pki/tls/certs/$(hostname -f).crt -key /etc/pki/tls/private/$(hostname -f).key\n\n# Check queue status\nlogger -p local0.info \"Test log from $(hostname)\"\nsleep 2\nrsyslogd -N1  # syntax check\ncat /var/log/rsyslog-stats | grep queue\n```","explanation":"## Why This Is Asked\nTests practical enterprise logging architecture requiring TLS security, certificate management, queue reliability, SELinux integration, and network configuration—core RHCSA skills.\n\n## Key Concepts\n- Mutual TLS authentication with private CA\n- rsyslog omfwd TLS forwarding configuration\n- Per-host disk-backed queues for outage tolerance\n- SELinux context management for certificates and logs\n- firewalld configuration for secure log transport\n- Certificate lifecycle and verification procedures\n\n## Code Example\n```bash\n# Verify log integrity across hosts\ntail -f /var/log/remote/web01.example.local/myapp.log\n# Expected: continuous log flow with timestamps\nrsyslogd -N1 && systemctl status rsyslog\n```","diagram":null,"difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Meta","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":["mutual tls","rsyslog forwarder","private ca","per-host queues","selinux context","firewalld configuration","tls authentication","disk-backed queues","certificate management","log transport","rhel 9","application logs"],"voiceSuitable":true,"isNew":false,"lastUpdated":"2026-01-25T05:11:01.184Z","createdAt":"2026-01-17T17:27:51.925Z"},{"id":"q-3501","question":"On a fresh RHEL 9 host, configure a minimal static website that serves files from /var/www/html/app using httpd. Ensure httpd starts on boot, firewall allows HTTP, and SELinux context is correct so httpd can read the files. Provide exact commands and files touched?","answer":"yum install -y httpd; mkdir -p /var/www/html/app; printf 'Hello world' > /var/www/html/app/index.html; chown -R apache:apache /var/www/html/app; restorecon -R /var/www/html/app; semanage fcontext -a -","explanation":"## Why This Is Asked\nTests practical system administration skills: package management, service control, SELinux context handling, and firewall configuration in a real-world web hosting scenario.\n\n## Key Concepts\n- Installing and enabling httpd on RHEL 9\n- Correct document root permissions and ownership\n- SELinux file contexts for web content (httpd_sys_content_t)\n- Firewall rules for HTTP access\n\n## Code Example\n```javascript\n# commands shown in answer above\n```\n\n## Follow-up Questions\n- What if SELinux blocks access after a semanage change; how would you diagnose and fix it?\n- How would you automate this setup with a simple Ansible playbook?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Salesforce","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-17T18:56:01.654Z","createdAt":"2026-01-17T18:56:01.654Z"},{"id":"q-3586","question":"On a fresh RHEL 9 server, configure a non-login systemd timer that runs every 15 minutes a small script which prints the host name and current time to a log file at /var/log/usage.log, and configure logrotate to rotate that log daily keeping 7 days of history; provide exact commands for creating the user, script, timer/unit files, and logrotate config?","answer":"Create a non-login user with `useradd -r -s /sbin/nologin usage`. Create a script at `/home/usage/collect.sh` that appends the hostname and current timestamp to `/var/log/usage.log`, then make it executable. Set up a systemd user service and timer in `/home/usage/.config/systemd/user/` configured to execute every 15 minutes. Finally, configure logrotate at `/etc/logrotate.d/usage` to perform daily rotations while retaining 7 days of log history.","explanation":"## Why This Is Asked\nThis question evaluates practical system administration skills including systemd user services, timer configuration, file permissions, and log management in a real-world operational scenario.\n\n## Key Concepts\n- systemd user services and timers\n- non-login user accounts and security\n- basic Bash scripting for logging\n- log rotation configuration with logrotate\n\n## Code Example\n```bash\n# /home/usage/collect.sh\n#!/bin/bash\nhostname >> /var/log/usage.log\ndate '+%F %T' >> /var/log/usage.log\n```\n\n```ini\n# /home/usage/.config/systemd/user/usage.service\n[Unit]\nDescription=Log hostname and timestamp to usage.log\n\n[Service]\nType=oneshot\nExecStart=/home/usage/collect.sh\n```\n\n```ini\n# /home/usage/.config/systemd/user/usage.timer\n[Unit]\nDescription=Run usage logging every 15 minutes\n\n[Timer]\nOnCalendar=*:0/15\nPersistent=true\n\n[Install]\nWantedBy=timers.target\n```\n\n```bash\n# /etc/logrotate.d/usage\n/var/log/usage.log {\n    daily\n    rotate 7\n    compress\n    missingok\n    notifempty\n    create 644 usage usage\n}\n```","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Discord","LinkedIn"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T05:34:01.376Z","createdAt":"2026-01-17T22:35:42.163Z"},{"id":"q-3832","question":"On a RHEL 9 host, a kernel update crashes a critical service. Implement an auditable rollback workflow: 1) pin the problematic kernel with dnf versionlock, 2) keep older kernel installed, 3) configure GRUB to boot the older kernel by default, 4) provide a one-shot rollback script that switches GRUB default to the older entry and reboots, 5) ensure all actions are logged in /var/log/rollback.log. Include exact commands, files, and a minimal test?","answer":"dnf versionlock add kernel-5.14.0-116.el9.x86_64; verify older kernels exist in /boot; edit /etc/default/grub to GRUB_DEFAULT=1>2; grub2-mkconfig -o /boot/grub2/grub.cfg; create /usr/local/sbin/rollba","explanation":"## Why This Is Asked\nTests disciplined rollback, bootloader mastery, and auditability under production pressure. It combines package pinning, boot config, and rollback tooling.\n\n## Key Concepts\n- dnf versionlock for kernel management\n- GRUB default vs saved entries\n- one-shot rollback script with idempotent logging\n- verification and test plan\n\n## Code Example\n```bash\n# Pin offending kernel\ndnf versionlock add kernel-5.14.0-116.el9.x86_64\n# Configure GRUB to older entry and rebuild config\ngrub2-mkconfig -o /boot/grub2/grub.cfg\n# Rollback script should set-default to older entry and reboot\n```\n\n## Follow-up Questions\n- How would you automate this with Ansible?\n- How would you test rollback safely in a staging environment?","diagram":"flowchart TD\n  A[Kernel Update] --> B[Pin bad kernel with versionlock]\n  B --> C[Set GRUB to older kernel by default]\n  C --> D[Regenerate grub config]\n  D --> E[Create rollback script + logging]\n  E --> F[Test rollback]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Goldman Sachs","LinkedIn"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-18T11:28:15.387Z","createdAt":"2026-01-18T11:28:15.387Z"},{"id":"q-3996","question":"On a fresh RHEL 9 server, configure firewalld to allow SSH access only from subnet 10.0.0.0/24, ensure the rule is permanent and persists after reboot, and verify by attempting to connect from an allowed host and a disallowed host. Provide exact commands to install and start firewalld, create the permanent rule, reload, and verify with firewall-cmd and nc?","answer":"Install, configure, and verify firewalld with SSH restricted to 10.0.0.0/24:\n\n```bash\n# Install and start firewalld\ndnf install -y firewalld\nsystemctl enable --now firewalld\n\n# Set default zone to public (if not already)\nfirewall-cmd --set-default-zone=public\n\n# Add permanent rich rule for SSH from specific subnet\nfirewall-cmd --permanent --add-rich-rule='rule family=\"ipv4\" source address=\"10.0.0.0/24\" service name=\"ssh\" accept'\n\n# Remove default SSH service to block other sources\nfirewall-cmd --permanent --remove-service=ssh\n\n# Reload to apply permanent rules\nfirewall-cmd --reload\n\n# Verify configuration\nfirewall-cmd --list-all\nfirewall-cmd --list-rich-rules\n\n# Test from allowed host (on 10.0.0.0/24)\nnc -zv server_ip 22  # Should show Connection succeeded\nssh user@server_ip    # Should connect successfully\n\n# Test from disallowed host (outside 10.0.0.0/24)\nnc -zv server_ip 22  # Should timeout or show Connection refused\nssh user@server_ip    # Should timeout or refuse\n```","explanation":"## Why This Is Asked\nTests essential RHCSA firewalld skills: permanent rule configuration, rich rule syntax for source-based filtering, and comprehensive verification.\n\n## Key Concepts\n- Permanent vs runtime firewalld rules\n- Rich rule syntax for granular source-based access control\n- Service-based firewall management vs port-based rules\n- End-to-end verification using firewall-cmd and network testing tools\n\n## Critical Details\n- `--permanent` flag ensures rules persist after reboot\n- Rich rules allow source IP filtering with service names\n- Always remove default SSH service to prevent unrestricted access\n- Use both firewall-cmd verification and actual network testing\n\n## Follow-up Questions\n- How to allow SSH from multiple subnets? (Add additional rich rules)\n- How to log blocked SSH attempts? (Add `log prefix=\"ssh-blocked\" level=\"notice\"` to rich rule)\n- How to temporarily override for maintenance? (Use `--timeout` with temporary rules)","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Meta","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T04:01:46.144Z","createdAt":"2026-01-18T18:53:44.670Z"},{"id":"q-4058","question":"On a fresh RHEL 9 server, create a non-login user 'web' and serve a static site from /srv/www on port 8080 using a per-service systemd unit that runs as 'web'. Provide exact commands to create the user, prepare the site, write the unit file at /etc/systemd/system/website.service, enable and start the service, and adjust the firewall to allow 8080; verify with curl http://localhost:8080 and confirm the process runs as user 'web'?","answer":"Create a non-login system user named 'web', deploy a static website to /srv/www, and serve it on port 8080 using a systemd service unit configured to run as the 'web' user. The implementation includes user creation, file permission setup, systemd service configuration, service activation, firewall configuration, and verification steps.","explanation":"## Why This Is Asked\nThis question evaluates the ability to configure systemd services with non-root execution, demonstrating proper security practices, service isolation, and system administration skills on RHEL 9.\n\n## Key Concepts\n- Systemd service configuration using the User= directive\n- Non-login system users for service isolation\n- Firewall-cmd for permanent port management\n- File permissions and SELinux context handling\n- Service verification and process ownership confirmation\n\n## Code Example\n```bash\n# /etc/systemd/system/website.service\n[Unit]\nDescription=Static website service\nAfter=network.target\n\n[Service]\nType=simple\nUser=web\nExecStart=/usr/bin/python3 -m http.server 8080 --directory /srv/www\nRestart=on-failure\nRestartSec=5s\n\n[Install]\nWantedBy=multi-user.target\n```","diagram":"flowchart TD\n  A[Create user web] --> B[Create site dir /srv/www]\n  B --> C[Write systemd unit]\n  C --> D[Enable and start service]\n  D --> E[Open firewall]\n  E --> F[Test with curl]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","MongoDB","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T05:57:47.337Z","createdAt":"2026-01-18T21:49:24.378Z"},{"id":"q-4074","question":"On a RHEL 9 host, configure rsyslog to forward all application logs to a TLS-enabled remote collector at loghub.example.com:10514. Enforce certificate validation, use a persistent disk-backed queue to retain logs for 30 days if the network is down, and verify with a test log entry. Provide exact rsyslog.conf fragments, TLS options, and rollback steps?","answer":"Install rsyslog, enable TLS, and forward with a disk-backed queue. Example fragments:\n\n```\n$DefaultNetstreamDriver gtls\n$ActionSendStreamDriver gtls\n$TLSCACertificateFile /etc/pki/tls/certs/ca-bundle.crt\n$TLSCertificateFile /etc/pki/tls/certs/rsyslog-client.crt\n$TLSKeyFile /etc/pki/tls/private/rsyslog-client.key\n$ActionSendStreamDriverAuthMode x509/name\n$ActionSendStreamDriverPermittedPeer loghub.example.com\n\n# Disk-backed queue configuration\n$ActionQueueFileName fwdq1\n$ActionQueueMaxDiskSpace 1g\n$ActionQueuePersistencyInterval 600\n$ActionQueueTimeoutEnqueue 86400\n$ActionQueueSaveOnShutdown on\n\n# Forward all application logs\n*.* @@loghub.example.com:10514\n```","explanation":"## Why This Is Asked\nTests TLS-enabled log forwarding, queueing to survive outages, and rollback procedures—core ops skills for RHCSA-level reliability work.\n\n## Key Concepts\n- rsyslog TLS forward with omfwd\n- TLS options: ca/cert/key files, verify peer\n- Disk-backed action queue for resilience\n- Safe rollback steps and verification\n\n## Code Example\n```javascript\n# /etc/rsyslog.d/60-forward.conf (illustrative)\n$DefaultNetstreamDriver gtls\n$ActionSendStreamDriver gtls\n$TLSCACertificateFile /etc/pki/tls/certs/ca-bundle.crt\n$TLSCertificateFile /etc/pki/tls/certs/rsyslog-client.crt\n$TLSKeyFile /etc/pki/tls/private/rsyslog-client.key\n$ActionSendStreamDriverAuthMode x509/name\n$ActionSendStreamDriverPermittedPeer loghub.example.com\n\n# Disk-backed queue configuration\n$ActionQueueFileName fwdq1\n$ActionQueueMaxDiskSpace 1g\n$ActionQueuePersistencyInterval 600\n$ActionQueueTimeoutEnqueue 86400\n$ActionQueueSaveOnShutdown on\n\n# Forward all application logs\n*.* @@loghub.example.com:10514\n```\n\n## Verification & Rollback\n```bash\n# Test configuration syntax\nrsyslogd -N1 -f /etc/rsyslog.conf\n\n# Send test log entry\nlogger \"Test TLS forward to loghub.example.com\"\n\n# Verify queue status\nls -la /var/spool/rsyslog/\n\n# Rollback: disable forwarding\nmv /etc/rsyslog.d/60-forward.conf /etc/rsyslog.d/60-forward.conf.disabled\nsystemctl restart rsyslog\n```","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Google","Hashicorp"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T05:53:02.963Z","createdAt":"2026-01-18T22:46:06.688Z"},{"id":"q-4084","question":"On a RHEL 9 host, deploy a new service in its own network namespace with a dedicated veth pair, assign 192.168.100.2/24 inside, and 192.168.100.1/24 on the host. Configure NAT and per-namespace traffic logging using nftables. Provide exact commands to create the netns, veth pair, move one end to the namespace, set addresses, enable IP forwarding, and a minimal systemd unit to run the service inside the namespace?","answer":"Create a network namespace (myservice), establish a veth pair (veth-host and veth-ns), assign veth-ns to the myservice namespace, configure IP addresses 192.168.100.1/24 on veth-host and 192.168.100.2/24 on veth-ns, enable IP forwarding, implement nftables NAT masquerading, set up per-namespace traffic logging, and create a minimal systemd unit to run the service within the namespace.","explanation":"## Why This Is Asked\nTests network namespace isolation, container-like routing, and host firewall interaction on RHEL 9 in a production-like scenario.\n\n## Key Concepts\n- Network namespaces, veth setup, IP addressing\n- IP forwarding and NAT with nftables\n- Systemd integration for netns-based services\n\n## Code Example\n```bash\n# example commands\n```\n\n## Follow-up Questions\n- How would you monitor per-namespace traffic and implement detailed logging?\n- How would you handle cleanup if the service crashes?","diagram":null,"difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Meta","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T05:50:20.442Z","createdAt":"2026-01-18T23:29:00.163Z"},{"id":"q-4115","question":"On a RHEL 9 host running PostgreSQL with the data directory on an LV mounted at /var/lib/pgsql/data, design and implement a zero-downtime migration to a new XFS LV mounted at /srv/pgsql, preserving SELinux contexts and existing client URLs. Provide exact commands for LV creation, filesystem setup, an rsync-based data copy, a brief cutover sequence, and rollback steps?","answer":"Plan: create a new LV vg/pgsql2, format with XFS, mount at /srv/pgsql; perform initial rsync with -aH --inplace --progress /var/lib/pgsql/data/ /srv/pgsql/; execute final sync during brief maintenance window; atomically swap data directories by renaming old and new directories; update PostgreSQL configuration and restart service.","explanation":"## Why This Is Asked\nTests practical data-migration skills on live systems, including LVM, XFS, SELinux, and PostgreSQL, with a focus on minimal downtime and safe rollback.\n\n## Key Concepts\n- LVM: PV, VG, LV creation and sizing\n- Filesystems: mkfs.xfs, mount options, fstab, SELinux relabeling\n- Data migration: rsync with -aH --inplace to preserve hard links and permissions\n- PostgreSQL: data_dir switch, VACUUM/ANALYZE validity, WAL/archiving continuity\n- Atomic switch: using directory renaming to avoid copy during cutover\n- Rollback: restore old path and restart service\n\n## Code Example\n```java","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Cloudflare","Databricks"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T05:09:56.149Z","createdAt":"2026-01-19T02:49:10.303Z"},{"id":"q-4192","question":"On a RHEL 9 host, deploy a small service at /opt/websvc that runs as user websvc, listens on port 8443, and writes data to /var/lib/websvc/data. The default SELinux policy blocks both data access and network binding. Provide exact commands and steps to (1) create a minimal systemd unit, (2) label the directories, and (3) implement a dedicated SELinux module (websvc_t) that allows websvc_t to read /opt/websvc, write to /var/lib/websvc/data, and bind to 8443, plus firewall adjustments and a test plan?","answer":"Deploy a small service at /opt/websvc running as user websvc, listening on 8443 and writing data to /var/lib/websvc/data. Create a minimal systemd unit, label the directories, and implement a dedicate","explanation":"## Why This Is Asked\n\nTests practical SELinux customization and systemd integration on RHCSA level.\n\n## Key Concepts\n\n- SELinux module creation (websvc_t)\n- File context labeling and restorecon\n- systemd unit with proper permissions\n- Firewall and port labeling (8443)\n\n## Code Example\n\n```bash\n# SELinux module skeleton\ncat > websvc.te << 'EOF'\nmodule websvc_t 1.0;\nrequire {\n  type websvc_t;\n  type var_lib_t;\n  class file { read write getattr };\n  class tcp_socket name_bind;\n}\n# policy rules go here\nEOF\n```\n\n## Follow-up Questions\n\n- How would you automate policy deployment?\n- How would you test rollback if policy blocks service startup?","diagram":"flowchart TD\n  A[Install service] --> B[Label files]\n  B --> C[Create SELinux module]\n  C --> D[Configure firewall]\n  D --> E[Test with curl]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T07:06:35.727Z","createdAt":"2026-01-19T07:06:35.728Z"},{"id":"q-4217","question":"Scenario: A RH9 host runs MongoDB with its data directory on an LV mounted at /data/mongo (XFS). During a maintenance window migrate the data dir to a new LV data_mongo_new of equal size mounted at /data/mongo2 preserving SELinux contexts and keeping client access seamless with no downtime. Provide exact commands to create the LV, format copy data update fstab and SELinux contexts perform the swap with minimal downtime and rollback steps if needed?","answer":"Create a new LV for Mongo data, format, mount at /data/mongo2; quiesce writes using MongoDB fsyncLock, rsync data from /data/mongo to /data/mongo2, then swap mounts to make /data/mongo point to the ne","explanation":"## Why This Is Asked\nTests live storage migration skills with minimal downtime while preserving SELinux context and service availability.\n\n## Key Concepts\n- LVM snapshots and new LV creation\n- Filesystem (XFS) on RH9\n- SELinux labeling and fstab updates\n- MongoDB fsyncLock for brief quiesce\n\n## Code Example\n```javascript\n// Mongo fsyncLock example (admin commands)\nuse admin\ndb.runCommand({fsync: 1, lock: true})\n// later: db.fsyncUnlock()\n```\n\n## Follow-up Questions\n- How would you verify data consistency after swap?\n- What are edge cases if the DB has large unflushed data?","diagram":"flowchart TD\n  Start(Start) --> LVCreate[Create data_mongo_new LV]\n  LVCreate --> FS[XFS format]\n  FS --> Mount[Mount to /data/mongo2]\n  Mount --> Quiesce[db.runCommand({fsync:1, lock:true})]\n  Quiesce --> Rsync[Rsync /data/mongo -> /data/mongo2]\n  Rsync --> Swap[Swap mounts to /data/mongo]\n  Swap --> Fstab[Update /etc/fstab and SELinux]\n  Fstab --> Verify[Verify with mongod]\n  Verify --> End(End)","difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T09:08:08.710Z","createdAt":"2026-01-19T09:08:08.710Z"},{"id":"q-4276","question":"On a fresh RHEL 9 server, deploy a tiny HTTP server that serves static files from /srv/www on port 8080, running as a non-root user 'webstatic'. Implement a systemd service to keep it alive and a separate timer that runs a health-check every 5 minutes and restarts the service if needed. Configure log rotation for /var/log/webstatic.log. Provide exact commands for user creation, the wrapper script, the service unit, the health-check script, the timer, and the logrotate entry?","answer":"Create user webstatic; prepare /srv/www; wrapper: /usr/local/bin/run-webstatic.sh (#!/bin/bash; exec /usr/bin/python3 -m http.server 8080 --directory /srv/www >> /var/log/webstatic.log 2>&1). systemd ","explanation":"## Why This Is Asked\nTests ability to combine user management, service lifecycle, health checks, and log management on a real host.\n\n## Key Concepts\n- Systemd service units and timers\n- Running daemons as non-root users\n- Simple health checks and automated restarts\n- Log rotation for long-running processes\n\n## Code Example\n```bash\n# run-webstatic.sh\n#!/bin/bash\nexec /usr/bin/python3 -m http.server 8080 --directory /srv/www >> /var/log/webstatic.log 2>&1\n```\n\n## Follow-up Questions\n- How would you add SELinux context adjustments for /srv/www?\n- How would you test the health timer without waiting 5 minutes?","diagram":"flowchart TD\n  A[Create webstatic user] --> B[Prepare /srv/www]\n  B --> C[Write wrappers and units]\n  C --> D[Configure health timer]\n  D --> E[Set up logrotate]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T11:06:49.234Z","createdAt":"2026-01-19T11:06:49.235Z"},{"id":"q-4334","question":"On a RHEL 9 host running Apache with TLS, perform a patch upgrade of OpenSSL with minimal downtime across a single host. Provide exact commands to verify the current version, apply the patch while keeping configuration intact, validate TLS handshakes post-upgrade, and a rollback procedure in case the new libcrypto breaks compatibility (including rpm history and reversion)?","answer":"Check current versions: rpm -q openssl; rpm -q openssl-libs. Upgrade: dnf upgrade openssl openssl-libs -y. Validate: openssl version; openssl s_client -connect localhost:443 -servername yourhost. Rest","explanation":"## Why This Is Asked\nTests practical, time-efficient OpenSSL patching and rollback on a live RHCSA host with minimal downtime. It emphasizes verifications, rollback hygiene, and service continuity.\n\n## Key Concepts\n- Package management (dnf history, rollback)\n- Service continuity (reload vs restart)\n- TLS validation (openssl s_client)\n- Config preservation (certs, /etc/httpd)\n\n## Code Example\n```javascript\n// Example shell commands for patching OpenSSL on RH9\nrpm -q openssl\ndnf history list\ndnf upgrade openssl openssl-libs -y\nopenssl version\nopenssl s_client -connect localhost:443 -servername yourhost -tls1_2\n// Rollback if needed\n// Obtain the txn_id from 'dnf history list' and undo\n// dnf history undo <txn_id>\ndnf history list\n```\n\n## Follow-up Questions\n- How would you test this patch in a staging environment before prod?\n- How would you extend this to a multi-host cluster with a load balancer for zero-downtime upgrades?","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Discord","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T14:45:34.117Z","createdAt":"2026-01-19T14:45:34.118Z"},{"id":"q-4361","question":"On a fresh RHEL 9 server, implement a small audit task: create a non-login user 'auditor', a script /usr/local/bin/collect-system-uptime.sh that appends date and uptime to /var/log/auditor/uptime.log, and schedule it with a systemd timer to run hourly. Ensure log rotation via /etc/logrotate.d/auditor and verify that file permissions and SELinux contexts allow the script to write under /var/log/auditor without enabling login. How would you implement this end-to-end?","answer":"Create a non-login user: useradd -m -s /sbin/nologin auditor. Write /usr/local/bin/collect-system-uptime.sh to log date and uptime; make it executable; ensure /var/log/auditor exists with correct owne","explanation":"## Why This Is Asked\nTests ability to compose a minimal, repeatable housekeeping task using standard RHEL9 tools: user management, scripting, systemd timers, log rotation, and basic SELinux considerations. It covers practical everyday ops and common pitfalls (permissions, context, rotation).\n\n## Key Concepts\n- User management with non-login accounts\n- Systemd: service + timer\n- Script writing and file permissions\n- Log rotation with logrotate\n- Basic SELinux context awareness\n\n## Code Example\n```javascript\n#!/bin/bash\nprintf '%s %s\\n' \"$(date)\" \"$(uptime -p)\" >> /var/log/auditor/uptime.log\n```\n\n## Follow-up Questions\n- How would you test the timer and verify rotation captured all entries?\n- How would you adapt this for multiple hosts or different log destinations?","diagram":"flowchart TD\nA[Create auditor user] --> B[Write script]\nB --> C[Configure systemd timer]\nC --> D[Set up logrotate]\nD --> E[Verify SELinux context]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","OpenAI","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T15:45:54.119Z","createdAt":"2026-01-19T15:45:54.119Z"},{"id":"q-4381","question":"On a RHEL 9 host, deploy a Go API service (port 8443) in a Podman container, behind an Nginx reverse proxy with TLS termination. The API must run as user 'apiuser', store data under /var/lib/api/data, and SELinux must allow network bind and file access. Implement a blue/green deployment on the same host with zero downtime and a rollback plan, including exact Podman unit files, nginx site config, SELinux policy snippet, and data-migration strategy?","answer":"Define a Podman pod named api-pod running as apiuser with /var/lib/api/data mounted and port 8443 exposed; configure nginx as TLS terminator with blue/green upstreams and a switch script; write a smal","explanation":"## Why This Is Asked\nTests practical application of containerization, SELinux, and deployment orchestration on a single host with zero-downtime goals.\n\n## Key Concepts\n- Podman pod lifecycle and per-service user mapping\n- SELinux policy customization for containerized apps\n- Nginx TLS termination and blue/green traffic shifting\n- Data migration, health checks, and rollback strategies\n\n## Code Example\n```bash\n# Podman setup (illustrative)\nsudo useradd -r apiuser\nsudo mkdir -p /var/lib/api/data\npodman pod create --name api-pod -p 8443:8443\npodman run -d --name api --pod api-pod -v /var/lib/api/data:/data:Z --user apiuser:apiuser myrepo/api:latest\n```\n\n```selinux\n# Minimal policy snippet outline (illustrative, not full policy)\nmodule api_t 1.0;\nrequire {\n  type container_runtime_t;\n  type api_data_t;\n  class file { read write getattr };\n  class dir { write read getattr };\n  type self;\n  class net_bind_service;\n}\nallow api_t api_data_t:dir { write read getattr };\nallow api_t api_data_t:file { read write getattr };\n# Allow binding to 8443 via runtime role\nallow api_t self:net_bind_service;\n```\n\n## Follow-up Questions\n- How would you extend this to multiple hosts with a shared data backend and zero-downtime failover?\n- What observability and metrics would you add to detect drift between blue/green environments?","diagram":null,"difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Instacart","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T16:47:38.465Z","createdAt":"2026-01-19T16:47:38.465Z"},{"id":"q-4490","question":"On a fresh RHEL 9 server, implement a tiny static web server that serves /srv/www on port 8080, running as a non-root user via systemd, with access logs written to /var/log/webmon/access.log and rotated. Provide exact commands to create the user, the server script, the systemd unit, SELinux labeling for /srv/www, and a logrotate config; ensure firewall allows 8080?","answer":"Create user webmon; write a minimal Python http.server script at /home/webmon/server.py serving /srv/www on 8080; a systemd unit /etc/systemd/system/webmon.service running as webmon. Label /srv/www wi","explanation":"## Why This Is Asked\nTests practical systemd, SELinux, and firewall basics with a realistic, minimal service. It checks ability to integrate multiple subsystems in a safe, non-root context.\n\n## Key Concepts\n- systemdUnit basics and service permissions\n- SELinux labeling for content directories\n- firewalld port opening and persistence\n- log rotation for application logs\n\n## Code Example\n```ini\n[Unit]\nDescription=Webmon static web server\n\n[Service]\nUser=webmon\nExecStart=/usr/bin/python3 /home/webmon/server.py\nRestart=on-failure\n\n[Install]\nWantedBy=multi-user.target\n```\n\n```python\nfrom http.server import SimpleHTTPRequestHandler\nimport socketserver\nPORT = 8080\nHandler = SimpleHTTPRequestHandler\nwith socketserver.TCPServer(('', PORT), Handler) as httpd:\n    print('serving at port', PORT)\n    httpd.serve_forever()\n```\n\n```sh\n/var/log/webmon/access.log {\n  daily\n  rotate 14\n  compress\n  missingok\n  notifempty\n  create 0640 webmon webmon\n}\n```\n\n## Follow-up Questions\n- How would you extend to TLS without root privileges?\n- How would you add basic health checks to the systemd unit?","diagram":"flowchart TD\n  A[Start] --> B[Create user webmon]\n  B --> C[Add server.py]\n  C --> D[Create systemd unit webmon.service]\n  D --> E[Label /srv/www with SELinux]\n  E --> F[Open 8080 in firewalld]\n  F --> G[Deploy logrotate for /var/log/webmon/access.log]\n  G --> H[Test locally on port 8080]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Hugging Face"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-19T20:53:15.901Z","createdAt":"2026-01-19T20:53:15.901Z"},{"id":"q-4615","question":"On a RHEL 9 host, TLS terminates at Nginx in front of a backend app. Certificates expire in 24 hours. Implement a zero-downtime certificate rotation strategy: (1) renew and install new certs to a separate path, (2) swap a symlink used by ssl_certificate to point to the new cert, (3) gracefully reload Nginx, (4) verify handshakes and SELinux contexts. Provide exact commands and validation steps?","answer":"Perform a canary-like rotation by using a symlink for ssl_certificate and ssl_certificate_key. After renewal, place cert-new.pem and key-new.pem in /etc/ssl/app, then: ln -sfn cert-new.pem cert-curren","explanation":"## Why This Is Asked\nTests practical, real-world maintenance of TLS in a single-host stack with zero downtime, SELinux awareness, and validation.\n\n## Key Concepts\n- Zero-downtime certificate rotation\n- Atomic symlink swap for ssl_certificate paths\n- Nginx graceful reload and TLS session handling\n- SELinux file contexts and troubleshooting\n\n## Code Example\n```bash\n# renewal (example use with certbot)\ncertbot renew --deploy-hook \"cp /etc/ssl/app/cert.pem /etc/ssl/app/cert-new.pem; cp /etc/ssl/app/privkey.pem /etc/ssl/app/key-new.pem\"\n\n# swap and reload (atomic)\nln -sfn cert-new.pem cert-current.pem\nln -sfn key-new.pem key-current.pem\nsystemctl reload nginx\n```\n\n## Follow-up Questions\n- How would you handle multiple upstreams and TLS session resumption?\n- What additional audit steps would you add for SELinux denials during rotation?","diagram":"flowchart TD\n  A[Renewal] --> B[Install new certs] \n  B --> C[Swap ssl_certificate symlink] \n  C --> D[Nginx reload] \n  D --> E[Health and TLS verify]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Salesforce","Square","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T04:33:28.590Z","createdAt":"2026-01-20T04:33:28.591Z"},{"id":"q-4788","question":"On a RHEL 9 host running three Podman containers (web, api, db) attached to a dedicated bridge, design and implement an nftables firewall that: (1) blocks inbound to the host except SSH and per-container ports limited to container IPs; (2) allows outbound DNS and HTTPS; (3) isolates containers from each other; (4) logs denied attempts; (5) provides /etc/nftables.conf and a rollback plan with verification steps. What exact configuration would you use?","answer":"Design and implement an nftables firewall on a RHEL 9 host running three Podman containers (web, api, db) on a dedicated bridge. Inbound: allow SSH and per-container ports only from the container brid","explanation":"## Why This Is Asked\nTests practical firewalling in a containerized Linux host, focusing on nftables, container networks, and safe rollback.\n\n## Key Concepts\n- nftables inet table and ruleset construction\n- Podman bridge networks and container IP scoping\n- Inbound vs outbound traffic controls and logging\n- Rollback and verification when applying host-level firewall changes\n\n## Code Example\n```bash\n#!/usr/sbin/nft -f\n# Minimal skeleton; real config would define table inet fw, chains input/forward/output,\n# allow lo, established connections, SSH, container ports by container IPs, and DNS/HTTPS outbound\n```\n\n## Follow-up Questions\n- How would you test without lockout of SSH?\n- How would you persist rules across reboots and migrate to a different host?","diagram":"flowchart TD\n  A[Host (RHEL 9)] --> B[Container: web (10.0.0.2)]\n  A --> C[Container: api (10.0.0.3)]\n  A --> D[Container: db (10.0.0.4)]\n  E[Rules] --> F{Inbound}\n  F --> G[SSH 22 allowed]\n  F --> H[web 80/443 allowed from bridge IPs]\n  F --> I[api 8080 allowed from bridge IPs]\n  F --> J[db 5432 allowed from bridge IPs]\n  E --> K{Outbound}\n  K --> L[DNS 53 allowed]\n  K --> M[HTTPS 443 allowed]\n  F --> N[Isolation: containers cannot reach each other unless allowed]\n  N --> O[Logging: deny events to /var/log/nftables.log]","difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","MongoDB","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T13:10:33.273Z","createdAt":"2026-01-20T13:10:33.273Z"},{"id":"q-4852","question":"On a RHEL 9 host, you must set up a secure local YUM/DNF repository mirror for security updates to serve a LAN of 50 hosts. Provide exact steps to create the mirror at /srv/repos, configure httpd with proper SELinux contexts, use reposync/createrepo_c to generate metadata, sign packages, and enable client GPG verification, plus a minimal-downtime nightly sync and a rollback plan if the mirror goes out of sync?","answer":"Configure a local YUM/DNF mirror on RHEL9 at /srv/repos, serving via httpd with proper SELinux contexts. Use reposync to fetch baseos/appstream, run createrepo_c to generate metadata, sign with RPM-GP","explanation":"## Why This Is Asked\nTests practical repo mirroring, SELinux, and high-availability downtime handling.\n\n## Key Concepts\n- YUM/DN F repos, reposync, createrepo_c\n- SELinux contexts and booleans for httpd\n- GPG signing and client verification\n- Systemd timers for automation\n- Atomic switch and rollback strategy\n\n## Code Example\n```bash\n# Sample repository config\n```\n\n## Follow-up Questions\n- How would you verify integrity of mirrored packages?\n- How would you scale to Satellite or multiple mirrors?\n","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Netflix","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-20T16:18:37.376Z","createdAt":"2026-01-20T16:18:37.376Z"},{"id":"q-5014","question":"On a RHEL 9 host running Apache with PHP serving /var/www/html, migrate to an encrypted LUKS volume mounted at /mnt/secure_www and switch traffic with zero downtime. Provide exact commands to: 1) create a new LV and LUKS container, 2) format and mount at /mnt/secure_www, 3) rsync data preserving perms, 4) update /etc/fstab and initramfs, 5) set SELinux context for httpd_sys_content_t, 6) change Apache DocumentRoot to /mnt/secure_www/html and gracefully reload, 7) rollback plan?","answer":"Create a new LV and LUKS container, open and format, mount at /mnt/secure_www, then rsync and switch DocumentRoot. Commands: lvcreate -L20G -n secure_www vg0; cryptsetup luksFormat /dev/vg0/secure_www","explanation":"## Why This Is Asked\nThis tests practical disk encryption, live data migration with minimal downtime, and integration with SELinux and initramfs on RHCSA-level systems.\n\n## Key Concepts\n- LUKS/dm-crypt, LVM, initramfs, SELinux contexts, rsync, graceful reloads\n- Downtime minimization and rollback\n\n## Code Example\n```bash\n# Step examples\n# create LV, luksFormat, open, format\nlvcreate -L 20G -n secure_www vg0\ncryptsetup luksFormat /dev/vg0/secure_www\ncryptsetup open /dev/vg0/secure_www secure_www\nmkfs.xfs /dev/mapper/secure_www\n... # mount, rsync commands\n```\n\n## Follow-up Questions\n- How would","diagram":"flowchart TD\n  A[Assess current site] --> B[Create LUKS container and LV]\n  B --> C[Format filesystem]\n  C --> D[Copy data to new mount]\n  D --> E[Update fstab and initramfs]\n  E --> F[Remount and test]\n  F --> G[Switch Apache DocumentRoot to new mount]\n  G --> H[Monitor and validate]\n  H --> I[Rollback plan if needed]","difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","MongoDB","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-21T05:24:30.642Z","createdAt":"2026-01-20T23:51:54.919Z"},{"id":"q-5055","question":"On a RHEL 9 host, harden SSH access for the user deploy: generate a 4096-bit RSA key, place the public key in /home/deploy/.ssh/authorized_keys, ensure proper permissions, and configure sshd to disable password authentication and root login. Restart sshd and verify login via the key from a separate session?","answer":"Generate a 4096-bit RSA key for deploy: ssh-keygen -t rsa -b 4096 -f /home/deploy/.ssh/id_rsa -N '' -C 'deploy@host'; ensure /home/deploy/.ssh exists with 700 and authorized_keys with 600, append the ","explanation":"## Why This Is Asked\nTests hands-on SSH hardening in RHCSA-style tasks, ensuring secure key-based authentication, proper file permissions, and correct access controls.\n\n## Key Concepts\n- SSH daemon hardening (sshd_config)\n- Public key authentication, authorized_keys perms\n- User permissions and home directory security\n- Service management (systemctl restart sshd)\n\n## Code Example\n```bash\n# as root or user with sudo\nmkdir -p /home/deploy/.ssh\nchmod 700 /home/deploy/.ssh\nssh-keygen -t rsa -b 4096 -f /home/deploy/.ssh/id_rsa -N '' -C 'deploy@host'\ncat /home/deploy/.ssh/id_rsa.pub >> /home/deploy/.ssh/authorized_keys\nchmod 600 /home/deploy/.ssh/authorized_keys\nsed -i 's/^#*PasswordAuthentication.*/PasswordAuthentication no/' /etc/ssh/sshd_config\nsed -i 's/^#*PermitRootLogin.*/PermitRootLogin no/' /etc/ssh/sshd_config\nsystemctl restart sshd\n```\n\n## Follow-up Questions\n- How would you recover if you lose the deploy private key?\n- What additional controls would you add for auditing SSH access?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Hashicorp","LinkedIn"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T04:12:32.417Z","createdAt":"2026-01-21T04:12:32.417Z"},{"id":"q-5185","question":"On a RHEL 9 host, two Podman-based services api-v1 and api-v2 run behind Nginx TLS termination on port 443. Implement blue/green deployments on the same host with zero downtime, enforce per-container memory limits (512m), SELinux confinement, and a rollback plan. Provide exact Podman systemd unit files for both versions, Nginx site config to route TLS to the active version, an SELinux policy snippet to permit network bind and DB writes, a traffic-switch workflow, and a minimal data-migration plan if the API schema changes?","answer":"Plan: Run api-v1/api-v2 as Podman containers with systemd units and 512m memory; map 8081/8082 and terminate TLS in Nginx on 443. Use blue/green by swapping a single upstream in nginx and reloading; k","explanation":"## Why This Is Asked\nTests end-to-end competency: container lifecycle, network hardening, and live-upgrade strategies in a realistic Linux stack.\n\n## Key Concepts\n- Podman systemd units\n- Resource limits and isolation\n- Nginx TLS termination and upstream switching\n- SELinux confinement and policy snippets\n- Blue/green on a single host with rollback\n- Lightweight data-migration planning\n\n## Code Example\n```bash\n# example: generate systemd unit for a Podman container\npodman generate systemd --name api-v1 --files\n```\n\n## Follow-up Questions\n- How would you validate zero-downtime during the switch?\n- What changes if the API adds a new DB column requiring migration?\n- How do you monitor health and roll back automatically?","diagram":"flowchart TD\n  A[Blue] --> B[Green]\n  B --> C[Swap nginx upstream]\n  C --> D[Health check]\n  D --> E[Rollback if failed]","difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Plaid","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T10:11:13.275Z","createdAt":"2026-01-21T10:11:13.275Z"},{"id":"q-5230","question":"On a RHEL 9 host, you must implement a fault-tolerant archival store using a 1 TB Btrfs volume with subvols and snapshots. Requirements: enable quotas and compression; create subvols for current data and immutable snapshots; automate nightly snapshots with systemd-timer and a restore script; label files with SELinux and write a minimal policy to allow the archival user read access to the current subvolume; validate by a PIT restore and hash checks?","answer":"Create a 1 TB LV, format as Btrfs with quotas and compression; create subvols @archive_current and @archive_snap; schedule nightly read-only snapshots with a systemd-timer calling `btrfs subvolume sna","explanation":"## Why This Is Asked\n\nTests ability to design a resilient archival store using modern Linux storage features and policy controls.\n\n## Key Concepts\n\n- Btrfs subvols, quotas, compression\n- Snapshots and point-in-time restores\n- SELinux labeling and custom policy modules\n- systemd-timer and script orchestration\n- Data integrity verification via checksums\n\n## Code Example\n\n```bash\n# Create LV and filesystem\nlvcreate -L 1T vg0/archive\nmkfs.btrfs /dev/vg0/archive\n\n# Mount and setup subvols (illustrative)\nmkdir -p /mnt/archive\nmount /dev/vg0/archive /mnt/archive\nbtrfs subvolume create /mnt/archive/@archive_current\nbtrfs subvolume create /mnt/archive/@archive_snap\n```\n\n## Follow-up Questions\n\n- How would you scale this to multiple servers?\n- How would you implement retention policies and verify restores in disaster scenarios?","diagram":"flowchart TD\n  A[LV creation] --> B[Format as Btrfs]\n  B --> C[Create subvols]\n  C --> D[Systemd-timer]\n  D --> E[SELinux policy]\n  E --> F[Validation]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Oracle","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T11:40:55.442Z","createdAt":"2026-01-21T11:40:55.442Z"},{"id":"q-5320","question":"Design and implement a TLS-enabled rsyslog pipeline to centralize logs from a fleet of RHEL 9 hosts. Provide exact commands to: 1) create a small CA and server/client certificates, 2) configure client rsyslog to forward all logs to a centralized log server on port 514 using TLS, 3) configure the log server to receive TLS logs and store them under /var/log/central with proper permissions, 4) apply SELinux contexts and enable necessary booleans for forwarding, 5) verify with a live test event and ensure integrity?","answer":"Set up a TLS rsyslog pipeline for a fleet: create a small CA and certs (ca.crt, server.crt/server.key, client.crt/client.key); configure clients to forward via imtcp with gtls, x509/name, and the CA/c","explanation":"## Why This Is Asked\nTests practical, production-ready log centralization with TLS, SELinux, and validation in a RHCSA-advanced context.\n\n## Key Concepts\n- TLS-enabled rsyslog forwarding\n- Certificate Authority workflow and rotation\n- Centralized log storage permissions and retention\n- SELinux context labeling and booleans for syslog forwarding\n- Verification: test events and TLS handshake checks\n\n## Code Example\n```bash\n# 1) CA and certs (simplified)\nopenssl genrsa -out ca.key 2048\nopenssl req -x509 -new -nodes -key ca.key -days 3650 -out ca.crt -subj \"/CN=logCA\"\nopenssl req -new -nodes -newkey rsa:2048 -keyout client.key -out client.csr -subj \"/CN=client\"\nopenssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -days 3650 -out client.crt\n\n# 2) Client rsyslog config (example)\ncat > /etc/rsyslog.d/50-forward.conf <<'EOF'\nmodule(load=\"imtcp\")\nmodule(load=\"gtls\")\n$DefaultNetstreamDriverCAFile /etc/rsyslog.d/ca.crt\n$DefaultNetstreamDriverCertFile /etc/rsyslog.d/client.crt\n$DefaultNetstreamDriverKeyFile /etc/rsyslog.d/client.key\n$ActionSendStreamDriver gtls\n*.*  action(type=\"omfwd\" Target=\"logserver.example\" Port=\"514\" Protocol=\"tcp\" StreamDriverMode=\"1\" StreamDriverAuthMode=\"x509/name\")\nEOF\nsystemctl restart rsyslog\n\n# 3) Server rsyslog TLS input\ncat > /etc/rsyslog.d/60-tls-recv.conf <<'EOF'\nmodule(load=\"imtcp\")\ninput(type=\"imtcp\" port=\"514\" tls=\"true\")\nEOF\nmkdir -p /var/log/central\nchown syslog:adm /var/log/central\nchmod 750 /var/log/central\nsystemctl restart rsyslog\n\n# 4) SELinux and booleans (example)\nsemanage fcontext -a -e /var/log /var/log\nrestorecon -R /var/log/central\nsetsebool -P rsyslogd_forwarding 1\n\n# 5) Verification\nlogger -t test -p user.info 'TLS rsyslog test'\nopenssl s_client -connect logserver.example:514 -tls1_2 </dev/null\n```\n\n## Follow-up Questions\n- How would you rotate logs without losing TLS session configuration?\n- How would you monitor for failed TLS handshakes and alert on anomalies?","diagram":null,"difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","MongoDB","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T17:16:15.608Z","createdAt":"2026-01-21T17:16:15.608Z"},{"id":"q-5412","question":"On a fresh RHEL 9 host, configure a dedicated storage volume for a web app and ensure automated backups. Tasks: Create an LVM volume group and a 20G logical volume on /dev/sdb named web_vg/web_lv; format ext4 and mount at /var/www; set SELinux context httpd_sys_content_t; enable mount at boot; schedule rsync backups to /backup/web every night using a systemd timer; provide exact commands?","answer":"pvcreate /dev/sdb; vgcreate web_vg /dev/sdb; lvcreate -L 20G -n web_lv web_vg; mkfs.ext4 /dev/web_vg/web_lv; mkdir -p /var/www; mount /dev/web_vg/web_lv /var/www; semanage fcontext -a -t httpd_sys_con","explanation":"Why This Is Asked\nTests storage provisioning, SELinux context handling, and automated backups—core RHCSA skills with production relevance.\n\nKey Concepts\n- LVM: PV, VG, LV sizing and formatting\n- Filesystems and fstab for boot-time mounts\n- SELinux contexts and restorecon\n- Systemd timers and services for nightly tasks\n- Rsync-based backups and offsite readiness\n\nCode Example\n```bash\npvcreate /dev/sdb; vgcreate web_vg /dev/sdb; lvcreate -L 20G -n web_lv web_vg; mkfs.ext4 /dev/web_vg/web_lv; mkdir -p /var/www; mount /dev/web_vg/web_lv /var/www; semanage fcontext -a -t httpd_sys_content_t '/var/www(/.*)?'; restorecon -Rv /var/www; echo '/dev/web_vg/web_lv /var/www ext4 defaults 0 2' >> /etc/fstab; mkdir -p /backup/web; cat > /etc/systemd/system/backup-web.service <<'EOF'\n[Service]\nExecStart=/usr/bin/rsync -a --delete /var/www/ backup:/backup/web/\nEOF\ncat > /etc/systemd/system/backup-web.timer <<'EOF'\n[Timer]\nOnCalendar=daily\nEOF\nsystemctl enable --now backup-web.timer\n```\n\nFollow-up Questions\n- How would you verify SELinux contexts after mounting? What if httpd is denied access?\n- How would you test the backup resiliency and restore from /backup/web? What if the remote host is unreachable?","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T21:12:14.453Z","createdAt":"2026-01-21T21:12:14.453Z"},{"id":"q-5465","question":"On a fresh RHEL 9 host, set up a minimal local YUM repository from /srv/repo (RPMs already placed there) and expose it via HTTP, then configure dnf to install a package from that repo. Provide exact commands for: 1) generating repo metadata, 2) serving with httpd, 3) creating the repo file, 4) installing a package and verifying it used the local repo?","answer":"Install createrepo_c and httpd, generate repository metadata using createrepo_c /srv/repo, start and enable the httpd service, configure the firewall to allow HTTP traffic, and create /etc/yum.repos.d/local.repo with baseurl=http://localhost/repo to enable package installation from the local repository.","explanation":"## Why This Is Asked\nTests practical understanding of local repositories, package management, and basic web serving in a real-world scenario.\n\n## Key Concepts\n- Local YUM/DNF repository creation and metadata generation\n- Serving static RPMs with httpd and basic firewall configuration\n- Repository file syntax and verification that packages originate from the local source\n- Basic security considerations for local repositories (GPG signing, access controls)\n\n## Code Example\n```bash\n# Prerequisites\ndnf install -y createrepo_c httpd\n\n# Prepare repository\nmkdir -p /srv/repo\n# Place RPMs in /srv/repo\ncreaterepo_c /srv/repo\n\n# Serve repository\nsystemctl start httpd\nsystemctl enable httpd\nfirewall-cmd --add-service=http --permanent\nfirewall-cmd --reload\n\n# Configure DNF to use local repo\ncat > /etc/yum.repos.d/local.repo << EOF\n[local-repo]\nname=Local Repository\nbaseurl=http://localhost/repo\nenabled=1\ngpgcheck=0\nEOF\n\n# Install and verify\ndnf install -y package-name\ndnf history info | grep local-repo\n```","diagram":"flowchart TD\nA[RPMs in /srv/repo] --> B[createrepo_c metadata]\nB --> C[httpd serves http://localhost/repo]\nC --> D[dnf makecache/install from local repo]\nD --> E[verify: From repo: local-repo]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Hashicorp","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T05:53:11.667Z","createdAt":"2026-01-21T23:35:49.946Z"},{"id":"q-5492","question":"On a fresh RHEL 9 host, create a non-root user who runs a tiny static file server as a systemd user service on port 8000, serving /srv/http. Log output to /home/rhtest/server.log with rotation. Provide exact commands to (1) create the user, (2) create /srv/http/index.html, (3) the server script and unit, (4) logrotate, and (5) verification steps using curl http://localhost:8000?","answer":"Created user 'rhtest' using `sudo useradd -m -s /bin/bash rhtest`; established /srv/http directory with index.html; implemented server script at /home/rhtest/server.sh executing `python3 -m http.server 8000 --directory /srv/http`; configured systemd user service for automatic startup; set up logrotate for /home/rhtest/server.log; verified functionality with `curl http://localhost:8000`.","explanation":"## Why This Is Asked\n\nThis evaluates comprehensive Linux administration skills: user management, service deployment, web server configuration, logging infrastructure, and system validation—all essential for production environment management.\n\n## Key Concepts\n\n- Systemd user service configuration and management\n- Lightweight Python HTTP server deployment\n- File system permissions and directory structure\n- Log rotation implementation for user services\n- Service verification and troubleshooting\n\n## Code Example\n\n```bash\n#!/usr/bin/env bash\nexec python3 -m http.server 8000 --directory /srv/http\n```","diagram":"flowchart TD\n  A[Create user] --> B[Create content in /srv/http]\n  B --> C[Write server.sh]\n  C --> D[Create systemd user unit]\n  D --> E[Enable and start service]\n  E --> F[Configure log rotation]\n  F --> G[Verify with curl]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T05:29:12.755Z","createdAt":"2026-01-22T02:33:21.626Z"},{"id":"q-5585","question":"On a fresh RHEL 9 server, configure a tiny HTTP server that serves Hello from /srv/www on port 8080. Run as a non-root user appuser (no login), log requests to /var/log/appserver.log with rotation, and ensure the service starts on boot. Provide exact commands to create user, script, systemd unit, and logrotate entry?","answer":"Create user appuser with --system and --shell /sbin/nologin; write /usr/local/bin/simple_http_server.py that chdirs to /srv/www and uses http.server, plus logging to /var/log/appserver.log; set up sys","explanation":"## Why This Is Asked\nTests practical ability to package a small server with correct privileges and log rotation.\n\n## Key Concepts\n- Systemd service for non-root process\n- Python HTTP server and logging\n- Log rotation basics with copytruncate\n\n## Code Example\n```python\nimport http.server, socketserver, logging, os\nLOG = '/var/log/appserver.log'\nlogging.basicConfig(filename=LOG, level=logging.INFO, format='%(asctime)s %(message)s')\nos.chdir('/srv/www')\nclass Handler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        logging.info(\"GET %s\", self.path)\n        self.send_response(200)\n        self.end_headers()\n        self.wfile.write(b'Hello')\nPORT = 8080\nwith socketserver.TCPServer(('', PORT), Handler) as httpd:\n    httpd.serve_forever()\n```\n\n## Follow-up Questions\n- How would you adapt for TLS or authentication?\n- How to verify service health and automatic restarts?","diagram":"flowchart TD\n  A[Create appuser] --> B[Write http server script]\n  B --> C[Create systemd unit]\n  C --> D[Enable & start service]\n  D --> E[Configure logrotate]\n  E --> F[Test with curl]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Google","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T07:15:15.023Z","createdAt":"2026-01-22T07:15:15.023Z"},{"id":"q-5712","question":"On a RHEL 9 host, configure a secure centralized logging workflow: applications write to /var/log/app/*.log and rsyslog forwards to a remote collector at logs.example.com:6514 using mutual TLS. Include certificate layout, rsyslog.conf, a systemd drop-in to reload during cert rotation, SELinux policy tweaks, and logrotate for local logs. Provide a test plan and a rollback strategy?","answer":"Configure rsyslog to forward to logs.example.com:6514 using TLS with tlsCaCert tlsCert tlsKey and enable mutual authentication. Place certs under /etc/pki, label /var/log/app with the proper SELinux c","explanation":"## Why This Is Asked\nTests ability to implement a real-world, secure log pipeline with TLS, user-space tooling, and container-ready practices.\n\n## Key Concepts\n- TLS/mTLS rsyslog forwarding\n- SELinux contexts and booleans\n- Systemd reloads during rotation\n- Log rotation and permissions\n- Certificate lifecycle and testing\n\n## Code Example\n```bash\n# example commands to verify rsyslog forwarding and TLS setup\nlogger -p local0.info 'test log'\n# verify on collector side\n```\n\n## Follow-up Questions\n- How would you rotate certificates without dropping logs?\n- How to monitor forward failures and alert on TLS handshake errors?","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Google","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T13:09:21.270Z","createdAt":"2026-01-22T13:09:21.270Z"},{"id":"q-5773","question":"On a RHEL 9 host, publish a private REST API on port 8444 behind an Nginx TLS-terminating reverse proxy. Implement an nftables firewall: default deny inbound, allow established/related, allow inbound port 443, allow localhost to 8444, log drops to /var/log/nft.log, and rotate logs. Provide exact nftables rules, the nginx site config for TLS termination, and a rollback/test plan with verification steps?","answer":"Configure nftables to: 1) default drop inbound; 2) allow established,related; 3) allow tcp dport 443; 4) allow 127.0.0.1 to dport 8444; 5) log drops to /var/log/nft.log; 6) drop or rate-limit ssh. Ngi","explanation":"## Why This Is Asked\nTests practical firewall hardening and host-to-service traffic control around a reverse proxy with a local backend.\n\n## Key Concepts\n- nftables inet rules and chains\n- TLS termination with Nginx and proxy_pass\n- Local backend access control (127.0.0.1 to 8444)\n- Log rotation and rollback strategy\n\n## Code Example\n```javascript\n// Placeholder example to illustrate intent; actual rules differ\n```\n\n## Follow-up Questions\n- How would you adapt for IPv6? \n- How would you monitor nftables hits in real time?","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Google","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T16:01:01.104Z","createdAt":"2026-01-22T16:01:01.104Z"},{"id":"q-5850","question":"On a RHEL 9 host, implement zero-downtime upgrade for a custom service deployed under /opt/app with versioned dirs and a /opt/app/current symlink. Create a systemd unit using ExecStart=/opt/app/current/bin/server and a rollback plan if health checks fail. Include exact steps: directory setup, unit file, daemon-reload, upgrade steps, rollback path, and a test plan?","answer":"Prepare two version dirs: /opt/app/1.0.0 and /opt/app/1.1.0 with binaries owned by root. Point /opt/app/current to 1.0.0 via symlink. Create systemd unit ExecStart=/opt/app/current/bin/server. For upg","explanation":"## Why This Is Asked\nDemonstrates practical, production-grade upgrade procedures on RHCSA level: versioned deployments, symlink switching, and rollback under health checks.\n\n## Key Concepts\n- Atomic deployments with symlinks\n- systemd service management\n- Health checks and rollback\n- Minimal downtime testing\n\n## Code Example\n```bash\n# Example: not required\n```\n\n## Follow-up Questions\n- How would you handle shared config during upgrades?\n- How to automate this with Ansible or a small script?","diagram":"flowchart TD\n  A[Upgrade] --> B[Stop service]\n  B --> C[Flip /opt/app/current]\n  C --> D[Reload & Start]\n  D --> E{Health OK?}\n  E -->|Yes| F[Monitor]\n  E -->|No| G[Rollback & Restart]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-22T19:15:48.812Z","createdAt":"2026-01-22T19:15:48.812Z"},{"id":"q-5909","question":"On a RHEL 9 host, a Podman-based web app is frontended by nginx on port 8443 with TLS certs stored on the host at /etc/letsencrypt/live/domain. Certificates rotate weekly. Outline a zero-downtime TLS certificate rotation workflow: how to update the cert without dropping connections, ensure SELinux contexts permit access, and provide rollback if renewal fails. Include precise steps and commands?","answer":"Implement a symlink-based certificate rotation with atomic updates and nginx reload. Create a stable path at /etc/ssl/domain pointing to current certificates via symlinks. Configure nginx to reference the stable path. During renewal, certbot updates symlinks atomically and triggers nginx reload via deploy hook.","explanation":"## Why This Is Asked\nTests practical TLS rotation with zero downtime, SELinux considerations, and rollback capabilities.\n\n## Key Concepts\n- TLS certificate rotation without connection drops\n- nginx + Podman integration on RHEL 9\n- SELinux context management for certificate directories\n- Deploy hooks and atomic symlink updates\n- Rollback procedures for failed renewals\n\n## Code Example\n```bash\n# Initial setup\nmkdir -p /etc/ssl/domain\nln -sf /etc/letsencrypt/live/domain/fullchain.pem /etc/ssl/domain/fullchain.pem\nln -sf /etc/letsencrypt/live/domain/privkey.pem /etc/ssl/domain/privkey.pem\nsemanage fcontext -a -t cert_t \"/etc/ssl/domain(/.*)?\"\nrestorecon -Rv /etc/ssl/domain\n\n# Configure certbot deploy hook\necho '#!/bin/bash\nif [ \"$RENEWED_LINEAGE\" = \"/etc/letsencrypt/live/domain\" ]; then\n    ln -sf \"$RENEWED_LINEAGE/fullchain.pem\" /etc/ssl/domain/fullchain.pem\n    ln -sf \"$RENEWED_LINEAGE/privkey.pem\" /etc/ssl/domain/privkey.pem\n    systemctl reload nginx\nfi' > /etc/letsencrypt/renewal-hooks/deploy/nginx-reload\nchmod +x /etc/letsencrypt/renewal-hooks/deploy/nginx-reload\n```\n\n## Follow-up Questions\n- How would you handle certificate validation before reload?\n- What monitoring would you implement for rotation failures?\n- How does this approach scale across multiple domains?","diagram":null,"difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Lyft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T04:48:22.701Z","createdAt":"2026-01-22T21:48:28.872Z"},{"id":"q-6006","question":"On a fresh RHEL 9 server, set up a daily backup of /home to /mnt/backup using rsync, run by user 'backup', via a systemd timer at 02:00. Provide exact commands to create the user, script, service, timer, and log rotation?","answer":"Create user: useradd -m backup\nScript /home/backup/backup_home.sh:\n#!/bin/bash\nset -e\nrsync -a --delete /home/ /mnt/backup/home/ >> /var/log/backup-home.log 2>&1\nchmod 750 /home/backup/backup_home.sh\n","explanation":"## Why This Is Asked\nTests practical system automation basics: user scoping, file layout, systemd units, and rsync.\n\n## Key Concepts\n- systemd service and timer\n- rsync options\n- permissions\n- log rotation\n\n## Code Example\n```javascript\n// Example snippets in a Bash mindset for illustration\n```\n\n## Follow-up Questions\n- How would you test the timer without waiting 24h?\n- How would you harden the rsync command for partial failures?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Tesla","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T04:23:21.091Z","createdAt":"2026-01-23T04:23:21.092Z"},{"id":"q-6130","question":"On a RHEL 9 host, you need to grant a non-privileged user limited sudo rights to two diagnostic commands only, without exposing a full shell. Create a dedicated audit user, a matching sudoers rule in /etc/sudoers.d, and ensure all sudo attempts are logged to /var/log/sudo-audit.log. Provide exact commands for user/group creation, sudoers file, and verification steps?","answer":"Create an audit group and user, then restrict sudo via a dedicated file in /etc/sudoers.d. Commands: groupadd auditgrp; useradd -m -s /bin/bash -g auditgrp audit; visudo -f /etc/sudoers.d/audit; conte","explanation":"## Why This Is Asked\nTests practical ability to implement constrained privilege escalation using sudoers, with per-user scoping and centralized logging.\n\n## Key Concepts\n- Sudoers.d for modular rules\n- User_Alias and Cmnd_Alias syntax\n- Defaults logfile for auditing\n- Verification via sudo -l and log inspection\n\n## Code Example\n```bash\nDefaults logfile=\"/var/log/sudo-audit.log\"\nUser_Alias AUD = audit\nCmnd_Alias DIAG = /usr/bin/systemctl status httpd, /usr/bin/journalctl -u httpd\nAUD ALL=(root) NOPASSWD: DIAG\n```\n\n## Follow-up Questions\n- How would you extend this to audit SSH login attempts from the same user?\n- How would you rotate the sudo log without losing history?","diagram":"flowchart TD\n  A[Create audit group] --> B[Create audit user in group]\n  B --> C[Create /etc/sudoers.d/audit with Defaults and Aliases]\n  C --> D[Run sudo -l -U audit to verify permissions]\n  D --> E[Tail /var/log/sudo-audit.log to confirm logging]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Google","Hugging Face"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T10:07:06.502Z","createdAt":"2026-01-23T10:07:06.502Z"},{"id":"q-6198","question":"On a RHEL 9 host, enforce image provenance for all Podman-deployed services by enabling container image signing (cosign), configuring Podman trust policy to reject unsigned images, and creating a minimal rollback path if a signed image fails health checks; include exact commands to set up cosign keys, sign/pull images, edit /etc/containers/policy.json, and a test plan?","answer":"Install cosign, generate keys, sign an image, e.g., cosign generate-key-pair; cosign sign localhost/myapi:latest. Edit /etc/containers/policy.json to default-action 'reject'. Pull and run the signed i","explanation":"## Why This Is Asked\nTests ability to enforce image provenance and perform safe rollbacks in containerized environments, a common production concern.\n\n## Key Concepts\n- Container image signing with cosign\n- Podman trust policies\n- Image digests and rollback strategies\n- Health checks and rollback triggers\n\n## Code Example\n```bash\ncosign generate-key-pair\ncosign sign localhost/myapi:latest\ncat > /etc/containers/policy.json << 'EOF'\n{\n  \"default-action\": \"reject\",\n  \"transports\": [\n    {\"name\": \"docker\", \"action\": \"accept\"}\n  ]\n}\nEOF\npodman pull localhost/myapi:latest\npodman run -d --name api --pull always localhost/myapi:latest\n```\n\n## Follow-up Questions\n- How would you sign multi-arch images and ensure all arches are validated?\n- How would you automate signing and policy tests in CI/CD and roll back on failure?","diagram":"flowchart TD\n  A[Cosign keys] --> B[Sign image]\n  B --> C[Policy.json: reject unsigned]\n  C --> D[Pull/run signed container]\n  D --> E[Health check passes]\n  E --> F[Continue]; E --> G[Rollback to prior digest]","difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Square","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T13:42:02.733Z","createdAt":"2026-01-23T13:42:02.733Z"},{"id":"q-6309","question":"On a RHEL 9 host with two uplinks (eth0 ISP_A, eth1 ISP_B) and a LAN 192.168.100.0/24, implement a dual-WAN router: NAT for outbound, policy routing so web traffic exits via ISP_A and all other traffic via ISP_B, plus a hardened nftables firewall and SSH remains accessible from LAN. Provide exact commands, config files, and a rollback plan?","answer":"Configure dual-WAN with policy routing and NAT: create two routing tables 100 and 101; set default via 203.0.113.1 dev eth0 table 100 and 198.51.100.1 dev eth1 table 101. Mark port 80/443 with fwmark ","explanation":"## Why This Is Asked\nReal-world networks often require reliable dual-WAN setups with policy routing. This tests practical skills while ensuring SSH remains accessible and rollback is straightforward.\n\n## Key Concepts\n- nftables firewall and NAT\n- policy-based routing with fwmark and routing tables\n- ip rule/ip route crafting\n- rollback and test procedures\n\n## Code Example\n```bash\n# example snippet (not exhaustive)\niptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE\n# ...\n```\n\n## Follow-up Questions\n- How would you monitor path distribution and failover latency?\n- How would you handle DNS in this setup?\n","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Oracle","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-23T18:54:54.647Z","createdAt":"2026-01-23T18:54:54.647Z"},{"id":"q-6429","question":"On a production RHEL 9 host, the PostgreSQL data directory is on an LVM LV lv_pgdata inside a LUKS container crypt-pgdata mapped at /dev/mapper/crypt-pgdata, mounted as /var/lib/pgsql. Maintain near-zero downtime while backing up. Provide exact commands to (1) issue a PostgreSQL backup start, (2) create a read-only LVM snapshot during the backup window, (3) mount the snapshot read-only and copy data to /backups/pgsql_base while WAL is streamed, (4) stop the backup and prepare recovery, and (5) remove the snapshot safely. Include crypttab/fstab notes?","answer":"Run `pg_start_backup('lvm-snapshot', true);` to initiate PostgreSQL backup mode, then `lvcreate -s -n pgdata-snap -L 20G vg00/lv_pgdata;` to create the LVM snapshot, followed by `mount -o ro /dev/vg00/pgdata-snap /mnt/pgdata-snap;` to mount it read-only. Copy data with `rsync -aH /mnt/pgdata-snap/ /backups/pgsql_base/;` while WAL streaming continues, then complete with `pg_stop_backup();` and cleanup using `umount /mnt/pgdata-snap; lvremove vg00/pgdata-snap;`.","explanation":"## Why This Is Asked\nTests online backup design with LVM snapshots on an encrypted path, plus PostgreSQL backup/restore workflow.\n\n## Key Concepts\n- LVM snapshots, dm-crypt, pg_start_backup/pg_stop_backup, WAL archiving, PITR\n\n## Code Example\n```javascript\npg_start_backup('lvm-snapshot', true)\nlvcreate -s -n pgdata-snap -L 20G vg00/lv_pgdata\nmount -o ro /dev/vg00/pgdata-snap /mnt/pgdata-snap\nrsync -aH /mnt/pgdata-snap/ /backups/pgsql_base/\npg_stop_backup()\numount /mnt/pgdata-snap\nlvremove vg00/pgdata-snap\n```\n\n## Follow-up Questions\n- How would you automate this with a systemd timer?\n- How would you handle snapshot size estimation and monitoring?\n- What recovery steps would you perform using this backup?","diagram":null,"difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T05:02:17.922Z","createdAt":"2026-01-23T23:45:52.096Z"},{"id":"q-6454","question":"On a fresh RHEL 9 host, enable user quotas on the filesystem hosting /home, create a user quotauser, set a 1 GiB soft and 1.5 GiB hard quota for that user, verify with repquota, and demonstrate enforcement by trying to exceed the quota with a file creation and showing the error?","answer":"Install the quota package, enable usrquota and grpquota on the target filesystem in /etc/fstab, remount the filesystem, run quotacheck -avug to initialize the quota database and quotaon -av to activate quotas, then use setquota -u quotauser 1048576 1572864 0 0 /home to set 1 GiB soft and 1.5 GiB hard limits, verify with quota -u quotauser and repquota /home, and test enforcement by attempting to create a file that exceeds the quota limit.","explanation":"## Why This Is Asked\n\nTests practical implementation of disk quotas, a core administration skill for resource control on RHCSA-level tasks.\n\n## Key Concepts\n\n- Enabling quotas on the target filesystem via fstab and remounting\n- Quota utilities: quotacheck, quotaon, setquota, repquota\n- Interpreting soft vs hard limits and inode limits\n- Quota enforcement and error handling\n\n## Code Example\n\n```bash\n# Install quota tools\nsudo dnf install -y quota quota-tools\n\n# Enable quotas on target FS (example assumes /home is on its own fs)\nsudo sed -i 's/ defaults,/ defaults,usrquota,grpquota/' /etc/fstab\n```","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T04:54:00.103Z","createdAt":"2026-01-24T02:26:33.883Z"},{"id":"q-6583","question":"On a fresh RHEL 9 host, implement a lightweight health check that runs every 5 minutes as a non-login user named 'health'. The script should print the hostname, date, load average, and root disk usage, appending to /var/log/health/health.log. Create the user, script, a systemd service (HealthCheck.service) running as health, and a timer (HealthCheck.timer). Add log rotation for the log file?","answer":"Create user health with system account, script at /home/health/healthcheck.sh that outputs hostname, date, loadavg, and df -h /; redirect to /var/log/health/health.log; set ownership to health. Define","explanation":"## Why This Is Asked\nTests systemd timer usage, per-user daemon execution, and log management in a minimal setup.\n\n## Key Concepts\n- systemd services and timers\n- non-login system users\n- log rotation and permissions\n- scripting idempotency and output formatting\n\n## Code Example\n```javascript\n# HealthCheck.sh (conceptual snippet)\n#!/bin/bash\necho \"$(hostname) $(date) $(cut -d' ' -f1-3 /proc/loadavg) $(df -h / | tail -n1 | awk '{print $2}')\" >> /var/log/health/health.log\n```\n\n## Follow-up Questions\n- How would you extend for multiple disks or exclude /var from the log?\n- How would you test the timer and verify all logs are rotated correctly?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Hashicorp","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T08:54:55.570Z","createdAt":"2026-01-24T08:54:55.570Z"},{"id":"q-6618","question":"On a RHEL 9 host, perform a blue-green deployment for a stateless web app behind Nginx. Maintain two app runners (app-v1 and app-v2) on separate localhost ports, switch traffic with zero downtime, and have a rollback plan. Provide exact systemd unit files, nginx upstream config, SELinux considerations, and a one-command switch procedure to promote v2 and rollback if health checks fail?","answer":"Adopt a blue-green pattern with two app services: app-v1 on 8081 and app-v2 on 8082. Nginx upstream routes to the live port. After staging, run a health check (curl /health) against 8082; if healthy, ","explanation":"## Why This Is Asked\nTests practical deployment orchestration, systemd, Nginx, health checks, rollback, and SELinux considerations in a single-host scenario typical for RHCSA advanced interviews.\n\n## Key Concepts\n- Blue-green deployment and zero-downtime switch\n- systemd unit management for parallel app versions\n- Nginx upstreams, health checks, and reloads\n- SELinux port labeling and policy implications\n- Rollback strategy and observability\n\n## Code Example\n```javascript\n// Conceptual health check snippet (illustrative only)\nasync function healthCheck(url){ try{ const r = await fetch(url); return r.ok; } catch{ return false; } }\n```\n\n## Follow-up Questions\n- How would you automate this with Ansible or a CI/CD pipeline?\n- How would you test failover under load and verify rollback reliability?","diagram":"flowchart TD\n  A[Live: app-v1 on 8081] --> B[Stage: app-v2 on 8082]\n  B --> C[Nginx reload to switch live to 8082]\n  C --> D[Monitor health for 2-3 min]\n  D --> E{Failure?}\n  E -->|Yes| F[Rollback to 8081]\n  E -->|No| G[Decommission 8081]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T10:36:04.708Z","createdAt":"2026-01-24T10:36:04.709Z"},{"id":"q-6833","question":"On a fresh RHEL 9 server, create a lightweight, non-root 'cronuser' that runs a script every 5 minutes via a systemd timer (not cron). The script appends the current date/time to /var/log/uptime.log; ensure log rotation rotates daily and keeps 7 days. Provide exact commands for user creation, script, systemd service and timer units, and logrotate config?","answer":"Create non-root user cronuser; script: /usr/local/bin/uptime_logger.sh appends date to /var/log/uptime.log; make 755; touch and chown /var/log/uptime.log to cronuser. Systemd: uptime-logger.service wi","explanation":"## Why This Is Asked\nAssesses practical ability to implement scheduled tasks without cron using systemd timers, plus correct file permissions and log rotation.\n\n## Key Concepts\n- systemd timers; non-root service accounts; logrotate; idempotent boot-enabled setup.\n\n## Code Example\n```ini\n# uptime-logger.service\n[Unit]\nDescription=Log uptime\n[Service]\nUser=cronuser\nExecStart=/usr/local/bin/uptime_logger.sh\n```\n\n```ini\n# uptime-logger.timer\n[Unit]\nDescription=Run every 5 minutes\n[Timer]\nOnBootSec=5min\nOnUnitActiveSec=5min\nUnit=uptime-logger.service\n[Install]\nWantedBy=timers.target\n```\n\n```bash\n# /etc/logrotate.d/uptime-logger\n /var/log/uptime.log {\n   daily\n   rotate 7\n   copytruncate\n   missingok\n   notifempty\n }\n```\n\n## Follow-up Questions\n- How would you troubleshoot if the timer does not fire?\n- How would you adapt this to multiple servers or centralize logs?","diagram":"flowchart TD\n  A[Create cronuser] --> B[Write script]\n  B --> C[Create systemd service]\n  C --> D[Create systemd timer]\n  D --> E[Enable timer]\n  E --> F[Configure logrotate]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Discord"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-24T19:25:30.861Z","createdAt":"2026-01-24T19:25:30.861Z"},{"id":"q-6920","question":"On a fresh RHEL 9 host, create a small JSON endpoint that returns {\"status\":\"ok\"} on GET /status, served by Python 3, running as a non-root user 'webstat' on port 8081. Provide exact commands to 1) create user, 2) write the Python script, 3) create a systemd service (and enable on boot), 4) set up log rotation for /var/log/webstat.log, 5) open firewall port 8081, 6) label SELinux for the port and log file, and 7) a basic test plan to verify the endpoint?","answer":"Create user webstat; write /opt/webstat/status.py using Python's http.server to return {\"status\":\"ok\"} on /status port 8081; systemd unit webstat.service with User=webstat and ExecStart=/usr/bin/python3 /opt/webstat/status.py; enable service; configure logrotate for /var/log/webstat.log; open firewall port 8081/tcp; set SELinux port type for 8081 and file context for log; test endpoint with curl and verify service status.","explanation":"## Why This Is Asked\nTests practical RHCSA fundamentals: user management, scripting, systemd service configuration with non-root execution, log handling, firewall management, and SELinux configuration in a realistic mini-service deployment.\n\n## Key Concepts\n- Systemd service context with User directive for non-root execution\n- Python HTTP server implementation for JSON endpoints\n- Log rotation configuration and file permissions\n- Firewalld port management and SELinux port labeling\n- Service verification and testing methodology\n\n## Code Example\n```python\n# status.py (simplified)\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nimport json\n\nclass StatusHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/status':\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps({'status': 'ok'}).encode())\n        else:\n            self.send_response(404)\n            self.end_headers()\n\nif __name__ == '__main__':\n    server = HTTPServer(('0.0.0.0', 8081), StatusHandler)\n    server.serve_forever()\n```","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["NVIDIA","Netflix","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T05:52:46.603Z","createdAt":"2026-01-24T22:53:43.667Z"},{"id":"q-7025","question":"On a RHEL 9 host running a single Java API behind Nginx, design a zero-downtime upgrade from OpenJDK 11 to 17 without changing the app bundle. Use blue/green deployment with two systemd services, a load balancer, and a rollback plan. Include how you isolate JDKs, update service unit files, health checks, SELinux considerations, and audit logging to capture upgrade events?","answer":"Blue/green rollout with two systemd services api-v1 and api-v2 and Nginx as load balancer. Install OpenJDK 17 at /usr/lib/jdk-17; keep JDK11 for api-v1. Add systemd drop-ins to set JAVA_HOME per servi","explanation":"## Why This Is Asked\nThis tests real-world upgrade discipline, blue/green deployment, and service hygiene without downtime. It also checks multi-JDK management, systemd customization, health checks, rollback planning, and how SELinux and audit trails are preserved during runtime changes.\n\n## Key Concepts\n- Blue/green deployments\n- systemd drop-ins and JAVA_HOME isolation\n- Health checks and traffic-shaping with Nginx\n- Rollback strategies and downtime minimization\n- SELinux context preservation and audit rules\n\n## Code Example\n```bash\n# Install JDK 17\nsudo dnf install -y java-17-openjdk\n\n# Example drop-in snippet\nsudo mkdir -p /etc/systemd/system/api-v2.service.d\nsudo tee /etc/systemd/system/api-v2.service.d/override.conf > /dev/null <<'EOF'\n[Service]\nEnvironment=JAVA_HOME=/usr/lib/jdk-17\nEOF\nsudo systemctl daemon-reload\n```\n\n## Follow-up Questions\n- How would you automate health checks and traffic shift?\n- How would you verify rollback integrity and log auditing during upgrade?","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T05:56:51.781Z","createdAt":"2026-01-25T05:56:51.781Z"},{"id":"q-7045","question":"On a RHEL 9 host, set up a lightweight DNS caching resolver using dnsmasq for a local network 192.168.100.0/24. Bind it to 127.0.0.1 and 192.168.100.2, enable systemd service, ensure it starts on boot, log queries to /var/log/dnsmasq.log with rotation, and provide a minimal firewall rule allowing 53/UDP/TCP only to the local subnet. Include exact commands for installation, config, service, and logrotate?","answer":"Install dnsmasq, enable and start it; configure listen-address=127.0.0.1,192.168.100.2 and interface eth0; enable log-queries to /var/log/dnsmasq.log; add a logrotate entry. Use a firewall rich rule t","explanation":"## Why This Is Asked\nTests practical DNS caching setup, systemd service handling, log rotation, and network filter hardening on a single host.\n\n## Key Concepts\n- dnsmasq basics and listen-address\n- systemd service startup\n- log rotation and log levels\n- firewalld vs. nftables rich rules\n- basic network security for a local subnet\n\n## Code Example\n```bash\n# Install and start\ndnf install -y dnsmasq\nsystemctl enable --now dnsmasq\n\n# Configure\ncat > /etc/dnsmasq.conf << 'CONF'\nlisten-address=127.0.0.1,192.168.100.2\ninterface=eth0\nlog-queries\nlog-facility=/var/log/dnsmasq.log\nCONF\nsystemctl restart dnsmasq\n```\n\n```bash\n# Logrotate\ncat > /etc/logrotate.d/dnsmasq << 'LOG'\n/var/log/dnsmasq.log {\n  weekly\n  rotate 4\n  missingok\n  notifempty\n  create 0640 root wheel\n}\nLOG\n```\n\n```bash\n# Lock down DNS to LAN\nfirewall-cmd --permanent --add-service=dns\nfirewall-cmd --permanent --add-rich-rule 'rule family=\"ipv4\" source address=\"192.168.100.0/24\" port protocol=\"tcp\" port=\"53\" accept'\nfirewall-cmd --reload\n```\n\n## Follow-up Questions\n- How would you scale this if the LAN expands to multiple subnets? What changes to dnsmasq.conf would you consider?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","MongoDB","NVIDIA"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T07:03:12.344Z","createdAt":"2026-01-25T07:03:12.344Z"},{"id":"q-7165","question":"On a RHEL 9 host, deploy a Podman container hosting a Go API behind Nginx. Run the container as a non-root user, drop all capabilities except NET_BIND_SERVICE, map /var/lib/api, and create a minimal SELinux policy that allows the container to read /var/lib/api and bind port 8080. Include the podman run command, systemd unit snippet with limits, and a rollback plan?","answer":"Implemented: run Podman rootless with UID 1001, drop ALL capabilities, keep NET_BIND_SERVICE, map /var/lib/api as read-only, and attach a minimal SELinux module allowing container_t read of /var/lib/a","explanation":"## Why This Is Asked\nTests practical hardening: container least privilege, SELinux policy, and service orchestration.\n\n## Key Concepts\n- Rootless Podman\n- Linux capabilities and dropping them\n- SELinux policy modules for container access\n- Systemd unit customization with resource limits\n- Rollback and auditability\n\n## Code Example\n```javascript\npodman run --rm -d --name api --user 1001 --cap-drop ALL --cap-add NET_BIND_SERVICE -p 8080:8080 -v /var/lib/api:/var/lib/api:ro myrepo/go-api:latest\n```\n\n## Follow-up Questions\n- How would you test the SELinux policy and ensure no unintended access?\n- How would you automate rollout and rollback in CI/CD?","diagram":"flowchart TD\n  A[Non-root Podman] --> B[SELinux policy] \n  B --> C[Port 8080 binding] \n  C --> D[systemd unit] \n  D --> E[rollback]","difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T11:44:10.154Z","createdAt":"2026-01-25T11:44:10.154Z"},{"id":"q-7202","question":"On a fresh RHEL 9 host, implement a tiny file-server daemon: a Python 3 script that serves the directory /srv/files using http.server on port 8080. Run it as a dedicated non-login user 'filesrv' via systemd, ensuring automatic restart on failure. Configure log rotation to write access logs to /var/log/filesrv/access.log with daily rotation and compression. Provide exact commands to create the user, the script, the systemd unit, and the logrotate config; include how to test?","answer":"Create user: useradd -r -s /sbin/nologin filesrv. Script at /opt/filesrv/server.py serves /srv/files on 8080 with Python's http.server. Systemd unit: ExecStart=/usr/bin/python3 /opt/filesrv/server.py;","explanation":"## Why This Is Asked\n\nAssesses practical daemon creation, non-root isolation, and observability wiring: script, service, and log rotation in a cohesive workflow.\n\n## Key Concepts\n\n- Systemd service units and Restart policies\n- Non-login user isolation\n- Python HTTP server basics\n- Log rotation configuration and permissions\n\n## Code Example\n\n```javascript\n// Placeholder: not required in production answer\n```\n\n## Follow-up Questions\n\n- How would you add basic authentication to the server?\n- How would you harden the environment (SELinux, firewalld) for port 8080?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Cloudflare","LinkedIn"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T13:44:28.128Z","createdAt":"2026-01-25T13:44:28.129Z"},{"id":"q-7277","question":"On a fresh RHEL 9 server, configure SSH so that only members of a new group devs can login, using key-based auth only, and grant passwordless sudo to that group. Provide exact commands for: creating group and user, generating and deploying a key, sshd_config edits (include AllowGroups and PasswordAuthentication settings), a sudoers.d entry, and a quick verification plan?","answer":"Create group devs; useradd -m -G devs devadmin. On client: ssh-keygen -t rsa -b 2048 -f id_rsa_devadmin -N ''; ssh-copy-id -i id_rsa_devadmin.pub devadmin@host. On server: edit /etc/ssh/sshd_config: A","explanation":"## Why This Is Asked\nTests the ability to implement secure access control with group-based SSH, key authentication, and per-group sudo without passwords. It covers account provisioning, SSH configuration, and basic hardening.\n\n## Key Concepts\n- Group-based SSH access (AllowGroups)\n- Key-based authentication and disabling passwords\n- Per-group sudoers (NOPASSWD)\n- SSH service reload and verification\n\n## Code Example\n```bash\n# create and assign\ngroupadd devs\nuseradd -m -G devs devadmin\n\n# client side\nssh-keygen -t rsa -b 2048 -f id_rsa_devadmin -N ''\nssh-copy-id -i id_rsa_devadmin.pub devadmin@host\n\n# server side (sshd_config)\nAllowGroups devs\nPasswordAuthentication no\nPubkeyAuthentication yes\nsystemctl reload sshd\n\n# sudoers\necho '%devs ALL=(ALL) NOPASSWD: ALL' > /etc/sudoers.d/devs\nchmod 440 /etc/sudoers.d/devs\n```\n\n## Follow-up Questions\n- How would you handle revoking access if a key is compromised?\n- What logs would you inspect to verify SSH login attempts are from authorized keys?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-25T16:41:16.685Z","createdAt":"2026-01-25T16:41:16.685Z"},{"id":"q-7415","question":"On a RHEL 9 host, configure a TLS-enabled rsyslog forward to a remote log host at loghost.internal:6514. Use certificate-based authentication, generate a local CA, issue client/server certs, and configure both sides for TLS. Include exact commands and config snippets, and outline a rollback plan with minimal downtime?","answer":"Install rsyslog with TLS support, generate a certificate authority and issue client/server certificates, configure the client with TLS driver and certificate-based authentication pointing to loghost.internal:6514, restart the rsyslog service, validate connectivity using logger and journalctl, and monitor traffic with tcpdump to confirm encrypted transmission.","explanation":"## Why This Is Asked\nThis evaluates practical implementation of secure log forwarding, TLS certificate management, and operational planning for production environments.\n\n## Key Concepts\n- rsyslog TLS implementation and configuration\n- X.509 certificate authority and certificate generation\n- Client/server TLS authentication using the gtls driver\n- Minimal downtime deployment and rollback procedures\n\n## Code Example\n```bash\n# Client: /etc/rsyslog.conf snippet\n$DefaultNetstreamDriverCAFile /etc/pki/CA/cacert.pem\n$ActionSendStreamDriver gtls\n$ActionSendStreamDriverMode 1\n*.* @@loghost.internal:6514\n```","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Tesla"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T06:40:01.328Z","createdAt":"2026-01-25T22:29:21.547Z"},{"id":"q-7468","question":"On a fresh RHEL 9 host, deploy a lightweight static file server that serves /srv/static on port 8080. Run as a non-root user 'staticsrv', auto-start at boot via systemd, and log all output to /var/log/staticsrv.log with daily rotation. Include exact commands for user creation, directory setup, a systemd unit, a logrotate config, and a firewall rule restricting access to 192.168.100.0/24. How would you verify proper operation?","answer":"Create a non-root user and directory structure, configure a systemd service to run Python's http.server on port 8088 with logging redirected to /var/log/staticsrv.log, enable the service for automatic startup, implement daily log rotation via logrotate, and restrict access to the 192.168.100.0/24 subnet using firewall rules.","explanation":"## Why This Is Asked\nThis question evaluates the ability to integrate multiple fundamental RHEL administration skills: systemd service management, non-root user operations, basic logging configuration, firewall rule implementation, and log rotation setup.\n\n## Key Concepts\n- Systemd service configuration for lightweight web servers\n- Non-root user execution with appropriate permissions\n- Log redirection and automated log rotation\n- Network access control using firewall-cmd rich rules\n- Service verification and testing methodologies\n\n## Code Example\n```bash\n# (implementation commands embedded in answer)\n```\n\n## Follow-up Questions\n- How would you implement TLS encryption for this service?\n- What monitoring solutions would you recommend for log size and service uptime?","diagram":"flowchart TD\n  A[Start] --> B[Create user & dir]\n  B --> C[Systemd unit]\n  C --> D[Enable & start]\n  D --> E[Firewall rule]\n  E --> F[Logrotate]\n  F --> G[Verify with curl]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Lyft","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T05:35:06.621Z","createdAt":"2026-01-26T02:42:39.406Z"},{"id":"q-7555","question":"On a RHEL 9 host, a legacy app runs as user 'legacy' and stores data under /var/lib/legacyapp and reads its config from /etc/legacyapp/config.yaml. Implement a minimal SELinux policy module that allows legacy_t to read that config and write to data, but denies all other network and file access. Provide exact commands to create labels, write the policy, install the module, and verify with audit logs; also include a safe rollback plan?","answer":"Create a dedicated SELinux domain legacy_app_t and a small policy module. Label config.yaml as legacy_config_t and data dir as legacy_data_t, then write a module via checkmodule/semodule. Allow legacy","explanation":"## Why This Is Asked\nThis tests knowledge of SELinux, policy modules, labeling, auditing, rollback.\n\n## Key Concepts\n- SELinux domains and types\n- Policy module creation with checkmodule/semodule\n- File context labeling with semanage fcontext/restorecon\n- Audit rules and ausearch/auseom\n- Rollback plans and safety\n\n## Code Example\n```javascript\n// Note: SELinux policy is typically written in .te/.pp files; this is a placeholder snippet to show intent.\n// Create and load policy modules in practice.\n```\n\n## Follow-up Questions\n- How would you test policy correctness without reboot?\n- How would you adapt if the app needs to write logs to /var/log/legacyapp?","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Google","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T07:35:42.754Z","createdAt":"2026-01-26T07:35:42.757Z"},{"id":"q-7802","question":"On a fresh RHEL 9 server, configure time synchronization using chrony to synchronize with **pool.ntp.org**, ensure **chronyd** starts on boot, and verify the clock is synchronized within **0.5 seconds**. Provide exact commands and a quick validation step (chronyc tracking and date)?","answer":"Install chrony, enable chronyd, configure pool.ntp.org, and verify: sudo dnf install -y chrony; sudo systemctl enable --now chronyd; sudo sed -i \\\"s/^server .*/server pool.ntp.org iburst/\\\" /etc/chron","explanation":"## Why This Is Asked\nChecks practical time-sync setup using chrony, a common task for reliable logging, authentication, and scheduling.\n\n## Key Concepts\n- chrony vs ntpd\n- /etc/chrony.conf syntax\n- systemctl enable/disable\n- chronyc tracking\n\n## Code Example\n```bash\nchronyc tracking\ndate\n```\n\n## Follow-up Questions\n- How to handle NTP stratum drift in a disconnected network\n- Troubleshooting: offset, jitter, or unreachable pool.ntp.org","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Bloomberg","Hashicorp"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T18:53:44.856Z","createdAt":"2026-01-26T18:53:44.856Z"},{"id":"q-7857","question":"On a fresh RHEL 9 host, replace a daily cron backup with a systemd timer-based workflow. Create a non-root user 'dbbackup', write a script at /usr/local/bin/backup.sh that rsyncs /var/lib/db/ to /mnt/backup/db/ with --archive --delete and logs to /var/log/dbbackup.log. Implement systemd units: /etc/systemd/system/backup.service (User=dbbackup, ExecStart=/usr/local/bin/backup.sh) and /etc/systemd/system/backup.timer configured to trigger daily at 02:30, Persistent=true. Enable and start the timer; verify with systemctl list-timers. Add an audit rule for /var/lib/db. Provide exact commands and config blocks?","answer":"Create dbbackup user, script /usr/local/bin/backup.sh with rsync -a --delete /var/lib/db/ /mnt/backup/db/ | logger -t dbbackup; systemd service backup.service (User=dbbackup, ExecStart=/usr/local/bin/","explanation":"## Why This Is Asked\nTests migration from cron to systemd timers and practical backup workflow, including permissions, logging, auditing.\n\n## Key Concepts\n- systemd timers vs cron\n- unprivileged users and file permissions\n- rsync backup semantics\n- auditing with auditd\n\n## Code Example\n```bash\n#!/bin/bash\nrsync -a --delete /var/lib/db/ /mnt/backup/db/ | logger -t dbbackup\n```\n\n## Follow-up Questions\n- How would you verify timer reliability during DST transitions?\n- How would you implement retention and failure alerts?\n","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-26T20:43:29.949Z","createdAt":"2026-01-26T20:43:29.949Z"},{"id":"q-7948","question":"On a RHEL 9 host, attach a new 50 GiB disk at /dev/sdb and provision it as a data volume using LVM: pvcreate /dev/sdb; vgcreate data /dev/sdb; lvcreate -L50G -n data data. Format the LV with XFS, mount at /data with noatime, ensure it auto-mounts on boot, and label SELinux to let httpd read files there. Include exact commands, fstab entry, and a minimal SELinux policy via booleans. Also provide a rollback plan if boot fails?","answer":"```bash\n# Initialize the physical volume\npvcreate /dev/sdb\n\n# Create the volume group and logical volume\nvgcreate data /dev/sdb\nlvcreate -L50G -n data data\n\n# Format with XFS filesystem\nmkfs.xfs /dev/data/data\n\n# Create mount point and mount with noatime\nmkdir -p /data\nmount /dev/data/data /data -o noatime\n\n# Add to fstab for automatic mounting on boot\necho '/dev/data/data /data xfs defaults,noatime 0 0' >> /etc/fstab\n\n# Configure SELinux for httpd access\nsetsebool -P httpd_can_network_connect 1\nsemanage fcontext -a -t httpd_sys_content_t '/data(/.*)?'\nrestorecon -Rv /data\n```","explanation":"## Why This Is Asked\n\nThis question evaluates practical storage provisioning, filesystem management, boot-time persistence, and SELinux configuration in a comprehensive real-world scenario. Production environments demand correct LVM implementation, XFS formatting, proper mount options, and secure SELinux posture.\n\n## Key Concepts\n\n- **LVM Architecture**: Physical Volume → Volume Group → Logical Volume hierarchy\n- **XFS Filesystem**: High-performance formatting and optimization techniques\n- **fstab Configuration**: Ensuring persistent mounting across system reboots\n- **SELinux Management**: Context labeling and boolean configuration for Apache/httpd access control\n\n## Implementation Notes\n\nThe solution follows industry best practices:\n- Sequential LVM setup ensures proper layering\n- XFS provides optimal performance for data volumes\n- `noatime` mount option reduces unnecessary disk I/O\n- SELinux `httpd_sys_content_t` context allows Apache to serve content securely\n- `setsebool -P` makes boolean changes persistent\n\n## Rollback Plan\n\nIf the system fails to boot after these changes:\n1. Boot from rescue media or single-user mode\n2. Comment out the problematic fstab entry: `sed -i 's|^/dev/data/data|#/dev/data/data|' /etc/fstab`\n3. Remove the LV and VG: `lvremove data/data && vgremove data`\n4. Wipe the PV: `pvremove /dev/sdb`\n5. Reboot normally","diagram":"flowchart TD\n  A[Attach /dev/sdb] --> B[PV/VG/LV] \n  B --> C[Format XFS] \n  C --> D[Mount /data] \n  D --> E[fstab Persistence] \n  E --> F[SELinux Context & Booleans] \n  F --> G[Rollback Plan]","difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Google","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T05:52:44.073Z","createdAt":"2026-01-27T02:27:28.510Z"},{"id":"q-7977","question":"On a RHEL 9 host running a web app on port 8080, implement an nftables firewall that allows connections to 8080 only from 10.0.0.0/24, blocks others, logs drops to /var/log/nftables.log, and persists across reboots. Provide the exact commands and a minimal conf snippet; demonstrate validation with nc and curl from an allowed host and a disallowed host?","answer":"Configure nftables to allow 8080 only from 10.0.0.0/24; default drop; log drops to /var/log/nftables.log; persist via /etc/nftables.conf and systemctl enable nftables. Apply with nft -f /etc/nftables.","explanation":"## Why This Is Asked\nThis tests practical firewall skills, nftables syntax, persistence, and validation in a real web-app scenario.\n\n## Key Concepts\n- nftables inet table, filter, and port/IP matching\n- Whitelisting, default deny, logging, persistence\n- Validation: functional tests and log inspection\n\n## Code Example\n```bash\n# /etc/nftables.conf\n#!/usr/sbin/nft -f\ntable inet filter {\n  chain input { type filter hook input priority 0; policy drop; }\n  tcp dport 8080 ip saddr 10.0.0.0/24 accept\n  ct state established,related accept\n  log prefix 'nft input drop: ' flags all\n  drop\n}\n```\n\n## Follow-up Questions\n- How would you adapt this for IPv6 and rate-limiting? \n- How would you test for bypass attempts from local host?","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","MongoDB","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T04:14:05.354Z","createdAt":"2026-01-27T04:14:05.356Z"},{"id":"q-8173","question":"On a fresh RHEL 9 server, create a new user named dev who cannot log in but can run a limited set of privileged commands via sudo. Provide exact commands to (1) create the user, disable login, (2) add a restricted sudoers entry allowing only running /usr/bin/systemctl restart httpd and /usr/bin/journalctl -u httpd with no password, and (3) verify the configuration with a test that shows only these commands are allowed and that other commands are rejected?","answer":"Create user: useradd -m dev; disable login: usermod -s /sbin/nologin dev; sudoers: echo 'dev ALL=(ALL) NOPASSWD: /usr/bin/systemctl restart httpd, /usr/bin/journalctl -u httpd' > /etc/sudoers.d/dev; c","explanation":"## Why This Is Asked\n\nTests ability to implement restricted sudo access for a non-login user and validate it safely. It also covers path correctness, permissions, and basic auditing implications.\n\n## Key Concepts\n\n- Linux user lifecycle: no-login accounts and sudo granularity\n- Sudoers file syntax and security considerations\n- Testing restricted access and avoiding privilege drift\n\n## Code Example\n\n```javascript\n// Placeholder: real commands shown in the answer\n```\n\n## Follow-up Questions\n\n- How would you extend this to log every sudo invocation for auditing?\n- What risks arise if httpd restarts fail and how would you handle retries?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","LinkedIn","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T13:16:30.555Z","createdAt":"2026-01-27T13:16:30.555Z"},{"id":"q-8341","question":"On a RHEL 9 host currently using firewalld, migrate to nftables with zero downtime, implement a strict default-deny policy, and apply a rate limit that allows at most 5 new SSH connections per minute per source IP while continuing to serve existing services. Provide exact commands, an nftables.conf snippet, verification steps, and a rollback plan?","answer":"Install nftables and migrate: dnf -y install nftables; systemctl stop firewalld; systemctl disable firewalld; systemctl enable --now nftables; configure /etc/nftables.conf with default drop, loopback,","explanation":"## Why This Is Asked\n\nEvaluates practical firewall migration, minimal downtime, and robust security controls.\n\n## Key Concepts\n\n- nftables syntax and rulesets\n- stepwise migration without losing reachability\n- verification and monitoring\n- rollback and recoverability\n\n## Code Example\n\n```conf\n# /etc/nftables.conf\nflush ruleset\ntable inet filter {\n  chain input { type filter hook input priority 0; policy drop;\n    iifname \"lo\" accept\n    ct state established,related accept\n    tcp dport 22 ct state new limit rate 5/minute burst 10 accept\n  }\n}\n```\n\n## Follow-up Questions\n\n- How would you test SSH reachability during migration from multiple networks?\n- What changes if ipv6 is used for SSH?\n","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-27T20:39:52.866Z","createdAt":"2026-01-27T20:39:52.866Z"},{"id":"q-8409","question":"On a RHEL 9 server hosting a critical web service, implement zero-downtime deployment with a versioned app directory and a symlink swap. Deploy to /opt/myapp/releases/vX, run a five-minute canary health check at http://localhost:8080/health, then swap /opt/myapp/current and reload the service; rollback by re-pointing current to the previous version and restarting. What exact steps and commands would you use to implement this deployment strategy?","answer":"Here's a complete zero-downtime deployment implementation for RHEL 9:\n\n**Deployment Script:**\n```bash\n#!/usr/bin/env bash\nset -euo pipefail\n\n# Configuration\nNEW_VER=\"/opt/myapp/releases/v$(date +%Y%m%d_%H%M%S)\"\nCURRENT=\"/opt/myapp/current\"\nPREV=\"/opt/myapp/previous\"\nCANARY_URL=\"http://localhost:8080/health\"\n\n# 1. Deploy new version\nmkdir -p /opt/myapp/releases\ncp -r /path/to/new/build \"$NEW_VER\"\n\n# 2. Five-minute canary health check\necho \"Starting canary health check...\"\nfor i in {1..60}; do\n    if curl -fsS \"$CANARY_URL\" | grep -q '\"status\":\"ok\"'; then\n        echo \"Health check $i/60 passed\"\n    else\n        echo \"Health check failed at attempt $i\"\n        rm -rf \"$NEW_VER\"\n        exit 1\n    fi\n    sleep 5\ndone\n\n# 3. Atomic symlink swap\nif [ -L \"$CURRENT\" ]; then\n    ln -sf \"$(readlink \"$CURRENT\")\" \"$PREV\"\nfi\nln -sfn \"$NEW_VER\" \"$CURRENT\"\n\n# 4. Reload service without downtime\nsystemctl reload myapp.service || systemctl restart myapp.service\n\n# 5. Verify new deployment\nsleep 2\nif ! curl -fsS \"$CANARY_URL\" | grep -q '\"status\":\"ok\"'; then\n    echo \"Deployment failed, initiating rollback...\"\n    if [ -L \"$PREV\" ]; then\n        ln -sfn \"$(readlink \"$PREV\")\" \"$CURRENT\"\n        systemctl restart myapp.service\n    fi\n    exit 1\nfi\n\necho \"Deployment successful!\"\n```\n\n**Manual Commands:**\n```bash\n# Deploy\n./deploy.sh\n\n# Manual rollback\nln -sfn /opt/myapp/releases/v20240101_120000 /opt/myapp/current\nsystemctl restart myapp.service\n```","explanation":"## Why This Is Asked\nThis question evaluates practical experience with production deployment strategies beyond basic service management. It tests the ability to plan, execute, and maintain service availability while implementing robust deployment and rollback procedures.\n\n## Key Concepts\n- **Atomic deployments** using versioned directories and symlinks for instant rollback capability\n- **Health checks and canary testing** to validate deployments before serving production traffic\n- **Rollback procedures** with idempotent operations and proper service state management\n- **Systemd integration** leveraging reload functionality for zero-downtime transitions\n\n## Code Example\n```bash\n#!/usr/bin/env bash\n# Note: Requires systemd service file with ExecReload configured for graceful restart\n```","diagram":"flowchart TD\n  A[Build vN] --> B{Health check pass?}\n  B -->|Yes| C[Swap symlink to vN+1]\n  C --> D[Restart service]\n  B -->|No| E[Rollback to vN]","difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Plaid","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-28T06:01:52.905Z","createdAt":"2026-01-27T23:34:07.506Z"},{"id":"q-933","question":"On a fresh RHEL 9 installation with a 120 GB disk, implement an LVM layout: ROOT 40G, HOME 40G, VAR 40G, all using XFS. Create PV, VG, and LVs, format, and mount at /, /home, /var with fstab. Enable and configure firewalld to allow http and https. Ensure SELinux is enforcing. Create a non-root user 'dev' and add to the wheel group with sudo privileges. Show commands and rationale?","answer":"I would create a single PV on /dev/sda, a VG named rhel, and three LVs: root, home, var at 40G each. After mkfs.xfs on each, mount them to /, /home, /var and persist in /etc/fstab. Enable firewalld an","explanation":"## Why This Is Asked\nTests practical, real-world sysadmin tasks: LVM planning, filesystem layout, boot/root considerations, firewall and SELinux configuration, and user privilege management.\n\n## Key Concepts\n- LVM: pvcreate, vgcreate, lvcreate\n- Filesystems: XFS and fstab\n- Security: SELinux enforcing and wheel-based sudo\n- Networking: firewalld http/https rules\n\n## Code Example\n```bash\npvcreate /dev/sda\nvgcreate rhel /dev/sda\nlvcreate -L40G -n root rhel\nlvcreate -L40G -n home rhel\nlvcreate -L40G -n var rhel\nmkfs.xfs /dev/rhel/root\nmkfs.xfs /dev/rhel/home\nmkfs.xfs /dev/rhel/var\nmount /dev/rhel/root /\nmkdir -p /home /var\nmount /dev/rhel/home /home\nmount /dev/rhel/var /var\n# /etc/fstab entries would reference /dev/rhel/... set here\nsystemctl enable --now firewalld\nfirewall-cmd --permanent --add-service=http\nfirewall-cmd --permanent --add-service=https\nfirewall-cmd --reload\nsetenforce 1\nsed -i 's/^SELINUX=.*/SELINUX=enforcing/' /etc/selinux/config\nuseradd -m dev\nusermod -aG wheel dev\n```\n\n## Follow-up Questions\n- How would you resize LVs while preserving data?\n- How would you verify SELinux contexts after mounting new filesystems?","diagram":"flowchart TD\n  A[Disk] --> B[PV] \n  B --> C[VG] \n  C --> D[LVs: root, home, var] \n  D --> E[Mounts: /, /home, /var] \n  E --> F[Services: firewalld, SELinux, sudo]","difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","IBM","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T15:42:25.882Z","createdAt":"2026-01-12T15:42:25.882Z"}],"subChannels":["general"],"companies":["Adobe","Airbnb","Amazon","Anthropic","Apple","Bloomberg","Citadel","Cloudflare","Coinbase","Databricks","Discord","DoorDash","Goldman Sachs","Google","Hashicorp","Hugging Face","IBM","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Netflix","OpenAI","Oracle","PayPal","Plaid","Robinhood","Salesforce","Scale Ai","Snap","Snowflake","Square","Stripe","Tesla","Twitter","Two Sigma","Uber","Zoom"],"stats":{"total":92,"beginner":39,"intermediate":28,"advanced":25,"newThisWeek":36}}