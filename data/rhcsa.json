{"questions":[{"id":"q-1023","question":"Design a centralized, tamper-evident logging pipeline for 6 RHEL hosts. Include: enable persistent journald, forward logs over TLS to a central collector, configure rotation/retention, protect in transit with certificate-based auth, and a rollback/validation plan that proves delivery during outages. Outline testing steps and failure scenarios?","answer":"Enable persistent journald on all six hosts; configure rsyslog to forward logs via TLS to a central collector with certificate-based authentication; enforce rotation/retention (90 days) and archive to","explanation":"## Why This Is Asked\nConcrete, scalable, secure logging is critical in production. This question tests practical setup, TLS, journald/rsyslog integration, retention, and failover planning.\n\n## Key Concepts\n- systemd-journald persistent storage\n- TLS-encrypted log forwarding (rsyslog/omfwd)\n- log rotation and retention policies\n- log integrity and rollback strategies\n- outage/failover validation\n\n## Code Example\n```javascript\n// Simple hash of a log line to simulate tamper-detection\nconst crypto = require('crypto');\nfunction hashLine(line){ return crypto.createHash('sha256').update(line).digest('hex'); }\n```\n\n## Follow-up Questions\n- How would you verify end-to-end delivery during a network outage?\n- How would you rotate encryption certificates without dropping logs?","diagram":"flowchart TD\n  A[Hosts] --> B[Local journald]\n  B --> C[rsyslog forward]\n  C --> D[Central TLS collector]\n  D --> E[Archive/Retention]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Hashicorp"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T19:35:30.051Z","createdAt":"2026-01-12T19:35:30.051Z"},{"id":"q-1118","question":"On a RHEL 9 host, a service named app writes to /srv/app/data. After deployment, SELinux denials prevent writes. Without disabling SELinux, outline exact, implementable steps to restore functionality, including identifying the AVC, creating a targeted policy module with audit2allow, loading it, labeling the data directory, and validating the fix with a controlled write and audit checks?","answer":"Identify AVCs with ausearch -m avc -ts today | tail. Build a policy with: ausearch -m avc -ts today | audit2allow -M app_fix; load: semodule -i app_fix.pp. Label: semanage fcontext -a -t app_data_t '/","explanation":"## Why This Is Asked\nTests SELinux troubleshooting, policy generation, and safe remediation without disabling security controls.\n\n## Key Concepts\n- AVCs and audit2allow\n- Custom SELinux policy modules\n- File context labeling and restorecon\n- Validation via audits and controlled writes\n\n## Code Example\n```bash\n# 1) Identify AVCs from today\nausearch -m avc -ts today | tail\n# 2) Create a policy module\nausearch -m avc -ts today | audit2allow -M app_fix\n# 3) Load the policy\nsemodule -i app_fix.pp\n# 4) Label directory and content\nsemanage fcontext -a -t app_data_t '/srv/app/data(/.*)?'\nrestorecon -R /srv/app/data\n```\n\n## Follow-up Questions\n- How would you adjust this if the data directory is on NFS?\n- How can you troubleshoot if the policy still blocks legitimate writes after labeling?","diagram":"flowchart TD\n  A[App writes to /srv/app/data] --> B{AVC denied}\n  B --> C[Audit log shows AVC]\n  C --> D[Create policy with audit2allow]\n  D --> E[Load policy with semodule]\n  E --> F[Label dir with semanage/restorecon]\n  F --> G[Test write succeeds]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Hugging Face","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T23:27:33.371Z","createdAt":"2026-01-12T23:27:33.371Z"},{"id":"q-1148","question":"On a RHEL 8 server, implement a daily backup of /home/userdata to /backup/userdata-YYYYMMDD.tgz, exclude caches and temp dirs, preserve permissions, and generate a sha256 checksum. Schedule at 02:30 via cron and rotate backups to keep last 7 days. Provide commands and a script outline?","answer":"Use a cron-driven backup with tar -p and excludes, plus a sha256 checksum and a 7-day rotation. Example approach: create /backup if needed, tar czpf /backup/userdata-YYYY-MM-DD.tgz -p --exclude patter","explanation":"## Why This Is Asked\nTests practical backup scripting skills: tar with permissions, exclude patterns, integrity checks, cron scheduling, and simple rotation.\n\n## Key Concepts\n- tar with permission preservation\n- --exclude patterns\n- sha256sum checksums\n- cron scheduling\n- rotation by date\n\n## Code Example\n```bash\n#!/bin/bash\nDATE=$(date +%F)\nSRC=\"/home/userdata\"\nDEST=\"/backup\"\nTAR=\"$DEST/userdata-$DATE.tgz\"\nEXCLUDES=\"--exclude='**/.cache' --exclude='**/tmp'\"\ntar czpf \"$TAR\" -p $EXCLUDES \"$SRC\"\nsha256sum \"$TAR\" > \"$TAR.sha256\"\nfind \"$DEST\" -name 'userdata-*.tgz' -mtime +7 -delete\n```\n\n## Follow-up Questions\n- How would you implement incremental backups?\n- How would you verify restoration from a random backup file?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Instacart","Lyft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T01:33:46.097Z","createdAt":"2026-01-13T01:33:46.097Z"},{"id":"q-1169","question":"Design and implement an encrypted root on LVM for a production RH host. Boot partition remains unencrypted; the root filesystem sits on a LUKS2 container inside an LVM PV, with a keyfile for unattended boot. Provide a concrete, command-level plan including crypttab, fstab, initramfs (dracut) generation, and grub configuration to ensure the system boots automatically after rotation?","answer":"Two-stage layout: /boot unencrypted; root on LUKS2 inside an LVM PV. Create 1G /boot partition and encrypt the rest. Steps: format and open LUKS, set up PV/VG/LV, create filesystem, copy data, update ","explanation":"## Why This Is Asked\nThis question probes practical, production-grade encryption setup, including boot-time unlocking, crypttab/fstab integration, and initramfs/grub changes — skills RHCSA expects for secure deployments.\n\n## Key Concepts\n- LUKS2 on a dedicated partition\n- LVM PV/VG/LV layering on top of a mapped device\n- crypttab and initramfs integration\n- Grub configuration and unattended boot considerations\n- Keyfile management and security\n\n## Code Example\n```javascript\n// Shell commands illustrating the flow\ncryptsetup luksFormat /dev/sdb2 --type luks2\ncryptsetup luksOpen /dev/sdb2 cryptroot --key-file /root/keyfile\npvcreate /dev/mapper/cryptroot\nvgcreate vg0 /dev/mapper/cryptroot\nlvcreate -L 100G -n root vg0\nmkfs.xfs /dev/vg0/root\n```\n\n## Follow-up Questions\n- How would you rotate the LUKS keyfile safely without reboot?\n- How do you verify the encrypted volume opens during boot with a degraded initramfs?","diagram":null,"difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Plaid","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T03:35:27.852Z","createdAt":"2026-01-13T03:35:27.852Z"},{"id":"q-1192","question":"On a RHEL8 host, set up a minimal Python HTTP server listening on port 8080, accessible only from 192.168.100.0/24. Use a non-root user, a systemd service, SELinux port labeling, and firewalld rules. Provide exact commands to create the service, configure semanage for port 8080, apply firewall rules, and test from a client. Address potential SELinux and port conflict caveats?","answer":"Create a non-root user webu; place app.py with a minimal HTTP server listening on 0.0.0.0:8080; a systemd service webserver.service (User=webu, WorkingDirectory=/home/webu, ExecStart=/usr/bin/python3 ","explanation":"## Why This Is Asked\nTests practical sysadmin tasks across users, services, SELinux, and firewall rules.\n\n## Key Concepts\n- systemd service creation\n- semanage port labeling\n- firewalld rich rules for IP ranges\n- binding to 0.0.0.0 and access control\n- testing with curl\n\n## Code Example\n```javascript\n# /etc/systemd/system/webserver.service\n[Unit]\nDescription=Minimal Python HTTP server\nAfter=network-online.target\n[Service]\nUser=webu\nWorkingDirectory=/home/webu\nExecStart=/usr/bin/python3 /home/webu/app.py\nRestart=on-failure\n[Install]\nWantedBy=multi-user.target\n```\n\n```javascript\n# app.py\nimport http.server, socketserver\nPORT=8080\nHandler=http.server.SimpleHTTPRequestHandler\nwith socketserver.TCPServer((\"0.0.0.0\", PORT), Handler) as httpd:\n    httpd.serve_forever()\n```","diagram":"flowchart TD\n  A[Create user and app] --> B[Create systemd service]\n  B --> C[Label port with SELinux]\n  C --> D[Configure firewall]\n  D --> E[Test access]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","LinkedIn"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T04:42:25.489Z","createdAt":"2026-01-13T04:42:25.489Z"},{"id":"q-1247","question":"On a RHEL 8 server, a web service listens on 127.0.0.1:9090. Configure firewalld to expose port 9090 only to the 10.1.0.0/24 management network, log drops, and persist across reboots. Provide exact commands, and describe test steps using curl from an allowed host and from a non-allowed host?","answer":"firewall-cmd --get-default-zone\nfirewall-cmd --permanent --zone=public --add-rich-rule='rule family=\"ipv4\" source address=\"10.1.0.0/24\" port port=\"9090\" protocol=\"tcp\" accept'\nfirewall-cmd --permanent","explanation":"## Why This Is Asked\nTests practical firewall configuration with persistent rules and live-testing.\n\n## Key Concepts\n- firewalld zones and rich rules\n- persistence with --permanent and firewall-cmd reload\n- testing network access with curl\n\n## Code Example\n```javascript\n// Commands illustrating the approach\nfirewall-cmd --get-default-zone\nfirewall-cmd --permanent --zone=public --add-rich-rule='rule family=\"ipv4\" source address=\"10.1.0.0/24\" port port=\"9090\" protocol=\"tcp\" accept'\nfirewall-cmd --permanent --zone=public --add-rich-rule='rule family=\"ipv4\" port port=\"9090\" protocol=\"tcp\" drop'\nfirewall-cmd --reload\n```\n\n## Follow-up Questions\n- How would you audit if the rule is being bypassed by another chain? \n- How would you revert the changes quickly? ","diagram":"flowchart TD\n  A[Define allowed subnet] --> B[Add accept rich rule]\n  B --> C[Add drop rule for others]\n  C --> D[Reload firewalld]\n  D --> E[Test with curl]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T06:42:21.017Z","createdAt":"2026-01-13T06:42:21.017Z"},{"id":"q-1399","question":"You manage a RHEL 8 server running SSH on port 22. To improve security, change SSH to listen on port 2222, disable root SSH login, and require key-based authentication, ensuring no downtime for existing sessions. List the exact commands and steps to implement this, including firewall and SELinux considerations, and how you verify connectivity afterwards?","answer":"Edit /etc/ssh/sshd_config: Port 2222; PermitRootLogin no; PasswordAuthentication no. Reload: systemctl reload sshd. Firewall: firewall-cmd --permanent --add-port=2222/tcp; firewall-cmd --reload. SELin","explanation":"## Why This Is Asked\nTests practical admin tasks across SSH config, firewall, and SELinux with minimal downtime.\n\n## Key Concepts\n- SSH daemon configuration\n- Firewalld management\n- SELinux port labeling\n- Connectivity testing and rollback\n\n## Code Example\n```bash\n# modify ssh config\nsudo sed -i 's/^#?Port .*/Port 2222/' /etc/ssh/sshd_config\nsudo sed -i 's/^Port 22/Port 2222/' /etc/ssh/sshd_config\nsudo sed -i 's/^#?PermitRootLogin.*/PermitRootLogin no/' /etc/ssh/sshd_config\nsudo sed -i 's/^#?PasswordAuthentication.*/PasswordAuthentication no/' /etc/ssh/sshd_config\nsudo systemctl restart sshd\nsudo firewall-cmd --permanent --add-port=2222/tcp\nsudo firewall-cmd --reload\nsudo semanage port -a -t ssh_port_t -p tcp 2222\nsudo restorecon -R /etc/ssh\n# test connectivity from admin host\nssh -p 2222 user@host\n```\n\n## Follow-up Questions\n- How would you revert if something goes wrong during the change?\n- How would you verify there are no lingering insecure access attempts?","diagram":"flowchart TD\n  A[SSH Config] --> B[Restart SSHD]\n  B --> C[Firewall Rule]\n  C --> D[SELinux Port]\n  D --> E[Verification]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","LinkedIn","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T15:40:50.563Z","createdAt":"2026-01-13T15:40:50.563Z"},{"id":"q-1484","question":"On a Red Hat-based host, you must deploy a statically compiled Go web app that runs on port 8080 behind firewalld with SELinux enforcing. The app should auto-start on boot, restart on failure, and log to rsyslog. Propose the concrete steps, files, and exact commands to configure systemd, firewalld, and SELinux contexts, ensuring minimal downtime during deploy?","answer":"Create a systemd unit for /opt/myapp/myapp listening on port 8080. In ExecStart use /opt/myapp/myapp --port 8080; Restart=on-failure; StandardOutput=journal; StandardError=journal. SELinux: semanage f","explanation":"## Why This Is Asked\nTests ability to package a real app with init, SELinux, and firewall integration.\n\n## Key Concepts\n- systemd service files and Restart logic\n- SELinux file context labeling\n- firewalld port management\n- logging through systemd/journald\n\n## Code Example\n```ini\n[Unit]\nDescription=My App\nAfter=network.target\n\n[Service]\nExecStart=/opt/myapp/myapp --port 8080\nRestart=on-failure\nStandardOutput=journal\nStandardError=journal\n\n[Install]\nWantedBy=multi-user.target\n```\n\n## Follow-up Questions\n- How would you roll back if the binary fails to start after deployment?\n- How would you audit SELinux denials for this service?","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T18:57:55.544Z","createdAt":"2026-01-13T18:57:55.544Z"},{"id":"q-1517","question":"On a RHEL 9 host, a custom service started via systemd fails to write logs to /var/www/app/logs after a patch, with SELinux enforcing. Describe a precise, minimal-risk remediation plan to identify and fix the root cause without broad permission grants, including AVC collection, targeted policy generation, and validation under load. What exact commands and steps would you perform?","answer":"Diagnose with SELinux AVCs for the failing service, collect today’s logs, and craft a targeted policy with audit2allow. Steps: 1) ausearch -m avc -ts today -i. 2) audit2allow -w -a -M svc_logfix. 3) s","explanation":"## Why This Is Asked\nSELinux troubleshooting in production is common; it tests practical, precise remediation without broad privileges.\n\n## Key Concepts\n- AVC denials, targeted policy, audit2allow, semodule\n- ausearch for AVCs, ts filtering, and interpreting logs\n- safe relabeling vs. creating a minimal policy module\n\n## Code Example\n```javascript\n# Collect AVCs for today\nausearch -m avc -ts today -i\n# Build a targeted module from logs\naudit2allow -w -a -M svc_logfix\nsemodule -i svc_logfix.pp\n```\n\n## Follow-up Questions\n- How would you verify no regression in other services after applying the module?\n- What are the risks of over-broad policy changes and how to mitigate them?","diagram":"flowchart TD\nA[AVC Denial Detected] --> B[Collect AVCs with ausearch]\nB --> C[Generate module via audit2allow]\nC --> D[Install module with semodule]\nD --> E[Restart service]\nE --> F[Load-test and verify logs]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-13T20:34:41.210Z","createdAt":"2026-01-13T20:34:41.212Z"},{"id":"q-1577","question":"You must serve a static site from content stored on an NFS mount at /srv/www with SELinux enforcing on a RHEL-based system. The SELinux policy blocks httpd from reading the files. Describe the exact sequence of commands and configurations to allow Apache to serve the site without disabling SELinux or putting the system in permissive mode, including boolean toggles, labeling, and firewall rules?","answer":"Enable httpd to read NFS content: setsebool -P httpd_use_nfs on; semanage fcontext -a -e httpd_sys_content_t '/srv/www(/.*)?'; restorecon -R /srv/www; systemctl restart httpd; firewall-cmd --permanent --add-service=http; firewall-cmd --reload","explanation":"## Why This Is Asked\nEvaluates practical SELinux handling for real-world shared content, not just theory.\n\n## Key Concepts\n- SELinux booleans (httpd_use_nfs)\n- File context labeling for web content\n- restorecon and semanage usage\n- Firewall rules for HTTP\n- Diagnosing and remediating AVCs with audit2allow\n\n## Code Example\n```bash\nsetsebool -P httpd_use_nfs on\nsemanage fcontext -a -e httpd_sys_content_t '/srv/www(/.*)?'\nrestorecon -R /srv/www\nsystemctl restart httpd\nfirewall-cmd --permanent --add-service=http\nfirewall-cmd --reload\n```\n\n## Follow-up Questions\n- How would you verify and remediate","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Meta","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T05:56:45.358Z","createdAt":"2026-01-13T22:44:11.540Z"},{"id":"q-1610","question":"Configure log rotation for a custom web app log path /var/log/myapp/*.log on a live Linux host. The log is written by a root-owned process and must rotate weekly, keep 4 copies, compress old logs, and after rotation reload nginx to reopen its handles. Provide a minimal, working logrotate.conf snippet and explain how this prevents log loss?","answer":"Use a dedicated logrotate stanza:\n\n```\n/var/log/myapp/*.log {\n    weekly\n    rotate 4\n    compress\n    missingok\n    notifempty\n    copytruncate\n    sharedscripts\n    postrotate\n        systemctl reload nginx >/dev/null 2>&1 || true\n    endscript\n}\n```","explanation":"Why This Is Asked\n- Tests practical log management and prevention of log loss in a real service\n- Checks understanding of rotation cadence, backup retention, and service interaction\n\nKey Concepts\n- logrotate stanza syntax and options (weekly, rotate, compress, missingok, notifempty, copytruncate, sharedscripts)\n- Post-rotation actions to refresh services (nginx log file handles)\n- Impact of log rotation on running daemons and data integrity\n\nCode Example\n```bash\n/var/log/myapp/*.log {\n    weekly\n    rotate 4\n    compress\n    missingok\n    notifempty\n    copytruncate\n    sharedscripts\n    postrotate\n        systemctl reload nginx >/dev/null 2>&1 || true\n    endscript\n}\n```\n\nHow This Prevents Log Loss\n- `copytruncate` copies the current log to a new file, then truncates the original, ensuring continuous logging without interruption\n- `sharedscripts` ensures the postrotate command runs only once per rotation, preventing multiple nginx reloads\n- `missingok` and `notifempty` prevent errors if logs don't exist or are empty, avoiding rotation failures\n- `systemctl reload nginx` gracefully reopens log file handles without dropping connections, preventing log loss during rotation","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","IBM","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-14T05:30:20.445Z","createdAt":"2026-01-14T02:35:40.954Z"},{"id":"q-1649","question":"On a RHEL system with root on an LV named /dev/vg_rhel/root, describe a precise method to test a disruptive system update using an LVM snapshot: create a 20G snapshot, apply the update inside the snapshot, validate service health, and rollback by booting the live system from the original LV if needed. Include exact commands?","answer":"Create a 20G root snapshot: lvcreate -s -n root-snap -L20G vg_rhel/root. Mount it at /mnt/snap, bind /dev /proc /sys, chroot /mnt/snap, run dnf update -y, test services. If healthy, reboot normally. I","explanation":"## Why This Is Asked\nAssesses practical rollback strategy using LVM snapshots for live testing of disruptive updates.\n\n## Key Concepts\n- LVM snapshots\n- chroot testing\n- Rollback via boot path adjustment\n\n## Code Example\n```javascript\nlvcreate -s -n root-snap -L20G vg_rhel/root\nmkdir -p /mnt/snap\nmount /dev/vg_rhel/root-snap /mnt/snap\nfor d in /proc /sys /dev; do mount --bind \"$d\" \"/mnt/snap$d\"; done\nchroot /mnt/snap\ndnf update -y\nsystemctl status httpd\nexit\n```\n\n## Follow-up Questions\n- How would you automate cleanup after a successful rollback?\n- How to secure the test against data inconsistency during the snapshot lifecycle?","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T04:33:32.950Z","createdAt":"2026-01-14T04:33:32.950Z"},{"id":"q-1679","question":"On a RHEL/CentOS host with two NICs (enp0s3 and enp0s8) connected to two switches, configure a 802.3ad (LACP) bond0 using NetworkManager. Bond should have a static IP 192.0.2.100/24, and both NICs must be slaves. Provide exact nmcli commands to create bond0, add slaves, bring it up, and verify; note required switch settings (LACP active on both ports)?","answer":"Configure a 802.3ad LACP bond across two NICs with a static IP on bond0. Use NM to create bond0, assign 192.0.2.100/24, add enp0s3 and enp0s8 as slaves, bring up bond0, and verify via /proc/net/bondin","explanation":"## Why This Is Asked\nReal-world networking reliability requires correct bonding configuration with LACP. This tests practical NM usage, understanding of switch prerequisites, and verification of bond status.\n\n## Key Concepts\n- 802.3ad/LACP bonding\n- NetworkManager nmcli commands\n- Slave interfaces and master bond configuration\n- Switch-side LACP, port-channel settings, MTU consistency\n\n## Code Example\n```bash\n# Create bond with LACP\nnmcli con add type bond ifname bond0 mode 802.3ad\n# Set static IP on bond\nnmcli con modify bond0 ipv4.addresses 192.0.2.100/24 ipv4.method manual\n# Add slaves\nnmcli con add type ethernet ifname enp0s3 master bond0\nnmcli con add type ethernet ifname enp0s8 master bond0\n# Bring interfaces up\nnmcli con up bond0\nnmcli con up enp0s3\nnmcli con up enp0s8\n```\n\n## Follow-up Questions\n- How would you troubleshoot if /proc/net/bonding/bond0 shows inconsistent slave status?\n- What changes are needed if one switch port goes down and the bond remains up?","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Scale Ai","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T06:51:43.330Z","createdAt":"2026-01-14T06:51:43.330Z"},{"id":"q-1738","question":"On a RHEL-based host, configure firewalld to allow SSH access only from 192.0.2.0/24 and deny all other inbound SSH; ensure the changes persist after reboot and can be tested quickly; outline exact commands and verification steps, including revert plan?","answer":"Remove the ssh service from the default zone, then add two permanent rich rules: allow ssh for source 192.0.2.0/24 and drop ssh from all others, then reload. Verify via firewall-cmd --zone=public --li","explanation":"## Why This Is Asked\nTests handling of firewalld, zones, and persistent rules in a concrete admin task.\n\n## Key Concepts\n- firewalld zones and permanent vs runtime rules\n- rich rules for source-based access\n- persistence and verification\n\n## Code Example\n```javascript\nfirewall-cmd --zone=public --permanent --remove-service=ssh\nfirewall-cmd --zone=public --permanent --add-rich-rule='rule family=\"ipv4\" source address=\"192.0.2.0/24\" service name=\"ssh\" accept'\nfirewall-cmd --zone=public --permanent --add-rich-rule='rule family=\"ipv4\" service name=\"ssh\" drop'\nfirewall-cmd --reload\n```\n\n## Follow-up Questions\n- How to mirror this for IPv6?\n- What if the admin needs temporary access from another network during maintenance?","diagram":"flowchart TD\n  A[Identify current rules] --> B[Remove ssh service] \n  B --> C[Add allow rule for 192.0.2.0/24] \n  C --> D[Add drop rule for others] \n  D --> E[Reload firewall] \n  E --> F[Verify rules] \n  F --> G[Revert if needed]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Tesla","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T09:00:00.925Z","createdAt":"2026-01-14T09:00:00.925Z"},{"id":"q-1756","question":"On a freshly provisioned Linux host (RHEL8), configure a new user 'audit' to log in exclusively via SSH key authentication, with a restricted shell rbash so only basic commands are allowed, and grant passwordless sudo to restart the 'auditd' service. Provide exact commands and edits to users, sshd_config, and sudoers, and how you would verify the setup?","answer":"Create user and home; assign rbash as shell; set a restricted PATH; configure SSH: PasswordAuthentication no; create /home/audit/.ssh/authorized_keys; edit /etc/sudoers.d/audit: audit ALL=(ALL) NOPASS","explanation":"## Why This Is Asked\nTests practical provisioning, SSH hardening, and sudo privileges for isolated accounts.\n\n## Key Concepts\n- rbash restrictions\n- SSH key-based auth\n- NOPASSWD sudo rules\n\n## Code Example\n```bash\n# basic provisioning (illustrative)\nuseradd -m audit\nchsh -s /bin/rbash audit\nmkdir -p /home/audit/.ssh\nchmod 700 /home/audit/.ssh\n# put key in authorized_keys\nchmod 600 /home/audit/.ssh/authorized_keys\necho 'audit ALL=(ALL) NOPASSWD: /bin/systemctl restart auditd' > /etc/sudoers.d/audit\n```\n\n## Follow-up Questions\n- How would you audit sudo usage for this user? \n- How would you extend to multiple restricted users with per-command whitelists?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","IBM"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T09:43:07.881Z","createdAt":"2026-01-14T09:43:07.881Z"},{"id":"q-1771","question":"On a RHEL 8 server, you must host a small static site with Nginx, ensure it starts on boot, expose only port 80, and serve content from /var/www/html with correct SELinux context. Provide exact commands to configure Nginx, firewall, and SELinux so SELinux stays enforcing?","answer":"Install nginx and set up a static site, start on boot, expose port 80, and serve /var/www/html with proper SELinux context. Run: dnf install -y nginx; mkdir -p /var/www/html; echo 'Hello' > /var/www/h","explanation":"## Why This Is Asked\nTests practical understanding of systemd service management, firewall configuration, and SELinux contexts for hosting static content on RHEL.\n\n## Key Concepts\n- systemd service enable/start\n- firewall-cmd for port 80\n- SELinux labeling with httpd_sys_content_t\n- restorecon and semanage usage\n\n## Code Example\n```bash\n# install\nsudo dnf install -y nginx\n# firewall\nsudo firewall-cmd --permanent --zone=public --add-service=http\nsudo firewall-cmd --reload\n# SELinux\nsudo semanage fcontext -a -t httpd_sys_content_t '/var/www/html(/.*)?'\nsudo restorecon -R -v /var/www/html\n```\n\n```bash\n# enable and start nginx\nsudo systemctl enable --now nginx\n```\n\n## Follow-up Questions\n- How would you serve content from a subpath like /var/www/html/site?\n- How would you adjust SELinux booleans if you later switch to CGI scripts?","diagram":"flowchart TD\n  A[Start] --> B[Install nginx]\n  B --> C[Configure firewall]\n  C --> D[Set SELinux context]\n  D --> E[Enable and start nginx]\n  E --> F[Validate with curl]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Snap","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T10:34:55.907Z","createdAt":"2026-01-14T10:34:55.909Z"},{"id":"q-1804","question":"On a Red Hat-based host, a Python web app writes to /srv/app/data and /var/log/app. After a system update, SELinux denies these writes. Outline an operational plan to diagnose and restore write access without disabling SELinux, including commands for audit review, context restoration, and persistent policy adjustments?","answer":"1) Inspect AVCs: ausearch -m avc -ts today | aureport -a -i; 2) confirm file contexts: ls -Z /srv/app /var/log/app; 3) set persistent contexts: semanage fcontext -a -t httpd_sys_rw_content_t '/srv/app","explanation":"## Why This Is Asked\nDemonstrates practical SELinux troubleshooting, policy tuning, and safe persistence without disabling security.\n\n## Key Concepts\n- SELinux types and booleans\n- semanage fcontext\n- restorecon\n- audit2why/ausearch\n- persistent policy changes\n\n## Code Example\n```bash\nausearch -m avc -ts today | aureport -a -i\nsemanage fcontext -a -t httpd_sys_rw_content_t '/srv/app(/.*)?'\nrestorecon -R /srv/app\n```\n\n## Follow-up Questions\n- How to roll back if a boolean causes regressions?\n- How to isolate contexts per app with dedicated policy modules?","diagram":"flowchart TD\n  A[SELinux Denial] --> B[Audit Review]\n  B --> C[Update File Contexts]\n  C --> D[Apply Persistently]\n  D --> E[Test Write]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Meta","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T11:39:38.392Z","createdAt":"2026-01-14T11:39:38.392Z"},{"id":"q-1982","question":"On a Linux host, create a project share at /srv/project where Alice can read/write and Bob can read only, with all others denied. Use POSIX permissions plus ACLs so new files created by Alice inherit Bob's read access. Provide exact commands to: 1) create the group, 2) add users, 3) set up the directory with setgid, 4) apply ACLs (explicit for Bob and default for new files), 5) verify with tests?","answer":"sudo groupadd proj\nsudo usermod -aG proj alice\nsudo mkdir -p /srv/project\nsudo chown root:proj /srv/project\nsudo chmod 2770 /srv/project\nsudo setfacl -m u:bob:rx /srv/project\nsudo setfacl -m d:u:bob:r","explanation":"## Why This Is Asked\nTests practical ACL usage and inheritance: combining POSIX permissions, setgid directories, and ACLs for multi-user access. It validates understanding of inheritance for new files and robust verification from non-privileged contexts.\n\n## Key Concepts\n- POSIX permissions and groups\n- Setgid directory inheritance\n- ACLs and default ACLs\n- Testing cross-user access\n- File vs directory permissions\n\n## Code Example\n```bash\n# Example verification (shown in answer above for clarity)\n```\n\n## Follow-up Questions\n- How would you audit and adjust ACLs if Alice creates a deep subdirectory?\n- How would you apply these permissions across a separate mount or NFS share?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Oracle","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T19:36:54.465Z","createdAt":"2026-01-14T19:36:54.466Z"},{"id":"q-2225","question":"On a RHEL 9 server running Apache httpd hosting a custom PHP app, uploads are saved to /srv/app/uploads owned by webuser with SELinux type httpd_sys_content_t. After a denied upload, design and implement a minimal SELinux policy module that lets httpd_t write to that directory and create new files, without broad permissive mode. Include exact commands and testing steps?","answer":"Identify the AVC with ausearch, generate a targeted module with audit2allow, install the module, and adjust file context. Commands: ausearch -m AVC -ts today | audit2allow -M httpd_upload; semodule -i","explanation":"## Why This Is Asked\nTests SELinux troubleshooting and policy crafting in a realistic app deployment.\n\n## Key Concepts\n- SELinux domains and booleans\n- AVC denials and audit2allow workflow\n- Persistent labeling with semanage and restorecon\n- Safe, least-privilege policy design\n\n## Code Example\n```bash\nausearch -m AVC -ts today\naudit2allow -M httpd_upload\nsemodule -i httpd_upload.pp\nsemanage fcontext -a -e '/srv/app/uploads'\nrestorecon -R /srv/app/uploads\n```\n\n## Follow-up Questions\n- How would you test for regressions across relabeled files?\n- How would you roll back the policy if it caused unintended access?","diagram":null,"difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T08:40:50.907Z","createdAt":"2026-01-15T08:40:50.909Z"},{"id":"q-2308","question":"On a fresh RHEL8 host with an unallocated disk at /dev/sdb, describe and implement the steps to (1) create a PV, (2) VG named vg_data, (3) LV named data of 900G, (4) format with XFS, (5) mount at /data with auto-mount in /etc/fstab, and (6) set ownership to user app and proper SELinux context. Provide exact commands?","answer":"pvcreate /dev/sdb; vgcreate vg_data /dev/sdb; lvcreate -L 900G -n data vg_data; mkfs.xfs /dev/vg_data/data; mkdir -p /data; mount /dev/vg_data/data /data; echo '/dev/vg_data/data /data xfs defaults 0 ","explanation":"## Why This Is Asked\n\nTests storage provisioning basics common in RHCSA tasks.\n\n## Key Concepts\n\n- PV/VG/LV lifecycle\n- XFS formatting\n- /etc/fstab persistence\n- SELinux context when mounting new data\n\n## Code Example\n\n```bash\npvcreate /dev/sdb\nvgcreate vg_data /dev/sdb\nlvcreate -L 900G -n data vg_data\nmkfs.xfs /dev/vg_data/data\nmkdir -p /data\nmount /dev/vg_data/data /data\necho '/dev/vg_data/data /data xfs defaults 0 0' >> /etc/fstab\n```\n\n## Follow-up Questions\n\n- How would you extend this to add a separate metadata LV?\n- How would you verify accessibility after reboot?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Hashicorp","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T11:37:43.926Z","createdAt":"2026-01-15T11:37:43.927Z"},{"id":"q-2357","question":"Scenario: You manage a RHEL host where /var/www and /etc live on an LVM-managed XFS volume. Implement a DR restore pipeline: daily incremental backups via rsync to an offsite server, preserving SELinux contexts and ACLs, with integrity verification. Describe the exact commands, systemd timer/unit setup, and restore steps to recover to the latest backup within 60 minutes?","answer":"Back up /etc and /var/www to an offsite server with rsync: rsync -aAXv --delete --link-dest=/backup/prev /etc /var/www host:/backup/daily-$(date +%F). Verify with sha256sums. Restore by rsync -aAXv fr","explanation":"## Why This Is Asked\nTests practical DR planning, SELinux/ACL preservation, incremental rsync backups, and systemd automation—core RHCSA skills for real-world repair.\n\n## Key Concepts\n- DR planning with RPO/RTO\n- rsync options -aAX, --link-dest, --delete\n- SELinux contexts preservation and restorecon\n- ACLs and extended attributes\n- systemd-timers and unit files\n- integrity verification with checksums\n\n## Code Example\n```bash\n# example restore workflow (dry-run)\nrsync -aAXv --dry-run /backup/latest/ /etc/\n```\n\n```bash\n# systemd timer example (simplified)\n[Unit]\nDescription=Daily DR backup\n\n[Timer]\nOnCalendar=daily\nPersistent=true\n\n[Service]\nType=oneshot\nExecStart=/usr/local/bin/run-dr-backup.sh\n```\n\n```bash\n# restore script outline\nrsync -aAXv --delete /backup/latest/ /etc/\nrsync -aAXv --delete /backup/latest/ /var/www/\nrestorecon -R /etc /var/www\nsystemctl restart httpd nginx\n```\n\n## Follow-up Questions\n- How would you handle offsite encryption and key rotation?\n- How would you test DR recovery with minimal downtime?","diagram":null,"difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T14:43:24.786Z","createdAt":"2026-01-15T14:43:24.786Z"},{"id":"q-2415","question":"On a fresh RHEL 9 server, implement a small utility that prints the host name and current date, running it as a non-login user via systemd and logging to a dedicated file with rotation. Provide exact commands for user creation, script, service, and log rotation?","answer":"Create a restricted user 'hello' with no login, place a script at /opt/hello-day/print.sh that appends \"Hello from <date> on <hostname>\" to /var/log/hello-day.log, set proper permissions, and configur","explanation":"## Why This Is Asked\nTests core RHCSA beginner skills: user creation and permissions, small script, systemd service basics, log management with rotation, and boot-time enablement.\n\n## Key Concepts\n- Systemd service fundamentals\n- Non-login user handling\n- File permissions and ownership\n- Log rotation basics\n- Service verification\n\n## Code Example\n```bash\n# Create user\nsudo useradd -r -s /sbin/nologin -d /var/empty hello\n# Prepare script\nsudo mkdir -p /opt/hello-day\nsudo tee /opt/hello-day/print.sh <<'SH'\n#!/bin/bash\necho \"Hello from $(date) on $(hostname)\" >> /var/log/hello-day.log\nSH\nsudo chmod +x /opt/hello-day/print.sh\nsudo mkdir -p /var/log/hello-day\nsudo chown hello:hello /var/log/hello-day.log\n# systemd service\nsudo tee /etc/systemd/system/hello-day.service <<'SERVICE'\n[Unit]\nDescription=Hello Day Service\n[Service]\nType=oneshot\nUser=hello\nExecStart=/opt/hello-day/print.sh\nSERVICE\nsudo systemctl daemon-reload\nsudo systemctl enable --now hello-day.service\n# logrotate\nsudo tee /etc/logrotate.d/hello-day <<'LOG'\n/var/log/hello-day.log {\n  daily\n  rotate 7\n  missingok\n  notifempty\n  create 0640 hello hello\n  copytruncate\n}\nLOG\n```\n\n## Follow-up Questions\n- How would you adapt this for a daemon vs. oneshot?\n- How would you ensure idempotence if the script could run multiple times?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T17:02:13.966Z","createdAt":"2026-01-15T17:02:13.966Z"},{"id":"q-2457","question":"On a Linux host, a Node.js web app runs in a container and connects to Postgres on localhost:5432. After reboot, the web app sometimes starts before Postgres is ready, causing startup failures. Propose a concrete, production-ready systemd-based solution: (1) implement a db-wait.service that blocks until pg_isready reports healthy, (2) make web-app.service depend on and After=db-wait.service, (3) add a lightweight container readiness check for the app, and (4) describe how you would test this reliably?","answer":"Create db-wait.service that blocks until pg_isready reports healthy: ExecStart=/bin/bash -lc 'until pg_isready -h localhost -p 5432; do sleep 1; done'. Web app unit: Wants=db-wait.service After=db-wai","explanation":"## Why This Is Asked\n\nTests the candidate's ability to coordinate startup order between services using systemd, plus practical health/readiness checks to prevent cascading failures.\n\n## Key Concepts\n\n- systemd unit dependencies (After, Wants, Requires)\n- pg_isready and database readiness signals\n- container health checks and readiness probes\n- startup ordering and failure isolation\n- practical testing of startup sequencing\n\n## Code Example\n\n```javascript\n# db-wait.service\n[Unit]\nDescription=Wait for PostgreSQL to be ready\n\n[Service]\nType=oneshot\nExecStart=/bin/bash -lc 'until pg_isready -h localhost -p 5432; do sleep 1; done'\nRemainAfterExit=yes\n```\n\n```javascript\n# web-app.service\n[Unit]\nDescription=Web App\nWants=db-wait.service\nAfter=db-wait.service\n\n[Service]\nRestart=on-failure\nExecStart=/usr/bin/node /opt/app/server.js\n```\n\n```javascript\n# Dockerfile HEALTHCHECK\nHEALTHCHECK --interval=30s --timeout=5s --start-period=5s --retries=3 CMD curl -f http://localhost:3000/health || exit 1\n```\n\n## Follow-up Questions\n\n- How would you adapt if Postgres runs in a separate container?\n- How would you handle timeouts and cascading failures?","diagram":null,"difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Discord"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T18:59:12.556Z","createdAt":"2026-01-15T18:59:12.556Z"},{"id":"q-2479","question":"On a RHEL 9 host, a production service writes logs to /var/app/logs with 0777 perms. You must relocate logs to a dedicated 1 TB LVM-backed XFS volume mounted at /var/app/logs with no downtime, ensure SELinux context, and configure logrotate to compress weekly. Provide exact steps including LV creation, filesystem, fstab, SELinux relabeling, and logrotate config?","answer":"Configure a 1 TB LVM-backed XFS volume mounted at /var/app/logs with zero downtime: create LV, format XFS, mount, update fstab, rsync data, switch mount, relabel SELinux contexts (semanage fcontext -a","explanation":"## Why This Is Asked\nTests storage disruption avoidance, LVM, SELinux contexts, and log management in a realistic migration.\n\n## Key Concepts\n- LVM provisioning and filesystem selection\n- Data migration with minimal downtime\n- SELinux file contexts and relabeling\n- logrotate configuration and permissions\n- FSTAB mounting and idempotent changes\n\n## Code Example\n```bash\n# example: fstab entry\n/dev/mapper/applog-vg/applog /var/app/logs xfs defaults 0 0\n```\n\n```bash\n# data migration\nrsync -aP /var/app/logs/ /mnt/applog/ \n```\n\n## Follow-up Questions\n- How to rollback if migration fails?\n- How would you handle concurrent writes during cutover?\n","diagram":"flowchart TD\n  A[Start] --> B[Create LV and format]\n  B --> C[Mount at /var/app/logs]\n  C --> D[Update /etc/fstab]\n  D --> E[Migrate logs with rsync]\n  E --> F[Relabel SELinux contexts]\n  F --> G[Configure logrotate]\n  G --> H[Validate with test logs]\n  H --> I[End]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Netflix","PayPal","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T19:41:12.926Z","createdAt":"2026-01-15T19:41:12.926Z"},{"id":"q-2557","question":"On a fresh RHEL 9 host, configure firewalld to allow SSH only from 203.0.113.0/24 and drop SSH from all other sources. Provide exact permanent commands, reload, and verification steps?","answer":"Enable firewalld and restrict SSH to 203.0.113.0/24. Exact commands: systemctl enable --now firewalld; SUB=203.0.113.0/24; firewall-cmd --permanent --zone=public --add-rich-rule=\"rule family='ipv4' source address='$SUB' port port='22' protocol='tcp' accept\"; firewall-cmd --permanent --zone=public --add-rich-rule=\"rule family='ipv4' port port='22' protocol='tcp' drop\"; firewall-cmd --reload; firewall-cmd --list-all --zone=public","explanation":"## Why This Is Asked\nTests practical firewall configuration and understanding of permanent vs runtime rules, plus idempotence.\n\n## Key Concepts\n- firewalld rich rules\n- permanent vs runtime configuration\n- rule ordering and specificity\n\n## Code Example\n```\nsystemctl enable --now firewalld\nSUB=203.0.113.0/24\nfirewall-cmd --permanent --zone=public --add-rich-rule=\"rule family='ipv4' source address='$SUB' port port='22' protocol='tcp' accept\"\nfirewall-cmd --permanent --zone=public --add-rich-rule=\"rule family='ipv4' port port='22' protocol='tcp' drop\"\nfirewall-cmd --reload\nfirewall-cmd --list-all\n```","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Hashicorp","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T05:26:09.742Z","createdAt":"2026-01-15T22:46:09.878Z"},{"id":"q-2637","question":"On a fresh RHEL 9 host, deploy a tiny Python HTTP health server that binds to 127.0.0.1:9090 and returns 200 OK for GET /health when the file /tmp/healthy exists; otherwise 503. Run this as a non-root systemd service with a dedicated unit file, a startup script, and a log file rotated by logrotate. Provide exact commands to create the non-login user, script, systemd unit, logrotate config, and enable the service. Ensure idempotence?","answer":"Create user healthchk (nologin). Place script at /opt/healthcheck/health_server.py that runs a tiny HTTP server on 127.0.0.1:9090 and returns 200 for /health when /tmp/healthy exists, else 503. System","explanation":"Why This Is Asked\nTests systemd service for non-root processes, health-check patterns, and log management.\n\nKey Concepts\n- systemd unit files (User, WorkingDirectory, ExecStart, StandardOutput)\n- Python HTTP server basics\n- idempotent filesystem setup and permissions\n- logrotate configuration for a dedicated log path\n\nCode Example\n```python\n# health_server.py\nimport http.server, socketserver, os\nclass H(http.server.BaseHTTPRequestHandler):\n  def do_GET(self):\n    if self.path == '/health' and os.path.exists('/tmp/healthy'):\n      self.send_response(200); self.end_headers(); self.wfile.write(b'OK')\n    else:\n      self.send_response(503); self.end_headers(); self.wfile.write(b' unhealthy ')\n\nif __name__ == '__main__':\n  with socketserver.TCPServer(('127.0.0.1',9090), H) as httpd:\n    httpd.serve_forever()\n```\n\nFollow-up Questions\n- How would you monitor this service and alert on failed health checks?\n- How would you harden the service against file tampering?","diagram":"flowchart TD\n  A[Create healthchk user] --> B[Write health_server.py]\n  B --> C[Systemd unit setup]\n  C --> D[Configure logrotate]\n  D --> E[Enable & start service]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Hashicorp","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T04:18:13.926Z","createdAt":"2026-01-16T04:18:13.927Z"},{"id":"q-2647","question":"On a fresh RHEL 9 server, create a non-root user named devops and configure passwordless sudo for only two commands: /bin/systemctl restart httpd and /usr/bin/journalctl -xe. Restrict SSH login for this user to localhost by updating sshd_config. Provide exact commands and file contents to accomplish this?","answer":"Create user devops with a home and bash: useradd -m -s /bin/bash devops; passwd devops. Add sudoers: echo 'devops ALL=(ALL) NOPASSWD: /bin/systemctl restart httpd, /usr/bin/journalctl -xe' > /etc/sudo","explanation":"## Why This Is Asked\nTests practical admin tasks: user provisioning, granular sudo rights, and SSH restrictions, all common on entry-level RHCSA tasks.\n\n## Key Concepts\n- User management with useradd and passwd\n- Fine-grained sudoers with /etc/sudoers.d\n- SSH access control with AllowUsers\n- Service and log viewing with systemctl and journalctl\n\n## Code Example\n```javascript\n# Commands to implement (illustrative, not executed here)\n```\n\n## Follow-up Questions\n- How would you log the sudo usage for this user?\n- How would you extend to allow additional commands safely?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T05:34:54.469Z","createdAt":"2026-01-16T05:34:54.469Z"},{"id":"q-2756","question":"Design and implement an offline, local repository patching workflow for 20 RHEL 9 servers to achieve zero downtime. Outline mirroring steps with reposync, GPG signing, local repo config, a rolling update procedure (kernel first, then user-space), reboot strategy, rollback via dnf history, and auditing. Provide exact commands and a deployment checklist?","answer":"Adopt a rolling patching strategy: mirror updates with reposync to a local repo, sign with the RH key, and configure hosts to use it. Stage patches on a canary group (5 hosts); update kernel first, re","explanation":"## Why This Is Asked\nTests ability to design offline patching pipelines, safety rails, and rollback in production.\n\n## Key Concepts\n- Offline repo mirroring with reposync\n- GPG verification and key management\n- Canary/rolling deployments and batch sizing\n- Kernel-first update strategy and reboot handling\n- Rollback via dnf history; versionlocking\n- Auditing with dnf logs and system audit trails\n\n## Code Example\n```bash\n# Mirror setup (example)\nreposync --repoid=rhel9-server-repo --download-path=/var/www/html/repos/rhel9\ncreaterepo /var/www/html/repos/rhel9/os\n# Host config\ncat > /etc/yum.repos.d/local.repo <<'EOF'\n[Local-RHEL9]\nname=Local RHEL9 Updates\nbaseurl=file:///var/www/html/repos/rhel9/os\nenabled=1\ngpgcheck=1\ngpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release\nEOF\n\ndnf makecache\n```\n\n## Follow-up Questions\n- How would you handle a host that cannot reboot during patching?\n- What monitoring would you add to verify patch integrity and rollback readiness?","diagram":"flowchart TD\n  A[Mirror updates to local repo] --> B[Configure hosts to use local repo]\n  B --> C[Canary patch (5 hosts)]\n  C --> D[Kernel first, reboot, verify]\n  D --> E[Batch patch rest]\n  E --> F[Audit logs; ready for rollback]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","OpenAI","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T10:43:27.554Z","createdAt":"2026-01-16T10:43:27.554Z"},{"id":"q-2838","question":"On a RHEL 9 host exposed to the internet, harden SSH with key-based login only, disable root login, enforce 2FA via pam_google_authenticator for SSH, and configure auditd to log authentication attempts with a daily report; provide exact commands and config snippets to implement this with minimal downtime?","answer":"Set SSH to Protocol 2, PubkeyAuthentication yes, PasswordAuthentication no, PermitRootLogin no, and ChallengeResponseAuthentication yes. Enforce 2FA with PAM using pam_google_authenticator.so and per-","explanation":"## Why This Is Asked\nTests practical hardening of a live system with minimal downtime and verifiable controls.\n\n## Key Concepts\n- SSH hardening: protocol, authentication methods, root login.\n- 2FA integration with PAM.\n- Per-user MFA provisioning.\n- Auditd visibility for authentication.\n- Automated reporting and scheduling.\n\n## Code Example\n```bash\n# /etc/ssh/sshd_config (snip)\nProtocol 2\nPubkeyAuthentication yes\nPasswordAuthentication no\nPermitRootLogin no\nChallengeResponseAuthentication yes\n\n# /etc/pam.d/sshd (snip)\nauth required pam_google_authenticator.so\n```\n\n```bash\n# Minimal audit rules (illustrative)\n-w /var/log/secure -p wa -k ssh-auth\n-a always,exit -F arch=b64 -S execve -k login\n```\n\n## Follow-up Questions\n- How would you rotate and retrain MFA tokens without downtime?\n- How do you verify no authentication bypass occurred after changes?","diagram":"flowchart TD\nA[SSH Hardening] --> B[SSHD Config]\nA --> C[2FA PAM]\nA --> D[Audit Rules]\nD --> E[Reporting]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","LinkedIn","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T14:32:39.461Z","createdAt":"2026-01-16T14:32:39.464Z"},{"id":"q-3053","question":"On a fresh RHEL 9 server, implement a minimal nftables-based firewall that permits SSH only from 192.168.1.0/24, allows loopback, and drops all other inbound traffic. Make the rules persistent across reboots and verify. Provide exact commands to install nftables, create /etc/nftables.conf with the rules, enable the nftables service, and test connectivity from an allowed host and a disallowed host?","answer":"Set up a minimal nftables firewall on a fresh RHEL 9 server that allows SSH only from 192.168.1.0/24, permits loopback, and drops all other inbound traffic; persist rules across reboots and verify functionality.","explanation":"## Why This Is Asked\nTests practical firewall configuration skills on RHEL 9, requiring precise rule creation, persistence, and verification—essential for enterprise security administration.\n\n## Key Concepts\n- nftables ruleset syntax and packet flow\n- Rule persistence via /etc/nftables.conf\n- Service management with systemctl\n- Connectivity testing from allowed vs. disallowed sources\n- Verification using nft list ruleset\n\n## Code Example\n```bash\n#!/usr/sbin/nft -f\nflush ruleset\ntable inet filter {\n  chain input {\n    type filter hook input priority 0; policy drop;\n    iifname \"lo\" accept\n    ip saddr 192.168.1.0/24 tcp dport 22 accept\n  }\n  chain forward {\n    type filter hook forward priority 0; policy drop;\n  }\n  chain output {\n    type filter hook output priority 0; policy accept;\n  }\n}\n```\n\n## Implementation Steps\n```bash\n# Install nftables\ndnf install -y nftables\n\n# Create ruleset\ncat > /etc/nftables.conf << 'EOF'\n#!/usr/sbin/nft -f\nflush ruleset\ntable inet filter {\n  chain input {\n    type filter hook input priority 0; policy drop;\n    iifname \"lo\" accept\n    ip saddr 192.168.1.0/24 tcp dport 22 accept\n  }\n  chain forward {\n    type filter hook forward priority 0; policy drop;\n  }\n  chain output {\n    type filter hook output priority 0; policy accept;\n  }\n}\nEOF\n\n# Enable and start services\nsystemctl enable nftables\nsystemctl start nftables\nsystemctl status nftables\n\n# Verify rules\nnft list ruleset\n\n# Test connectivity (from allowed host)\nssh user@server-ip\n\n# Test connectivity (from disallowed host)\nssh user@server-ip  # Should timeout/refuse\n```","diagram":"flowchart TD\n  A[Start] --> B[Create /etc/nftables.conf]\n  B --> C[Enable nftables service]\n  C --> D[Test from allowed host]\n  D --> E[Test from disallowed host]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","Microsoft","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T05:19:44.665Z","createdAt":"2026-01-16T22:45:57.038Z"},{"id":"q-3130","question":"You have a running RHEL 9 server hosting an Apache site. The DocumentRoot /var/www/html must move to a dedicated XFS LV mounted at /srv/www, with zero downtime, preserving SELinux contexts and without changing client URLs. Provide exact commands, config changes, and rollback steps to perform the migration safely?","answer":"Create a new XFS LV and mount it at /mnt/www; rsync -aAX /var/www/html/ /mnt/www/; bind mount to the original path: mount --bind /mnt/www /var/www/html; persist with fstab: /dev/webvg/wwwlv /mnt/www x","explanation":"## Why This Is Asked\nNew angle: live data migration using bind mounts to avoid downtime while relocating content to a dedicated LV. Tests LVM provisioning, bind mounts, SELinux labeling, and httpd restart behavior.\n\n## Key Concepts\n- LVM/XFS provisioning and mounting\n- rsync for a-safe data copy\n- bind mounts and fstab persistence\n- SELinux labeling with restorecon\n- Apache DocumentRoot changes with minimal disruption\n\n## Code Example\n```bash\nmount --bind /mnt/www /var/www/html\n```\n\n## Follow-up Questions\n- How would you verify data integrity post-migration?\n- How would you handle future certificate rotations without downtime?","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T04:11:56.028Z","createdAt":"2026-01-17T04:11:56.028Z"},{"id":"q-3216","question":"Devise a three-tenant container deployment on a single RHEL 9 host (advanced RHCSA). Each tenant runs in its own container using non-root user namespaces, isolated network namespace, and defined CPU and memory quotas. Implement per-tenant logging and logrotate, and address SELinux considerations. Provide exact commands and files: UID/GID mappings, subuid/subgid setup, Podman usage, systemd unit files, and a minimal HTTP server container example?","answer":"Plan three tenants (tenant1-tenant3) with non-root users; map UID/GID ranges via /etc/subuid and /etc/subgid; run containers with Podman in user namespaces; create systemd services per tenant with CPU","explanation":"## Why This Is Asked\nTests advanced RHCSA practices: practical isolation using user namespaces, per-tenant quotas, secure container runtimes, and per-tenant logging.\n\n## Key Concepts\n- User namespaces and subuid/subgid mappings\n- Podman/systemd integration with quotas\n- Network namespace isolation per tenant\n- SELinux labeling for containers\n- Per-tenant logging and logrotate\n\n## Code Example\n```ini\n# sample systemd unit for a tenant container (Tenant1)\n[Unit]\nDescription=Tenant1 web container\n[Service]\nExecStart=/usr/bin/podman run --name tenant1 --rm --network=tenant1_net --memory=512M --cpu-quota=25000 --cpu-period=100000\nRestart=on-failure\n```\n\n## Follow-up Questions\n- How would you scale to more tenants while maintaining isolation?\n- How would you ensure persistent storage across container recreations?\n- What monitoring would you add to observe per-tenant resource usage?","diagram":"flowchart TD\n  A[User Namespaces] --> B[Podman Containers]\n  B --> C[Systemd Services]\n  C --> D[Resource Quotas]\n  A --> E[Network Isolation]\n  F[Logs per Tenant] --> G[Logrotate]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T07:29:09.590Z","createdAt":"2026-01-17T07:29:09.590Z"},{"id":"q-3303","question":"On a RHEL 9 host behind Nginx serving a critical API, describe a zero-downtime upgrade path for a Python Flask app using blue/green deployment. Provide exact steps and commands to prepare two virtualenvs, two systemd service units, traffic switch with Nginx, health checks, and rollback plan, including SELinux considerations and verifying in-flight requests are not dropped?","answer":"Use blue/green deployment: two virtualenvs (/opt/api-blue, /opt/api-green) and two systemd units api-blue.service, api-green.service each on distinct ports. Deploy to green, run health checks (curl -f","explanation":"## Why This Is Asked\n\nTests ability to orchestrate zero-downtime upgrades in a production-like RHCSA setting.\n\n## Key Concepts\n\n- Blue/green deployment\n- systemd service management\n- Nginx upstream switching\n- Health checks and drift detection\n- Rollback safety and SELinux considerations\n\n## Code Example\n\n```bash\n# Example setup (illustrative)\nmkdir -p /opt/api-blue /opt/api-green\npython3 -m venv /opt/api-blue\npython3 -m venv /opt/api-green\n# install deps and configure services... \n```\n\n## Follow-up Questions\n\n- How would you automate green health checks and promote/demote automatically?\n- How would you preserve session continuity for in-flight requests during the switch?","diagram":"flowchart TD\n  A[Blue API] --> B[Green API]\n  B --> C{Health OK}\n  C -- Yes --> D[Switch Nginx Upstream]\n  C -- No --> E[Rollback to Blue]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T10:39:50.586Z","createdAt":"2026-01-17T10:39:50.586Z"},{"id":"q-3433","question":"On a fresh RHEL 9 server, set up a minimal local Yum repository mirror to host a subset of packages. Create a non-privileged user reposync, configure httpd to serve /var/www/html/repos, set up reposync -p /var/www/html/repos -r base -n to populate the mirror, and automate with a systemd service and daily timer. Enable GPG verification and log rotation. Provide exact commands for user creation, systemd unit, timer, httpd, and logrotate?","answer":"Create user reposync; install httpd and yum-utils; configure /var/www/html/repos as web root; run reposync -p /var/www/html/repos -r base -n via a systemd service, triggered by a daily timer; import and configure GPG keys for verification; set up logrotate for reposync logs.","explanation":"## Why This Is Asked\nTests the ability to set up a local, secure package mirror with an unprivileged worker, automated scheduling, proper web serving, and log maintenance—core RHCSA skills.\n\n## Key Concepts\n- reposync usage and local mirror layout\n- systemd service and timer for automation\n- httpd configuration and permissions\n- GPG verification and key management\n- logrotate for auditability and disk health\n\n## Code Example\n```bash\n# Example systemd service (reposync.service)\n[Unit]\nDescription=Populate local Yum mirror\nAfter=network.target\n\n[Service]\nType=oneshot\nUser=reposync\nExecStart=/usr/bin/reposync -p /var/www/html/repos -r base -n\nStandardOutput=journal\nStandardError=journal\n```\n\n```bash\n# Example systemd timer (reposync.timer)\n[Unit]\nDescription=Daily reposync for local mirror\nRequires=reposync.service\n\n[Timer]\nOnCalendar=daily\nPersistent=true\n\n[Install]\nWantedBy=timers.target\n```\n\n```bash\n# Example httpd config snippet\nAlias /repos /var/www/html/repos\n<Directory /var/www/html/repos>\n    Options Indexes FollowSymLinks\n    AllowOverride None\n    Require all granted\n    EnableSendfile on\n</Directory>\n```\n\n## Follow-up Questions\n- How would you validate the mirror serves content correctly?\n- How would you add a second repo and handle multiple architectures?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","NVIDIA","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T04:02:01.775Z","createdAt":"2026-01-17T16:31:59.975Z"},{"id":"q-3462","question":"Scenario: A prod RHEL 9 fleet generates app logs at /var/log/myapp; implement a centralized TLS-enabled rsyslog forwarder to log-ops.example.local:6514. Use mutual TLS with a private CA, configure per-host queues to tolerate outages, ensure proper SELinux context, and update firewalld. Provide exact rsyslog.conf fragments, certificate paths, and verification steps?","answer":"Plan: establish internal CA and issue client certs for each host; server listens on 6514 with TLS and mutual auth; clients forward with omfwd tls, TLSCAFile, TLSCertFile, TLSKeyFile; enable per-host q","explanation":"## Why This Is Asked\nTests practical TLS, rsyslog config, and SELinux integration; covers reliability with offline queues and secure transport across hosts.\n\n## Key Concepts\n- rsyslog TLS forwarding\n- mutual TLS and cert management\n- per-host queues for reliability\n- SELinux and firewall adjustments\n- verification of log integrity\n\n## Code Example\n```javascript\n// Not applicable for this task\n```\n\n## Follow-up Questions\n- How would you rotate certificates without service downtime?\n- How would you monitor queue backlogs and alert on outages?","diagram":null,"difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","Meta","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T17:27:51.924Z","createdAt":"2026-01-17T17:27:51.925Z"},{"id":"q-3501","question":"On a fresh RHEL 9 host, configure a minimal static website that serves files from /var/www/html/app using httpd. Ensure httpd starts on boot, firewall allows HTTP, and SELinux context is correct so httpd can read the files. Provide exact commands and files touched?","answer":"yum install -y httpd; mkdir -p /var/www/html/app; printf 'Hello world' > /var/www/html/app/index.html; chown -R apache:apache /var/www/html/app; restorecon -R /var/www/html/app; semanage fcontext -a -","explanation":"## Why This Is Asked\nTests practical system administration skills: package management, service control, SELinux context handling, and firewall configuration in a real-world web hosting scenario.\n\n## Key Concepts\n- Installing and enabling httpd on RHEL 9\n- Correct document root permissions and ownership\n- SELinux file contexts for web content (httpd_sys_content_t)\n- Firewall rules for HTTP access\n\n## Code Example\n```javascript\n# commands shown in answer above\n```\n\n## Follow-up Questions\n- What if SELinux blocks access after a semanage change; how would you diagnose and fix it?\n- How would you automate this setup with a simple Ansible playbook?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Salesforce","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-17T18:56:01.654Z","createdAt":"2026-01-17T18:56:01.654Z"},{"id":"q-3586","question":"On a fresh RHEL 9 server, configure a non-login systemd timer that runs every 15 minutes a small script which prints the host name and current time to a log file at /var/log/usage.log, and configure logrotate to rotate that log daily keeping 7 days of history; provide exact commands for creating the user, script, timer/unit files, and logrotate config?","answer":"Create a non-login user with `useradd -r -s /sbin/nologin usage`. Create a script at `/home/usage/collect.sh` that appends the hostname and current timestamp to `/var/log/usage.log`, then make it executable. Set up a systemd user service and timer in `/home/usage/.config/systemd/user/` configured to execute every 15 minutes. Finally, configure logrotate at `/etc/logrotate.d/usage` to perform daily rotations while retaining 7 days of log history.","explanation":"## Why This Is Asked\nThis question evaluates practical system administration skills including systemd user services, timer configuration, file permissions, and log management in a real-world operational scenario.\n\n## Key Concepts\n- systemd user services and timers\n- non-login user accounts and security\n- basic Bash scripting for logging\n- log rotation configuration with logrotate\n\n## Code Example\n```bash\n# /home/usage/collect.sh\n#!/bin/bash\nhostname >> /var/log/usage.log\ndate '+%F %T' >> /var/log/usage.log\n```\n\n```ini\n# /home/usage/.config/systemd/user/usage.service\n[Unit]\nDescription=Log hostname and timestamp to usage.log\n\n[Service]\nType=oneshot\nExecStart=/home/usage/collect.sh\n```\n\n```ini\n# /home/usage/.config/systemd/user/usage.timer\n[Unit]\nDescription=Run usage logging every 15 minutes\n\n[Timer]\nOnCalendar=*:0/15\nPersistent=true\n\n[Install]\nWantedBy=timers.target\n```\n\n```bash\n# /etc/logrotate.d/usage\n/var/log/usage.log {\n    daily\n    rotate 7\n    compress\n    missingok\n    notifempty\n    create 644 usage usage\n}\n```","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Discord","LinkedIn"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T05:34:01.376Z","createdAt":"2026-01-17T22:35:42.163Z"},{"id":"q-3832","question":"On a RHEL 9 host, a kernel update crashes a critical service. Implement an auditable rollback workflow: 1) pin the problematic kernel with dnf versionlock, 2) keep older kernel installed, 3) configure GRUB to boot the older kernel by default, 4) provide a one-shot rollback script that switches GRUB default to the older entry and reboots, 5) ensure all actions are logged in /var/log/rollback.log. Include exact commands, files, and a minimal test?","answer":"dnf versionlock add kernel-5.14.0-116.el9.x86_64; verify older kernels exist in /boot; edit /etc/default/grub to GRUB_DEFAULT=1>2; grub2-mkconfig -o /boot/grub2/grub.cfg; create /usr/local/sbin/rollba","explanation":"## Why This Is Asked\nTests disciplined rollback, bootloader mastery, and auditability under production pressure. It combines package pinning, boot config, and rollback tooling.\n\n## Key Concepts\n- dnf versionlock for kernel management\n- GRUB default vs saved entries\n- one-shot rollback script with idempotent logging\n- verification and test plan\n\n## Code Example\n```bash\n# Pin offending kernel\ndnf versionlock add kernel-5.14.0-116.el9.x86_64\n# Configure GRUB to older entry and rebuild config\ngrub2-mkconfig -o /boot/grub2/grub.cfg\n# Rollback script should set-default to older entry and reboot\n```\n\n## Follow-up Questions\n- How would you automate this with Ansible?\n- How would you test rollback safely in a staging environment?","diagram":"flowchart TD\n  A[Kernel Update] --> B[Pin bad kernel with versionlock]\n  B --> C[Set GRUB to older kernel by default]\n  C --> D[Regenerate grub config]\n  D --> E[Create rollback script + logging]\n  E --> F[Test rollback]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Goldman Sachs","LinkedIn"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-18T11:28:15.387Z","createdAt":"2026-01-18T11:28:15.387Z"},{"id":"q-3996","question":"On a fresh RHEL 9 server, configure firewalld to allow SSH access only from subnet 10.0.0.0/24, ensure the rule is permanent and persists after reboot, and verify by attempting to connect from an allowed host and a disallowed host. Provide exact commands to install and start firewalld, create the permanent rule, reload, and verify with firewall-cmd and nc?","answer":"Install, configure, and verify firewalld with SSH restricted to 10.0.0.0/24:\n\n```bash\n# Install and start firewalld\ndnf install -y firewalld\nsystemctl enable --now firewalld\n\n# Set default zone to public (if not already)\nfirewall-cmd --set-default-zone=public\n\n# Add permanent rich rule for SSH from specific subnet\nfirewall-cmd --permanent --add-rich-rule='rule family=\"ipv4\" source address=\"10.0.0.0/24\" service name=\"ssh\" accept'\n\n# Remove default SSH service to block other sources\nfirewall-cmd --permanent --remove-service=ssh\n\n# Reload to apply permanent rules\nfirewall-cmd --reload\n\n# Verify configuration\nfirewall-cmd --list-all\nfirewall-cmd --list-rich-rules\n\n# Test from allowed host (on 10.0.0.0/24)\nnc -zv server_ip 22  # Should show Connection succeeded\nssh user@server_ip    # Should connect successfully\n\n# Test from disallowed host (outside 10.0.0.0/24)\nnc -zv server_ip 22  # Should timeout or show Connection refused\nssh user@server_ip    # Should timeout or refuse\n```","explanation":"## Why This Is Asked\nTests essential RHCSA firewalld skills: permanent rule configuration, rich rule syntax for source-based filtering, and comprehensive verification.\n\n## Key Concepts\n- Permanent vs runtime firewalld rules\n- Rich rule syntax for granular source-based access control\n- Service-based firewall management vs port-based rules\n- End-to-end verification using firewall-cmd and network testing tools\n\n## Critical Details\n- `--permanent` flag ensures rules persist after reboot\n- Rich rules allow source IP filtering with service names\n- Always remove default SSH service to prevent unrestricted access\n- Use both firewall-cmd verification and actual network testing\n\n## Follow-up Questions\n- How to allow SSH from multiple subnets? (Add additional rich rules)\n- How to log blocked SSH attempts? (Add `log prefix=\"ssh-blocked\" level=\"notice\"` to rich rule)\n- How to temporarily override for maintenance? (Use `--timeout` with temporary rules)","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Meta","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T04:01:46.144Z","createdAt":"2026-01-18T18:53:44.670Z"},{"id":"q-4058","question":"On a fresh RHEL 9 server, create a non-login user 'web' and serve a static site from /srv/www on port 8080 using a per-service systemd unit that runs as 'web'. Provide exact commands to create the user, prepare the site, write the unit file at /etc/systemd/system/website.service, enable and start the service, and adjust the firewall to allow 8080; verify with curl http://localhost:8080 and confirm the process runs as user 'web'?","answer":"Create a non-login system user named 'web', deploy a static website to /srv/www, and serve it on port 8080 using a systemd service unit configured to run as the 'web' user. The implementation includes user creation, file permission setup, systemd service configuration, service activation, firewall configuration, and verification steps.","explanation":"## Why This Is Asked\nThis question evaluates the ability to configure systemd services with non-root execution, demonstrating proper security practices, service isolation, and system administration skills on RHEL 9.\n\n## Key Concepts\n- Systemd service configuration using the User= directive\n- Non-login system users for service isolation\n- Firewall-cmd for permanent port management\n- File permissions and SELinux context handling\n- Service verification and process ownership confirmation\n\n## Code Example\n```bash\n# /etc/systemd/system/website.service\n[Unit]\nDescription=Static website service\nAfter=network.target\n\n[Service]\nType=simple\nUser=web\nExecStart=/usr/bin/python3 -m http.server 8080 --directory /srv/www\nRestart=on-failure\nRestartSec=5s\n\n[Install]\nWantedBy=multi-user.target\n```","diagram":"flowchart TD\n  A[Create user web] --> B[Create site dir /srv/www]\n  B --> C[Write systemd unit]\n  C --> D[Enable and start service]\n  D --> E[Open firewall]\n  E --> F[Test with curl]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Discord","MongoDB","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T05:57:47.337Z","createdAt":"2026-01-18T21:49:24.378Z"},{"id":"q-4074","question":"On a RHEL 9 host, configure rsyslog to forward all application logs to a TLS-enabled remote collector at loghub.example.com:10514. Enforce certificate validation, use a persistent disk-backed queue to retain logs for 30 days if the network is down, and verify with a test log entry. Provide exact rsyslog.conf fragments, TLS options, and rollback steps?","answer":"Install rsyslog, enable TLS, and forward with a disk-backed queue. Example fragments:\n\n```\n$DefaultNetstreamDriver gtls\n$ActionSendStreamDriver gtls\n$TLSCACertificateFile /etc/pki/tls/certs/ca-bundle.crt\n$TLSCertificateFile /etc/pki/tls/certs/rsyslog-client.crt\n$TLSKeyFile /etc/pki/tls/private/rsyslog-client.key\n$ActionSendStreamDriverAuthMode x509/name\n$ActionSendStreamDriverPermittedPeer loghub.example.com\n\n# Disk-backed queue configuration\n$ActionQueueFileName fwdq1\n$ActionQueueMaxDiskSpace 1g\n$ActionQueuePersistencyInterval 600\n$ActionQueueTimeoutEnqueue 86400\n$ActionQueueSaveOnShutdown on\n\n# Forward all application logs\n*.* @@loghub.example.com:10514\n```","explanation":"## Why This Is Asked\nTests TLS-enabled log forwarding, queueing to survive outages, and rollback procedures—core ops skills for RHCSA-level reliability work.\n\n## Key Concepts\n- rsyslog TLS forward with omfwd\n- TLS options: ca/cert/key files, verify peer\n- Disk-backed action queue for resilience\n- Safe rollback steps and verification\n\n## Code Example\n```javascript\n# /etc/rsyslog.d/60-forward.conf (illustrative)\n$DefaultNetstreamDriver gtls\n$ActionSendStreamDriver gtls\n$TLSCACertificateFile /etc/pki/tls/certs/ca-bundle.crt\n$TLSCertificateFile /etc/pki/tls/certs/rsyslog-client.crt\n$TLSKeyFile /etc/pki/tls/private/rsyslog-client.key\n$ActionSendStreamDriverAuthMode x509/name\n$ActionSendStreamDriverPermittedPeer loghub.example.com\n\n# Disk-backed queue configuration\n$ActionQueueFileName fwdq1\n$ActionQueueMaxDiskSpace 1g\n$ActionQueuePersistencyInterval 600\n$ActionQueueTimeoutEnqueue 86400\n$ActionQueueSaveOnShutdown on\n\n# Forward all application logs\n*.* @@loghub.example.com:10514\n```\n\n## Verification & Rollback\n```bash\n# Test configuration syntax\nrsyslogd -N1 -f /etc/rsyslog.conf\n\n# Send test log entry\nlogger \"Test TLS forward to loghub.example.com\"\n\n# Verify queue status\nls -la /var/spool/rsyslog/\n\n# Rollback: disable forwarding\nmv /etc/rsyslog.d/60-forward.conf /etc/rsyslog.d/60-forward.conf.disabled\nsystemctl restart rsyslog\n```","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Google","Hashicorp"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T05:53:02.963Z","createdAt":"2026-01-18T22:46:06.688Z"},{"id":"q-4084","question":"On a RHEL 9 host, deploy a new service in its own network namespace with a dedicated veth pair, assign 192.168.100.2/24 inside, and 192.168.100.1/24 on the host. Configure NAT and per-namespace traffic logging using nftables. Provide exact commands to create the netns, veth pair, move one end to the namespace, set addresses, enable IP forwarding, and a minimal systemd unit to run the service inside the namespace?","answer":"Create a network namespace (myservice), establish a veth pair (veth-host and veth-ns), assign veth-ns to the myservice namespace, configure IP addresses 192.168.100.1/24 on veth-host and 192.168.100.2/24 on veth-ns, enable IP forwarding, implement nftables NAT masquerading, set up per-namespace traffic logging, and create a minimal systemd unit to run the service within the namespace.","explanation":"## Why This Is Asked\nTests network namespace isolation, container-like routing, and host firewall interaction on RHEL 9 in a production-like scenario.\n\n## Key Concepts\n- Network namespaces, veth setup, IP addressing\n- IP forwarding and NAT with nftables\n- Systemd integration for netns-based services\n\n## Code Example\n```bash\n# example commands\n```\n\n## Follow-up Questions\n- How would you monitor per-namespace traffic and implement detailed logging?\n- How would you handle cleanup if the service crashes?","diagram":null,"difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Meta","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T05:50:20.442Z","createdAt":"2026-01-18T23:29:00.163Z"},{"id":"q-4115","question":"On a RHEL 9 host running PostgreSQL with the data directory on an LV mounted at /var/lib/pgsql/data, design and implement a zero-downtime migration to a new XFS LV mounted at /srv/pgsql, preserving SELinux contexts and existing client URLs. Provide exact commands for LV creation, filesystem setup, an rsync-based data copy, a brief cutover sequence, and rollback steps?","answer":"Plan: create a new LV vg/pgsql2, format with XFS, mount at /srv/pgsql; perform initial rsync with -aH --inplace --progress /var/lib/pgsql/data/ /srv/pgsql/; execute final sync during brief maintenance window; atomically swap data directories by renaming old and new directories; update PostgreSQL configuration and restart service.","explanation":"## Why This Is Asked\nTests practical data-migration skills on live systems, including LVM, XFS, SELinux, and PostgreSQL, with a focus on minimal downtime and safe rollback.\n\n## Key Concepts\n- LVM: PV, VG, LV creation and sizing\n- Filesystems: mkfs.xfs, mount options, fstab, SELinux relabeling\n- Data migration: rsync with -aH --inplace to preserve hard links and permissions\n- PostgreSQL: data_dir switch, VACUUM/ANALYZE validity, WAL/archiving continuity\n- Atomic switch: using directory renaming to avoid copy during cutover\n- Rollback: restore old path and restart service\n\n## Code Example\n```java","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Cloudflare","Databricks"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T05:09:56.149Z","createdAt":"2026-01-19T02:49:10.303Z"},{"id":"q-4192","question":"On a RHEL 9 host, deploy a small service at /opt/websvc that runs as user websvc, listens on port 8443, and writes data to /var/lib/websvc/data. The default SELinux policy blocks both data access and network binding. Provide exact commands and steps to (1) create a minimal systemd unit, (2) label the directories, and (3) implement a dedicated SELinux module (websvc_t) that allows websvc_t to read /opt/websvc, write to /var/lib/websvc/data, and bind to 8443, plus firewall adjustments and a test plan?","answer":"Deploy a small service at /opt/websvc running as user websvc, listening on 8443 and writing data to /var/lib/websvc/data. Create a minimal systemd unit, label the directories, and implement a dedicate","explanation":"## Why This Is Asked\n\nTests practical SELinux customization and systemd integration on RHCSA level.\n\n## Key Concepts\n\n- SELinux module creation (websvc_t)\n- File context labeling and restorecon\n- systemd unit with proper permissions\n- Firewall and port labeling (8443)\n\n## Code Example\n\n```bash\n# SELinux module skeleton\ncat > websvc.te << 'EOF'\nmodule websvc_t 1.0;\nrequire {\n  type websvc_t;\n  type var_lib_t;\n  class file { read write getattr };\n  class tcp_socket name_bind;\n}\n# policy rules go here\nEOF\n```\n\n## Follow-up Questions\n\n- How would you automate policy deployment?\n- How would you test rollback if policy blocks service startup?","diagram":"flowchart TD\n  A[Install service] --> B[Label files]\n  B --> C[Create SELinux module]\n  C --> D[Configure firewall]\n  D --> E[Test with curl]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T07:06:35.727Z","createdAt":"2026-01-19T07:06:35.728Z"},{"id":"q-4217","question":"Scenario: A RH9 host runs MongoDB with its data directory on an LV mounted at /data/mongo (XFS). During a maintenance window migrate the data dir to a new LV data_mongo_new of equal size mounted at /data/mongo2 preserving SELinux contexts and keeping client access seamless with no downtime. Provide exact commands to create the LV, format copy data update fstab and SELinux contexts perform the swap with minimal downtime and rollback steps if needed?","answer":"Create a new LV for Mongo data, format, mount at /data/mongo2; quiesce writes using MongoDB fsyncLock, rsync data from /data/mongo to /data/mongo2, then swap mounts to make /data/mongo point to the ne","explanation":"## Why This Is Asked\nTests live storage migration skills with minimal downtime while preserving SELinux context and service availability.\n\n## Key Concepts\n- LVM snapshots and new LV creation\n- Filesystem (XFS) on RH9\n- SELinux labeling and fstab updates\n- MongoDB fsyncLock for brief quiesce\n\n## Code Example\n```javascript\n// Mongo fsyncLock example (admin commands)\nuse admin\ndb.runCommand({fsync: 1, lock: true})\n// later: db.fsyncUnlock()\n```\n\n## Follow-up Questions\n- How would you verify data consistency after swap?\n- What are edge cases if the DB has large unflushed data?","diagram":"flowchart TD\n  Start(Start) --> LVCreate[Create data_mongo_new LV]\n  LVCreate --> FS[XFS format]\n  FS --> Mount[Mount to /data/mongo2]\n  Mount --> Quiesce[db.runCommand({fsync:1, lock:true})]\n  Quiesce --> Rsync[Rsync /data/mongo -> /data/mongo2]\n  Rsync --> Swap[Swap mounts to /data/mongo]\n  Swap --> Fstab[Update /etc/fstab and SELinux]\n  Fstab --> Verify[Verify with mongod]\n  Verify --> End(End)","difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Netflix"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T09:08:08.710Z","createdAt":"2026-01-19T09:08:08.710Z"},{"id":"q-4276","question":"On a fresh RHEL 9 server, deploy a tiny HTTP server that serves static files from /srv/www on port 8080, running as a non-root user 'webstatic'. Implement a systemd service to keep it alive and a separate timer that runs a health-check every 5 minutes and restarts the service if needed. Configure log rotation for /var/log/webstatic.log. Provide exact commands for user creation, the wrapper script, the service unit, the health-check script, the timer, and the logrotate entry?","answer":"Create user webstatic; prepare /srv/www; wrapper: /usr/local/bin/run-webstatic.sh (#!/bin/bash; exec /usr/bin/python3 -m http.server 8080 --directory /srv/www >> /var/log/webstatic.log 2>&1). systemd ","explanation":"## Why This Is Asked\nTests ability to combine user management, service lifecycle, health checks, and log management on a real host.\n\n## Key Concepts\n- Systemd service units and timers\n- Running daemons as non-root users\n- Simple health checks and automated restarts\n- Log rotation for long-running processes\n\n## Code Example\n```bash\n# run-webstatic.sh\n#!/bin/bash\nexec /usr/bin/python3 -m http.server 8080 --directory /srv/www >> /var/log/webstatic.log 2>&1\n```\n\n## Follow-up Questions\n- How would you add SELinux context adjustments for /srv/www?\n- How would you test the health timer without waiting 5 minutes?","diagram":"flowchart TD\n  A[Create webstatic user] --> B[Prepare /srv/www]\n  B --> C[Write wrappers and units]\n  C --> D[Configure health timer]\n  D --> E[Set up logrotate]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T11:06:49.234Z","createdAt":"2026-01-19T11:06:49.235Z"},{"id":"q-4334","question":"On a RHEL 9 host running Apache with TLS, perform a patch upgrade of OpenSSL with minimal downtime across a single host. Provide exact commands to verify the current version, apply the patch while keeping configuration intact, validate TLS handshakes post-upgrade, and a rollback procedure in case the new libcrypto breaks compatibility (including rpm history and reversion)?","answer":"Check current versions: rpm -q openssl; rpm -q openssl-libs. Upgrade: dnf upgrade openssl openssl-libs -y. Validate: openssl version; openssl s_client -connect localhost:443 -servername yourhost. Rest","explanation":"## Why This Is Asked\nTests practical, time-efficient OpenSSL patching and rollback on a live RHCSA host with minimal downtime. It emphasizes verifications, rollback hygiene, and service continuity.\n\n## Key Concepts\n- Package management (dnf history, rollback)\n- Service continuity (reload vs restart)\n- TLS validation (openssl s_client)\n- Config preservation (certs, /etc/httpd)\n\n## Code Example\n```javascript\n// Example shell commands for patching OpenSSL on RH9\nrpm -q openssl\ndnf history list\ndnf upgrade openssl openssl-libs -y\nopenssl version\nopenssl s_client -connect localhost:443 -servername yourhost -tls1_2\n// Rollback if needed\n// Obtain the txn_id from 'dnf history list' and undo\n// dnf history undo <txn_id>\ndnf history list\n```\n\n## Follow-up Questions\n- How would you test this patch in a staging environment before prod?\n- How would you extend this to a multi-host cluster with a load balancer for zero-downtime upgrades?","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","Discord","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T14:45:34.117Z","createdAt":"2026-01-19T14:45:34.118Z"},{"id":"q-4361","question":"On a fresh RHEL 9 server, implement a small audit task: create a non-login user 'auditor', a script /usr/local/bin/collect-system-uptime.sh that appends date and uptime to /var/log/auditor/uptime.log, and schedule it with a systemd timer to run hourly. Ensure log rotation via /etc/logrotate.d/auditor and verify that file permissions and SELinux contexts allow the script to write under /var/log/auditor without enabling login. How would you implement this end-to-end?","answer":"Create a non-login user: useradd -m -s /sbin/nologin auditor. Write /usr/local/bin/collect-system-uptime.sh to log date and uptime; make it executable; ensure /var/log/auditor exists with correct owne","explanation":"## Why This Is Asked\nTests ability to compose a minimal, repeatable housekeeping task using standard RHEL9 tools: user management, scripting, systemd timers, log rotation, and basic SELinux considerations. It covers practical everyday ops and common pitfalls (permissions, context, rotation).\n\n## Key Concepts\n- User management with non-login accounts\n- Systemd: service + timer\n- Script writing and file permissions\n- Log rotation with logrotate\n- Basic SELinux context awareness\n\n## Code Example\n```javascript\n#!/bin/bash\nprintf '%s %s\\n' \"$(date)\" \"$(uptime -p)\" >> /var/log/auditor/uptime.log\n```\n\n## Follow-up Questions\n- How would you test the timer and verify rotation captured all entries?\n- How would you adapt this for multiple hosts or different log destinations?","diagram":"flowchart TD\nA[Create auditor user] --> B[Write script]\nB --> C[Configure systemd timer]\nC --> D[Set up logrotate]\nD --> E[Verify SELinux context]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","OpenAI","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T15:45:54.119Z","createdAt":"2026-01-19T15:45:54.119Z"},{"id":"q-4381","question":"On a RHEL 9 host, deploy a Go API service (port 8443) in a Podman container, behind an Nginx reverse proxy with TLS termination. The API must run as user 'apiuser', store data under /var/lib/api/data, and SELinux must allow network bind and file access. Implement a blue/green deployment on the same host with zero downtime and a rollback plan, including exact Podman unit files, nginx site config, SELinux policy snippet, and data-migration strategy?","answer":"Define a Podman pod named api-pod running as apiuser with /var/lib/api/data mounted and port 8443 exposed; configure nginx as TLS terminator with blue/green upstreams and a switch script; write a smal","explanation":"## Why This Is Asked\nTests practical application of containerization, SELinux, and deployment orchestration on a single host with zero-downtime goals.\n\n## Key Concepts\n- Podman pod lifecycle and per-service user mapping\n- SELinux policy customization for containerized apps\n- Nginx TLS termination and blue/green traffic shifting\n- Data migration, health checks, and rollback strategies\n\n## Code Example\n```bash\n# Podman setup (illustrative)\nsudo useradd -r apiuser\nsudo mkdir -p /var/lib/api/data\npodman pod create --name api-pod -p 8443:8443\npodman run -d --name api --pod api-pod -v /var/lib/api/data:/data:Z --user apiuser:apiuser myrepo/api:latest\n```\n\n```selinux\n# Minimal policy snippet outline (illustrative, not full policy)\nmodule api_t 1.0;\nrequire {\n  type container_runtime_t;\n  type api_data_t;\n  class file { read write getattr };\n  class dir { write read getattr };\n  type self;\n  class net_bind_service;\n}\nallow api_t api_data_t:dir { write read getattr };\nallow api_t api_data_t:file { read write getattr };\n# Allow binding to 8443 via runtime role\nallow api_t self:net_bind_service;\n```\n\n## Follow-up Questions\n- How would you extend this to multiple hosts with a shared data backend and zero-downtime failover?\n- What observability and metrics would you add to detect drift between blue/green environments?","diagram":null,"difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Instacart","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T16:47:38.465Z","createdAt":"2026-01-19T16:47:38.465Z"},{"id":"q-4490","question":"On a fresh RHEL 9 server, implement a tiny static web server that serves /srv/www on port 8080, running as a non-root user via systemd, with access logs written to /var/log/webmon/access.log and rotated. Provide exact commands to create the user, the server script, the systemd unit, SELinux labeling for /srv/www, and a logrotate config; ensure firewall allows 8080?","answer":"Create user webmon; write a minimal Python http.server script at /home/webmon/server.py serving /srv/www on 8080; a systemd unit /etc/systemd/system/webmon.service running as webmon. Label /srv/www wi","explanation":"## Why This Is Asked\nTests practical systemd, SELinux, and firewall basics with a realistic, minimal service. It checks ability to integrate multiple subsystems in a safe, non-root context.\n\n## Key Concepts\n- systemdUnit basics and service permissions\n- SELinux labeling for content directories\n- firewalld port opening and persistence\n- log rotation for application logs\n\n## Code Example\n```ini\n[Unit]\nDescription=Webmon static web server\n\n[Service]\nUser=webmon\nExecStart=/usr/bin/python3 /home/webmon/server.py\nRestart=on-failure\n\n[Install]\nWantedBy=multi-user.target\n```\n\n```python\nfrom http.server import SimpleHTTPRequestHandler\nimport socketserver\nPORT = 8080\nHandler = SimpleHTTPRequestHandler\nwith socketserver.TCPServer(('', PORT), Handler) as httpd:\n    print('serving at port', PORT)\n    httpd.serve_forever()\n```\n\n```sh\n/var/log/webmon/access.log {\n  daily\n  rotate 14\n  compress\n  missingok\n  notifempty\n  create 0640 webmon webmon\n}\n```\n\n## Follow-up Questions\n- How would you extend to TLS without root privileges?\n- How would you add basic health checks to the systemd unit?","diagram":"flowchart TD\n  A[Start] --> B[Create user webmon]\n  B --> C[Add server.py]\n  C --> D[Create systemd unit webmon.service]\n  D --> E[Label /srv/www with SELinux]\n  E --> F[Open 8080 in firewalld]\n  F --> G[Deploy logrotate for /var/log/webmon/access.log]\n  G --> H[Test locally on port 8080]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Hugging Face"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-19T20:53:15.901Z","createdAt":"2026-01-19T20:53:15.901Z"},{"id":"q-4615","question":"On a RHEL 9 host, TLS terminates at Nginx in front of a backend app. Certificates expire in 24 hours. Implement a zero-downtime certificate rotation strategy: (1) renew and install new certs to a separate path, (2) swap a symlink used by ssl_certificate to point to the new cert, (3) gracefully reload Nginx, (4) verify handshakes and SELinux contexts. Provide exact commands and validation steps?","answer":"Perform a canary-like rotation by using a symlink for ssl_certificate and ssl_certificate_key. After renewal, place cert-new.pem and key-new.pem in /etc/ssl/app, then: ln -sfn cert-new.pem cert-curren","explanation":"## Why This Is Asked\nTests practical, real-world maintenance of TLS in a single-host stack with zero downtime, SELinux awareness, and validation.\n\n## Key Concepts\n- Zero-downtime certificate rotation\n- Atomic symlink swap for ssl_certificate paths\n- Nginx graceful reload and TLS session handling\n- SELinux file contexts and troubleshooting\n\n## Code Example\n```bash\n# renewal (example use with certbot)\ncertbot renew --deploy-hook \"cp /etc/ssl/app/cert.pem /etc/ssl/app/cert-new.pem; cp /etc/ssl/app/privkey.pem /etc/ssl/app/key-new.pem\"\n\n# swap and reload (atomic)\nln -sfn cert-new.pem cert-current.pem\nln -sfn key-new.pem key-current.pem\nsystemctl reload nginx\n```\n\n## Follow-up Questions\n- How would you handle multiple upstreams and TLS session resumption?\n- What additional audit steps would you add for SELinux denials during rotation?","diagram":"flowchart TD\n  A[Renewal] --> B[Install new certs] \n  B --> C[Swap ssl_certificate symlink] \n  C --> D[Nginx reload] \n  D --> E[Health and TLS verify]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Salesforce","Square","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T04:33:28.590Z","createdAt":"2026-01-20T04:33:28.591Z"},{"id":"q-4788","question":"On a RHEL 9 host running three Podman containers (web, api, db) attached to a dedicated bridge, design and implement an nftables firewall that: (1) blocks inbound to the host except SSH and per-container ports limited to container IPs; (2) allows outbound DNS and HTTPS; (3) isolates containers from each other; (4) logs denied attempts; (5) provides /etc/nftables.conf and a rollback plan with verification steps. What exact configuration would you use?","answer":"Design and implement an nftables firewall on a RHEL 9 host running three Podman containers (web, api, db) on a dedicated bridge. Inbound: allow SSH and per-container ports only from the container brid","explanation":"## Why This Is Asked\nTests practical firewalling in a containerized Linux host, focusing on nftables, container networks, and safe rollback.\n\n## Key Concepts\n- nftables inet table and ruleset construction\n- Podman bridge networks and container IP scoping\n- Inbound vs outbound traffic controls and logging\n- Rollback and verification when applying host-level firewall changes\n\n## Code Example\n```bash\n#!/usr/sbin/nft -f\n# Minimal skeleton; real config would define table inet fw, chains input/forward/output,\n# allow lo, established connections, SSH, container ports by container IPs, and DNS/HTTPS outbound\n```\n\n## Follow-up Questions\n- How would you test without lockout of SSH?\n- How would you persist rules across reboots and migrate to a different host?","diagram":"flowchart TD\n  A[Host (RHEL 9)] --> B[Container: web (10.0.0.2)]\n  A --> C[Container: api (10.0.0.3)]\n  A --> D[Container: db (10.0.0.4)]\n  E[Rules] --> F{Inbound}\n  F --> G[SSH 22 allowed]\n  F --> H[web 80/443 allowed from bridge IPs]\n  F --> I[api 8080 allowed from bridge IPs]\n  F --> J[db 5432 allowed from bridge IPs]\n  E --> K{Outbound}\n  K --> L[DNS 53 allowed]\n  K --> M[HTTPS 443 allowed]\n  F --> N[Isolation: containers cannot reach each other unless allowed]\n  N --> O[Logging: deny events to /var/log/nftables.log]","difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","MongoDB","Uber"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T13:10:33.273Z","createdAt":"2026-01-20T13:10:33.273Z"},{"id":"q-4852","question":"On a RHEL 9 host, you must set up a secure local YUM/DNF repository mirror for security updates to serve a LAN of 50 hosts. Provide exact steps to create the mirror at /srv/repos, configure httpd with proper SELinux contexts, use reposync/createrepo_c to generate metadata, sign packages, and enable client GPG verification, plus a minimal-downtime nightly sync and a rollback plan if the mirror goes out of sync?","answer":"Configure a local YUM/DNF mirror on RHEL9 at /srv/repos, serving via httpd with proper SELinux contexts. Use reposync to fetch baseos/appstream, run createrepo_c to generate metadata, sign with RPM-GP","explanation":"## Why This Is Asked\nTests practical repo mirroring, SELinux, and high-availability downtime handling.\n\n## Key Concepts\n- YUM/DN F repos, reposync, createrepo_c\n- SELinux contexts and booleans for httpd\n- GPG signing and client verification\n- Systemd timers for automation\n- Atomic switch and rollback strategy\n\n## Code Example\n```bash\n# Sample repository config\n```\n\n## Follow-up Questions\n- How would you verify integrity of mirrored packages?\n- How would you scale to Satellite or multiple mirrors?\n","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["MongoDB","Netflix","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-20T16:18:37.376Z","createdAt":"2026-01-20T16:18:37.376Z"},{"id":"q-5014","question":"On a RHEL 9 host running Apache with PHP serving /var/www/html, migrate to an encrypted LUKS volume mounted at /mnt/secure_www and switch traffic with zero downtime. Provide exact commands to: 1) create a new LV and LUKS container, 2) format and mount at /mnt/secure_www, 3) rsync data preserving perms, 4) update /etc/fstab and initramfs, 5) set SELinux context for httpd_sys_content_t, 6) change Apache DocumentRoot to /mnt/secure_www/html and gracefully reload, 7) rollback plan?","answer":"Create a new LV and LUKS container, open and format, mount at /mnt/secure_www, then rsync and switch DocumentRoot. Commands: lvcreate -L20G -n secure_www vg0; cryptsetup luksFormat /dev/vg0/secure_www","explanation":"## Why This Is Asked\nThis tests practical disk encryption, live data migration with minimal downtime, and integration with SELinux and initramfs on RHCSA-level systems.\n\n## Key Concepts\n- LUKS/dm-crypt, LVM, initramfs, SELinux contexts, rsync, graceful reloads\n- Downtime minimization and rollback\n\n## Code Example\n```bash\n# Step examples\n# create LV, luksFormat, open, format\nlvcreate -L 20G -n secure_www vg0\ncryptsetup luksFormat /dev/vg0/secure_www\ncryptsetup open /dev/vg0/secure_www secure_www\nmkfs.xfs /dev/mapper/secure_www\n... # mount, rsync commands\n```\n\n## Follow-up Questions\n- How would","diagram":"flowchart TD\n  A[Assess current site] --> B[Create LUKS container and LV]\n  B --> C[Format filesystem]\n  C --> D[Copy data to new mount]\n  D --> E[Update fstab and initramfs]\n  E --> F[Remount and test]\n  F --> G[Switch Apache DocumentRoot to new mount]\n  G --> H[Monitor and validate]\n  H --> I[Rollback plan if needed]","difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","MongoDB","Robinhood"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T05:24:30.642Z","createdAt":"2026-01-20T23:51:54.919Z"},{"id":"q-5055","question":"On a RHEL 9 host, harden SSH access for the user deploy: generate a 4096-bit RSA key, place the public key in /home/deploy/.ssh/authorized_keys, ensure proper permissions, and configure sshd to disable password authentication and root login. Restart sshd and verify login via the key from a separate session?","answer":"Generate a 4096-bit RSA key for deploy: ssh-keygen -t rsa -b 4096 -f /home/deploy/.ssh/id_rsa -N '' -C 'deploy@host'; ensure /home/deploy/.ssh exists with 700 and authorized_keys with 600, append the ","explanation":"## Why This Is Asked\nTests hands-on SSH hardening in RHCSA-style tasks, ensuring secure key-based authentication, proper file permissions, and correct access controls.\n\n## Key Concepts\n- SSH daemon hardening (sshd_config)\n- Public key authentication, authorized_keys perms\n- User permissions and home directory security\n- Service management (systemctl restart sshd)\n\n## Code Example\n```bash\n# as root or user with sudo\nmkdir -p /home/deploy/.ssh\nchmod 700 /home/deploy/.ssh\nssh-keygen -t rsa -b 4096 -f /home/deploy/.ssh/id_rsa -N '' -C 'deploy@host'\ncat /home/deploy/.ssh/id_rsa.pub >> /home/deploy/.ssh/authorized_keys\nchmod 600 /home/deploy/.ssh/authorized_keys\nsed -i 's/^#*PasswordAuthentication.*/PasswordAuthentication no/' /etc/ssh/sshd_config\nsed -i 's/^#*PermitRootLogin.*/PermitRootLogin no/' /etc/ssh/sshd_config\nsystemctl restart sshd\n```\n\n## Follow-up Questions\n- How would you recover if you lose the deploy private key?\n- What additional controls would you add for auditing SSH access?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Hashicorp","LinkedIn"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-21T04:12:32.417Z","createdAt":"2026-01-21T04:12:32.417Z"},{"id":"q-933","question":"On a fresh RHEL 9 installation with a 120 GB disk, implement an LVM layout: ROOT 40G, HOME 40G, VAR 40G, all using XFS. Create PV, VG, and LVs, format, and mount at /, /home, /var with fstab. Enable and configure firewalld to allow http and https. Ensure SELinux is enforcing. Create a non-root user 'dev' and add to the wheel group with sudo privileges. Show commands and rationale?","answer":"I would create a single PV on /dev/sda, a VG named rhel, and three LVs: root, home, var at 40G each. After mkfs.xfs on each, mount them to /, /home, /var and persist in /etc/fstab. Enable firewalld an","explanation":"## Why This Is Asked\nTests practical, real-world sysadmin tasks: LVM planning, filesystem layout, boot/root considerations, firewall and SELinux configuration, and user privilege management.\n\n## Key Concepts\n- LVM: pvcreate, vgcreate, lvcreate\n- Filesystems: XFS and fstab\n- Security: SELinux enforcing and wheel-based sudo\n- Networking: firewalld http/https rules\n\n## Code Example\n```bash\npvcreate /dev/sda\nvgcreate rhel /dev/sda\nlvcreate -L40G -n root rhel\nlvcreate -L40G -n home rhel\nlvcreate -L40G -n var rhel\nmkfs.xfs /dev/rhel/root\nmkfs.xfs /dev/rhel/home\nmkfs.xfs /dev/rhel/var\nmount /dev/rhel/root /\nmkdir -p /home /var\nmount /dev/rhel/home /home\nmount /dev/rhel/var /var\n# /etc/fstab entries would reference /dev/rhel/... set here\nsystemctl enable --now firewalld\nfirewall-cmd --permanent --add-service=http\nfirewall-cmd --permanent --add-service=https\nfirewall-cmd --reload\nsetenforce 1\nsed -i 's/^SELINUX=.*/SELINUX=enforcing/' /etc/selinux/config\nuseradd -m dev\nusermod -aG wheel dev\n```\n\n## Follow-up Questions\n- How would you resize LVs while preserving data?\n- How would you verify SELinux contexts after mounting new filesystems?","diagram":"flowchart TD\n  A[Disk] --> B[PV] \n  B --> C[VG] \n  C --> D[LVs: root, home, var] \n  D --> E[Mounts: /, /home, /var] \n  E --> F[Services: firewalld, SELinux, sudo]","difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","IBM","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":false,"lastUpdated":"2026-01-12T15:42:25.882Z","createdAt":"2026-01-12T15:42:25.882Z"}],"subChannels":["general"],"companies":["Adobe","Airbnb","Amazon","Anthropic","Apple","Bloomberg","Citadel","Cloudflare","Coinbase","Databricks","Discord","DoorDash","Goldman Sachs","Google","Hashicorp","Hugging Face","IBM","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Netflix","OpenAI","Oracle","PayPal","Plaid","Robinhood","Salesforce","Scale Ai","Snap","Snowflake","Square","Stripe","Tesla","Twitter","Two Sigma","Uber","Zoom"],"stats":{"total":56,"beginner":24,"intermediate":13,"advanced":19,"newThisWeek":42}}