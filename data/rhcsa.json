{"questions":[{"id":"q-1023","question":"Design a centralized, tamper-evident logging pipeline for 6 RHEL hosts. Include: enable persistent journald, forward logs over TLS to a central collector, configure rotation/retention, protect in transit with certificate-based auth, and a rollback/validation plan that proves delivery during outages. Outline testing steps and failure scenarios?","answer":"Enable persistent journald on all six hosts; configure rsyslog to forward logs via TLS to a central collector with certificate-based authentication; enforce rotation/retention (90 days) and archive to","explanation":"## Why This Is Asked\nConcrete, scalable, secure logging is critical in production. This question tests practical setup, TLS, journald/rsyslog integration, retention, and failover planning.\n\n## Key Concepts\n- systemd-journald persistent storage\n- TLS-encrypted log forwarding (rsyslog/omfwd)\n- log rotation and retention policies\n- log integrity and rollback strategies\n- outage/failover validation\n\n## Code Example\n```javascript\n// Simple hash of a log line to simulate tamper-detection\nconst crypto = require('crypto');\nfunction hashLine(line){ return crypto.createHash('sha256').update(line).digest('hex'); }\n```\n\n## Follow-up Questions\n- How would you verify end-to-end delivery during a network outage?\n- How would you rotate encryption certificates without dropping logs?","diagram":"flowchart TD\n  A[Hosts] --> B[Local journald]\n  B --> C[rsyslog forward]\n  C --> D[Central TLS collector]\n  D --> E[Archive/Retention]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Hashicorp"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T19:35:30.051Z","createdAt":"2026-01-12T19:35:30.051Z"},{"id":"q-1118","question":"On a RHEL 9 host, a service named app writes to /srv/app/data. After deployment, SELinux denials prevent writes. Without disabling SELinux, outline exact, implementable steps to restore functionality, including identifying the AVC, creating a targeted policy module with audit2allow, loading it, labeling the data directory, and validating the fix with a controlled write and audit checks?","answer":"Identify AVCs with ausearch -m avc -ts today | tail. Build a policy with: ausearch -m avc -ts today | audit2allow -M app_fix; load: semodule -i app_fix.pp. Label: semanage fcontext -a -t app_data_t '/","explanation":"## Why This Is Asked\nTests SELinux troubleshooting, policy generation, and safe remediation without disabling security controls.\n\n## Key Concepts\n- AVCs and audit2allow\n- Custom SELinux policy modules\n- File context labeling and restorecon\n- Validation via audits and controlled writes\n\n## Code Example\n```bash\n# 1) Identify AVCs from today\nausearch -m avc -ts today | tail\n# 2) Create a policy module\nausearch -m avc -ts today | audit2allow -M app_fix\n# 3) Load the policy\nsemodule -i app_fix.pp\n# 4) Label directory and content\nsemanage fcontext -a -t app_data_t '/srv/app/data(/.*)?'\nrestorecon -R /srv/app/data\n```\n\n## Follow-up Questions\n- How would you adjust this if the data directory is on NFS?\n- How can you troubleshoot if the policy still blocks legitimate writes after labeling?","diagram":"flowchart TD\n  A[App writes to /srv/app/data] --> B{AVC denied}\n  B --> C[Audit log shows AVC]\n  C --> D[Create policy with audit2allow]\n  D --> E[Load policy with semodule]\n  E --> F[Label dir with semanage/restorecon]\n  F --> G[Test write succeeds]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Hugging Face","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T23:27:33.371Z","createdAt":"2026-01-12T23:27:33.371Z"},{"id":"q-1148","question":"On a RHEL 8 server, implement a daily backup of /home/userdata to /backup/userdata-YYYYMMDD.tgz, exclude caches and temp dirs, preserve permissions, and generate a sha256 checksum. Schedule at 02:30 via cron and rotate backups to keep last 7 days. Provide commands and a script outline?","answer":"Use a cron-driven backup with tar -p and excludes, plus a sha256 checksum and a 7-day rotation. Example approach: create /backup if needed, tar czpf /backup/userdata-YYYY-MM-DD.tgz -p --exclude patter","explanation":"## Why This Is Asked\nTests practical backup scripting skills: tar with permissions, exclude patterns, integrity checks, cron scheduling, and simple rotation.\n\n## Key Concepts\n- tar with permission preservation\n- --exclude patterns\n- sha256sum checksums\n- cron scheduling\n- rotation by date\n\n## Code Example\n```bash\n#!/bin/bash\nDATE=$(date +%F)\nSRC=\"/home/userdata\"\nDEST=\"/backup\"\nTAR=\"$DEST/userdata-$DATE.tgz\"\nEXCLUDES=\"--exclude='**/.cache' --exclude='**/tmp'\"\ntar czpf \"$TAR\" -p $EXCLUDES \"$SRC\"\nsha256sum \"$TAR\" > \"$TAR.sha256\"\nfind \"$DEST\" -name 'userdata-*.tgz' -mtime +7 -delete\n```\n\n## Follow-up Questions\n- How would you implement incremental backups?\n- How would you verify restoration from a random backup file?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Goldman Sachs","Instacart","Lyft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T01:33:46.097Z","createdAt":"2026-01-13T01:33:46.097Z"},{"id":"q-1169","question":"Design and implement an encrypted root on LVM for a production RH host. Boot partition remains unencrypted; the root filesystem sits on a LUKS2 container inside an LVM PV, with a keyfile for unattended boot. Provide a concrete, command-level plan including crypttab, fstab, initramfs (dracut) generation, and grub configuration to ensure the system boots automatically after rotation?","answer":"Two-stage layout: /boot unencrypted; root on LUKS2 inside an LVM PV. Create 1G /boot partition and encrypt the rest. Steps: format and open LUKS, set up PV/VG/LV, create filesystem, copy data, update ","explanation":"## Why This Is Asked\nThis question probes practical, production-grade encryption setup, including boot-time unlocking, crypttab/fstab integration, and initramfs/grub changes — skills RHCSA expects for secure deployments.\n\n## Key Concepts\n- LUKS2 on a dedicated partition\n- LVM PV/VG/LV layering on top of a mapped device\n- crypttab and initramfs integration\n- Grub configuration and unattended boot considerations\n- Keyfile management and security\n\n## Code Example\n```javascript\n// Shell commands illustrating the flow\ncryptsetup luksFormat /dev/sdb2 --type luks2\ncryptsetup luksOpen /dev/sdb2 cryptroot --key-file /root/keyfile\npvcreate /dev/mapper/cryptroot\nvgcreate vg0 /dev/mapper/cryptroot\nlvcreate -L 100G -n root vg0\nmkfs.xfs /dev/vg0/root\n```\n\n## Follow-up Questions\n- How would you rotate the LUKS keyfile safely without reboot?\n- How do you verify the encrypted volume opens during boot with a degraded initramfs?","diagram":null,"difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Bloomberg","Plaid","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T03:35:27.852Z","createdAt":"2026-01-13T03:35:27.852Z"},{"id":"q-1192","question":"On a RHEL8 host, set up a minimal Python HTTP server listening on port 8080, accessible only from 192.168.100.0/24. Use a non-root user, a systemd service, SELinux port labeling, and firewalld rules. Provide exact commands to create the service, configure semanage for port 8080, apply firewall rules, and test from a client. Address potential SELinux and port conflict caveats?","answer":"Create a non-root user webu; place app.py with a minimal HTTP server listening on 0.0.0.0:8080; a systemd service webserver.service (User=webu, WorkingDirectory=/home/webu, ExecStart=/usr/bin/python3 ","explanation":"## Why This Is Asked\nTests practical sysadmin tasks across users, services, SELinux, and firewall rules.\n\n## Key Concepts\n- systemd service creation\n- semanage port labeling\n- firewalld rich rules for IP ranges\n- binding to 0.0.0.0 and access control\n- testing with curl\n\n## Code Example\n```javascript\n# /etc/systemd/system/webserver.service\n[Unit]\nDescription=Minimal Python HTTP server\nAfter=network-online.target\n[Service]\nUser=webu\nWorkingDirectory=/home/webu\nExecStart=/usr/bin/python3 /home/webu/app.py\nRestart=on-failure\n[Install]\nWantedBy=multi-user.target\n```\n\n```javascript\n# app.py\nimport http.server, socketserver\nPORT=8080\nHandler=http.server.SimpleHTTPRequestHandler\nwith socketserver.TCPServer((\"0.0.0.0\", PORT), Handler) as httpd:\n    httpd.serve_forever()\n```","diagram":"flowchart TD\n  A[Create user and app] --> B[Create systemd service]\n  B --> C[Label port with SELinux]\n  C --> D[Configure firewall]\n  D --> E[Test access]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Instacart","LinkedIn"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T04:42:25.489Z","createdAt":"2026-01-13T04:42:25.489Z"},{"id":"q-1247","question":"On a RHEL 8 server, a web service listens on 127.0.0.1:9090. Configure firewalld to expose port 9090 only to the 10.1.0.0/24 management network, log drops, and persist across reboots. Provide exact commands, and describe test steps using curl from an allowed host and from a non-allowed host?","answer":"firewall-cmd --get-default-zone\nfirewall-cmd --permanent --zone=public --add-rich-rule='rule family=\"ipv4\" source address=\"10.1.0.0/24\" port port=\"9090\" protocol=\"tcp\" accept'\nfirewall-cmd --permanent","explanation":"## Why This Is Asked\nTests practical firewall configuration with persistent rules and live-testing.\n\n## Key Concepts\n- firewalld zones and rich rules\n- persistence with --permanent and firewall-cmd reload\n- testing network access with curl\n\n## Code Example\n```javascript\n// Commands illustrating the approach\nfirewall-cmd --get-default-zone\nfirewall-cmd --permanent --zone=public --add-rich-rule='rule family=\"ipv4\" source address=\"10.1.0.0/24\" port port=\"9090\" protocol=\"tcp\" accept'\nfirewall-cmd --permanent --zone=public --add-rich-rule='rule family=\"ipv4\" port port=\"9090\" protocol=\"tcp\" drop'\nfirewall-cmd --reload\n```\n\n## Follow-up Questions\n- How would you audit if the rule is being bypassed by another chain? \n- How would you revert the changes quickly? ","diagram":"flowchart TD\n  A[Define allowed subnet] --> B[Add accept rich rule]\n  B --> C[Add drop rule for others]\n  C --> D[Reload firewalld]\n  D --> E[Test with curl]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T06:42:21.017Z","createdAt":"2026-01-13T06:42:21.017Z"},{"id":"q-1399","question":"You manage a RHEL 8 server running SSH on port 22. To improve security, change SSH to listen on port 2222, disable root SSH login, and require key-based authentication, ensuring no downtime for existing sessions. List the exact commands and steps to implement this, including firewall and SELinux considerations, and how you verify connectivity afterwards?","answer":"Edit /etc/ssh/sshd_config: Port 2222; PermitRootLogin no; PasswordAuthentication no. Reload: systemctl reload sshd. Firewall: firewall-cmd --permanent --add-port=2222/tcp; firewall-cmd --reload. SELin","explanation":"## Why This Is Asked\nTests practical admin tasks across SSH config, firewall, and SELinux with minimal downtime.\n\n## Key Concepts\n- SSH daemon configuration\n- Firewalld management\n- SELinux port labeling\n- Connectivity testing and rollback\n\n## Code Example\n```bash\n# modify ssh config\nsudo sed -i 's/^#?Port .*/Port 2222/' /etc/ssh/sshd_config\nsudo sed -i 's/^Port 22/Port 2222/' /etc/ssh/sshd_config\nsudo sed -i 's/^#?PermitRootLogin.*/PermitRootLogin no/' /etc/ssh/sshd_config\nsudo sed -i 's/^#?PasswordAuthentication.*/PasswordAuthentication no/' /etc/ssh/sshd_config\nsudo systemctl restart sshd\nsudo firewall-cmd --permanent --add-port=2222/tcp\nsudo firewall-cmd --reload\nsudo semanage port -a -t ssh_port_t -p tcp 2222\nsudo restorecon -R /etc/ssh\n# test connectivity from admin host\nssh -p 2222 user@host\n```\n\n## Follow-up Questions\n- How would you revert if something goes wrong during the change?\n- How would you verify there are no lingering insecure access attempts?","diagram":"flowchart TD\n  A[SSH Config] --> B[Restart SSHD]\n  B --> C[Firewall Rule]\n  C --> D[SELinux Port]\n  D --> E[Verification]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hugging Face","LinkedIn","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T15:40:50.563Z","createdAt":"2026-01-13T15:40:50.563Z"},{"id":"q-1484","question":"On a Red Hat-based host, you must deploy a statically compiled Go web app that runs on port 8080 behind firewalld with SELinux enforcing. The app should auto-start on boot, restart on failure, and log to rsyslog. Propose the concrete steps, files, and exact commands to configure systemd, firewalld, and SELinux contexts, ensuring minimal downtime during deploy?","answer":"Create a systemd unit for /opt/myapp/myapp listening on port 8080. In ExecStart use /opt/myapp/myapp --port 8080; Restart=on-failure; StandardOutput=journal; StandardError=journal. SELinux: semanage f","explanation":"## Why This Is Asked\nTests ability to package a real app with init, SELinux, and firewall integration.\n\n## Key Concepts\n- systemd service files and Restart logic\n- SELinux file context labeling\n- firewalld port management\n- logging through systemd/journald\n\n## Code Example\n```ini\n[Unit]\nDescription=My App\nAfter=network.target\n\n[Service]\nExecStart=/opt/myapp/myapp --port 8080\nRestart=on-failure\nStandardOutput=journal\nStandardError=journal\n\n[Install]\nWantedBy=multi-user.target\n```\n\n## Follow-up Questions\n- How would you roll back if the binary fails to start after deployment?\n- How would you audit SELinux denials for this service?","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Salesforce"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T18:57:55.544Z","createdAt":"2026-01-13T18:57:55.544Z"},{"id":"q-1517","question":"On a RHEL 9 host, a custom service started via systemd fails to write logs to /var/www/app/logs after a patch, with SELinux enforcing. Describe a precise, minimal-risk remediation plan to identify and fix the root cause without broad permission grants, including AVC collection, targeted policy generation, and validation under load. What exact commands and steps would you perform?","answer":"Diagnose with SELinux AVCs for the failing service, collect today’s logs, and craft a targeted policy with audit2allow. Steps: 1) ausearch -m avc -ts today -i. 2) audit2allow -w -a -M svc_logfix. 3) s","explanation":"## Why This Is Asked\nSELinux troubleshooting in production is common; it tests practical, precise remediation without broad privileges.\n\n## Key Concepts\n- AVC denials, targeted policy, audit2allow, semodule\n- ausearch for AVCs, ts filtering, and interpreting logs\n- safe relabeling vs. creating a minimal policy module\n\n## Code Example\n```javascript\n# Collect AVCs for today\nausearch -m avc -ts today -i\n# Build a targeted module from logs\naudit2allow -w -a -M svc_logfix\nsemodule -i svc_logfix.pp\n```\n\n## Follow-up Questions\n- How would you verify no regression in other services after applying the module?\n- What are the risks of over-broad policy changes and how to mitigate them?","diagram":"flowchart TD\nA[AVC Denial Detected] --> B[Collect AVCs with ausearch]\nB --> C[Generate module via audit2allow]\nC --> D[Install module with semodule]\nD --> E[Restart service]\nE --> F[Load-test and verify logs]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Snap"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-13T20:34:41.210Z","createdAt":"2026-01-13T20:34:41.212Z"},{"id":"q-1577","question":"You must serve a static site from content stored on an NFS mount at /srv/www with SELinux enforcing on a RHEL-based system. The SELinux policy blocks httpd from reading the files. Describe the exact sequence of commands and configurations to allow Apache to serve the site without disabling SELinux or putting the system in permissive mode, including boolean toggles, labeling, and firewall rules?","answer":"Enable httpd to read NFS content: setsebool -P httpd_use_nfs on; semanage fcontext -a -e httpd_sys_content_t '/srv/www(/.*)?'; restorecon -R /srv/www; systemctl restart httpd; firewall-cmd --permanent --add-service=http; firewall-cmd --reload","explanation":"## Why This Is Asked\nEvaluates practical SELinux handling for real-world shared content, not just theory.\n\n## Key Concepts\n- SELinux booleans (httpd_use_nfs)\n- File context labeling for web content\n- restorecon and semanage usage\n- Firewall rules for HTTP\n- Diagnosing and remediating AVCs with audit2allow\n\n## Code Example\n```bash\nsetsebool -P httpd_use_nfs on\nsemanage fcontext -a -e httpd_sys_content_t '/srv/www(/.*)?'\nrestorecon -R /srv/www\nsystemctl restart httpd\nfirewall-cmd --permanent --add-service=http\nfirewall-cmd --reload\n```\n\n## Follow-up Questions\n- How would you verify and remediate","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","Meta","Twitter"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T05:56:45.358Z","createdAt":"2026-01-13T22:44:11.540Z"},{"id":"q-1610","question":"Configure log rotation for a custom web app log path /var/log/myapp/*.log on a live Linux host. The log is written by a root-owned process and must rotate weekly, keep 4 copies, compress old logs, and after rotation reload nginx to reopen its handles. Provide a minimal, working logrotate.conf snippet and explain how this prevents log loss?","answer":"Use a dedicated logrotate stanza:\n\n```\n/var/log/myapp/*.log {\n    weekly\n    rotate 4\n    compress\n    missingok\n    notifempty\n    copytruncate\n    sharedscripts\n    postrotate\n        systemctl reload nginx >/dev/null 2>&1 || true\n    endscript\n}\n```","explanation":"Why This Is Asked\n- Tests practical log management and prevention of log loss in a real service\n- Checks understanding of rotation cadence, backup retention, and service interaction\n\nKey Concepts\n- logrotate stanza syntax and options (weekly, rotate, compress, missingok, notifempty, copytruncate, sharedscripts)\n- Post-rotation actions to refresh services (nginx log file handles)\n- Impact of log rotation on running daemons and data integrity\n\nCode Example\n```bash\n/var/log/myapp/*.log {\n    weekly\n    rotate 4\n    compress\n    missingok\n    notifempty\n    copytruncate\n    sharedscripts\n    postrotate\n        systemctl reload nginx >/dev/null 2>&1 || true\n    endscript\n}\n```\n\nHow This Prevents Log Loss\n- `copytruncate` copies the current log to a new file, then truncates the original, ensuring continuous logging without interruption\n- `sharedscripts` ensures the postrotate command runs only once per rotation, preventing multiple nginx reloads\n- `missingok` and `notifempty` prevent errors if logs don't exist or are empty, avoiding rotation failures\n- `systemctl reload nginx` gracefully reopens log file handles without dropping connections, preventing log loss during rotation","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Coinbase","IBM","Plaid"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T05:30:20.445Z","createdAt":"2026-01-14T02:35:40.954Z"},{"id":"q-1649","question":"On a RHEL system with root on an LV named /dev/vg_rhel/root, describe a precise method to test a disruptive system update using an LVM snapshot: create a 20G snapshot, apply the update inside the snapshot, validate service health, and rollback by booting the live system from the original LV if needed. Include exact commands?","answer":"Create a 20G root snapshot: lvcreate -s -n root-snap -L20G vg_rhel/root. Mount it at /mnt/snap, bind /dev /proc /sys, chroot /mnt/snap, run dnf update -y, test services. If healthy, reboot normally. I","explanation":"## Why This Is Asked\nAssesses practical rollback strategy using LVM snapshots for live testing of disruptive updates.\n\n## Key Concepts\n- LVM snapshots\n- chroot testing\n- Rollback via boot path adjustment\n\n## Code Example\n```javascript\nlvcreate -s -n root-snap -L20G vg_rhel/root\nmkdir -p /mnt/snap\nmount /dev/vg_rhel/root-snap /mnt/snap\nfor d in /proc /sys /dev; do mount --bind \"$d\" \"/mnt/snap$d\"; done\nchroot /mnt/snap\ndnf update -y\nsystemctl status httpd\nexit\n```\n\n## Follow-up Questions\n- How would you automate cleanup after a successful rollback?\n- How to secure the test against data inconsistency during the snapshot lifecycle?","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Citadel","Google"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T04:33:32.950Z","createdAt":"2026-01-14T04:33:32.950Z"},{"id":"q-1679","question":"On a RHEL/CentOS host with two NICs (enp0s3 and enp0s8) connected to two switches, configure a 802.3ad (LACP) bond0 using NetworkManager. Bond should have a static IP 192.0.2.100/24, and both NICs must be slaves. Provide exact nmcli commands to create bond0, add slaves, bring it up, and verify; note required switch settings (LACP active on both ports)?","answer":"Configure a 802.3ad LACP bond across two NICs with a static IP on bond0. Use NM to create bond0, assign 192.0.2.100/24, add enp0s3 and enp0s8 as slaves, bring up bond0, and verify via /proc/net/bondin","explanation":"## Why This Is Asked\nReal-world networking reliability requires correct bonding configuration with LACP. This tests practical NM usage, understanding of switch prerequisites, and verification of bond status.\n\n## Key Concepts\n- 802.3ad/LACP bonding\n- NetworkManager nmcli commands\n- Slave interfaces and master bond configuration\n- Switch-side LACP, port-channel settings, MTU consistency\n\n## Code Example\n```bash\n# Create bond with LACP\nnmcli con add type bond ifname bond0 mode 802.3ad\n# Set static IP on bond\nnmcli con modify bond0 ipv4.addresses 192.0.2.100/24 ipv4.method manual\n# Add slaves\nnmcli con add type ethernet ifname enp0s3 master bond0\nnmcli con add type ethernet ifname enp0s8 master bond0\n# Bring interfaces up\nnmcli con up bond0\nnmcli con up enp0s3\nnmcli con up enp0s8\n```\n\n## Follow-up Questions\n- How would you troubleshoot if /proc/net/bonding/bond0 shows inconsistent slave status?\n- What changes are needed if one switch port goes down and the bond remains up?","diagram":null,"difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Scale Ai","Stripe"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T06:51:43.330Z","createdAt":"2026-01-14T06:51:43.330Z"},{"id":"q-1738","question":"On a RHEL-based host, configure firewalld to allow SSH access only from 192.0.2.0/24 and deny all other inbound SSH; ensure the changes persist after reboot and can be tested quickly; outline exact commands and verification steps, including revert plan?","answer":"Remove the ssh service from the default zone, then add two permanent rich rules: allow ssh for source 192.0.2.0/24 and drop ssh from all others, then reload. Verify via firewall-cmd --zone=public --li","explanation":"## Why This Is Asked\nTests handling of firewalld, zones, and persistent rules in a concrete admin task.\n\n## Key Concepts\n- firewalld zones and permanent vs runtime rules\n- rich rules for source-based access\n- persistence and verification\n\n## Code Example\n```javascript\nfirewall-cmd --zone=public --permanent --remove-service=ssh\nfirewall-cmd --zone=public --permanent --add-rich-rule='rule family=\"ipv4\" source address=\"192.0.2.0/24\" service name=\"ssh\" accept'\nfirewall-cmd --zone=public --permanent --add-rich-rule='rule family=\"ipv4\" service name=\"ssh\" drop'\nfirewall-cmd --reload\n```\n\n## Follow-up Questions\n- How to mirror this for IPv6?\n- What if the admin needs temporary access from another network during maintenance?","diagram":"flowchart TD\n  A[Identify current rules] --> B[Remove ssh service] \n  B --> C[Add allow rule for 192.0.2.0/24] \n  C --> D[Add drop rule for others] \n  D --> E[Reload firewall] \n  E --> F[Verify rules] \n  F --> G[Revert if needed]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","Tesla","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T09:00:00.925Z","createdAt":"2026-01-14T09:00:00.925Z"},{"id":"q-1756","question":"On a freshly provisioned Linux host (RHEL8), configure a new user 'audit' to log in exclusively via SSH key authentication, with a restricted shell rbash so only basic commands are allowed, and grant passwordless sudo to restart the 'auditd' service. Provide exact commands and edits to users, sshd_config, and sudoers, and how you would verify the setup?","answer":"Create user and home; assign rbash as shell; set a restricted PATH; configure SSH: PasswordAuthentication no; create /home/audit/.ssh/authorized_keys; edit /etc/sudoers.d/audit: audit ALL=(ALL) NOPASS","explanation":"## Why This Is Asked\nTests practical provisioning, SSH hardening, and sudo privileges for isolated accounts.\n\n## Key Concepts\n- rbash restrictions\n- SSH key-based auth\n- NOPASSWD sudo rules\n\n## Code Example\n```bash\n# basic provisioning (illustrative)\nuseradd -m audit\nchsh -s /bin/rbash audit\nmkdir -p /home/audit/.ssh\nchmod 700 /home/audit/.ssh\n# put key in authorized_keys\nchmod 600 /home/audit/.ssh/authorized_keys\necho 'audit ALL=(ALL) NOPASSWD: /bin/systemctl restart auditd' > /etc/sudoers.d/audit\n```\n\n## Follow-up Questions\n- How would you audit sudo usage for this user? \n- How would you extend to multiple restricted users with per-command whitelists?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","IBM"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T09:43:07.881Z","createdAt":"2026-01-14T09:43:07.881Z"},{"id":"q-1771","question":"On a RHEL 8 server, you must host a small static site with Nginx, ensure it starts on boot, expose only port 80, and serve content from /var/www/html with correct SELinux context. Provide exact commands to configure Nginx, firewall, and SELinux so SELinux stays enforcing?","answer":"Install nginx and set up a static site, start on boot, expose port 80, and serve /var/www/html with proper SELinux context. Run: dnf install -y nginx; mkdir -p /var/www/html; echo 'Hello' > /var/www/h","explanation":"## Why This Is Asked\nTests practical understanding of systemd service management, firewall configuration, and SELinux contexts for hosting static content on RHEL.\n\n## Key Concepts\n- systemd service enable/start\n- firewall-cmd for port 80\n- SELinux labeling with httpd_sys_content_t\n- restorecon and semanage usage\n\n## Code Example\n```bash\n# install\nsudo dnf install -y nginx\n# firewall\nsudo firewall-cmd --permanent --zone=public --add-service=http\nsudo firewall-cmd --reload\n# SELinux\nsudo semanage fcontext -a -t httpd_sys_content_t '/var/www/html(/.*)?'\nsudo restorecon -R -v /var/www/html\n```\n\n```bash\n# enable and start nginx\nsudo systemctl enable --now nginx\n```\n\n## Follow-up Questions\n- How would you serve content from a subpath like /var/www/html/site?\n- How would you adjust SELinux booleans if you later switch to CGI scripts?","diagram":"flowchart TD\n  A[Start] --> B[Install nginx]\n  B --> C[Configure firewall]\n  C --> D[Set SELinux context]\n  D --> E[Enable and start nginx]\n  E --> F[Validate with curl]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Meta","Snap","Snowflake"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T10:34:55.907Z","createdAt":"2026-01-14T10:34:55.909Z"},{"id":"q-1804","question":"On a Red Hat-based host, a Python web app writes to /srv/app/data and /var/log/app. After a system update, SELinux denies these writes. Outline an operational plan to diagnose and restore write access without disabling SELinux, including commands for audit review, context restoration, and persistent policy adjustments?","answer":"1) Inspect AVCs: ausearch -m avc -ts today | aureport -a -i; 2) confirm file contexts: ls -Z /srv/app /var/log/app; 3) set persistent contexts: semanage fcontext -a -t httpd_sys_rw_content_t '/srv/app","explanation":"## Why This Is Asked\nDemonstrates practical SELinux troubleshooting, policy tuning, and safe persistence without disabling security.\n\n## Key Concepts\n- SELinux types and booleans\n- semanage fcontext\n- restorecon\n- audit2why/ausearch\n- persistent policy changes\n\n## Code Example\n```bash\nausearch -m avc -ts today | aureport -a -i\nsemanage fcontext -a -t httpd_sys_rw_content_t '/srv/app(/.*)?'\nrestorecon -R /srv/app\n```\n\n## Follow-up Questions\n- How to roll back if a boolean causes regressions?\n- How to isolate contexts per app with dedicated policy modules?","diagram":"flowchart TD\n  A[SELinux Denial] --> B[Audit Review]\n  B --> C[Update File Contexts]\n  C --> D[Apply Persistently]\n  D --> E[Test Write]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Meta","Square"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T11:39:38.392Z","createdAt":"2026-01-14T11:39:38.392Z"},{"id":"q-1982","question":"On a Linux host, create a project share at /srv/project where Alice can read/write and Bob can read only, with all others denied. Use POSIX permissions plus ACLs so new files created by Alice inherit Bob's read access. Provide exact commands to: 1) create the group, 2) add users, 3) set up the directory with setgid, 4) apply ACLs (explicit for Bob and default for new files), 5) verify with tests?","answer":"sudo groupadd proj\nsudo usermod -aG proj alice\nsudo mkdir -p /srv/project\nsudo chown root:proj /srv/project\nsudo chmod 2770 /srv/project\nsudo setfacl -m u:bob:rx /srv/project\nsudo setfacl -m d:u:bob:r","explanation":"## Why This Is Asked\nTests practical ACL usage and inheritance: combining POSIX permissions, setgid directories, and ACLs for multi-user access. It validates understanding of inheritance for new files and robust verification from non-privileged contexts.\n\n## Key Concepts\n- POSIX permissions and groups\n- Setgid directory inheritance\n- ACLs and default ACLs\n- Testing cross-user access\n- File vs directory permissions\n\n## Code Example\n```bash\n# Example verification (shown in answer above for clarity)\n```\n\n## Follow-up Questions\n- How would you audit and adjust ACLs if Alice creates a deep subdirectory?\n- How would you apply these permissions across a separate mount or NFS share?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["DoorDash","Oracle","Zoom"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-14T19:36:54.465Z","createdAt":"2026-01-14T19:36:54.466Z"},{"id":"q-2225","question":"On a RHEL 9 server running Apache httpd hosting a custom PHP app, uploads are saved to /srv/app/uploads owned by webuser with SELinux type httpd_sys_content_t. After a denied upload, design and implement a minimal SELinux policy module that lets httpd_t write to that directory and create new files, without broad permissive mode. Include exact commands and testing steps?","answer":"Identify the AVC with ausearch, generate a targeted module with audit2allow, install the module, and adjust file context. Commands: ausearch -m AVC -ts today | audit2allow -M httpd_upload; semodule -i","explanation":"## Why This Is Asked\nTests SELinux troubleshooting and policy crafting in a realistic app deployment.\n\n## Key Concepts\n- SELinux domains and booleans\n- AVC denials and audit2allow workflow\n- Persistent labeling with semanage and restorecon\n- Safe, least-privilege policy design\n\n## Code Example\n```bash\nausearch -m AVC -ts today\naudit2allow -M httpd_upload\nsemodule -i httpd_upload.pp\nsemanage fcontext -a -e '/srv/app/uploads'\nrestorecon -R /srv/app/uploads\n```\n\n## Follow-up Questions\n- How would you test for regressions across relabeled files?\n- How would you roll back the policy if it caused unintended access?","diagram":null,"difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T08:40:50.907Z","createdAt":"2026-01-15T08:40:50.909Z"},{"id":"q-2308","question":"On a fresh RHEL8 host with an unallocated disk at /dev/sdb, describe and implement the steps to (1) create a PV, (2) VG named vg_data, (3) LV named data of 900G, (4) format with XFS, (5) mount at /data with auto-mount in /etc/fstab, and (6) set ownership to user app and proper SELinux context. Provide exact commands?","answer":"pvcreate /dev/sdb; vgcreate vg_data /dev/sdb; lvcreate -L 900G -n data vg_data; mkfs.xfs /dev/vg_data/data; mkdir -p /data; mount /dev/vg_data/data /data; echo '/dev/vg_data/data /data xfs defaults 0 ","explanation":"## Why This Is Asked\n\nTests storage provisioning basics common in RHCSA tasks.\n\n## Key Concepts\n\n- PV/VG/LV lifecycle\n- XFS formatting\n- /etc/fstab persistence\n- SELinux context when mounting new data\n\n## Code Example\n\n```bash\npvcreate /dev/sdb\nvgcreate vg_data /dev/sdb\nlvcreate -L 900G -n data vg_data\nmkfs.xfs /dev/vg_data/data\nmkdir -p /data\nmount /dev/vg_data/data /data\necho '/dev/vg_data/data /data xfs defaults 0 0' >> /etc/fstab\n```\n\n## Follow-up Questions\n\n- How would you extend this to add a separate metadata LV?\n- How would you verify accessibility after reboot?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Google","Hashicorp","Scale Ai"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T11:37:43.926Z","createdAt":"2026-01-15T11:37:43.927Z"},{"id":"q-2357","question":"Scenario: You manage a RHEL host where /var/www and /etc live on an LVM-managed XFS volume. Implement a DR restore pipeline: daily incremental backups via rsync to an offsite server, preserving SELinux contexts and ACLs, with integrity verification. Describe the exact commands, systemd timer/unit setup, and restore steps to recover to the latest backup within 60 minutes?","answer":"Back up /etc and /var/www to an offsite server with rsync: rsync -aAXv --delete --link-dest=/backup/prev /etc /var/www host:/backup/daily-$(date +%F). Verify with sha256sums. Restore by rsync -aAXv fr","explanation":"## Why This Is Asked\nTests practical DR planning, SELinux/ACL preservation, incremental rsync backups, and systemd automation—core RHCSA skills for real-world repair.\n\n## Key Concepts\n- DR planning with RPO/RTO\n- rsync options -aAX, --link-dest, --delete\n- SELinux contexts preservation and restorecon\n- ACLs and extended attributes\n- systemd-timers and unit files\n- integrity verification with checksums\n\n## Code Example\n```bash\n# example restore workflow (dry-run)\nrsync -aAXv --dry-run /backup/latest/ /etc/\n```\n\n```bash\n# systemd timer example (simplified)\n[Unit]\nDescription=Daily DR backup\n\n[Timer]\nOnCalendar=daily\nPersistent=true\n\n[Service]\nType=oneshot\nExecStart=/usr/local/bin/run-dr-backup.sh\n```\n\n```bash\n# restore script outline\nrsync -aAXv --delete /backup/latest/ /etc/\nrsync -aAXv --delete /backup/latest/ /var/www/\nrestorecon -R /etc /var/www\nsystemctl restart httpd nginx\n```\n\n## Follow-up Questions\n- How would you handle offsite encryption and key rotation?\n- How would you test DR recovery with minimal downtime?","diagram":null,"difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Hashicorp","Oracle"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T14:43:24.786Z","createdAt":"2026-01-15T14:43:24.786Z"},{"id":"q-2415","question":"On a fresh RHEL 9 server, implement a small utility that prints the host name and current date, running it as a non-login user via systemd and logging to a dedicated file with rotation. Provide exact commands for user creation, script, service, and log rotation?","answer":"Create a restricted user 'hello' with no login, place a script at /opt/hello-day/print.sh that appends \"Hello from <date> on <hostname>\" to /var/log/hello-day.log, set proper permissions, and configur","explanation":"## Why This Is Asked\nTests core RHCSA beginner skills: user creation and permissions, small script, systemd service basics, log management with rotation, and boot-time enablement.\n\n## Key Concepts\n- Systemd service fundamentals\n- Non-login user handling\n- File permissions and ownership\n- Log rotation basics\n- Service verification\n\n## Code Example\n```bash\n# Create user\nsudo useradd -r -s /sbin/nologin -d /var/empty hello\n# Prepare script\nsudo mkdir -p /opt/hello-day\nsudo tee /opt/hello-day/print.sh <<'SH'\n#!/bin/bash\necho \"Hello from $(date) on $(hostname)\" >> /var/log/hello-day.log\nSH\nsudo chmod +x /opt/hello-day/print.sh\nsudo mkdir -p /var/log/hello-day\nsudo chown hello:hello /var/log/hello-day.log\n# systemd service\nsudo tee /etc/systemd/system/hello-day.service <<'SERVICE'\n[Unit]\nDescription=Hello Day Service\n[Service]\nType=oneshot\nUser=hello\nExecStart=/opt/hello-day/print.sh\nSERVICE\nsudo systemctl daemon-reload\nsudo systemctl enable --now hello-day.service\n# logrotate\nsudo tee /etc/logrotate.d/hello-day <<'LOG'\n/var/log/hello-day.log {\n  daily\n  rotate 7\n  missingok\n  notifempty\n  create 0640 hello hello\n  copytruncate\n}\nLOG\n```\n\n## Follow-up Questions\n- How would you adapt this for a daemon vs. oneshot?\n- How would you ensure idempotence if the script could run multiple times?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Meta"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T17:02:13.966Z","createdAt":"2026-01-15T17:02:13.966Z"},{"id":"q-2457","question":"On a Linux host, a Node.js web app runs in a container and connects to Postgres on localhost:5432. After reboot, the web app sometimes starts before Postgres is ready, causing startup failures. Propose a concrete, production-ready systemd-based solution: (1) implement a db-wait.service that blocks until pg_isready reports healthy, (2) make web-app.service depend on and After=db-wait.service, (3) add a lightweight container readiness check for the app, and (4) describe how you would test this reliably?","answer":"Create db-wait.service that blocks until pg_isready reports healthy: ExecStart=/bin/bash -lc 'until pg_isready -h localhost -p 5432; do sleep 1; done'. Web app unit: Wants=db-wait.service After=db-wai","explanation":"## Why This Is Asked\n\nTests the candidate's ability to coordinate startup order between services using systemd, plus practical health/readiness checks to prevent cascading failures.\n\n## Key Concepts\n\n- systemd unit dependencies (After, Wants, Requires)\n- pg_isready and database readiness signals\n- container health checks and readiness probes\n- startup ordering and failure isolation\n- practical testing of startup sequencing\n\n## Code Example\n\n```javascript\n# db-wait.service\n[Unit]\nDescription=Wait for PostgreSQL to be ready\n\n[Service]\nType=oneshot\nExecStart=/bin/bash -lc 'until pg_isready -h localhost -p 5432; do sleep 1; done'\nRemainAfterExit=yes\n```\n\n```javascript\n# web-app.service\n[Unit]\nDescription=Web App\nWants=db-wait.service\nAfter=db-wait.service\n\n[Service]\nRestart=on-failure\nExecStart=/usr/bin/node /opt/app/server.js\n```\n\n```javascript\n# Dockerfile HEALTHCHECK\nHEALTHCHECK --interval=30s --timeout=5s --start-period=5s --retries=3 CMD curl -f http://localhost:3000/health || exit 1\n```\n\n## Follow-up Questions\n\n- How would you adapt if Postgres runs in a separate container?\n- How would you handle timeouts and cascading failures?","diagram":null,"difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Discord"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T18:59:12.556Z","createdAt":"2026-01-15T18:59:12.556Z"},{"id":"q-2479","question":"On a RHEL 9 host, a production service writes logs to /var/app/logs with 0777 perms. You must relocate logs to a dedicated 1 TB LVM-backed XFS volume mounted at /var/app/logs with no downtime, ensure SELinux context, and configure logrotate to compress weekly. Provide exact steps including LV creation, filesystem, fstab, SELinux relabeling, and logrotate config?","answer":"Configure a 1 TB LVM-backed XFS volume mounted at /var/app/logs with zero downtime: create LV, format XFS, mount, update fstab, rsync data, switch mount, relabel SELinux contexts (semanage fcontext -a","explanation":"## Why This Is Asked\nTests storage disruption avoidance, LVM, SELinux contexts, and log management in a realistic migration.\n\n## Key Concepts\n- LVM provisioning and filesystem selection\n- Data migration with minimal downtime\n- SELinux file contexts and relabeling\n- logrotate configuration and permissions\n- FSTAB mounting and idempotent changes\n\n## Code Example\n```bash\n# example: fstab entry\n/dev/mapper/applog-vg/applog /var/app/logs xfs defaults 0 0\n```\n\n```bash\n# data migration\nrsync -aP /var/app/logs/ /mnt/applog/ \n```\n\n## Follow-up Questions\n- How to rollback if migration fails?\n- How would you handle concurrent writes during cutover?\n","diagram":"flowchart TD\n  A[Start] --> B[Create LV and format]\n  B --> C[Mount at /var/app/logs]\n  C --> D[Update /etc/fstab]\n  D --> E[Migrate logs with rsync]\n  E --> F[Relabel SELinux contexts]\n  F --> G[Configure logrotate]\n  G --> H[Validate with test logs]\n  H --> I[End]","difficulty":"advanced","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Netflix","PayPal","Two Sigma"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-15T19:41:12.926Z","createdAt":"2026-01-15T19:41:12.926Z"},{"id":"q-2557","question":"On a fresh RHEL 9 host, configure firewalld to allow SSH only from 203.0.113.0/24 and drop SSH from all other sources. Provide exact permanent commands, reload, and verification steps?","answer":"Enable firewalld and restrict SSH to 203.0.113.0/24. Exact commands: systemctl enable --now firewalld; SUB=203.0.113.0/24; firewall-cmd --permanent --zone=public --add-rich-rule=\"rule family='ipv4' source address='$SUB' port port='22' protocol='tcp' accept\"; firewall-cmd --permanent --zone=public --add-rich-rule=\"rule family='ipv4' port port='22' protocol='tcp' drop\"; firewall-cmd --reload; firewall-cmd --list-all --zone=public","explanation":"## Why This Is Asked\nTests practical firewall configuration and understanding of permanent vs runtime rules, plus idempotence.\n\n## Key Concepts\n- firewalld rich rules\n- permanent vs runtime configuration\n- rule ordering and specificity\n\n## Code Example\n```\nsystemctl enable --now firewalld\nSUB=203.0.113.0/24\nfirewall-cmd --permanent --zone=public --add-rich-rule=\"rule family='ipv4' source address='$SUB' port port='22' protocol='tcp' accept\"\nfirewall-cmd --permanent --zone=public --add-rich-rule=\"rule family='ipv4' port port='22' protocol='tcp' drop\"\nfirewall-cmd --reload\nfirewall-cmd --list-all\n```","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Databricks","Hashicorp","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T05:26:09.742Z","createdAt":"2026-01-15T22:46:09.878Z"},{"id":"q-2637","question":"On a fresh RHEL 9 host, deploy a tiny Python HTTP health server that binds to 127.0.0.1:9090 and returns 200 OK for GET /health when the file /tmp/healthy exists; otherwise 503. Run this as a non-root systemd service with a dedicated unit file, a startup script, and a log file rotated by logrotate. Provide exact commands to create the non-login user, script, systemd unit, logrotate config, and enable the service. Ensure idempotence?","answer":"Create user healthchk (nologin). Place script at /opt/healthcheck/health_server.py that runs a tiny HTTP server on 127.0.0.1:9090 and returns 200 for /health when /tmp/healthy exists, else 503. System","explanation":"Why This Is Asked\nTests systemd service for non-root processes, health-check patterns, and log management.\n\nKey Concepts\n- systemd unit files (User, WorkingDirectory, ExecStart, StandardOutput)\n- Python HTTP server basics\n- idempotent filesystem setup and permissions\n- logrotate configuration for a dedicated log path\n\nCode Example\n```python\n# health_server.py\nimport http.server, socketserver, os\nclass H(http.server.BaseHTTPRequestHandler):\n  def do_GET(self):\n    if self.path == '/health' and os.path.exists('/tmp/healthy'):\n      self.send_response(200); self.end_headers(); self.wfile.write(b'OK')\n    else:\n      self.send_response(503); self.end_headers(); self.wfile.write(b' unhealthy ')\n\nif __name__ == '__main__':\n  with socketserver.TCPServer(('127.0.0.1',9090), H) as httpd:\n    httpd.serve_forever()\n```\n\nFollow-up Questions\n- How would you monitor this service and alert on failed health checks?\n- How would you harden the service against file tampering?","diagram":"flowchart TD\n  A[Create healthchk user] --> B[Write health_server.py]\n  B --> C[Systemd unit setup]\n  C --> D[Configure logrotate]\n  D --> E[Enable & start service]","difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Anthropic","Hashicorp","OpenAI"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T04:18:13.926Z","createdAt":"2026-01-16T04:18:13.927Z"},{"id":"q-2647","question":"On a fresh RHEL 9 server, create a non-root user named devops and configure passwordless sudo for only two commands: /bin/systemctl restart httpd and /usr/bin/journalctl -xe. Restrict SSH login for this user to localhost by updating sshd_config. Provide exact commands and file contents to accomplish this?","answer":"Create user devops with a home and bash: useradd -m -s /bin/bash devops; passwd devops. Add sudoers: echo 'devops ALL=(ALL) NOPASSWD: /bin/systemctl restart httpd, /usr/bin/journalctl -xe' > /etc/sudo","explanation":"## Why This Is Asked\nTests practical admin tasks: user provisioning, granular sudo rights, and SSH restrictions, all common on entry-level RHCSA tasks.\n\n## Key Concepts\n- User management with useradd and passwd\n- Fine-grained sudoers with /etc/sudoers.d\n- SSH access control with AllowUsers\n- Service and log viewing with systemctl and journalctl\n\n## Code Example\n```javascript\n# Commands to implement (illustrative, not executed here)\n```\n\n## Follow-up Questions\n- How would you log the sudo usage for this user?\n- How would you extend to allow additional commands safely?","diagram":null,"difficulty":"beginner","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Microsoft","MongoDB"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-16T05:34:54.469Z","createdAt":"2026-01-16T05:34:54.469Z"},{"id":"q-933","question":"On a fresh RHEL 9 installation with a 120 GB disk, implement an LVM layout: ROOT 40G, HOME 40G, VAR 40G, all using XFS. Create PV, VG, and LVs, format, and mount at /, /home, /var with fstab. Enable and configure firewalld to allow http and https. Ensure SELinux is enforcing. Create a non-root user 'dev' and add to the wheel group with sudo privileges. Show commands and rationale?","answer":"I would create a single PV on /dev/sda, a VG named rhel, and three LVs: root, home, var at 40G each. After mkfs.xfs on each, mount them to /, /home, /var and persist in /etc/fstab. Enable firewalld an","explanation":"## Why This Is Asked\nTests practical, real-world sysadmin tasks: LVM planning, filesystem layout, boot/root considerations, firewall and SELinux configuration, and user privilege management.\n\n## Key Concepts\n- LVM: pvcreate, vgcreate, lvcreate\n- Filesystems: XFS and fstab\n- Security: SELinux enforcing and wheel-based sudo\n- Networking: firewalld http/https rules\n\n## Code Example\n```bash\npvcreate /dev/sda\nvgcreate rhel /dev/sda\nlvcreate -L40G -n root rhel\nlvcreate -L40G -n home rhel\nlvcreate -L40G -n var rhel\nmkfs.xfs /dev/rhel/root\nmkfs.xfs /dev/rhel/home\nmkfs.xfs /dev/rhel/var\nmount /dev/rhel/root /\nmkdir -p /home /var\nmount /dev/rhel/home /home\nmount /dev/rhel/var /var\n# /etc/fstab entries would reference /dev/rhel/... set here\nsystemctl enable --now firewalld\nfirewall-cmd --permanent --add-service=http\nfirewall-cmd --permanent --add-service=https\nfirewall-cmd --reload\nsetenforce 1\nsed -i 's/^SELINUX=.*/SELINUX=enforcing/' /etc/selinux/config\nuseradd -m dev\nusermod -aG wheel dev\n```\n\n## Follow-up Questions\n- How would you resize LVs while preserving data?\n- How would you verify SELinux contexts after mounting new filesystems?","diagram":"flowchart TD\n  A[Disk] --> B[PV] \n  B --> C[VG] \n  C --> D[LVs: root, home, var] \n  D --> E[Mounts: /, /home, /var] \n  E --> F[Services: firewalld, SELinux, sudo]","difficulty":"intermediate","tags":["rhcsa"],"channel":"rhcsa","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Adobe","IBM","Microsoft"],"eli5":null,"relevanceScore":null,"voiceKeywords":null,"voiceSuitable":false,"isNew":true,"lastUpdated":"2026-01-12T15:42:25.882Z","createdAt":"2026-01-12T15:42:25.882Z"}],"subChannels":["general"],"companies":["Adobe","Airbnb","Amazon","Anthropic","Apple","Bloomberg","Citadel","Coinbase","Databricks","Discord","DoorDash","Goldman Sachs","Google","Hashicorp","Hugging Face","IBM","Instacart","LinkedIn","Lyft","Meta","Microsoft","MongoDB","Netflix","OpenAI","Oracle","PayPal","Plaid","Salesforce","Scale Ai","Snap","Snowflake","Square","Stripe","Tesla","Twitter","Two Sigma","Zoom"],"stats":{"total":28,"beginner":14,"intermediate":5,"advanced":9,"newThisWeek":28}}